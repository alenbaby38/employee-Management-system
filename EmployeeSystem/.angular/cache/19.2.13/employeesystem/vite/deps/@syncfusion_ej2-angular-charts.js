import {
  AccPointData,
  AccPoints,
  Accessibility,
  AccumulationAnnotation,
  AccumulationAnnotationSettings,
  AccumulationChart,
  AccumulationDataLabel,
  AccumulationDataLabelSettings,
  AccumulationDistributionIndicator,
  AccumulationHighlight,
  AccumulationLegend,
  AccumulationSelection,
  AccumulationSeries,
  AccumulationTooltip,
  Animation,
  AreaSeries,
  AtrIndicator,
  Axis,
  AxisLine,
  AxisRenderer,
  AxisSettings,
  BarSeries,
  BarSeries3D,
  BinaryTreeBuilder,
  BollingerBands,
  Border,
  BoxAndWhiskerSeries,
  BubbleSeries,
  BulletChart,
  BulletChartLegend,
  BulletChartLegendSettings,
  BulletDataLabel,
  BulletLabelStyle,
  BulletTooltip,
  BulletTooltipSettings,
  CandleSeries,
  CartesianAxisLayoutPanel,
  Category,
  Category3D,
  CenterLabel,
  Chart,
  Chart3D,
  Chart3DAxis,
  Chart3DColumn,
  Chart3DDataLabelSettings,
  Chart3DEmptyPointSettings,
  Chart3DLegendSettings,
  Chart3DMajorGridLines,
  Chart3DMajorTickLines,
  Chart3DMinorGridLines,
  Chart3DMinorTickLines,
  Chart3DPoint,
  Chart3DRender,
  Chart3DRow,
  Chart3DSeries,
  Chart3DTextFont,
  Chart3DTooltipSettings,
  ChartAnnotation,
  ChartAnnotationSettings,
  ChartArea,
  ChartLocation,
  ChartSegment,
  ChartTransform3D,
  CircleOption,
  CircularChart3D,
  CircularChart3DConnector,
  CircularChart3DDataLabelFont,
  CircularChart3DDataLabelSettings,
  CircularChart3DEmptyPointSettings,
  CircularChart3DLegendSettings,
  CircularChart3DPointData,
  CircularChart3DPoints,
  CircularChart3DSeries,
  CircularChart3DTooltipSettings,
  CircularChartDataLabel3D,
  CircularChartExport3D,
  CircularChartHighlight3D,
  CircularChartLegend3D,
  CircularChartSelection3D,
  CircularChartTooltip3D,
  ClosestPoint,
  CoefficientToVector,
  ColorValue,
  Column,
  ColumnSeries,
  ColumnSeries3D,
  Connector,
  ContainerArea,
  ContainerPadding,
  ControlPoints,
  CornerRadius,
  Crosshair,
  CrosshairSettings,
  CrosshairTooltip,
  CustomizeOption,
  DataEditing,
  DataLabel,
  DataLabel3D,
  DataLabelSettings,
  DataLabelTextOptions,
  DataPoint,
  DateTime,
  DateTime3D,
  DateTimeCategory,
  DateTimeCategory3D,
  Direction,
  Double,
  Double3D,
  DragSettings,
  EmaIndicator,
  EmptyPointSettings,
  ErrorBar,
  ErrorBarCapSettings,
  ErrorBarSettings,
  Export,
  Export3D,
  Font,
  FunnelSeries,
  Graphics3D,
  GridArcPoints,
  Highlight,
  Highlight3D,
  HiloOpenCloseSeries,
  HiloSeries,
  HistogramSeries,
  HorizontalLabelCollection,
  ImageOption,
  Index,
  Indexes,
  LabelBorder,
  LabelCollection,
  LabelLocation,
  LabelOffset,
  LabelOption,
  LabelRegion,
  Legend,
  Legend3D,
  LegendBorder,
  LegendItemStyle,
  LegendItemStyleBorder,
  LegendLocation,
  LegendSeries,
  LegendTitle,
  LineSegment,
  LineSeries,
  LineSettings,
  Location,
  Logarithmic,
  Logarithmic3D,
  MacdIndicator,
  MajorGridLines,
  MajorTickLines,
  MajorTickLinesSettings,
  Margin,
  MarkerOptions,
  MarkerSettings,
  Matrix3D,
  Mean,
  MinorGridLines,
  MinorTickLines,
  MinorTickLinesSettings,
  MomentumIndicator,
  MultiColoredAreaSeries,
  MultiColoredLineSeries,
  MultiColoredSeries,
  MultiLevelCategories,
  MultiLevelLabel,
  MultiLevelLabels,
  NiceInterval,
  NiceIntervals,
  Offset,
  Padding,
  ParetoOptions,
  ParetoSeries,
  PeriodSelector,
  PeriodSelectorSettings,
  Periods,
  PieCenter,
  PieSeries,
  PieSeries3D,
  Point,
  Point3D,
  PointData,
  PointRegion,
  Points,
  PolarArc,
  PolarSeries,
  Polygon3D,
  PolygonOption,
  PyramidSeries,
  RadarSeries,
  RadialLabelCollections,
  Range,
  RangeAreaSeries,
  RangeBandSettings,
  RangeColorSetting,
  RangeColumnSeries,
  RangeNavigator,
  RangeNavigatorAxis,
  RangeNavigatorSeries,
  RangeSeries,
  RangeSlider,
  RangeStepAreaSeries,
  RangeTooltip,
  RangeTooltipSettings,
  RectOption,
  Row,
  RsiIndicator,
  ScatterSeries,
  ScrollBar,
  ScrollbarSettings,
  ScrollbarSettingsRange,
  Selection,
  Selection3D,
  Series,
  SeriesAccessibility,
  SeriesBase,
  SeriesMarker,
  SeriesMarkerBorder,
  SeriesMarkerDataLabel,
  SeriesMarkerDataLabelBorder,
  SeriesMarkerDataLabelConnectorLine,
  SeriesTooltip,
  SeriesTooltipBorder,
  SmaIndicator,
  Smithchart,
  SmithchartAxis,
  SmithchartAxisLine,
  SmithchartBorder,
  SmithchartFont,
  SmithchartLabelPosition,
  SmithchartLegend,
  SmithchartLegendSettings,
  SmithchartMajorGridLines,
  SmithchartMargin,
  SmithchartMinorGridLines,
  SmithchartRect,
  SmithchartSeries,
  SmithchartSize,
  Sparkline,
  SparklineBorder,
  SparklineDataLabelSettings,
  SparklineFont,
  SparklineMarkerSettings,
  SparklineTooltip,
  SparklineTooltipSettings,
  SplineAreaSeries,
  SplineRangeAreaSeries,
  SplineSeries,
  StackLabelSettings,
  StackLabelsFont,
  StackValues,
  StackingAreaSeries,
  StackingBarSeries,
  StackingBarSeries3D,
  StackingColumnSeries,
  StackingColumnSeries3D,
  StackingLineSeries,
  StackingStepAreaSeries,
  StepAreaSeries,
  StepLineSeries,
  StochasticIndicator,
  StockChart,
  StockChartAnnotationSettings,
  StockChartArea,
  StockChartAxis,
  StockChartBorder,
  StockChartConnector,
  StockChartFont,
  StockChartIndexes,
  StockChartIndicator,
  StockChartLegendSettings,
  StockChartRow,
  StockChartStripLineSettings,
  StockChartTrendline,
  StockEmptyPointSettings,
  StockEventsSettings,
  StockLegend,
  StockMargin,
  StockSeries,
  StockTooltipSettings,
  StripLine,
  StripLineSettings,
  StyleSettings,
  Subtitle,
  Svg3DRenderer,
  TechnicalIndicator,
  Thickness,
  ThumbSettings,
  Title,
  TitleBorder,
  TitleSettings,
  TitleStyleSettings,
  TmaIndicator,
  ToolbarPosition,
  Tooltip,
  Tooltip3D,
  TooltipRender,
  TooltipSettings,
  TrackLineSettings,
  TransformToVisible,
  Trendline,
  Trendlines,
  Vector3D,
  Visible3DLabels,
  VisibleLabels,
  WallRenderer,
  WaterfallSeries,
  Zoom,
  ZoomSettings,
  accReactTemplate,
  afterExport,
  animateAddPoints,
  animateRectElement,
  animateRedrawElement,
  animateTextElement,
  animationComplete,
  annotationRender,
  appendChildElement,
  appendClipElement,
  appendElement,
  applyZLight,
  axisLabelClick,
  axisLabelRender,
  axisMultiLabelRender,
  axisRangeCalculated,
  beforeExport,
  beforePrint,
  beforeResize,
  blazorTemplatesReset,
  bulletChartMouseClick,
  calculateLegendShapes,
  calculateRect,
  calculateScrollbarOffset,
  calculateShapes,
  calculateSize,
  chartDoubleClick,
  chartMouseClick,
  chartMouseDown,
  chartMouseLeave,
  chartMouseMove,
  chartMouseUp,
  chartReactTemplate,
  checkBounds,
  checkColorFormat,
  colorNameToHex,
  componentToHex,
  containsRect,
  convertHexToColor,
  convertToHexCode,
  createSvg,
  createTemplate,
  createTooltip,
  createZoomingLabels,
  degreeToLocation,
  degreeToRadian,
  drag,
  dragComplete,
  dragEnd,
  dragStart,
  drawSymbol,
  findClipRect,
  findCrosshairDirection,
  findlElement,
  firstToLowerCase,
  get3DSeriesColor,
  get3DThemeColor,
  getActualDesiredIntervalsCount,
  getAngle,
  getAnimationFunction,
  getBulletThemeColor,
  getColorByValue,
  getDraggedRectLocation,
  getElement,
  getExactData,
  getFontStyle,
  getGradientColor,
  getLabelText,
  getMedian,
  getMinPointsDelta,
  getMinPointsDeltaValue,
  getNearestValue,
  getPercentage,
  getPercentageColor,
  getPoint,
  getRangeThemeColor,
  getRangeValueXByPoint,
  getRectLocation,
  getRotatedRectangleCoordinates,
  getSaturationColor,
  getScrollbarThemeColor,
  getSeriesColor,
  getSeriesFromIndex,
  getTemplateFunction,
  getTextAnchor,
  getThemeColor,
  getTitle,
  getTransform,
  getUnicodeText,
  getValueXByPoint,
  getValueYByPoint,
  getVisiblePoints,
  getXLocation,
  indexFinder,
  inside,
  isBreakLabel,
  isCollide,
  isOverlap,
  isRotatedRectIntersect,
  isZoomSet,
  legendClick,
  legendRender,
  lineBreakLabelTrim,
  linear,
  load,
  loaded,
  logBase,
  logWithIn,
  markerAnimate,
  measureElementRect,
  minMax,
  multiLevelLabelClick,
  onZooming,
  pathAnimation,
  pointByIndex,
  pointClick,
  pointDoubleClick,
  pointMove,
  pointRender,
  rangeValueToCoefficient,
  redrawElement,
  regSub,
  regSup,
  removeElement,
  resized,
  rotateTextSize,
  scrollChanged,
  scrollEnd,
  scrollStart,
  selectionComplete,
  seriesRender,
  setRange,
  sharedTooltipRender,
  showTooltip,
  smithchartBeforePrint,
  sort,
  stockEventFont,
  stockEventRender,
  stopTimer,
  stringToNumber,
  subArray,
  subArraySum,
  subtractRect,
  subtractThickness,
  sum,
  templateAnimate,
  textElement,
  textRender,
  textTrim,
  textWrap,
  textWrapAnyWhere,
  titleBorder,
  titlePositionX,
  titleSettings,
  tooltipRender,
  triggerLabelRender,
  valueToCoefficient,
  valueToCoefficients,
  valueToPolarCoefficient,
  withIn,
  withInBounds,
  withInRange,
  zoomComplete
} from "./chunk-DIHZL7EQ.js";
import "./chunk-JYQ5LDSI.js";
import "./chunk-LIV5E5HL.js";
import {
  ArrayBase,
  ComplexBase,
  ComponentBase,
  ComponentMixins,
  Template,
  setValue
} from "./chunk-CDRQPQ4F.js";
import "./chunk-J6KMUI6T.js";
import {
  CommonModule
} from "./chunk-PDYOBC5X.js";
import "./chunk-JL63MSYC.js";
import {
  ChangeDetectionStrategy,
  Component,
  ContentChild,
  ContentChildren,
  Directive,
  ElementRef,
  Injector,
  NgModule,
  Renderer2,
  ViewContainerRef,
  __decorate,
  setClassMetadata,
  ɵɵInheritDefinitionFeature,
  ɵɵcontentQuery,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdirectiveInject,
  ɵɵloadQuery,
  ɵɵqueryRefresh
} from "./chunk-UOGKAELO.js";
import "./chunk-WDMUDEB6.js";

// node_modules/@syncfusion/ej2-angular-charts/fesm2020/syncfusion-ej2-angular-charts.mjs
var _c0 = ["dataLabelTemplate"];
var _c1 = ["content"];
var _c2 = ["tooltipTemplate"];
var input$y = ["accessibility", "animation", "backwardForecast", "dashArray", "enableTooltip", "fill", "forwardForecast", "intercept", "legendShape", "marker", "name", "period", "polynomialOrder", "type", "visible", "width"];
var outputs$H = [];
var TrendlineDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$H);
    this.directivePropList = input$y;
  }
};
TrendlineDirective.ɵfac = function TrendlineDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TrendlineDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
TrendlineDirective.ɵdir = ɵɵdefineDirective({
  type: TrendlineDirective,
  selectors: [["e-trendline"]],
  inputs: {
    accessibility: "accessibility",
    animation: "animation",
    backwardForecast: "backwardForecast",
    dashArray: "dashArray",
    enableTooltip: "enableTooltip",
    fill: "fill",
    forwardForecast: "forwardForecast",
    intercept: "intercept",
    legendShape: "legendShape",
    marker: "marker",
    name: "name",
    period: "period",
    polynomialOrder: "polynomialOrder",
    type: "type",
    visible: "visible",
    width: "width"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TrendlineDirective, [{
    type: Directive,
    args: [{
      selector: "e-series>e-trendlines>e-trendline",
      inputs: input$y,
      outputs: outputs$H,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, null);
})();
var TrendlinesDirective = class extends ArrayBase {
  constructor() {
    super("trendlines");
  }
};
TrendlinesDirective.ɵfac = function TrendlinesDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TrendlinesDirective)();
};
TrendlinesDirective.ɵdir = ɵɵdefineDirective({
  type: TrendlinesDirective,
  selectors: [["e-trendlines"]],
  contentQueries: function TrendlinesDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, TrendlineDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TrendlinesDirective, [{
    type: Directive,
    args: [{
      selector: "e-series>e-trendlines",
      queries: {
        children: new ContentChildren(TrendlineDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var input$x = ["color", "dashArray", "value"];
var outputs$G = [];
var SegmentDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$G);
    this.directivePropList = input$x;
  }
};
SegmentDirective.ɵfac = function SegmentDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SegmentDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
SegmentDirective.ɵdir = ɵɵdefineDirective({
  type: SegmentDirective,
  selectors: [["e-segment"]],
  inputs: {
    color: "color",
    dashArray: "dashArray",
    value: "value"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SegmentDirective, [{
    type: Directive,
    args: [{
      selector: "e-series>e-segments>e-segment",
      inputs: input$x,
      outputs: outputs$G,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, null);
})();
var SegmentsDirective = class extends ArrayBase {
  constructor() {
    super("segments");
  }
};
SegmentsDirective.ɵfac = function SegmentsDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SegmentsDirective)();
};
SegmentsDirective.ɵdir = ɵɵdefineDirective({
  type: SegmentsDirective,
  selectors: [["e-segments"]],
  contentQueries: function SegmentsDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, SegmentDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SegmentsDirective, [{
    type: Directive,
    args: [{
      selector: "e-series>e-segments",
      queries: {
        children: new ContentChildren(SegmentDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var input$w = ["accessibility", "animation", "bearFillColor", "binInterval", "border", "boxPlotMode", "bullFillColor", "cardinalSplineTension", "close", "colorName", "columnFacet", "columnSpacing", "columnWidth", "columnWidthInPixel", "connector", "cornerRadius", "dashArray", "dataSource", "dragSettings", "drawType", "emptyPointSettings", "enableComplexProperty", "enableSolidCandles", "enableTooltip", "errorBar", "fill", "groupName", "high", "intermediateSumIndexes", "isClosed", "legendImageUrl", "legendShape", "low", "marker", "maxRadius", "minRadius", "name", "negativeFillColor", "noRisers", "nonHighlightStyle", "opacity", "open", "paretoOptions", "pointColorMapping", "query", "segmentAxis", "segments", "selectionStyle", "showMean", "showNearestTooltip", "showNormalDistribution", "showOutliers", "size", "splineType", "stackingGroup", "step", "sumIndexes", "summaryFillColor", "tooltipFormat", "tooltipMappingName", "trendlines", "type", "unSelectedStyle", "visible", "volume", "width", "xAxisName", "xName", "yAxisName", "yName", "zOrder"];
var outputs$F = [];
var SeriesDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    this.tags = ["trendlines", "segments"];
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$F);
    this.directivePropList = input$w;
  }
};
SeriesDirective.ɵfac = function SeriesDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SeriesDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
SeriesDirective.ɵdir = ɵɵdefineDirective({
  type: SeriesDirective,
  selectors: [["e-series"]],
  contentQueries: function SeriesDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, _c0, 5);
      ɵɵcontentQuery(dirIndex, TrendlinesDirective, 5);
      ɵɵcontentQuery(dirIndex, SegmentsDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dataLabel_template = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childTrendlines = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childSegments = _t.first);
    }
  },
  inputs: {
    accessibility: "accessibility",
    animation: "animation",
    bearFillColor: "bearFillColor",
    binInterval: "binInterval",
    border: "border",
    boxPlotMode: "boxPlotMode",
    bullFillColor: "bullFillColor",
    cardinalSplineTension: "cardinalSplineTension",
    close: "close",
    colorName: "colorName",
    columnFacet: "columnFacet",
    columnSpacing: "columnSpacing",
    columnWidth: "columnWidth",
    columnWidthInPixel: "columnWidthInPixel",
    connector: "connector",
    cornerRadius: "cornerRadius",
    dashArray: "dashArray",
    dataSource: "dataSource",
    dragSettings: "dragSettings",
    drawType: "drawType",
    emptyPointSettings: "emptyPointSettings",
    enableComplexProperty: "enableComplexProperty",
    enableSolidCandles: "enableSolidCandles",
    enableTooltip: "enableTooltip",
    errorBar: "errorBar",
    fill: "fill",
    groupName: "groupName",
    high: "high",
    intermediateSumIndexes: "intermediateSumIndexes",
    isClosed: "isClosed",
    legendImageUrl: "legendImageUrl",
    legendShape: "legendShape",
    low: "low",
    marker: "marker",
    maxRadius: "maxRadius",
    minRadius: "minRadius",
    name: "name",
    negativeFillColor: "negativeFillColor",
    noRisers: "noRisers",
    nonHighlightStyle: "nonHighlightStyle",
    opacity: "opacity",
    open: "open",
    paretoOptions: "paretoOptions",
    pointColorMapping: "pointColorMapping",
    query: "query",
    segmentAxis: "segmentAxis",
    segments: "segments",
    selectionStyle: "selectionStyle",
    showMean: "showMean",
    showNearestTooltip: "showNearestTooltip",
    showNormalDistribution: "showNormalDistribution",
    showOutliers: "showOutliers",
    size: "size",
    splineType: "splineType",
    stackingGroup: "stackingGroup",
    step: "step",
    sumIndexes: "sumIndexes",
    summaryFillColor: "summaryFillColor",
    tooltipFormat: "tooltipFormat",
    tooltipMappingName: "tooltipMappingName",
    trendlines: "trendlines",
    type: "type",
    unSelectedStyle: "unSelectedStyle",
    visible: "visible",
    volume: "volume",
    width: "width",
    xAxisName: "xAxisName",
    xName: "xName",
    yAxisName: "yAxisName",
    yName: "yName",
    zOrder: "zOrder"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
__decorate([Template()], SeriesDirective.prototype, "dataLabel_template", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesDirective, [{
    type: Directive,
    args: [{
      selector: "e-series-collection>e-series",
      inputs: input$w,
      outputs: outputs$F,
      queries: {
        childTrendlines: new ContentChild(TrendlinesDirective),
        childSegments: new ContentChild(SegmentsDirective)
      }
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, {
    dataLabel_template: [{
      type: ContentChild,
      args: ["dataLabelTemplate"]
    }]
  });
})();
var SeriesCollectionDirective = class extends ArrayBase {
  constructor() {
    super("series");
  }
};
SeriesCollectionDirective.ɵfac = function SeriesCollectionDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SeriesCollectionDirective)();
};
SeriesCollectionDirective.ɵdir = ɵɵdefineDirective({
  type: SeriesCollectionDirective,
  selectors: [["e-series-collection"]],
  contentQueries: function SeriesCollectionDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, SeriesDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesCollectionDirective, [{
    type: Directive,
    args: [{
      selector: "ej-chart>e-series-collection",
      queries: {
        children: new ContentChildren(SeriesDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var input$v = ["border", "color", "dashArray", "end", "horizontalAlignment", "imageUrl", "isRepeat", "isSegmented", "opacity", "repeatEvery", "repeatUntil", "rotation", "segmentAxisName", "segmentEnd", "segmentStart", "size", "sizeType", "start", "startFromAxis", "text", "textStyle", "verticalAlignment", "visible", "zIndex"];
var outputs$E = [];
var StripLineDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$E);
    this.directivePropList = input$v;
  }
};
StripLineDirective.ɵfac = function StripLineDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StripLineDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
StripLineDirective.ɵdir = ɵɵdefineDirective({
  type: StripLineDirective,
  selectors: [["e-stripline"]],
  inputs: {
    border: "border",
    color: "color",
    dashArray: "dashArray",
    end: "end",
    horizontalAlignment: "horizontalAlignment",
    imageUrl: "imageUrl",
    isRepeat: "isRepeat",
    isSegmented: "isSegmented",
    opacity: "opacity",
    repeatEvery: "repeatEvery",
    repeatUntil: "repeatUntil",
    rotation: "rotation",
    segmentAxisName: "segmentAxisName",
    segmentEnd: "segmentEnd",
    segmentStart: "segmentStart",
    size: "size",
    sizeType: "sizeType",
    start: "start",
    startFromAxis: "startFromAxis",
    text: "text",
    textStyle: "textStyle",
    verticalAlignment: "verticalAlignment",
    visible: "visible",
    zIndex: "zIndex"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StripLineDirective, [{
    type: Directive,
    args: [{
      selector: "e-axis>e-striplines>e-stripline",
      inputs: input$v,
      outputs: outputs$E,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, null);
})();
var StripLinesDirective = class extends ArrayBase {
  constructor() {
    super("striplines");
  }
};
StripLinesDirective.ɵfac = function StripLinesDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StripLinesDirective)();
};
StripLinesDirective.ɵdir = ɵɵdefineDirective({
  type: StripLinesDirective,
  selectors: [["e-striplines"]],
  contentQueries: function StripLinesDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, StripLineDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StripLinesDirective, [{
    type: Directive,
    args: [{
      selector: "e-axis>e-striplines",
      queries: {
        children: new ContentChildren(StripLineDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var input$u = ["customAttributes", "end", "maximumTextWidth", "start", "text", "type"];
var outputs$D = [];
var CategoryDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$D);
    this.directivePropList = input$u;
  }
};
CategoryDirective.ɵfac = function CategoryDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || CategoryDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
CategoryDirective.ɵdir = ɵɵdefineDirective({
  type: CategoryDirective,
  selectors: [["e-category"]],
  inputs: {
    customAttributes: "customAttributes",
    end: "end",
    maximumTextWidth: "maximumTextWidth",
    start: "start",
    text: "text",
    type: "type"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CategoryDirective, [{
    type: Directive,
    args: [{
      selector: "e-multilevellabel>e-categories>e-category",
      inputs: input$u,
      outputs: outputs$D,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, null);
})();
var CategoriesDirective = class extends ArrayBase {
  constructor() {
    super("categories");
  }
};
CategoriesDirective.ɵfac = function CategoriesDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || CategoriesDirective)();
};
CategoriesDirective.ɵdir = ɵɵdefineDirective({
  type: CategoriesDirective,
  selectors: [["e-categories"]],
  contentQueries: function CategoriesDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, CategoryDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CategoriesDirective, [{
    type: Directive,
    args: [{
      selector: "e-multilevellabel>e-categories",
      queries: {
        children: new ContentChildren(CategoryDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var input$t = ["alignment", "border", "categories", "overflow", "textStyle"];
var outputs$C = [];
var MultiLevelLabelDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    this.tags = ["categories"];
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$C);
    this.directivePropList = input$t;
  }
};
MultiLevelLabelDirective.ɵfac = function MultiLevelLabelDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || MultiLevelLabelDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
MultiLevelLabelDirective.ɵdir = ɵɵdefineDirective({
  type: MultiLevelLabelDirective,
  selectors: [["e-multilevellabel"]],
  contentQueries: function MultiLevelLabelDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, CategoriesDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childCategories = _t.first);
    }
  },
  inputs: {
    alignment: "alignment",
    border: "border",
    categories: "categories",
    overflow: "overflow",
    textStyle: "textStyle"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiLevelLabelDirective, [{
    type: Directive,
    args: [{
      selector: "e-axis>e-multilevellabels>e-multilevellabel",
      inputs: input$t,
      outputs: outputs$C,
      queries: {
        childCategories: new ContentChild(CategoriesDirective)
      }
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, null);
})();
var MultiLevelLabelsDirective = class extends ArrayBase {
  constructor() {
    super("multilevellabels");
  }
};
MultiLevelLabelsDirective.ɵfac = function MultiLevelLabelsDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || MultiLevelLabelsDirective)();
};
MultiLevelLabelsDirective.ɵdir = ɵɵdefineDirective({
  type: MultiLevelLabelsDirective,
  selectors: [["e-multilevellabels"]],
  contentQueries: function MultiLevelLabelsDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, MultiLevelLabelDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiLevelLabelsDirective, [{
    type: Directive,
    args: [{
      selector: "e-axis>e-multilevellabels",
      queries: {
        children: new ContentChildren(MultiLevelLabelDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var input$s = ["border", "coefficient", "columnIndex", "crossesAt", "crossesInAxis", "crosshairTooltip", "description", "desiredIntervals", "edgeLabelPlacement", "enableAutoIntervalOnZooming", "enableScrollbarOnZooming", "enableTrim", "enableWrap", "interval", "intervalOffset", "intervalType", "isIndexed", "isInversed", "labelFormat", "labelIntersectAction", "labelPadding", "labelPlacement", "labelPosition", "labelRotation", "labelStyle", "lineBreakAlignment", "lineStyle", "logBase", "majorGridLines", "majorTickLines", "maximum", "maximumLabelWidth", "maximumLabels", "minimum", "minorGridLines", "minorTickLines", "minorTicksPerInterval", "multiLevelLabels", "name", "opposedPosition", "placeNextToAxisLine", "plotOffset", "plotOffsetBottom", "plotOffsetLeft", "plotOffsetRight", "plotOffsetTop", "rangePadding", "rowIndex", "scrollbarSettings", "skeleton", "skeletonType", "span", "startAngle", "startFromZero", "stripLines", "tabIndex", "tickPosition", "title", "titlePadding", "titleRotation", "titleStyle", "valueType", "visible", "zoomFactor", "zoomPosition"];
var outputs$B = [];
var AxisDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    this.tags = ["stripLines", "multiLevelLabels"];
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$B);
    this.directivePropList = input$s;
  }
};
AxisDirective.ɵfac = function AxisDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AxisDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
AxisDirective.ɵdir = ɵɵdefineDirective({
  type: AxisDirective,
  selectors: [["e-axis"]],
  contentQueries: function AxisDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, StripLinesDirective, 5);
      ɵɵcontentQuery(dirIndex, MultiLevelLabelsDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childStripLines = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childMultiLevelLabels = _t.first);
    }
  },
  inputs: {
    border: "border",
    coefficient: "coefficient",
    columnIndex: "columnIndex",
    crossesAt: "crossesAt",
    crossesInAxis: "crossesInAxis",
    crosshairTooltip: "crosshairTooltip",
    description: "description",
    desiredIntervals: "desiredIntervals",
    edgeLabelPlacement: "edgeLabelPlacement",
    enableAutoIntervalOnZooming: "enableAutoIntervalOnZooming",
    enableScrollbarOnZooming: "enableScrollbarOnZooming",
    enableTrim: "enableTrim",
    enableWrap: "enableWrap",
    interval: "interval",
    intervalOffset: "intervalOffset",
    intervalType: "intervalType",
    isIndexed: "isIndexed",
    isInversed: "isInversed",
    labelFormat: "labelFormat",
    labelIntersectAction: "labelIntersectAction",
    labelPadding: "labelPadding",
    labelPlacement: "labelPlacement",
    labelPosition: "labelPosition",
    labelRotation: "labelRotation",
    labelStyle: "labelStyle",
    lineBreakAlignment: "lineBreakAlignment",
    lineStyle: "lineStyle",
    logBase: "logBase",
    majorGridLines: "majorGridLines",
    majorTickLines: "majorTickLines",
    maximum: "maximum",
    maximumLabelWidth: "maximumLabelWidth",
    maximumLabels: "maximumLabels",
    minimum: "minimum",
    minorGridLines: "minorGridLines",
    minorTickLines: "minorTickLines",
    minorTicksPerInterval: "minorTicksPerInterval",
    multiLevelLabels: "multiLevelLabels",
    name: "name",
    opposedPosition: "opposedPosition",
    placeNextToAxisLine: "placeNextToAxisLine",
    plotOffset: "plotOffset",
    plotOffsetBottom: "plotOffsetBottom",
    plotOffsetLeft: "plotOffsetLeft",
    plotOffsetRight: "plotOffsetRight",
    plotOffsetTop: "plotOffsetTop",
    rangePadding: "rangePadding",
    rowIndex: "rowIndex",
    scrollbarSettings: "scrollbarSettings",
    skeleton: "skeleton",
    skeletonType: "skeletonType",
    span: "span",
    startAngle: "startAngle",
    startFromZero: "startFromZero",
    stripLines: "stripLines",
    tabIndex: "tabIndex",
    tickPosition: "tickPosition",
    title: "title",
    titlePadding: "titlePadding",
    titleRotation: "titleRotation",
    titleStyle: "titleStyle",
    valueType: "valueType",
    visible: "visible",
    zoomFactor: "zoomFactor",
    zoomPosition: "zoomPosition"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AxisDirective, [{
    type: Directive,
    args: [{
      selector: "e-axes>e-axis",
      inputs: input$s,
      outputs: outputs$B,
      queries: {
        childStripLines: new ContentChild(StripLinesDirective),
        childMultiLevelLabels: new ContentChild(MultiLevelLabelsDirective)
      }
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, null);
})();
var AxesDirective = class extends ArrayBase {
  constructor() {
    super("axes");
  }
};
AxesDirective.ɵfac = function AxesDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AxesDirective)();
};
AxesDirective.ɵdir = ɵɵdefineDirective({
  type: AxesDirective,
  selectors: [["e-axes"]],
  contentQueries: function AxesDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, AxisDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AxesDirective, [{
    type: Directive,
    args: [{
      selector: "ejs-chart>e-axes",
      queries: {
        children: new ContentChildren(AxisDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var input$r = ["border", "height"];
var outputs$A = [];
var RowDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$A);
    this.directivePropList = input$r;
  }
};
RowDirective.ɵfac = function RowDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RowDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
RowDirective.ɵdir = ɵɵdefineDirective({
  type: RowDirective,
  selectors: [["e-row"]],
  inputs: {
    border: "border",
    height: "height"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RowDirective, [{
    type: Directive,
    args: [{
      selector: "e-rows>e-row",
      inputs: input$r,
      outputs: outputs$A,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, null);
})();
var RowsDirective = class extends ArrayBase {
  constructor() {
    super("rows");
  }
};
RowsDirective.ɵfac = function RowsDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RowsDirective)();
};
RowsDirective.ɵdir = ɵɵdefineDirective({
  type: RowsDirective,
  selectors: [["e-rows"]],
  contentQueries: function RowsDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, RowDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RowsDirective, [{
    type: Directive,
    args: [{
      selector: "ejs-chart>e-rows",
      queries: {
        children: new ContentChildren(RowDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var input$q = ["border", "width"];
var outputs$z = [];
var ColumnDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$z);
    this.directivePropList = input$q;
  }
};
ColumnDirective.ɵfac = function ColumnDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ColumnDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
ColumnDirective.ɵdir = ɵɵdefineDirective({
  type: ColumnDirective,
  selectors: [["e-column"]],
  inputs: {
    border: "border",
    width: "width"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnDirective, [{
    type: Directive,
    args: [{
      selector: "e-columns>e-column",
      inputs: input$q,
      outputs: outputs$z,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, null);
})();
var ColumnsDirective = class extends ArrayBase {
  constructor() {
    super("columns");
  }
};
ColumnsDirective.ɵfac = function ColumnsDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ColumnsDirective)();
};
ColumnsDirective.ɵdir = ɵɵdefineDirective({
  type: ColumnsDirective,
  selectors: [["e-columns"]],
  contentQueries: function ColumnsDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ColumnDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnsDirective, [{
    type: Directive,
    args: [{
      selector: "ejs-chart>e-columns",
      queries: {
        children: new ContentChildren(ColumnDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var input$p = ["colors", "end", "label", "start"];
var outputs$y = [];
var RangeColorSettingDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$y);
    this.directivePropList = input$p;
  }
};
RangeColorSettingDirective.ɵfac = function RangeColorSettingDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RangeColorSettingDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
RangeColorSettingDirective.ɵdir = ɵɵdefineDirective({
  type: RangeColorSettingDirective,
  selectors: [["e-rangecolorsetting"]],
  inputs: {
    colors: "colors",
    end: "end",
    label: "label",
    start: "start"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangeColorSettingDirective, [{
    type: Directive,
    args: [{
      selector: "e-rangecolorsettings>e-rangecolorsetting",
      inputs: input$p,
      outputs: outputs$y,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, null);
})();
var RangeColorSettingsDirective = class extends ArrayBase {
  constructor() {
    super("rangecolorsettings");
  }
};
RangeColorSettingsDirective.ɵfac = function RangeColorSettingsDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RangeColorSettingsDirective)();
};
RangeColorSettingsDirective.ɵdir = ɵɵdefineDirective({
  type: RangeColorSettingsDirective,
  selectors: [["e-rangecolorsettings"]],
  contentQueries: function RangeColorSettingsDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, RangeColorSettingDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangeColorSettingsDirective, [{
    type: Directive,
    args: [{
      selector: "ejs-chart>e-rangecolorsettings",
      queries: {
        children: new ContentChildren(RangeColorSettingDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var input$o = ["accessibility", "content", "coordinateUnits", "description", "horizontalAlignment", "region", "verticalAlignment", "x", "xAxisName", "y", "yAxisName"];
var outputs$x = [];
var AnnotationDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$x);
    this.directivePropList = input$o;
  }
};
AnnotationDirective.ɵfac = function AnnotationDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AnnotationDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
AnnotationDirective.ɵdir = ɵɵdefineDirective({
  type: AnnotationDirective,
  selectors: [["e-annotation"]],
  contentQueries: function AnnotationDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, _c1, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.content = _t.first);
    }
  },
  inputs: {
    accessibility: "accessibility",
    content: "content",
    coordinateUnits: "coordinateUnits",
    description: "description",
    horizontalAlignment: "horizontalAlignment",
    region: "region",
    verticalAlignment: "verticalAlignment",
    x: "x",
    xAxisName: "xAxisName",
    y: "y",
    yAxisName: "yAxisName"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
__decorate([Template()], AnnotationDirective.prototype, "content", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AnnotationDirective, [{
    type: Directive,
    args: [{
      selector: "e-annotations>e-annotation",
      inputs: input$o,
      outputs: outputs$x,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, {
    content: [{
      type: ContentChild,
      args: ["content"]
    }]
  });
})();
var AnnotationsDirective = class extends ArrayBase {
  constructor() {
    super("annotations");
  }
};
AnnotationsDirective.ɵfac = function AnnotationsDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AnnotationsDirective)();
};
AnnotationsDirective.ɵdir = ɵɵdefineDirective({
  type: AnnotationsDirective,
  selectors: [["e-annotations"]],
  contentQueries: function AnnotationsDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, AnnotationDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AnnotationsDirective, [{
    type: Directive,
    args: [{
      selector: "ejs-chart>e-annotations",
      queries: {
        children: new ContentChildren(AnnotationDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var input$n = ["point", "series"];
var outputs$w = [];
var SelectedDataIndexDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$w);
    this.directivePropList = input$n;
  }
};
SelectedDataIndexDirective.ɵfac = function SelectedDataIndexDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SelectedDataIndexDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
SelectedDataIndexDirective.ɵdir = ɵɵdefineDirective({
  type: SelectedDataIndexDirective,
  selectors: [["e-selecteddataindex"]],
  inputs: {
    point: "point",
    series: "series"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectedDataIndexDirective, [{
    type: Directive,
    args: [{
      selector: "e-selecteddataindexes>e-selecteddataindex",
      inputs: input$n,
      outputs: outputs$w,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, null);
})();
var SelectedDataIndexesDirective = class extends ArrayBase {
  constructor() {
    super("selecteddataindexes");
  }
};
SelectedDataIndexesDirective.ɵfac = function SelectedDataIndexesDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SelectedDataIndexesDirective)();
};
SelectedDataIndexesDirective.ɵdir = ɵɵdefineDirective({
  type: SelectedDataIndexesDirective,
  selectors: [["e-selecteddataindexes"]],
  contentQueries: function SelectedDataIndexesDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, SelectedDataIndexDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectedDataIndexesDirective, [{
    type: Directive,
    args: [{
      selector: "ejs-chart>e-selecteddataindexes",
      queries: {
        children: new ContentChildren(SelectedDataIndexDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var input$m = ["accessibility", "animation", "bandColor", "close", "colorName", "dPeriod", "dashArray", "dataSource", "enableComplexProperty", "fastPeriod", "field", "fill", "high", "kPeriod", "low", "lowerLine", "macdLine", "macdNegativeColor", "macdPositiveColor", "macdType", "open", "overBought", "overSold", "period", "periodLine", "pointColorMapping", "query", "segmentAxis", "segments", "seriesName", "showZones", "slowPeriod", "standardDeviation", "type", "upperLine", "visible", "volume", "width", "xAxisName", "xName", "yAxisName"];
var outputs$v = [];
var IndicatorDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$v);
    this.directivePropList = input$m;
  }
};
IndicatorDirective.ɵfac = function IndicatorDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || IndicatorDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
IndicatorDirective.ɵdir = ɵɵdefineDirective({
  type: IndicatorDirective,
  selectors: [["e-indicator"]],
  inputs: {
    accessibility: "accessibility",
    animation: "animation",
    bandColor: "bandColor",
    close: "close",
    colorName: "colorName",
    dPeriod: "dPeriod",
    dashArray: "dashArray",
    dataSource: "dataSource",
    enableComplexProperty: "enableComplexProperty",
    fastPeriod: "fastPeriod",
    field: "field",
    fill: "fill",
    high: "high",
    kPeriod: "kPeriod",
    low: "low",
    lowerLine: "lowerLine",
    macdLine: "macdLine",
    macdNegativeColor: "macdNegativeColor",
    macdPositiveColor: "macdPositiveColor",
    macdType: "macdType",
    open: "open",
    overBought: "overBought",
    overSold: "overSold",
    period: "period",
    periodLine: "periodLine",
    pointColorMapping: "pointColorMapping",
    query: "query",
    segmentAxis: "segmentAxis",
    segments: "segments",
    seriesName: "seriesName",
    showZones: "showZones",
    slowPeriod: "slowPeriod",
    standardDeviation: "standardDeviation",
    type: "type",
    upperLine: "upperLine",
    visible: "visible",
    volume: "volume",
    width: "width",
    xAxisName: "xAxisName",
    xName: "xName",
    yAxisName: "yAxisName"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IndicatorDirective, [{
    type: Directive,
    args: [{
      selector: "e-indicators>e-indicator",
      inputs: input$m,
      outputs: outputs$v,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, null);
})();
var IndicatorsDirective = class extends ArrayBase {
  constructor() {
    super("indicators");
  }
};
IndicatorsDirective.ɵfac = function IndicatorsDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || IndicatorsDirective)();
};
IndicatorsDirective.ɵdir = ɵɵdefineDirective({
  type: IndicatorsDirective,
  selectors: [["e-indicators"]],
  contentQueries: function IndicatorsDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, IndicatorDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IndicatorsDirective, [{
    type: Directive,
    args: [{
      selector: "ej-chart>e-indicators",
      queries: {
        children: new ContentChildren(IndicatorDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var inputs$8 = ["accessibility", "allowExport", "allowMultiSelection", "annotations", "axes", "background", "backgroundImage", "border", "chartArea", "columns", "crosshair", "currencyCode", "dataSource", "description", "enableAnimation", "enableAutoIntervalOnBothAxis", "enableCanvas", "enableExport", "enableHtmlSanitizer", "enablePersistence", "enableRtl", "enableSideBySidePlacement", "focusBorderColor", "focusBorderMargin", "focusBorderWidth", "height", "highlightColor", "highlightMode", "highlightPattern", "indicators", "isMultiSelect", "isTransposed", "legendSettings", "locale", "margin", "palettes", "primaryXAxis", "primaryYAxis", "rangeColorSettings", "rows", "selectedDataIndexes", "selectionMode", "selectionPattern", "series", "stackLabels", "subTitle", "subTitleStyle", "tabIndex", "theme", "title", "titleStyle", "tooltip", "useGroupingSeparator", "width", "zoomSettings"];
var outputs$u = ["afterExport", "animationComplete", "annotationRender", "axisLabelClick", "axisLabelRender", "axisMultiLabelRender", "axisRangeCalculated", "beforeExport", "beforePrint", "beforeResize", "chartDoubleClick", "chartMouseClick", "chartMouseDown", "chartMouseLeave", "chartMouseMove", "chartMouseUp", "drag", "dragComplete", "dragEnd", "dragStart", "legendClick", "legendRender", "load", "loaded", "multiLevelLabelClick", "onZooming", "pointClick", "pointDoubleClick", "pointMove", "pointRender", "resized", "scrollChanged", "scrollEnd", "scrollStart", "selectionComplete", "seriesRender", "sharedTooltipRender", "textRender", "tooltipRender", "zoomComplete", "dataSourceChange"];
var twoWays$8 = ["dataSource"];
var ChartComponent = class ChartComponent2 extends Chart {
  constructor(ngEle, srenderer, viewContainerRef, injector) {
    super();
    this.ngEle = ngEle;
    this.srenderer = srenderer;
    this.viewContainerRef = viewContainerRef;
    this.injector = injector;
    this.tags = ["series", "axes", "rows", "columns", "rangeColorSettings", "annotations", "selectedDataIndexes", "indicators"];
    this.element = this.ngEle.nativeElement;
    this.injectedModules = this.injectedModules || [];
    try {
      let mod = this.injector.get("ChartsLineSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsScatterSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsColumnSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsSplineSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsSplineAreaSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsStripLine");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsAreaSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsScrollBar");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsStepLineSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsStepAreaSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsStackingColumnSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsStackingLineSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsStackingAreaSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsStackingStepAreaSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsBarSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsStackingBarSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsRangeColumnSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsBubbleSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsTooltip");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsCrosshair");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsCategory");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsDateTime");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsLogarithmic");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsLegend");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsZoom");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsDataLabel");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsSelection");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsChartAnnotation");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsHiloSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsHiloOpenCloseSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsWaterfallSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsRangeAreaSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsRangeStepAreaSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsSplineRangeAreaSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsCandleSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsPolarSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsRadarSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsSmaIndicator");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsTmaIndicator");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsEmaIndicator");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsAccumulationDistributionIndicator");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsMacdIndicator");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsAtrIndicator");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsRsiIndicator");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsMomentumIndicator");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsStochasticIndicator");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsBollingerBands");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsBoxAndWhiskerSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsHistogramSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsErrorBar");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsTrendlines");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsDateTimeCategory");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsMultiColoredLineSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsMultiColoredAreaSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsMultiLevelLabel");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsParetoSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsExport");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsDataEditing");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsHighlight");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    this.registerEvents(outputs$u);
    this.addTwoWay.call(this, twoWays$8);
    setValue("currentInstance", this, this.viewContainerRef);
    this.context = new ComponentBase();
  }
  ngOnInit() {
    this.context.ngOnInit(this);
  }
  ngAfterViewInit() {
    this.context.ngAfterViewInit(this);
  }
  ngOnDestroy() {
    this.context.ngOnDestroy(this);
  }
  ngAfterContentChecked() {
    this.tagObjects[0].instance = this.childSeries;
    if (this.childAxes) {
      this.tagObjects[1].instance = this.childAxes;
    }
    if (this.childRows) {
      this.tagObjects[2].instance = this.childRows;
    }
    if (this.childColumns) {
      this.tagObjects[3].instance = this.childColumns;
    }
    if (this.childRangeColorSettings) {
      this.tagObjects[4].instance = this.childRangeColorSettings;
    }
    if (this.childAnnotations) {
      this.tagObjects[5].instance = this.childAnnotations;
    }
    if (this.childSelectedDataIndexes) {
      this.tagObjects[6].instance = this.childSelectedDataIndexes;
    }
    if (this.childIndicators) {
      this.tagObjects[7].instance = this.childIndicators;
    }
    this.context.ngAfterContentChecked(this);
  }
};
ChartComponent.ɵfac = function ChartComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ChartComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector));
};
ChartComponent.ɵcmp = ɵɵdefineComponent({
  type: ChartComponent,
  selectors: [["ejs-chart"]],
  contentQueries: function ChartComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, _c2, 5);
      ɵɵcontentQuery(dirIndex, SeriesCollectionDirective, 5);
      ɵɵcontentQuery(dirIndex, AxesDirective, 5);
      ɵɵcontentQuery(dirIndex, RowsDirective, 5);
      ɵɵcontentQuery(dirIndex, ColumnsDirective, 5);
      ɵɵcontentQuery(dirIndex, RangeColorSettingsDirective, 5);
      ɵɵcontentQuery(dirIndex, AnnotationsDirective, 5);
      ɵɵcontentQuery(dirIndex, SelectedDataIndexesDirective, 5);
      ɵɵcontentQuery(dirIndex, IndicatorsDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tooltip_template = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childSeries = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childAxes = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childRows = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childColumns = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childRangeColorSettings = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childAnnotations = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childSelectedDataIndexes = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childIndicators = _t.first);
    }
  },
  inputs: {
    accessibility: "accessibility",
    allowExport: "allowExport",
    allowMultiSelection: "allowMultiSelection",
    annotations: "annotations",
    axes: "axes",
    background: "background",
    backgroundImage: "backgroundImage",
    border: "border",
    chartArea: "chartArea",
    columns: "columns",
    crosshair: "crosshair",
    currencyCode: "currencyCode",
    dataSource: "dataSource",
    description: "description",
    enableAnimation: "enableAnimation",
    enableAutoIntervalOnBothAxis: "enableAutoIntervalOnBothAxis",
    enableCanvas: "enableCanvas",
    enableExport: "enableExport",
    enableHtmlSanitizer: "enableHtmlSanitizer",
    enablePersistence: "enablePersistence",
    enableRtl: "enableRtl",
    enableSideBySidePlacement: "enableSideBySidePlacement",
    focusBorderColor: "focusBorderColor",
    focusBorderMargin: "focusBorderMargin",
    focusBorderWidth: "focusBorderWidth",
    height: "height",
    highlightColor: "highlightColor",
    highlightMode: "highlightMode",
    highlightPattern: "highlightPattern",
    indicators: "indicators",
    isMultiSelect: "isMultiSelect",
    isTransposed: "isTransposed",
    legendSettings: "legendSettings",
    locale: "locale",
    margin: "margin",
    palettes: "palettes",
    primaryXAxis: "primaryXAxis",
    primaryYAxis: "primaryYAxis",
    rangeColorSettings: "rangeColorSettings",
    rows: "rows",
    selectedDataIndexes: "selectedDataIndexes",
    selectionMode: "selectionMode",
    selectionPattern: "selectionPattern",
    series: "series",
    stackLabels: "stackLabels",
    subTitle: "subTitle",
    subTitleStyle: "subTitleStyle",
    tabIndex: "tabIndex",
    theme: "theme",
    title: "title",
    titleStyle: "titleStyle",
    tooltip: "tooltip",
    useGroupingSeparator: "useGroupingSeparator",
    width: "width",
    zoomSettings: "zoomSettings"
  },
  outputs: {
    afterExport: "afterExport",
    animationComplete: "animationComplete",
    annotationRender: "annotationRender",
    axisLabelClick: "axisLabelClick",
    axisLabelRender: "axisLabelRender",
    axisMultiLabelRender: "axisMultiLabelRender",
    axisRangeCalculated: "axisRangeCalculated",
    beforeExport: "beforeExport",
    beforePrint: "beforePrint",
    beforeResize: "beforeResize",
    chartDoubleClick: "chartDoubleClick",
    chartMouseClick: "chartMouseClick",
    chartMouseDown: "chartMouseDown",
    chartMouseLeave: "chartMouseLeave",
    chartMouseMove: "chartMouseMove",
    chartMouseUp: "chartMouseUp",
    drag: "drag",
    dragComplete: "dragComplete",
    dragEnd: "dragEnd",
    dragStart: "dragStart",
    legendClick: "legendClick",
    legendRender: "legendRender",
    load: "load",
    loaded: "loaded",
    multiLevelLabelClick: "multiLevelLabelClick",
    onZooming: "onZooming",
    pointClick: "pointClick",
    pointDoubleClick: "pointDoubleClick",
    pointMove: "pointMove",
    pointRender: "pointRender",
    resized: "resized",
    scrollChanged: "scrollChanged",
    scrollEnd: "scrollEnd",
    scrollStart: "scrollStart",
    selectionComplete: "selectionComplete",
    seriesRender: "seriesRender",
    sharedTooltipRender: "sharedTooltipRender",
    textRender: "textRender",
    tooltipRender: "tooltipRender",
    zoomComplete: "zoomComplete",
    dataSourceChange: "dataSourceChange"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function ChartComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
__decorate([Template()], ChartComponent.prototype, "tooltip_template", void 0);
ChartComponent = __decorate([ComponentMixins([ComponentBase])], ChartComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChartComponent, [{
    type: Component,
    args: [{
      selector: "ejs-chart",
      inputs: inputs$8,
      outputs: outputs$u,
      template: "",
      queries: {
        childSeries: new ContentChild(SeriesCollectionDirective),
        childAxes: new ContentChild(AxesDirective),
        childRows: new ContentChild(RowsDirective),
        childColumns: new ContentChild(ColumnsDirective),
        childRangeColorSettings: new ContentChild(RangeColorSettingsDirective),
        childAnnotations: new ContentChild(AnnotationsDirective),
        childSelectedDataIndexes: new ContentChild(SelectedDataIndexesDirective),
        childIndicators: new ContentChild(IndicatorsDirective)
      }
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ViewContainerRef
    }, {
      type: Injector
    }];
  }, {
    tooltip_template: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var ChartModule = class {
};
ChartModule.ɵfac = function ChartModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ChartModule)();
};
ChartModule.ɵmod = ɵɵdefineNgModule({
  type: ChartModule,
  declarations: [ChartComponent, TrendlineDirective, TrendlinesDirective, SegmentDirective, SegmentsDirective, SeriesDirective, SeriesCollectionDirective, StripLineDirective, StripLinesDirective, CategoryDirective, CategoriesDirective, MultiLevelLabelDirective, MultiLevelLabelsDirective, AxisDirective, AxesDirective, RowDirective, RowsDirective, ColumnDirective, ColumnsDirective, RangeColorSettingDirective, RangeColorSettingsDirective, AnnotationDirective, AnnotationsDirective, SelectedDataIndexDirective, SelectedDataIndexesDirective, IndicatorDirective, IndicatorsDirective],
  imports: [CommonModule],
  exports: [ChartComponent, TrendlineDirective, TrendlinesDirective, SegmentDirective, SegmentsDirective, SeriesDirective, SeriesCollectionDirective, StripLineDirective, StripLinesDirective, CategoryDirective, CategoriesDirective, MultiLevelLabelDirective, MultiLevelLabelsDirective, AxisDirective, AxesDirective, RowDirective, RowsDirective, ColumnDirective, ColumnsDirective, RangeColorSettingDirective, RangeColorSettingsDirective, AnnotationDirective, AnnotationsDirective, SelectedDataIndexDirective, SelectedDataIndexesDirective, IndicatorDirective, IndicatorsDirective]
});
ChartModule.ɵinj = ɵɵdefineInjector({
  imports: [[CommonModule]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChartModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [ChartComponent, TrendlineDirective, TrendlinesDirective, SegmentDirective, SegmentsDirective, SeriesDirective, SeriesCollectionDirective, StripLineDirective, StripLinesDirective, CategoryDirective, CategoriesDirective, MultiLevelLabelDirective, MultiLevelLabelsDirective, AxisDirective, AxesDirective, RowDirective, RowsDirective, ColumnDirective, ColumnsDirective, RangeColorSettingDirective, RangeColorSettingsDirective, AnnotationDirective, AnnotationsDirective, SelectedDataIndexDirective, SelectedDataIndexesDirective, IndicatorDirective, IndicatorsDirective],
      exports: [ChartComponent, TrendlineDirective, TrendlinesDirective, SegmentDirective, SegmentsDirective, SeriesDirective, SeriesCollectionDirective, StripLineDirective, StripLinesDirective, CategoryDirective, CategoriesDirective, MultiLevelLabelDirective, MultiLevelLabelsDirective, AxisDirective, AxesDirective, RowDirective, RowsDirective, ColumnDirective, ColumnsDirective, RangeColorSettingDirective, RangeColorSettingsDirective, AnnotationDirective, AnnotationsDirective, SelectedDataIndexDirective, SelectedDataIndexesDirective, IndicatorDirective, IndicatorsDirective]
    }]
  }], null, null);
})();
var LineSeriesService = {
  provide: "ChartsLineSeries",
  useValue: LineSeries
};
var ScatterSeriesService = {
  provide: "ChartsScatterSeries",
  useValue: ScatterSeries
};
var ColumnSeriesService = {
  provide: "ChartsColumnSeries",
  useValue: ColumnSeries
};
var SplineSeriesService = {
  provide: "ChartsSplineSeries",
  useValue: SplineSeries
};
var SplineAreaSeriesService = {
  provide: "ChartsSplineAreaSeries",
  useValue: SplineAreaSeries
};
var StripLineService = {
  provide: "ChartsStripLine",
  useValue: StripLine
};
var AreaSeriesService = {
  provide: "ChartsAreaSeries",
  useValue: AreaSeries
};
var ScrollBarService = {
  provide: "ChartsScrollBar",
  useValue: ScrollBar
};
var StepLineSeriesService = {
  provide: "ChartsStepLineSeries",
  useValue: StepLineSeries
};
var StepAreaSeriesService = {
  provide: "ChartsStepAreaSeries",
  useValue: StepAreaSeries
};
var StackingColumnSeriesService = {
  provide: "ChartsStackingColumnSeries",
  useValue: StackingColumnSeries
};
var StackingLineSeriesService = {
  provide: "ChartsStackingLineSeries",
  useValue: StackingLineSeries
};
var StackingAreaSeriesService = {
  provide: "ChartsStackingAreaSeries",
  useValue: StackingAreaSeries
};
var StackingStepAreaSeriesService = {
  provide: "ChartsStackingStepAreaSeries",
  useValue: StackingStepAreaSeries
};
var BarSeriesService = {
  provide: "ChartsBarSeries",
  useValue: BarSeries
};
var StackingBarSeriesService = {
  provide: "ChartsStackingBarSeries",
  useValue: StackingBarSeries
};
var RangeColumnSeriesService = {
  provide: "ChartsRangeColumnSeries",
  useValue: RangeColumnSeries
};
var BubbleSeriesService = {
  provide: "ChartsBubbleSeries",
  useValue: BubbleSeries
};
var TooltipService = {
  provide: "ChartsTooltip",
  useValue: Tooltip
};
var CrosshairService = {
  provide: "ChartsCrosshair",
  useValue: Crosshair
};
var CategoryService = {
  provide: "ChartsCategory",
  useValue: Category
};
var DateTimeService = {
  provide: "ChartsDateTime",
  useValue: DateTime
};
var LogarithmicService = {
  provide: "ChartsLogarithmic",
  useValue: Logarithmic
};
var LegendService = {
  provide: "ChartsLegend",
  useValue: Legend
};
var ZoomService = {
  provide: "ChartsZoom",
  useValue: Zoom
};
var DataLabelService = {
  provide: "ChartsDataLabel",
  useValue: DataLabel
};
var SelectionService = {
  provide: "ChartsSelection",
  useValue: Selection
};
var ChartAnnotationService = {
  provide: "ChartsChartAnnotation",
  useValue: ChartAnnotation
};
var HiloSeriesService = {
  provide: "ChartsHiloSeries",
  useValue: HiloSeries
};
var HiloOpenCloseSeriesService = {
  provide: "ChartsHiloOpenCloseSeries",
  useValue: HiloOpenCloseSeries
};
var WaterfallSeriesService = {
  provide: "ChartsWaterfallSeries",
  useValue: WaterfallSeries
};
var RangeAreaSeriesService = {
  provide: "ChartsRangeAreaSeries",
  useValue: RangeAreaSeries
};
var RangeStepAreaSeriesService = {
  provide: "ChartsRangeStepAreaSeries",
  useValue: RangeStepAreaSeries
};
var SplineRangeAreaSeriesService = {
  provide: "ChartsSplineRangeAreaSeries",
  useValue: SplineRangeAreaSeries
};
var CandleSeriesService = {
  provide: "ChartsCandleSeries",
  useValue: CandleSeries
};
var PolarSeriesService = {
  provide: "ChartsPolarSeries",
  useValue: PolarSeries
};
var RadarSeriesService = {
  provide: "ChartsRadarSeries",
  useValue: RadarSeries
};
var SmaIndicatorService = {
  provide: "ChartsSmaIndicator",
  useValue: SmaIndicator
};
var TmaIndicatorService = {
  provide: "ChartsTmaIndicator",
  useValue: TmaIndicator
};
var EmaIndicatorService = {
  provide: "ChartsEmaIndicator",
  useValue: EmaIndicator
};
var AccumulationDistributionIndicatorService = {
  provide: "ChartsAccumulationDistributionIndicator",
  useValue: AccumulationDistributionIndicator
};
var MacdIndicatorService = {
  provide: "ChartsMacdIndicator",
  useValue: MacdIndicator
};
var AtrIndicatorService = {
  provide: "ChartsAtrIndicator",
  useValue: AtrIndicator
};
var RsiIndicatorService = {
  provide: "ChartsRsiIndicator",
  useValue: RsiIndicator
};
var MomentumIndicatorService = {
  provide: "ChartsMomentumIndicator",
  useValue: MomentumIndicator
};
var StochasticIndicatorService = {
  provide: "ChartsStochasticIndicator",
  useValue: StochasticIndicator
};
var BollingerBandsService = {
  provide: "ChartsBollingerBands",
  useValue: BollingerBands
};
var BoxAndWhiskerSeriesService = {
  provide: "ChartsBoxAndWhiskerSeries",
  useValue: BoxAndWhiskerSeries
};
var HistogramSeriesService = {
  provide: "ChartsHistogramSeries",
  useValue: HistogramSeries
};
var ErrorBarService = {
  provide: "ChartsErrorBar",
  useValue: ErrorBar
};
var TrendlinesService = {
  provide: "ChartsTrendlines",
  useValue: Trendlines
};
var DateTimeCategoryService = {
  provide: "ChartsDateTimeCategory",
  useValue: DateTimeCategory
};
var MultiColoredLineSeriesService = {
  provide: "ChartsMultiColoredLineSeries",
  useValue: MultiColoredLineSeries
};
var MultiColoredAreaSeriesService = {
  provide: "ChartsMultiColoredAreaSeries",
  useValue: MultiColoredAreaSeries
};
var MultiLevelLabelService = {
  provide: "ChartsMultiLevelLabel",
  useValue: MultiLevelLabel
};
var ParetoSeriesService = {
  provide: "ChartsParetoSeries",
  useValue: ParetoSeries
};
var ExportService = {
  provide: "ChartsExport",
  useValue: Export
};
var DataEditingService = {
  provide: "ChartsDataEditing",
  useValue: DataEditing
};
var HighlightService = {
  provide: "ChartsHighlight",
  useValue: Highlight
};
var ChartAllModule = class {
};
ChartAllModule.ɵfac = function ChartAllModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ChartAllModule)();
};
ChartAllModule.ɵmod = ɵɵdefineNgModule({
  type: ChartAllModule,
  imports: [CommonModule, ChartModule],
  exports: [ChartModule]
});
ChartAllModule.ɵinj = ɵɵdefineInjector({
  providers: [LineSeriesService, ScatterSeriesService, ColumnSeriesService, SplineSeriesService, SplineAreaSeriesService, StripLineService, AreaSeriesService, ScrollBarService, StepLineSeriesService, StepAreaSeriesService, StackingColumnSeriesService, StackingLineSeriesService, StackingAreaSeriesService, StackingStepAreaSeriesService, BarSeriesService, StackingBarSeriesService, RangeColumnSeriesService, BubbleSeriesService, TooltipService, CrosshairService, CategoryService, DateTimeService, LogarithmicService, LegendService, ZoomService, DataLabelService, SelectionService, ChartAnnotationService, HiloSeriesService, HiloOpenCloseSeriesService, WaterfallSeriesService, RangeAreaSeriesService, RangeStepAreaSeriesService, SplineRangeAreaSeriesService, CandleSeriesService, PolarSeriesService, RadarSeriesService, SmaIndicatorService, TmaIndicatorService, EmaIndicatorService, AccumulationDistributionIndicatorService, MacdIndicatorService, AtrIndicatorService, RsiIndicatorService, MomentumIndicatorService, StochasticIndicatorService, BollingerBandsService, BoxAndWhiskerSeriesService, HistogramSeriesService, ErrorBarService, TrendlinesService, DateTimeCategoryService, MultiColoredLineSeriesService, MultiColoredAreaSeriesService, MultiLevelLabelService, ParetoSeriesService, ExportService, DataEditingService, HighlightService],
  imports: [[CommonModule, ChartModule], ChartModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChartAllModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ChartModule],
      exports: [ChartModule],
      providers: [LineSeriesService, ScatterSeriesService, ColumnSeriesService, SplineSeriesService, SplineAreaSeriesService, StripLineService, AreaSeriesService, ScrollBarService, StepLineSeriesService, StepAreaSeriesService, StackingColumnSeriesService, StackingLineSeriesService, StackingAreaSeriesService, StackingStepAreaSeriesService, BarSeriesService, StackingBarSeriesService, RangeColumnSeriesService, BubbleSeriesService, TooltipService, CrosshairService, CategoryService, DateTimeService, LogarithmicService, LegendService, ZoomService, DataLabelService, SelectionService, ChartAnnotationService, HiloSeriesService, HiloOpenCloseSeriesService, WaterfallSeriesService, RangeAreaSeriesService, RangeStepAreaSeriesService, SplineRangeAreaSeriesService, CandleSeriesService, PolarSeriesService, RadarSeriesService, SmaIndicatorService, TmaIndicatorService, EmaIndicatorService, AccumulationDistributionIndicatorService, MacdIndicatorService, AtrIndicatorService, RsiIndicatorService, MomentumIndicatorService, StochasticIndicatorService, BollingerBandsService, BoxAndWhiskerSeriesService, HistogramSeriesService, ErrorBarService, TrendlinesService, DateTimeCategoryService, MultiColoredLineSeriesService, MultiColoredAreaSeriesService, MultiLevelLabelService, ParetoSeriesService, ExportService, DataEditingService, HighlightService]
    }]
  }], null, null);
})();
var input$l = ["accessibility", "animation", "applyPattern", "border", "borderRadius", "dashArray", "dataLabel", "dataSource", "emptyPointSettings", "enableTooltip", "endAngle", "explode", "explodeAll", "explodeIndex", "explodeOffset", "funnelMode", "gapRatio", "groupMode", "groupTo", "height", "innerRadius", "legendImageUrl", "legendShape", "name", "neckHeight", "neckWidth", "opacity", "palettes", "pointColorMapping", "pyramidMode", "query", "radius", "selectionStyle", "startAngle", "tooltipMappingName", "type", "visible", "width", "xName", "yName"];
var outputs$t = [];
var AccumulationSeriesDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$t);
    this.directivePropList = input$l;
  }
};
AccumulationSeriesDirective.ɵfac = function AccumulationSeriesDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AccumulationSeriesDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
AccumulationSeriesDirective.ɵdir = ɵɵdefineDirective({
  type: AccumulationSeriesDirective,
  selectors: [["e-accumulation-series"]],
  contentQueries: function AccumulationSeriesDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, _c0, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dataLabel_template = _t.first);
    }
  },
  inputs: {
    accessibility: "accessibility",
    animation: "animation",
    applyPattern: "applyPattern",
    border: "border",
    borderRadius: "borderRadius",
    dashArray: "dashArray",
    dataLabel: "dataLabel",
    dataSource: "dataSource",
    emptyPointSettings: "emptyPointSettings",
    enableTooltip: "enableTooltip",
    endAngle: "endAngle",
    explode: "explode",
    explodeAll: "explodeAll",
    explodeIndex: "explodeIndex",
    explodeOffset: "explodeOffset",
    funnelMode: "funnelMode",
    gapRatio: "gapRatio",
    groupMode: "groupMode",
    groupTo: "groupTo",
    height: "height",
    innerRadius: "innerRadius",
    legendImageUrl: "legendImageUrl",
    legendShape: "legendShape",
    name: "name",
    neckHeight: "neckHeight",
    neckWidth: "neckWidth",
    opacity: "opacity",
    palettes: "palettes",
    pointColorMapping: "pointColorMapping",
    pyramidMode: "pyramidMode",
    query: "query",
    radius: "radius",
    selectionStyle: "selectionStyle",
    startAngle: "startAngle",
    tooltipMappingName: "tooltipMappingName",
    type: "type",
    visible: "visible",
    width: "width",
    xName: "xName",
    yName: "yName"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
__decorate([Template()], AccumulationSeriesDirective.prototype, "dataLabel_template", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AccumulationSeriesDirective, [{
    type: Directive,
    args: [{
      selector: "e-accumulation-series-collection>e-accumulation-series",
      inputs: input$l,
      outputs: outputs$t,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, {
    dataLabel_template: [{
      type: ContentChild,
      args: ["dataLabelTemplate"]
    }]
  });
})();
var AccumulationSeriesCollectionDirective = class extends ArrayBase {
  constructor() {
    super("series");
  }
};
AccumulationSeriesCollectionDirective.ɵfac = function AccumulationSeriesCollectionDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AccumulationSeriesCollectionDirective)();
};
AccumulationSeriesCollectionDirective.ɵdir = ɵɵdefineDirective({
  type: AccumulationSeriesCollectionDirective,
  selectors: [["e-accumulation-series-collection"]],
  contentQueries: function AccumulationSeriesCollectionDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, AccumulationSeriesDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AccumulationSeriesCollectionDirective, [{
    type: Directive,
    args: [{
      selector: "ej-accumulationchart>e-accumulation-series-collection",
      queries: {
        children: new ContentChildren(AccumulationSeriesDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var input$k = ["content", "coordinateUnits", "description", "horizontalAlignment", "region", "verticalAlignment", "x", "y"];
var outputs$s = [];
var AccumulationAnnotationDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$s);
    this.directivePropList = input$k;
  }
};
AccumulationAnnotationDirective.ɵfac = function AccumulationAnnotationDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AccumulationAnnotationDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
AccumulationAnnotationDirective.ɵdir = ɵɵdefineDirective({
  type: AccumulationAnnotationDirective,
  selectors: [["e-accumulation-annotation"]],
  contentQueries: function AccumulationAnnotationDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, _c1, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.content = _t.first);
    }
  },
  inputs: {
    content: "content",
    coordinateUnits: "coordinateUnits",
    description: "description",
    horizontalAlignment: "horizontalAlignment",
    region: "region",
    verticalAlignment: "verticalAlignment",
    x: "x",
    y: "y"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
__decorate([Template()], AccumulationAnnotationDirective.prototype, "content", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AccumulationAnnotationDirective, [{
    type: Directive,
    args: [{
      selector: "e-accumulation-annotations>e-accumulation-annotation",
      inputs: input$k,
      outputs: outputs$s,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, {
    content: [{
      type: ContentChild,
      args: ["content"]
    }]
  });
})();
var AccumulationAnnotationsDirective = class extends ArrayBase {
  constructor() {
    super("annotations");
  }
};
AccumulationAnnotationsDirective.ɵfac = function AccumulationAnnotationsDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AccumulationAnnotationsDirective)();
};
AccumulationAnnotationsDirective.ɵdir = ɵɵdefineDirective({
  type: AccumulationAnnotationsDirective,
  selectors: [["e-accumulation-annotations"]],
  contentQueries: function AccumulationAnnotationsDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, AccumulationAnnotationDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AccumulationAnnotationsDirective, [{
    type: Directive,
    args: [{
      selector: "ej-accumulationchart>e-accumulation-annotations",
      queries: {
        children: new ContentChildren(AccumulationAnnotationDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var inputs$7 = ["accessibility", "allowExport", "annotations", "background", "backgroundImage", "border", "center", "centerLabel", "currencyCode", "dataSource", "enableAnimation", "enableBorderOnMouseMove", "enableExport", "enableHtmlSanitizer", "enablePersistence", "enableRtl", "enableSmartLabels", "focusBorderColor", "focusBorderMargin", "focusBorderWidth", "height", "highlightColor", "highlightMode", "highlightPattern", "isMultiSelect", "legendSettings", "locale", "margin", "selectedDataIndexes", "selectionMode", "selectionPattern", "series", "subTitle", "subTitleStyle", "theme", "title", "titleStyle", "tooltip", "useGroupingSeparator", "width"];
var outputs$r = ["afterExport", "animationComplete", "annotationRender", "beforeExport", "beforePrint", "beforeResize", "chartDoubleClick", "chartMouseClick", "chartMouseDown", "chartMouseLeave", "chartMouseMove", "chartMouseUp", "legendClick", "legendRender", "load", "loaded", "pointClick", "pointMove", "pointRender", "resized", "selectionComplete", "seriesRender", "textRender", "tooltipRender", "dataSourceChange"];
var twoWays$7 = ["dataSource"];
var AccumulationChartComponent = class AccumulationChartComponent2 extends AccumulationChart {
  constructor(ngEle, srenderer, viewContainerRef, injector) {
    super();
    this.ngEle = ngEle;
    this.srenderer = srenderer;
    this.viewContainerRef = viewContainerRef;
    this.injector = injector;
    this.tags = ["series", "annotations"];
    this.element = this.ngEle.nativeElement;
    this.injectedModules = this.injectedModules || [];
    try {
      let mod = this.injector.get("ChartsPieSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsFunnelSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsPyramidSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsAccumulationTooltip");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsAccumulationLegend");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsAccumulationSelection");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsAccumulationHighlight");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsAccumulationDataLabel");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsAccumulationAnnotation");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsExport");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    this.registerEvents(outputs$r);
    this.addTwoWay.call(this, twoWays$7);
    setValue("currentInstance", this, this.viewContainerRef);
    this.context = new ComponentBase();
  }
  ngOnInit() {
    this.context.ngOnInit(this);
  }
  ngAfterViewInit() {
    this.context.ngAfterViewInit(this);
  }
  ngOnDestroy() {
    this.context.ngOnDestroy(this);
  }
  ngAfterContentChecked() {
    this.tagObjects[0].instance = this.childSeries;
    if (this.childAnnotations) {
      this.tagObjects[1].instance = this.childAnnotations;
    }
    this.context.ngAfterContentChecked(this);
  }
};
AccumulationChartComponent.ɵfac = function AccumulationChartComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AccumulationChartComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector));
};
AccumulationChartComponent.ɵcmp = ɵɵdefineComponent({
  type: AccumulationChartComponent,
  selectors: [["ejs-accumulationchart"]],
  contentQueries: function AccumulationChartComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, _c2, 5);
      ɵɵcontentQuery(dirIndex, AccumulationSeriesCollectionDirective, 5);
      ɵɵcontentQuery(dirIndex, AccumulationAnnotationsDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tooltip_template = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childSeries = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childAnnotations = _t.first);
    }
  },
  inputs: {
    accessibility: "accessibility",
    allowExport: "allowExport",
    annotations: "annotations",
    background: "background",
    backgroundImage: "backgroundImage",
    border: "border",
    center: "center",
    centerLabel: "centerLabel",
    currencyCode: "currencyCode",
    dataSource: "dataSource",
    enableAnimation: "enableAnimation",
    enableBorderOnMouseMove: "enableBorderOnMouseMove",
    enableExport: "enableExport",
    enableHtmlSanitizer: "enableHtmlSanitizer",
    enablePersistence: "enablePersistence",
    enableRtl: "enableRtl",
    enableSmartLabels: "enableSmartLabels",
    focusBorderColor: "focusBorderColor",
    focusBorderMargin: "focusBorderMargin",
    focusBorderWidth: "focusBorderWidth",
    height: "height",
    highlightColor: "highlightColor",
    highlightMode: "highlightMode",
    highlightPattern: "highlightPattern",
    isMultiSelect: "isMultiSelect",
    legendSettings: "legendSettings",
    locale: "locale",
    margin: "margin",
    selectedDataIndexes: "selectedDataIndexes",
    selectionMode: "selectionMode",
    selectionPattern: "selectionPattern",
    series: "series",
    subTitle: "subTitle",
    subTitleStyle: "subTitleStyle",
    theme: "theme",
    title: "title",
    titleStyle: "titleStyle",
    tooltip: "tooltip",
    useGroupingSeparator: "useGroupingSeparator",
    width: "width"
  },
  outputs: {
    afterExport: "afterExport",
    animationComplete: "animationComplete",
    annotationRender: "annotationRender",
    beforeExport: "beforeExport",
    beforePrint: "beforePrint",
    beforeResize: "beforeResize",
    chartDoubleClick: "chartDoubleClick",
    chartMouseClick: "chartMouseClick",
    chartMouseDown: "chartMouseDown",
    chartMouseLeave: "chartMouseLeave",
    chartMouseMove: "chartMouseMove",
    chartMouseUp: "chartMouseUp",
    legendClick: "legendClick",
    legendRender: "legendRender",
    load: "load",
    loaded: "loaded",
    pointClick: "pointClick",
    pointMove: "pointMove",
    pointRender: "pointRender",
    resized: "resized",
    selectionComplete: "selectionComplete",
    seriesRender: "seriesRender",
    textRender: "textRender",
    tooltipRender: "tooltipRender",
    dataSourceChange: "dataSourceChange"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function AccumulationChartComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
__decorate([Template()], AccumulationChartComponent.prototype, "tooltip_template", void 0);
AccumulationChartComponent = __decorate([ComponentMixins([ComponentBase])], AccumulationChartComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AccumulationChartComponent, [{
    type: Component,
    args: [{
      selector: "ejs-accumulationchart",
      inputs: inputs$7,
      outputs: outputs$r,
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush,
      queries: {
        childSeries: new ContentChild(AccumulationSeriesCollectionDirective),
        childAnnotations: new ContentChild(AccumulationAnnotationsDirective)
      }
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ViewContainerRef
    }, {
      type: Injector
    }];
  }, {
    tooltip_template: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var AccumulationChartModule = class {
};
AccumulationChartModule.ɵfac = function AccumulationChartModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AccumulationChartModule)();
};
AccumulationChartModule.ɵmod = ɵɵdefineNgModule({
  type: AccumulationChartModule,
  declarations: [AccumulationChartComponent, AccumulationSeriesDirective, AccumulationSeriesCollectionDirective, AccumulationAnnotationDirective, AccumulationAnnotationsDirective],
  imports: [CommonModule],
  exports: [AccumulationChartComponent, AccumulationSeriesDirective, AccumulationSeriesCollectionDirective, AccumulationAnnotationDirective, AccumulationAnnotationsDirective]
});
AccumulationChartModule.ɵinj = ɵɵdefineInjector({
  imports: [[CommonModule]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AccumulationChartModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [AccumulationChartComponent, AccumulationSeriesDirective, AccumulationSeriesCollectionDirective, AccumulationAnnotationDirective, AccumulationAnnotationsDirective],
      exports: [AccumulationChartComponent, AccumulationSeriesDirective, AccumulationSeriesCollectionDirective, AccumulationAnnotationDirective, AccumulationAnnotationsDirective]
    }]
  }], null, null);
})();
var PieSeriesService = {
  provide: "ChartsPieSeries",
  useValue: PieSeries
};
var FunnelSeriesService = {
  provide: "ChartsFunnelSeries",
  useValue: FunnelSeries
};
var PyramidSeriesService = {
  provide: "ChartsPyramidSeries",
  useValue: PyramidSeries
};
var AccumulationTooltipService = {
  provide: "ChartsAccumulationTooltip",
  useValue: AccumulationTooltip
};
var AccumulationLegendService = {
  provide: "ChartsAccumulationLegend",
  useValue: AccumulationLegend
};
var AccumulationSelectionService = {
  provide: "ChartsAccumulationSelection",
  useValue: AccumulationSelection
};
var AccumulationHighlightService = {
  provide: "ChartsAccumulationHighlight",
  useValue: AccumulationHighlight
};
var AccumulationDataLabelService = {
  provide: "ChartsAccumulationDataLabel",
  useValue: AccumulationDataLabel
};
var AccumulationAnnotationService = {
  provide: "ChartsAccumulationAnnotation",
  useValue: AccumulationAnnotation
};
var AccumulationChartAllModule = class {
};
AccumulationChartAllModule.ɵfac = function AccumulationChartAllModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AccumulationChartAllModule)();
};
AccumulationChartAllModule.ɵmod = ɵɵdefineNgModule({
  type: AccumulationChartAllModule,
  imports: [CommonModule, AccumulationChartModule],
  exports: [AccumulationChartModule]
});
AccumulationChartAllModule.ɵinj = ɵɵdefineInjector({
  providers: [PieSeriesService, FunnelSeriesService, PyramidSeriesService, AccumulationTooltipService, AccumulationLegendService, AccumulationSelectionService, AccumulationHighlightService, AccumulationDataLabelService, AccumulationAnnotationService],
  imports: [[CommonModule, AccumulationChartModule], AccumulationChartModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AccumulationChartAllModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, AccumulationChartModule],
      exports: [AccumulationChartModule],
      providers: [PieSeriesService, FunnelSeriesService, PyramidSeriesService, AccumulationTooltipService, AccumulationLegendService, AccumulationSelectionService, AccumulationHighlightService, AccumulationDataLabelService, AccumulationAnnotationService]
    }]
  }], null, null);
})();
var input$j = ["animation", "border", "dashArray", "dataSource", "fill", "opacity", "query", "type", "width", "xName", "yName"];
var outputs$q = [];
var RangenavigatorSeriesDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$q);
    this.directivePropList = input$j;
  }
};
RangenavigatorSeriesDirective.ɵfac = function RangenavigatorSeriesDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RangenavigatorSeriesDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
RangenavigatorSeriesDirective.ɵdir = ɵɵdefineDirective({
  type: RangenavigatorSeriesDirective,
  selectors: [["e-rangenavigator-series"]],
  inputs: {
    animation: "animation",
    border: "border",
    dashArray: "dashArray",
    dataSource: "dataSource",
    fill: "fill",
    opacity: "opacity",
    query: "query",
    type: "type",
    width: "width",
    xName: "xName",
    yName: "yName"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangenavigatorSeriesDirective, [{
    type: Directive,
    args: [{
      selector: "e-rangenavigator-series-collection>e-rangenavigator-series",
      inputs: input$j,
      outputs: outputs$q,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, null);
})();
var RangenavigatorSeriesCollectionDirective = class extends ArrayBase {
  constructor() {
    super("series");
  }
};
RangenavigatorSeriesCollectionDirective.ɵfac = function RangenavigatorSeriesCollectionDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RangenavigatorSeriesCollectionDirective)();
};
RangenavigatorSeriesCollectionDirective.ɵdir = ɵɵdefineDirective({
  type: RangenavigatorSeriesCollectionDirective,
  selectors: [["e-rangenavigator-series-collection"]],
  contentQueries: function RangenavigatorSeriesCollectionDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, RangenavigatorSeriesDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangenavigatorSeriesCollectionDirective, [{
    type: Directive,
    args: [{
      selector: "ej-rangenavigator>e-rangenavigator-series-collection",
      queries: {
        children: new ContentChildren(RangenavigatorSeriesDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var inputs$6 = ["allowIntervalData", "allowSnapping", "animationDuration", "background", "dataSource", "disableRangeSelector", "enableDeferredUpdate", "enableGrouping", "enablePersistence", "enableRtl", "groupBy", "height", "interval", "intervalType", "labelFormat", "labelIntersectAction", "labelPlacement", "labelPosition", "labelStyle", "locale", "logBase", "majorGridLines", "majorTickLines", "margin", "maximum", "minimum", "navigatorBorder", "navigatorStyleSettings", "periodSelectorSettings", "query", "secondaryLabelAlignment", "series", "skeleton", "skeletonType", "theme", "tickPosition", "tooltip", "useGroupingSeparator", "value", "valueType", "width", "xName", "yName"];
var outputs$p = ["beforePrint", "beforeResize", "changed", "labelRender", "load", "loaded", "resized", "selectorRender", "tooltipRender", "dataSourceChange"];
var twoWays$6 = ["dataSource"];
var RangeNavigatorComponent = class RangeNavigatorComponent2 extends RangeNavigator {
  constructor(ngEle, srenderer, viewContainerRef, injector) {
    super();
    this.ngEle = ngEle;
    this.srenderer = srenderer;
    this.viewContainerRef = viewContainerRef;
    this.injector = injector;
    this.tags = ["series"];
    this.element = this.ngEle.nativeElement;
    this.injectedModules = this.injectedModules || [];
    try {
      let mod = this.injector.get("ChartsRangeTooltip");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsPeriodSelector");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsAreaSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsStepLineSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsDateTime");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsLogarithmic");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsExport");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsDateTimeCategory");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    this.registerEvents(outputs$p);
    this.addTwoWay.call(this, twoWays$6);
    setValue("currentInstance", this, this.viewContainerRef);
    this.context = new ComponentBase();
  }
  ngOnInit() {
    this.context.ngOnInit(this);
  }
  ngAfterViewInit() {
    this.context.ngAfterViewInit(this);
  }
  ngOnDestroy() {
    this.context.ngOnDestroy(this);
  }
  ngAfterContentChecked() {
    this.tagObjects[0].instance = this.childSeries;
    this.context.ngAfterContentChecked(this);
  }
};
RangeNavigatorComponent.ɵfac = function RangeNavigatorComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RangeNavigatorComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector));
};
RangeNavigatorComponent.ɵcmp = ɵɵdefineComponent({
  type: RangeNavigatorComponent,
  selectors: [["ejs-rangenavigator"]],
  contentQueries: function RangeNavigatorComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, _c2, 5);
      ɵɵcontentQuery(dirIndex, RangenavigatorSeriesCollectionDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tooltip_template = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childSeries = _t.first);
    }
  },
  inputs: {
    allowIntervalData: "allowIntervalData",
    allowSnapping: "allowSnapping",
    animationDuration: "animationDuration",
    background: "background",
    dataSource: "dataSource",
    disableRangeSelector: "disableRangeSelector",
    enableDeferredUpdate: "enableDeferredUpdate",
    enableGrouping: "enableGrouping",
    enablePersistence: "enablePersistence",
    enableRtl: "enableRtl",
    groupBy: "groupBy",
    height: "height",
    interval: "interval",
    intervalType: "intervalType",
    labelFormat: "labelFormat",
    labelIntersectAction: "labelIntersectAction",
    labelPlacement: "labelPlacement",
    labelPosition: "labelPosition",
    labelStyle: "labelStyle",
    locale: "locale",
    logBase: "logBase",
    majorGridLines: "majorGridLines",
    majorTickLines: "majorTickLines",
    margin: "margin",
    maximum: "maximum",
    minimum: "minimum",
    navigatorBorder: "navigatorBorder",
    navigatorStyleSettings: "navigatorStyleSettings",
    periodSelectorSettings: "periodSelectorSettings",
    query: "query",
    secondaryLabelAlignment: "secondaryLabelAlignment",
    series: "series",
    skeleton: "skeleton",
    skeletonType: "skeletonType",
    theme: "theme",
    tickPosition: "tickPosition",
    tooltip: "tooltip",
    useGroupingSeparator: "useGroupingSeparator",
    value: "value",
    valueType: "valueType",
    width: "width",
    xName: "xName",
    yName: "yName"
  },
  outputs: {
    beforePrint: "beforePrint",
    beforeResize: "beforeResize",
    changed: "changed",
    labelRender: "labelRender",
    load: "load",
    loaded: "loaded",
    resized: "resized",
    selectorRender: "selectorRender",
    tooltipRender: "tooltipRender",
    dataSourceChange: "dataSourceChange"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function RangeNavigatorComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
__decorate([Template()], RangeNavigatorComponent.prototype, "tooltip_template", void 0);
RangeNavigatorComponent = __decorate([ComponentMixins([ComponentBase])], RangeNavigatorComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangeNavigatorComponent, [{
    type: Component,
    args: [{
      selector: "ejs-rangenavigator",
      inputs: inputs$6,
      outputs: outputs$p,
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush,
      queries: {
        childSeries: new ContentChild(RangenavigatorSeriesCollectionDirective)
      }
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ViewContainerRef
    }, {
      type: Injector
    }];
  }, {
    tooltip_template: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var RangeNavigatorModule = class {
};
RangeNavigatorModule.ɵfac = function RangeNavigatorModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RangeNavigatorModule)();
};
RangeNavigatorModule.ɵmod = ɵɵdefineNgModule({
  type: RangeNavigatorModule,
  declarations: [RangeNavigatorComponent, RangenavigatorSeriesDirective, RangenavigatorSeriesCollectionDirective],
  imports: [CommonModule],
  exports: [RangeNavigatorComponent, RangenavigatorSeriesDirective, RangenavigatorSeriesCollectionDirective]
});
RangeNavigatorModule.ɵinj = ɵɵdefineInjector({
  imports: [[CommonModule]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangeNavigatorModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [RangeNavigatorComponent, RangenavigatorSeriesDirective, RangenavigatorSeriesCollectionDirective],
      exports: [RangeNavigatorComponent, RangenavigatorSeriesDirective, RangenavigatorSeriesCollectionDirective]
    }]
  }], null, null);
})();
var RangeTooltipService = {
  provide: "ChartsRangeTooltip",
  useValue: RangeTooltip
};
var PeriodSelectorService = {
  provide: "ChartsPeriodSelector",
  useValue: PeriodSelector
};
var RangeNavigatorAllModule = class {
};
RangeNavigatorAllModule.ɵfac = function RangeNavigatorAllModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RangeNavigatorAllModule)();
};
RangeNavigatorAllModule.ɵmod = ɵɵdefineNgModule({
  type: RangeNavigatorAllModule,
  imports: [CommonModule, RangeNavigatorModule],
  exports: [RangeNavigatorModule]
});
RangeNavigatorAllModule.ɵinj = ɵɵdefineInjector({
  providers: [RangeTooltipService, PeriodSelectorService],
  imports: [[CommonModule, RangeNavigatorModule], RangeNavigatorModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangeNavigatorAllModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RangeNavigatorModule],
      exports: [RangeNavigatorModule],
      providers: [RangeTooltipService, PeriodSelectorService]
    }]
  }], null, null);
})();
var input$i = ["color", "endRange", "opacity", "startRange"];
var outputs$o = [];
var RangeBandSettingDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$o);
    this.directivePropList = input$i;
  }
};
RangeBandSettingDirective.ɵfac = function RangeBandSettingDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RangeBandSettingDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
RangeBandSettingDirective.ɵdir = ɵɵdefineDirective({
  type: RangeBandSettingDirective,
  selectors: [["e-rangeBandSetting"]],
  inputs: {
    color: "color",
    endRange: "endRange",
    opacity: "opacity",
    startRange: "startRange"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangeBandSettingDirective, [{
    type: Directive,
    args: [{
      selector: "e-rangeBandSettings>e-rangeBandSetting",
      inputs: input$i,
      outputs: outputs$o,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, null);
})();
var RangeBandSettingsDirective = class extends ArrayBase {
  constructor() {
    super("rangebandsettings");
  }
};
RangeBandSettingsDirective.ɵfac = function RangeBandSettingsDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RangeBandSettingsDirective)();
};
RangeBandSettingsDirective.ɵdir = ɵɵdefineDirective({
  type: RangeBandSettingsDirective,
  selectors: [["e-rangeBandSettings"]],
  contentQueries: function RangeBandSettingsDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, RangeBandSettingDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangeBandSettingsDirective, [{
    type: Directive,
    args: [{
      selector: "ejs-sparkline>e-rangeBandSettings",
      queries: {
        children: new ContentChildren(RangeBandSettingDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var inputs$5 = ["axisSettings", "border", "containerArea", "dataLabelSettings", "dataSource", "enablePersistence", "enableRtl", "endPointColor", "fill", "format", "height", "highPointColor", "lineWidth", "locale", "lowPointColor", "markerSettings", "negativePointColor", "opacity", "padding", "palette", "query", "rangeBandSettings", "rangePadding", "startPointColor", "theme", "tiePointColor", "tooltipSettings", "type", "useGroupingSeparator", "valueType", "width", "xName", "yName"];
var outputs$n = ["axisRendering", "dataLabelRendering", "load", "loaded", "markerRendering", "pointRegionMouseClick", "pointRegionMouseMove", "pointRendering", "resize", "seriesRendering", "sparklineMouseClick", "sparklineMouseMove", "tooltipInitialize"];
var twoWays$5 = [""];
var SparklineComponent = class SparklineComponent2 extends Sparkline {
  constructor(ngEle, srenderer, viewContainerRef, injector) {
    super();
    this.ngEle = ngEle;
    this.srenderer = srenderer;
    this.viewContainerRef = viewContainerRef;
    this.injector = injector;
    this.tags = ["rangeBandSettings"];
    this.element = this.ngEle.nativeElement;
    this.injectedModules = this.injectedModules || [];
    try {
      let mod = this.injector.get("ChartsSparklineTooltip");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    this.registerEvents(outputs$n);
    this.addTwoWay.call(this, twoWays$5);
    setValue("currentInstance", this, this.viewContainerRef);
    this.context = new ComponentBase();
  }
  ngOnInit() {
    this.context.ngOnInit(this);
  }
  ngAfterViewInit() {
    this.context.ngAfterViewInit(this);
  }
  ngOnDestroy() {
    this.context.ngOnDestroy(this);
  }
  ngAfterContentChecked() {
    this.tagObjects[0].instance = this.childRangeBandSettings;
    this.context.ngAfterContentChecked(this);
  }
};
SparklineComponent.ɵfac = function SparklineComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SparklineComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector));
};
SparklineComponent.ɵcmp = ɵɵdefineComponent({
  type: SparklineComponent,
  selectors: [["ejs-sparkline"]],
  contentQueries: function SparklineComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, RangeBandSettingsDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childRangeBandSettings = _t.first);
    }
  },
  inputs: {
    axisSettings: "axisSettings",
    border: "border",
    containerArea: "containerArea",
    dataLabelSettings: "dataLabelSettings",
    dataSource: "dataSource",
    enablePersistence: "enablePersistence",
    enableRtl: "enableRtl",
    endPointColor: "endPointColor",
    fill: "fill",
    format: "format",
    height: "height",
    highPointColor: "highPointColor",
    lineWidth: "lineWidth",
    locale: "locale",
    lowPointColor: "lowPointColor",
    markerSettings: "markerSettings",
    negativePointColor: "negativePointColor",
    opacity: "opacity",
    padding: "padding",
    palette: "palette",
    query: "query",
    rangeBandSettings: "rangeBandSettings",
    rangePadding: "rangePadding",
    startPointColor: "startPointColor",
    theme: "theme",
    tiePointColor: "tiePointColor",
    tooltipSettings: "tooltipSettings",
    type: "type",
    useGroupingSeparator: "useGroupingSeparator",
    valueType: "valueType",
    width: "width",
    xName: "xName",
    yName: "yName"
  },
  outputs: {
    axisRendering: "axisRendering",
    dataLabelRendering: "dataLabelRendering",
    load: "load",
    loaded: "loaded",
    markerRendering: "markerRendering",
    pointRegionMouseClick: "pointRegionMouseClick",
    pointRegionMouseMove: "pointRegionMouseMove",
    pointRendering: "pointRendering",
    resize: "resize",
    seriesRendering: "seriesRendering",
    sparklineMouseClick: "sparklineMouseClick",
    sparklineMouseMove: "sparklineMouseMove",
    tooltipInitialize: "tooltipInitialize"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SparklineComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
SparklineComponent = __decorate([ComponentMixins([ComponentBase])], SparklineComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SparklineComponent, [{
    type: Component,
    args: [{
      selector: "ejs-sparkline",
      inputs: inputs$5,
      outputs: outputs$n,
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush,
      queries: {
        childRangeBandSettings: new ContentChild(RangeBandSettingsDirective)
      }
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ViewContainerRef
    }, {
      type: Injector
    }];
  }, null);
})();
var SparklineModule = class {
};
SparklineModule.ɵfac = function SparklineModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SparklineModule)();
};
SparklineModule.ɵmod = ɵɵdefineNgModule({
  type: SparklineModule,
  declarations: [SparklineComponent, RangeBandSettingDirective, RangeBandSettingsDirective],
  imports: [CommonModule],
  exports: [SparklineComponent, RangeBandSettingDirective, RangeBandSettingsDirective]
});
SparklineModule.ɵinj = ɵɵdefineInjector({
  imports: [[CommonModule]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SparklineModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [SparklineComponent, RangeBandSettingDirective, RangeBandSettingsDirective],
      exports: [SparklineComponent, RangeBandSettingDirective, RangeBandSettingsDirective]
    }]
  }], null, null);
})();
var SparklineTooltipService = {
  provide: "ChartsSparklineTooltip",
  useValue: SparklineTooltip
};
var SparklineAllModule = class {
};
SparklineAllModule.ɵfac = function SparklineAllModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SparklineAllModule)();
};
SparklineAllModule.ɵmod = ɵɵdefineNgModule({
  type: SparklineAllModule,
  imports: [CommonModule, SparklineModule],
  exports: [SparklineModule]
});
SparklineAllModule.ɵinj = ɵɵdefineInjector({
  providers: [SparklineTooltipService],
  imports: [[CommonModule, SparklineModule], SparklineModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SparklineAllModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, SparklineModule],
      exports: [SparklineModule],
      providers: [SparklineTooltipService]
    }]
  }], null, null);
})();
var input$h = ["animationDuration", "dataSource", "enableAnimation", "enableSmartLabels", "fill", "marker", "name", "opacity", "points", "reactance", "resistance", "tooltip", "tooltipMappingName", "visibility", "width"];
var outputs$m = [];
var SmithchartSeriesDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$m);
    this.directivePropList = input$h;
  }
};
SmithchartSeriesDirective.ɵfac = function SmithchartSeriesDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SmithchartSeriesDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
SmithchartSeriesDirective.ɵdir = ɵɵdefineDirective({
  type: SmithchartSeriesDirective,
  selectors: [["e-series"]],
  inputs: {
    animationDuration: "animationDuration",
    dataSource: "dataSource",
    enableAnimation: "enableAnimation",
    enableSmartLabels: "enableSmartLabels",
    fill: "fill",
    marker: "marker",
    name: "name",
    opacity: "opacity",
    points: "points",
    reactance: "reactance",
    resistance: "resistance",
    tooltip: "tooltip",
    tooltipMappingName: "tooltipMappingName",
    visibility: "visibility",
    width: "width"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SmithchartSeriesDirective, [{
    type: Directive,
    args: [{
      selector: "e-seriesCollection>e-series",
      inputs: input$h,
      outputs: outputs$m,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, null);
})();
var SmithchartSeriesCollectionDirective = class extends ArrayBase {
  constructor() {
    super("series");
  }
};
SmithchartSeriesCollectionDirective.ɵfac = function SmithchartSeriesCollectionDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SmithchartSeriesCollectionDirective)();
};
SmithchartSeriesCollectionDirective.ɵdir = ɵɵdefineDirective({
  type: SmithchartSeriesCollectionDirective,
  selectors: [["e-seriesCollection"]],
  contentQueries: function SmithchartSeriesCollectionDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, SmithchartSeriesDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SmithchartSeriesCollectionDirective, [{
    type: Directive,
    args: [{
      selector: "ejs-smithchart>e-seriesCollection",
      queries: {
        children: new ContentChildren(SmithchartSeriesDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var inputs$4 = ["background", "border", "elementSpacing", "enablePersistence", "enableRtl", "font", "height", "horizontalAxis", "legendSettings", "locale", "margin", "radialAxis", "radius", "renderType", "series", "theme", "title", "width"];
var outputs$l = ["animationComplete", "axisLabelRender", "beforePrint", "legendRender", "load", "loaded", "seriesRender", "subtitleRender", "textRender", "titleRender", "tooltipRender"];
var twoWays$4 = [""];
var SmithchartComponent = class SmithchartComponent2 extends Smithchart {
  constructor(ngEle, srenderer, viewContainerRef, injector) {
    super();
    this.ngEle = ngEle;
    this.srenderer = srenderer;
    this.viewContainerRef = viewContainerRef;
    this.injector = injector;
    this.tags = ["series"];
    this.element = this.ngEle.nativeElement;
    this.injectedModules = this.injectedModules || [];
    try {
      let mod = this.injector.get("ChartsSmithchartLegend");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsTooltipRender");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    this.registerEvents(outputs$l);
    this.addTwoWay.call(this, twoWays$4);
    setValue("currentInstance", this, this.viewContainerRef);
    this.context = new ComponentBase();
  }
  ngOnInit() {
    this.context.ngOnInit(this);
  }
  ngAfterViewInit() {
    this.context.ngAfterViewInit(this);
  }
  ngOnDestroy() {
    this.context.ngOnDestroy(this);
  }
  ngAfterContentChecked() {
    this.tagObjects[0].instance = this.childSeries;
    this.context.ngAfterContentChecked(this);
  }
};
SmithchartComponent.ɵfac = function SmithchartComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SmithchartComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector));
};
SmithchartComponent.ɵcmp = ɵɵdefineComponent({
  type: SmithchartComponent,
  selectors: [["ejs-smithchart"]],
  contentQueries: function SmithchartComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, SmithchartSeriesCollectionDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childSeries = _t.first);
    }
  },
  inputs: {
    background: "background",
    border: "border",
    elementSpacing: "elementSpacing",
    enablePersistence: "enablePersistence",
    enableRtl: "enableRtl",
    font: "font",
    height: "height",
    horizontalAxis: "horizontalAxis",
    legendSettings: "legendSettings",
    locale: "locale",
    margin: "margin",
    radialAxis: "radialAxis",
    radius: "radius",
    renderType: "renderType",
    series: "series",
    theme: "theme",
    title: "title",
    width: "width"
  },
  outputs: {
    animationComplete: "animationComplete",
    axisLabelRender: "axisLabelRender",
    beforePrint: "beforePrint",
    legendRender: "legendRender",
    load: "load",
    loaded: "loaded",
    seriesRender: "seriesRender",
    subtitleRender: "subtitleRender",
    textRender: "textRender",
    titleRender: "titleRender",
    tooltipRender: "tooltipRender"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SmithchartComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
SmithchartComponent = __decorate([ComponentMixins([ComponentBase])], SmithchartComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SmithchartComponent, [{
    type: Component,
    args: [{
      selector: "ejs-smithchart",
      inputs: inputs$4,
      outputs: outputs$l,
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush,
      queries: {
        childSeries: new ContentChild(SmithchartSeriesCollectionDirective)
      }
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ViewContainerRef
    }, {
      type: Injector
    }];
  }, null);
})();
var SmithchartModule = class {
};
SmithchartModule.ɵfac = function SmithchartModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SmithchartModule)();
};
SmithchartModule.ɵmod = ɵɵdefineNgModule({
  type: SmithchartModule,
  declarations: [SmithchartComponent, SmithchartSeriesDirective, SmithchartSeriesCollectionDirective],
  imports: [CommonModule],
  exports: [SmithchartComponent, SmithchartSeriesDirective, SmithchartSeriesCollectionDirective]
});
SmithchartModule.ɵinj = ɵɵdefineInjector({
  imports: [[CommonModule]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SmithchartModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [SmithchartComponent, SmithchartSeriesDirective, SmithchartSeriesCollectionDirective],
      exports: [SmithchartComponent, SmithchartSeriesDirective, SmithchartSeriesCollectionDirective]
    }]
  }], null, null);
})();
var SmithchartLegendService = {
  provide: "ChartsSmithchartLegend",
  useValue: SmithchartLegend
};
var TooltipRenderService = {
  provide: "ChartsTooltipRender",
  useValue: TooltipRender
};
var SmithchartAllModule = class {
};
SmithchartAllModule.ɵfac = function SmithchartAllModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SmithchartAllModule)();
};
SmithchartAllModule.ɵmod = ɵɵdefineNgModule({
  type: SmithchartAllModule,
  imports: [CommonModule, SmithchartModule],
  exports: [SmithchartModule]
});
SmithchartAllModule.ɵinj = ɵɵdefineInjector({
  providers: [SmithchartLegendService, TooltipRenderService],
  imports: [[CommonModule, SmithchartModule], SmithchartModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SmithchartAllModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, SmithchartModule],
      exports: [SmithchartModule],
      providers: [SmithchartLegendService, TooltipRenderService]
    }]
  }], null, null);
})();
var input$g = ["accessibility", "animation", "backwardForecast", "dashArray", "enableTooltip", "fill", "forwardForecast", "intercept", "legendShape", "marker", "name", "period", "polynomialOrder", "type", "visible", "width"];
var outputs$k = [];
var StockChartTrendlineDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$k);
    this.directivePropList = input$g;
  }
};
StockChartTrendlineDirective.ɵfac = function StockChartTrendlineDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StockChartTrendlineDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
StockChartTrendlineDirective.ɵdir = ɵɵdefineDirective({
  type: StockChartTrendlineDirective,
  selectors: [["e-trendline"]],
  inputs: {
    accessibility: "accessibility",
    animation: "animation",
    backwardForecast: "backwardForecast",
    dashArray: "dashArray",
    enableTooltip: "enableTooltip",
    fill: "fill",
    forwardForecast: "forwardForecast",
    intercept: "intercept",
    legendShape: "legendShape",
    marker: "marker",
    name: "name",
    period: "period",
    polynomialOrder: "polynomialOrder",
    type: "type",
    visible: "visible",
    width: "width"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StockChartTrendlineDirective, [{
    type: Directive,
    args: [{
      selector: "e-stockchart-series>e-trendlines>e-trendline",
      inputs: input$g,
      outputs: outputs$k,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, null);
})();
var StockChartTrendlinesDirective = class extends ArrayBase {
  constructor() {
    super("trendlines");
  }
};
StockChartTrendlinesDirective.ɵfac = function StockChartTrendlinesDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StockChartTrendlinesDirective)();
};
StockChartTrendlinesDirective.ɵdir = ɵɵdefineDirective({
  type: StockChartTrendlinesDirective,
  selectors: [["e-trendlines"]],
  contentQueries: function StockChartTrendlinesDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, StockChartTrendlineDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StockChartTrendlinesDirective, [{
    type: Directive,
    args: [{
      selector: "e-stockchart-series>e-trendlines",
      queries: {
        children: new ContentChildren(StockChartTrendlineDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var input$f = ["animation", "bearFillColor", "border", "bullFillColor", "cardinalSplineTension", "close", "columnSpacing", "columnWidth", "cornerRadius", "dashArray", "dataSource", "emptyPointSettings", "enableSolidCandles", "enableTooltip", "fill", "high", "legendImageUrl", "legendShape", "low", "marker", "name", "opacity", "open", "pointColorMapping", "query", "selectionStyle", "showNearestTooltip", "tooltipMappingName", "trendlines", "type", "visible", "volume", "width", "xAxisName", "xName", "yAxisName", "yName"];
var outputs$j = [];
var StockChartSeriesDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    this.tags = ["trendlines"];
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$j);
    this.directivePropList = input$f;
  }
};
StockChartSeriesDirective.ɵfac = function StockChartSeriesDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StockChartSeriesDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
StockChartSeriesDirective.ɵdir = ɵɵdefineDirective({
  type: StockChartSeriesDirective,
  selectors: [["e-stockchart-series"]],
  contentQueries: function StockChartSeriesDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, StockChartTrendlinesDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childTrendlines = _t.first);
    }
  },
  inputs: {
    animation: "animation",
    bearFillColor: "bearFillColor",
    border: "border",
    bullFillColor: "bullFillColor",
    cardinalSplineTension: "cardinalSplineTension",
    close: "close",
    columnSpacing: "columnSpacing",
    columnWidth: "columnWidth",
    cornerRadius: "cornerRadius",
    dashArray: "dashArray",
    dataSource: "dataSource",
    emptyPointSettings: "emptyPointSettings",
    enableSolidCandles: "enableSolidCandles",
    enableTooltip: "enableTooltip",
    fill: "fill",
    high: "high",
    legendImageUrl: "legendImageUrl",
    legendShape: "legendShape",
    low: "low",
    marker: "marker",
    name: "name",
    opacity: "opacity",
    open: "open",
    pointColorMapping: "pointColorMapping",
    query: "query",
    selectionStyle: "selectionStyle",
    showNearestTooltip: "showNearestTooltip",
    tooltipMappingName: "tooltipMappingName",
    trendlines: "trendlines",
    type: "type",
    visible: "visible",
    volume: "volume",
    width: "width",
    xAxisName: "xAxisName",
    xName: "xName",
    yAxisName: "yAxisName",
    yName: "yName"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StockChartSeriesDirective, [{
    type: Directive,
    args: [{
      selector: "e-stockchart-series-collection>e-stockchart-series",
      inputs: input$f,
      outputs: outputs$j,
      queries: {
        childTrendlines: new ContentChild(StockChartTrendlinesDirective)
      }
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, null);
})();
var StockChartSeriesCollectionDirective = class extends ArrayBase {
  constructor() {
    super("series");
  }
};
StockChartSeriesCollectionDirective.ɵfac = function StockChartSeriesCollectionDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StockChartSeriesCollectionDirective)();
};
StockChartSeriesCollectionDirective.ɵdir = ɵɵdefineDirective({
  type: StockChartSeriesCollectionDirective,
  selectors: [["e-stockchart-series-collection"]],
  contentQueries: function StockChartSeriesCollectionDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, StockChartSeriesDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StockChartSeriesCollectionDirective, [{
    type: Directive,
    args: [{
      selector: "ejs-stockchart>e-stockchart-series-collection",
      queries: {
        children: new ContentChildren(StockChartSeriesDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var input$e = ["coefficient", "crossesAt", "crossesInAxis", "crosshairTooltip", "description", "desiredIntervals", "edgeLabelPlacement", "enableAutoIntervalOnZooming", "enableTrim", "interval", "intervalType", "isInversed", "labelFormat", "labelIntersectAction", "labelPlacement", "labelPosition", "labelRotation", "labelStyle", "lineStyle", "logBase", "majorGridLines", "majorTickLines", "maximum", "maximumLabelWidth", "maximumLabels", "minimum", "minorGridLines", "minorTickLines", "minorTicksPerInterval", "name", "opposedPosition", "placeNextToAxisLine", "plotOffset", "rangePadding", "rowIndex", "skeleton", "skeletonType", "span", "startAngle", "stripLines", "tabIndex", "tickPosition", "title", "titleStyle", "valueType", "visible", "zoomFactor", "zoomPosition"];
var outputs$i = [];
var StockChartAxisDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$i);
    this.directivePropList = input$e;
  }
};
StockChartAxisDirective.ɵfac = function StockChartAxisDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StockChartAxisDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
StockChartAxisDirective.ɵdir = ɵɵdefineDirective({
  type: StockChartAxisDirective,
  selectors: [["e-stockchart-axis"]],
  inputs: {
    coefficient: "coefficient",
    crossesAt: "crossesAt",
    crossesInAxis: "crossesInAxis",
    crosshairTooltip: "crosshairTooltip",
    description: "description",
    desiredIntervals: "desiredIntervals",
    edgeLabelPlacement: "edgeLabelPlacement",
    enableAutoIntervalOnZooming: "enableAutoIntervalOnZooming",
    enableTrim: "enableTrim",
    interval: "interval",
    intervalType: "intervalType",
    isInversed: "isInversed",
    labelFormat: "labelFormat",
    labelIntersectAction: "labelIntersectAction",
    labelPlacement: "labelPlacement",
    labelPosition: "labelPosition",
    labelRotation: "labelRotation",
    labelStyle: "labelStyle",
    lineStyle: "lineStyle",
    logBase: "logBase",
    majorGridLines: "majorGridLines",
    majorTickLines: "majorTickLines",
    maximum: "maximum",
    maximumLabelWidth: "maximumLabelWidth",
    maximumLabels: "maximumLabels",
    minimum: "minimum",
    minorGridLines: "minorGridLines",
    minorTickLines: "minorTickLines",
    minorTicksPerInterval: "minorTicksPerInterval",
    name: "name",
    opposedPosition: "opposedPosition",
    placeNextToAxisLine: "placeNextToAxisLine",
    plotOffset: "plotOffset",
    rangePadding: "rangePadding",
    rowIndex: "rowIndex",
    skeleton: "skeleton",
    skeletonType: "skeletonType",
    span: "span",
    startAngle: "startAngle",
    stripLines: "stripLines",
    tabIndex: "tabIndex",
    tickPosition: "tickPosition",
    title: "title",
    titleStyle: "titleStyle",
    valueType: "valueType",
    visible: "visible",
    zoomFactor: "zoomFactor",
    zoomPosition: "zoomPosition"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StockChartAxisDirective, [{
    type: Directive,
    args: [{
      selector: "e-stockchart-axes>e-stockchart-axis",
      inputs: input$e,
      outputs: outputs$i,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, null);
})();
var StockChartAxesDirective = class extends ArrayBase {
  constructor() {
    super("axes");
  }
};
StockChartAxesDirective.ɵfac = function StockChartAxesDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StockChartAxesDirective)();
};
StockChartAxesDirective.ɵdir = ɵɵdefineDirective({
  type: StockChartAxesDirective,
  selectors: [["e-stockchart-axes"]],
  contentQueries: function StockChartAxesDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, StockChartAxisDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StockChartAxesDirective, [{
    type: Directive,
    args: [{
      selector: "ejs-stockchart>e-stockchart-axes",
      queries: {
        children: new ContentChildren(StockChartAxisDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var input$d = ["border", "height"];
var outputs$h = [];
var StockChartRowDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$h);
    this.directivePropList = input$d;
  }
};
StockChartRowDirective.ɵfac = function StockChartRowDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StockChartRowDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
StockChartRowDirective.ɵdir = ɵɵdefineDirective({
  type: StockChartRowDirective,
  selectors: [["e-stockchart-row"]],
  inputs: {
    border: "border",
    height: "height"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StockChartRowDirective, [{
    type: Directive,
    args: [{
      selector: "e-stockchart-rows>e-striplines>e-stockchart-row",
      inputs: input$d,
      outputs: outputs$h,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, null);
})();
var StockChartRowsDirective = class extends ArrayBase {
  constructor() {
    super("rows");
  }
};
StockChartRowsDirective.ɵfac = function StockChartRowsDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StockChartRowsDirective)();
};
StockChartRowsDirective.ɵdir = ɵɵdefineDirective({
  type: StockChartRowsDirective,
  selectors: [["e-stockchart-rows"]],
  contentQueries: function StockChartRowsDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, StockChartRowDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StockChartRowsDirective, [{
    type: Directive,
    args: [{
      selector: "ejs-stockchart>e-stockchart-rows",
      queries: {
        children: new ContentChildren(StockChartRowDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var input$c = ["content", "coordinateUnits", "description", "horizontalAlignment", "region", "verticalAlignment", "x", "xAxisName", "y", "yAxisName"];
var outputs$g = [];
var StockChartAnnotationDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$g);
    this.directivePropList = input$c;
  }
};
StockChartAnnotationDirective.ɵfac = function StockChartAnnotationDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StockChartAnnotationDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
StockChartAnnotationDirective.ɵdir = ɵɵdefineDirective({
  type: StockChartAnnotationDirective,
  selectors: [["e-stockchart-annotation"]],
  contentQueries: function StockChartAnnotationDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, _c1, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.content = _t.first);
    }
  },
  inputs: {
    content: "content",
    coordinateUnits: "coordinateUnits",
    description: "description",
    horizontalAlignment: "horizontalAlignment",
    region: "region",
    verticalAlignment: "verticalAlignment",
    x: "x",
    xAxisName: "xAxisName",
    y: "y",
    yAxisName: "yAxisName"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
__decorate([Template()], StockChartAnnotationDirective.prototype, "content", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StockChartAnnotationDirective, [{
    type: Directive,
    args: [{
      selector: "ejs-stockchart-annotations>e-stockchart-annotation",
      inputs: input$c,
      outputs: outputs$g,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, {
    content: [{
      type: ContentChild,
      args: ["content"]
    }]
  });
})();
var StockChartAnnotationsDirective = class extends ArrayBase {
  constructor() {
    super("annotations");
  }
};
StockChartAnnotationsDirective.ɵfac = function StockChartAnnotationsDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StockChartAnnotationsDirective)();
};
StockChartAnnotationsDirective.ɵdir = ɵɵdefineDirective({
  type: StockChartAnnotationsDirective,
  selectors: [["e-stockchart-annotations"]],
  contentQueries: function StockChartAnnotationsDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, StockChartAnnotationDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StockChartAnnotationsDirective, [{
    type: Directive,
    args: [{
      selector: "ejs-stockchart>e-stockchart-annotations",
      queries: {
        children: new ContentChildren(StockChartAnnotationDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var input$b = ["point", "series"];
var outputs$f = [];
var StockChartSelectedDataIndexDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$f);
    this.directivePropList = input$b;
  }
};
StockChartSelectedDataIndexDirective.ɵfac = function StockChartSelectedDataIndexDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StockChartSelectedDataIndexDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
StockChartSelectedDataIndexDirective.ɵdir = ɵɵdefineDirective({
  type: StockChartSelectedDataIndexDirective,
  selectors: [["e-stockchart-selectedDataIndex"]],
  inputs: {
    point: "point",
    series: "series"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StockChartSelectedDataIndexDirective, [{
    type: Directive,
    args: [{
      selector: "ejs-stockchart-selectedDataIndexes>e-stockchart-selectedDataIndex",
      inputs: input$b,
      outputs: outputs$f,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, null);
})();
var StockChartSelectedDataIndexesDirective = class extends ArrayBase {
  constructor() {
    super("selecteddataindexes");
  }
};
StockChartSelectedDataIndexesDirective.ɵfac = function StockChartSelectedDataIndexesDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StockChartSelectedDataIndexesDirective)();
};
StockChartSelectedDataIndexesDirective.ɵdir = ɵɵdefineDirective({
  type: StockChartSelectedDataIndexesDirective,
  selectors: [["e-stockchart-selectedDataIndexes"]],
  contentQueries: function StockChartSelectedDataIndexesDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, StockChartSelectedDataIndexDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StockChartSelectedDataIndexesDirective, [{
    type: Directive,
    args: [{
      selector: "ejs-stockchart>e-stockchart-selectedDataIndexes",
      queries: {
        children: new ContentChildren(StockChartSelectedDataIndexDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var input$a = ["interval", "intervalType", "selected", "text"];
var outputs$e = [];
var StockChartPeriodDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$e);
    this.directivePropList = input$a;
  }
};
StockChartPeriodDirective.ɵfac = function StockChartPeriodDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StockChartPeriodDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
StockChartPeriodDirective.ɵdir = ɵɵdefineDirective({
  type: StockChartPeriodDirective,
  selectors: [["e-stockchart-period"]],
  inputs: {
    interval: "interval",
    intervalType: "intervalType",
    selected: "selected",
    text: "text"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StockChartPeriodDirective, [{
    type: Directive,
    args: [{
      selector: "e-stockchart-indicators>e-stockchart-period",
      inputs: input$a,
      outputs: outputs$e,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, null);
})();
var StockChartPeriodsDirective = class extends ArrayBase {
  constructor() {
    super("periods");
  }
};
StockChartPeriodsDirective.ɵfac = function StockChartPeriodsDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StockChartPeriodsDirective)();
};
StockChartPeriodsDirective.ɵdir = ɵɵdefineDirective({
  type: StockChartPeriodsDirective,
  selectors: [["e-stockchart-periods"]],
  contentQueries: function StockChartPeriodsDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, StockChartPeriodDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StockChartPeriodsDirective, [{
    type: Directive,
    args: [{
      selector: "ejs-stockchart>e-stockchart-periods",
      queries: {
        children: new ContentChildren(StockChartPeriodDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var input$9 = ["background", "border", "date", "description", "placeAt", "seriesIndexes", "showOnSeries", "text", "textStyle", "type"];
var outputs$d = [];
var StockEventDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$d);
    this.directivePropList = input$9;
  }
};
StockEventDirective.ɵfac = function StockEventDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StockEventDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
StockEventDirective.ɵdir = ɵɵdefineDirective({
  type: StockEventDirective,
  selectors: [["e-stockchart-stockevent"]],
  inputs: {
    background: "background",
    border: "border",
    date: "date",
    description: "description",
    placeAt: "placeAt",
    seriesIndexes: "seriesIndexes",
    showOnSeries: "showOnSeries",
    text: "text",
    textStyle: "textStyle",
    type: "type"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StockEventDirective, [{
    type: Directive,
    args: [{
      selector: "e-stockchart-indicators>e-stockchart-stockevent",
      inputs: input$9,
      outputs: outputs$d,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, null);
})();
var StockEventsDirective = class extends ArrayBase {
  constructor() {
    super("stockevents");
  }
};
StockEventsDirective.ɵfac = function StockEventsDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StockEventsDirective)();
};
StockEventsDirective.ɵdir = ɵɵdefineDirective({
  type: StockEventsDirective,
  selectors: [["e-stockchart-stockevents"]],
  contentQueries: function StockEventsDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, StockEventDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StockEventsDirective, [{
    type: Directive,
    args: [{
      selector: "ejs-stockchart>e-stockchart-stockevents",
      queries: {
        children: new ContentChildren(StockEventDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var input$8 = ["animation", "bandColor", "close", "dPeriod", "dashArray", "dataSource", "fastPeriod", "field", "fill", "high", "kPeriod", "low", "lowerLine", "macdLine", "macdNegativeColor", "macdPositiveColor", "macdType", "open", "overBought", "overSold", "period", "periodLine", "pointColorMapping", "query", "seriesName", "showZones", "slowPeriod", "standardDeviation", "type", "upperLine", "volume", "width", "xAxisName", "xName", "yAxisName"];
var outputs$c = [];
var StockChartIndicatorDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$c);
    this.directivePropList = input$8;
  }
};
StockChartIndicatorDirective.ɵfac = function StockChartIndicatorDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StockChartIndicatorDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
StockChartIndicatorDirective.ɵdir = ɵɵdefineDirective({
  type: StockChartIndicatorDirective,
  selectors: [["e-stockchart-indicator"]],
  inputs: {
    animation: "animation",
    bandColor: "bandColor",
    close: "close",
    dPeriod: "dPeriod",
    dashArray: "dashArray",
    dataSource: "dataSource",
    fastPeriod: "fastPeriod",
    field: "field",
    fill: "fill",
    high: "high",
    kPeriod: "kPeriod",
    low: "low",
    lowerLine: "lowerLine",
    macdLine: "macdLine",
    macdNegativeColor: "macdNegativeColor",
    macdPositiveColor: "macdPositiveColor",
    macdType: "macdType",
    open: "open",
    overBought: "overBought",
    overSold: "overSold",
    period: "period",
    periodLine: "periodLine",
    pointColorMapping: "pointColorMapping",
    query: "query",
    seriesName: "seriesName",
    showZones: "showZones",
    slowPeriod: "slowPeriod",
    standardDeviation: "standardDeviation",
    type: "type",
    upperLine: "upperLine",
    volume: "volume",
    width: "width",
    xAxisName: "xAxisName",
    xName: "xName",
    yAxisName: "yAxisName"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StockChartIndicatorDirective, [{
    type: Directive,
    args: [{
      selector: "e-stockchart-indicators>e-stockchart-indicator",
      inputs: input$8,
      outputs: outputs$c,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, null);
})();
var StockChartIndicatorsDirective = class extends ArrayBase {
  constructor() {
    super("indicators");
  }
};
StockChartIndicatorsDirective.ɵfac = function StockChartIndicatorsDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StockChartIndicatorsDirective)();
};
StockChartIndicatorsDirective.ɵdir = ɵɵdefineDirective({
  type: StockChartIndicatorsDirective,
  selectors: [["e-stockchart-indicators"]],
  contentQueries: function StockChartIndicatorsDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, StockChartIndicatorDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StockChartIndicatorsDirective, [{
    type: Directive,
    args: [{
      selector: "ejs-stockchart>e-stockchart-indicators",
      queries: {
        children: new ContentChildren(StockChartIndicatorDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var inputs$3 = ["annotations", "axes", "background", "border", "chartArea", "crosshair", "dataSource", "enableCustomRange", "enablePeriodSelector", "enablePersistence", "enableRtl", "enableSelector", "exportType", "height", "indicatorType", "indicators", "isMultiSelect", "isSelect", "isTransposed", "legendSettings", "locale", "margin", "periods", "primaryXAxis", "primaryYAxis", "rows", "selectedDataIndexes", "selectionMode", "series", "seriesType", "stockEvents", "theme", "title", "titleStyle", "tooltip", "trendlineType", "width", "zoomSettings"];
var outputs$b = ["axisLabelRender", "beforeExport", "legendClick", "legendRender", "load", "loaded", "onZooming", "pointClick", "pointMove", "rangeChange", "selectorRender", "seriesRender", "stockChartMouseClick", "stockChartMouseDown", "stockChartMouseLeave", "stockChartMouseMove", "stockChartMouseUp", "stockEventRender", "tooltipRender", "dataSourceChange"];
var twoWays$3 = ["dataSource"];
var StockChartComponent = class StockChartComponent2 extends StockChart {
  constructor(ngEle, srenderer, viewContainerRef, injector) {
    super();
    this.ngEle = ngEle;
    this.srenderer = srenderer;
    this.viewContainerRef = viewContainerRef;
    this.injector = injector;
    this.tags = ["series", "axes", "rows", "annotations", "selectedDataIndexes", "periods", "stockEvents", "indicators"];
    this.element = this.ngEle.nativeElement;
    this.injectedModules = this.injectedModules || [];
    try {
      let mod = this.injector.get("ChartsLineSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsColumnSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsSplineSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsSplineAreaSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsStripLine");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsAreaSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsRangeAreaSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsTooltip");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsCrosshair");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsDateTime");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsZoom");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsDataLabel");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsSelection");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsChartAnnotation");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsHiloSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsHiloOpenCloseSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsCandleSeries");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsSmaIndicator");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsTmaIndicator");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsEmaIndicator");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsAccumulationDistributionIndicator");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsMacdIndicator");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsAtrIndicator");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsRsiIndicator");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsMomentumIndicator");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsStochasticIndicator");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsBollingerBands");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsTrendlines");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsRangeTooltip");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsExport");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsStockLegend");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsDateTimeCategory");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    this.registerEvents(outputs$b);
    this.addTwoWay.call(this, twoWays$3);
    setValue("currentInstance", this, this.viewContainerRef);
    this.context = new ComponentBase();
  }
  ngOnInit() {
    this.context.ngOnInit(this);
  }
  ngAfterViewInit() {
    this.context.ngAfterViewInit(this);
  }
  ngOnDestroy() {
    this.context.ngOnDestroy(this);
  }
  ngAfterContentChecked() {
    this.tagObjects[0].instance = this.childSeries;
    if (this.childAxes) {
      this.tagObjects[1].instance = this.childAxes;
    }
    if (this.childRows) {
      this.tagObjects[2].instance = this.childRows;
    }
    if (this.childAnnotations) {
      this.tagObjects[3].instance = this.childAnnotations;
    }
    if (this.childSelectedDataIndexes) {
      this.tagObjects[4].instance = this.childSelectedDataIndexes;
    }
    if (this.childPeriods) {
      this.tagObjects[5].instance = this.childPeriods;
    }
    if (this.childStockEvents) {
      this.tagObjects[6].instance = this.childStockEvents;
    }
    if (this.childIndicators) {
      this.tagObjects[7].instance = this.childIndicators;
    }
    this.context.ngAfterContentChecked(this);
  }
};
StockChartComponent.ɵfac = function StockChartComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StockChartComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector));
};
StockChartComponent.ɵcmp = ɵɵdefineComponent({
  type: StockChartComponent,
  selectors: [["ejs-stockchart"]],
  contentQueries: function StockChartComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, _c2, 5);
      ɵɵcontentQuery(dirIndex, StockChartSeriesCollectionDirective, 5);
      ɵɵcontentQuery(dirIndex, StockChartAxesDirective, 5);
      ɵɵcontentQuery(dirIndex, StockChartRowsDirective, 5);
      ɵɵcontentQuery(dirIndex, StockChartAnnotationsDirective, 5);
      ɵɵcontentQuery(dirIndex, StockChartSelectedDataIndexesDirective, 5);
      ɵɵcontentQuery(dirIndex, StockChartPeriodsDirective, 5);
      ɵɵcontentQuery(dirIndex, StockEventsDirective, 5);
      ɵɵcontentQuery(dirIndex, StockChartIndicatorsDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tooltip_template = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childSeries = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childAxes = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childRows = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childAnnotations = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childSelectedDataIndexes = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childPeriods = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childStockEvents = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childIndicators = _t.first);
    }
  },
  inputs: {
    annotations: "annotations",
    axes: "axes",
    background: "background",
    border: "border",
    chartArea: "chartArea",
    crosshair: "crosshair",
    dataSource: "dataSource",
    enableCustomRange: "enableCustomRange",
    enablePeriodSelector: "enablePeriodSelector",
    enablePersistence: "enablePersistence",
    enableRtl: "enableRtl",
    enableSelector: "enableSelector",
    exportType: "exportType",
    height: "height",
    indicatorType: "indicatorType",
    indicators: "indicators",
    isMultiSelect: "isMultiSelect",
    isSelect: "isSelect",
    isTransposed: "isTransposed",
    legendSettings: "legendSettings",
    locale: "locale",
    margin: "margin",
    periods: "periods",
    primaryXAxis: "primaryXAxis",
    primaryYAxis: "primaryYAxis",
    rows: "rows",
    selectedDataIndexes: "selectedDataIndexes",
    selectionMode: "selectionMode",
    series: "series",
    seriesType: "seriesType",
    stockEvents: "stockEvents",
    theme: "theme",
    title: "title",
    titleStyle: "titleStyle",
    tooltip: "tooltip",
    trendlineType: "trendlineType",
    width: "width",
    zoomSettings: "zoomSettings"
  },
  outputs: {
    axisLabelRender: "axisLabelRender",
    beforeExport: "beforeExport",
    legendClick: "legendClick",
    legendRender: "legendRender",
    load: "load",
    loaded: "loaded",
    onZooming: "onZooming",
    pointClick: "pointClick",
    pointMove: "pointMove",
    rangeChange: "rangeChange",
    selectorRender: "selectorRender",
    seriesRender: "seriesRender",
    stockChartMouseClick: "stockChartMouseClick",
    stockChartMouseDown: "stockChartMouseDown",
    stockChartMouseLeave: "stockChartMouseLeave",
    stockChartMouseMove: "stockChartMouseMove",
    stockChartMouseUp: "stockChartMouseUp",
    stockEventRender: "stockEventRender",
    tooltipRender: "tooltipRender",
    dataSourceChange: "dataSourceChange"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function StockChartComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
__decorate([Template()], StockChartComponent.prototype, "tooltip_template", void 0);
StockChartComponent = __decorate([ComponentMixins([ComponentBase])], StockChartComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StockChartComponent, [{
    type: Component,
    args: [{
      selector: "ejs-stockchart",
      inputs: inputs$3,
      outputs: outputs$b,
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush,
      queries: {
        childSeries: new ContentChild(StockChartSeriesCollectionDirective),
        childAxes: new ContentChild(StockChartAxesDirective),
        childRows: new ContentChild(StockChartRowsDirective),
        childAnnotations: new ContentChild(StockChartAnnotationsDirective),
        childSelectedDataIndexes: new ContentChild(StockChartSelectedDataIndexesDirective),
        childPeriods: new ContentChild(StockChartPeriodsDirective),
        childStockEvents: new ContentChild(StockEventsDirective),
        childIndicators: new ContentChild(StockChartIndicatorsDirective)
      }
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ViewContainerRef
    }, {
      type: Injector
    }];
  }, {
    tooltip_template: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var StockChartModule = class {
};
StockChartModule.ɵfac = function StockChartModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StockChartModule)();
};
StockChartModule.ɵmod = ɵɵdefineNgModule({
  type: StockChartModule,
  declarations: [StockChartComponent, StockChartTrendlineDirective, StockChartTrendlinesDirective, StockChartSeriesDirective, StockChartSeriesCollectionDirective, StockChartAxisDirective, StockChartAxesDirective, StockChartRowDirective, StockChartRowsDirective, StockChartAnnotationDirective, StockChartAnnotationsDirective, StockChartSelectedDataIndexDirective, StockChartSelectedDataIndexesDirective, StockChartPeriodDirective, StockChartPeriodsDirective, StockEventDirective, StockEventsDirective, StockChartIndicatorDirective, StockChartIndicatorsDirective],
  imports: [CommonModule],
  exports: [StockChartComponent, StockChartTrendlineDirective, StockChartTrendlinesDirective, StockChartSeriesDirective, StockChartSeriesCollectionDirective, StockChartAxisDirective, StockChartAxesDirective, StockChartRowDirective, StockChartRowsDirective, StockChartAnnotationDirective, StockChartAnnotationsDirective, StockChartSelectedDataIndexDirective, StockChartSelectedDataIndexesDirective, StockChartPeriodDirective, StockChartPeriodsDirective, StockEventDirective, StockEventsDirective, StockChartIndicatorDirective, StockChartIndicatorsDirective]
});
StockChartModule.ɵinj = ɵɵdefineInjector({
  imports: [[CommonModule]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StockChartModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [StockChartComponent, StockChartTrendlineDirective, StockChartTrendlinesDirective, StockChartSeriesDirective, StockChartSeriesCollectionDirective, StockChartAxisDirective, StockChartAxesDirective, StockChartRowDirective, StockChartRowsDirective, StockChartAnnotationDirective, StockChartAnnotationsDirective, StockChartSelectedDataIndexDirective, StockChartSelectedDataIndexesDirective, StockChartPeriodDirective, StockChartPeriodsDirective, StockEventDirective, StockEventsDirective, StockChartIndicatorDirective, StockChartIndicatorsDirective],
      exports: [StockChartComponent, StockChartTrendlineDirective, StockChartTrendlinesDirective, StockChartSeriesDirective, StockChartSeriesCollectionDirective, StockChartAxisDirective, StockChartAxesDirective, StockChartRowDirective, StockChartRowsDirective, StockChartAnnotationDirective, StockChartAnnotationsDirective, StockChartSelectedDataIndexDirective, StockChartSelectedDataIndexesDirective, StockChartPeriodDirective, StockChartPeriodsDirective, StockEventDirective, StockEventsDirective, StockChartIndicatorDirective, StockChartIndicatorsDirective]
    }]
  }], null, null);
})();
var StockLegendService = {
  provide: "ChartsStockLegend",
  useValue: StockLegend
};
var StockChartAllModule = class {
};
StockChartAllModule.ɵfac = function StockChartAllModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StockChartAllModule)();
};
StockChartAllModule.ɵmod = ɵɵdefineNgModule({
  type: StockChartAllModule,
  imports: [CommonModule, StockChartModule],
  exports: [StockChartModule]
});
StockChartAllModule.ɵinj = ɵɵdefineInjector({
  providers: [StockLegendService],
  imports: [[CommonModule, StockChartModule], StockChartModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StockChartAllModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, StockChartModule],
      exports: [StockChartModule],
      providers: [StockLegendService]
    }]
  }], null, null);
})();
var input$7 = ["color", "end", "index", "legendImageUrl", "name", "opacity", "shape"];
var outputs$a = [];
var BulletRangeDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$a);
    this.directivePropList = input$7;
  }
};
BulletRangeDirective.ɵfac = function BulletRangeDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || BulletRangeDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
BulletRangeDirective.ɵdir = ɵɵdefineDirective({
  type: BulletRangeDirective,
  selectors: [["e-bullet-range"]],
  inputs: {
    color: "color",
    end: "end",
    index: "index",
    legendImageUrl: "legendImageUrl",
    name: "name",
    opacity: "opacity",
    shape: "shape"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BulletRangeDirective, [{
    type: Directive,
    args: [{
      selector: "e-bullet-range-collection>e-bullet-range",
      inputs: input$7,
      outputs: outputs$a,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, null);
})();
var BulletRangeCollectionDirective = class extends ArrayBase {
  constructor() {
    super("ranges");
  }
};
BulletRangeCollectionDirective.ɵfac = function BulletRangeCollectionDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || BulletRangeCollectionDirective)();
};
BulletRangeCollectionDirective.ɵdir = ɵɵdefineDirective({
  type: BulletRangeCollectionDirective,
  selectors: [["e-bullet-range-collection"]],
  contentQueries: function BulletRangeCollectionDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, BulletRangeDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BulletRangeCollectionDirective, [{
    type: Directive,
    args: [{
      selector: "ej-bulletchart>e-bullet-range-collection",
      queries: {
        children: new ContentChildren(BulletRangeDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var inputs$2 = ["animation", "border", "categoryField", "categoryLabelStyle", "dataLabel", "dataSource", "enableGroupSeparator", "enablePersistence", "enableRtl", "height", "interval", "labelFormat", "labelPosition", "labelStyle", "legendSettings", "locale", "majorTickLines", "margin", "maximum", "minimum", "minorTickLines", "minorTicksPerInterval", "opposedPosition", "orientation", "query", "ranges", "subtitle", "subtitleStyle", "tabIndex", "targetColor", "targetField", "targetTypes", "targetWidth", "theme", "tickPosition", "title", "titlePosition", "titleStyle", "tooltip", "type", "valueBorder", "valueField", "valueFill", "valueHeight", "width"];
var outputs$9 = ["beforePrint", "bulletChartMouseClick", "legendRender", "load", "loaded", "tooltipRender", "dataSourceChange"];
var twoWays$2 = ["dataSource"];
var BulletChartComponent = class BulletChartComponent2 extends BulletChart {
  constructor(ngEle, srenderer, viewContainerRef, injector) {
    super();
    this.ngEle = ngEle;
    this.srenderer = srenderer;
    this.viewContainerRef = viewContainerRef;
    this.injector = injector;
    this.tags = ["ranges"];
    this.element = this.ngEle.nativeElement;
    this.injectedModules = this.injectedModules || [];
    try {
      let mod = this.injector.get("ChartsBulletTooltip");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsBulletChartLegend");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    this.registerEvents(outputs$9);
    this.addTwoWay.call(this, twoWays$2);
    setValue("currentInstance", this, this.viewContainerRef);
    this.context = new ComponentBase();
  }
  ngOnInit() {
    this.context.ngOnInit(this);
  }
  ngAfterViewInit() {
    this.context.ngAfterViewInit(this);
  }
  ngOnDestroy() {
    this.context.ngOnDestroy(this);
  }
  ngAfterContentChecked() {
    this.tagObjects[0].instance = this.childRanges;
    this.context.ngAfterContentChecked(this);
  }
};
BulletChartComponent.ɵfac = function BulletChartComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || BulletChartComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector));
};
BulletChartComponent.ɵcmp = ɵɵdefineComponent({
  type: BulletChartComponent,
  selectors: [["ejs-bulletchart"]],
  contentQueries: function BulletChartComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, _c2, 5);
      ɵɵcontentQuery(dirIndex, BulletRangeCollectionDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tooltip_template = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childRanges = _t.first);
    }
  },
  inputs: {
    animation: "animation",
    border: "border",
    categoryField: "categoryField",
    categoryLabelStyle: "categoryLabelStyle",
    dataLabel: "dataLabel",
    dataSource: "dataSource",
    enableGroupSeparator: "enableGroupSeparator",
    enablePersistence: "enablePersistence",
    enableRtl: "enableRtl",
    height: "height",
    interval: "interval",
    labelFormat: "labelFormat",
    labelPosition: "labelPosition",
    labelStyle: "labelStyle",
    legendSettings: "legendSettings",
    locale: "locale",
    majorTickLines: "majorTickLines",
    margin: "margin",
    maximum: "maximum",
    minimum: "minimum",
    minorTickLines: "minorTickLines",
    minorTicksPerInterval: "minorTicksPerInterval",
    opposedPosition: "opposedPosition",
    orientation: "orientation",
    query: "query",
    ranges: "ranges",
    subtitle: "subtitle",
    subtitleStyle: "subtitleStyle",
    tabIndex: "tabIndex",
    targetColor: "targetColor",
    targetField: "targetField",
    targetTypes: "targetTypes",
    targetWidth: "targetWidth",
    theme: "theme",
    tickPosition: "tickPosition",
    title: "title",
    titlePosition: "titlePosition",
    titleStyle: "titleStyle",
    tooltip: "tooltip",
    type: "type",
    valueBorder: "valueBorder",
    valueField: "valueField",
    valueFill: "valueFill",
    valueHeight: "valueHeight",
    width: "width"
  },
  outputs: {
    beforePrint: "beforePrint",
    bulletChartMouseClick: "bulletChartMouseClick",
    legendRender: "legendRender",
    load: "load",
    loaded: "loaded",
    tooltipRender: "tooltipRender",
    dataSourceChange: "dataSourceChange"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function BulletChartComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
__decorate([Template()], BulletChartComponent.prototype, "tooltip_template", void 0);
BulletChartComponent = __decorate([ComponentMixins([ComponentBase])], BulletChartComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BulletChartComponent, [{
    type: Component,
    args: [{
      selector: "ejs-bulletchart",
      inputs: inputs$2,
      outputs: outputs$9,
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush,
      queries: {
        childRanges: new ContentChild(BulletRangeCollectionDirective)
      }
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ViewContainerRef
    }, {
      type: Injector
    }];
  }, {
    tooltip_template: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var BulletChartModule = class {
};
BulletChartModule.ɵfac = function BulletChartModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || BulletChartModule)();
};
BulletChartModule.ɵmod = ɵɵdefineNgModule({
  type: BulletChartModule,
  declarations: [BulletChartComponent, BulletRangeDirective, BulletRangeCollectionDirective],
  imports: [CommonModule],
  exports: [BulletChartComponent, BulletRangeDirective, BulletRangeCollectionDirective]
});
BulletChartModule.ɵinj = ɵɵdefineInjector({
  imports: [[CommonModule]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BulletChartModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [BulletChartComponent, BulletRangeDirective, BulletRangeCollectionDirective],
      exports: [BulletChartComponent, BulletRangeDirective, BulletRangeCollectionDirective]
    }]
  }], null, null);
})();
var BulletTooltipService = {
  provide: "ChartsBulletTooltip",
  useValue: BulletTooltip
};
var BulletChartLegendService = {
  provide: "ChartsBulletChartLegend",
  useValue: BulletChartLegend
};
var BulletChartAllModule = class {
};
BulletChartAllModule.ɵfac = function BulletChartAllModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || BulletChartAllModule)();
};
BulletChartAllModule.ɵmod = ɵɵdefineNgModule({
  type: BulletChartAllModule,
  imports: [CommonModule, BulletChartModule],
  exports: [BulletChartModule]
});
BulletChartAllModule.ɵinj = ɵɵdefineInjector({
  providers: [BulletTooltipService, BulletChartLegendService],
  imports: [[CommonModule, BulletChartModule], BulletChartModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BulletChartAllModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, BulletChartModule],
      exports: [BulletChartModule],
      providers: [BulletTooltipService, BulletChartLegendService]
    }]
  }], null, null);
})();
var input$6 = ["animation", "columnFacet", "columnSpacing", "columnWidth", "dataLabel", "dataSource", "emptyPointSettings", "enableTooltip", "fill", "groupName", "legendImageUrl", "legendShape", "name", "opacity", "pointColorMapping", "query", "size", "stackingGroup", "tooltipFormat", "tooltipMappingName", "type", "visible", "xAxisName", "xName", "yAxisName", "yName"];
var outputs$8 = [];
var Chart3DSeriesDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$8);
    this.directivePropList = input$6;
  }
};
Chart3DSeriesDirective.ɵfac = function Chart3DSeriesDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Chart3DSeriesDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
Chart3DSeriesDirective.ɵdir = ɵɵdefineDirective({
  type: Chart3DSeriesDirective,
  selectors: [["e-chart3d-series"]],
  contentQueries: function Chart3DSeriesDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, _c0, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dataLabel_template = _t.first);
    }
  },
  inputs: {
    animation: "animation",
    columnFacet: "columnFacet",
    columnSpacing: "columnSpacing",
    columnWidth: "columnWidth",
    dataLabel: "dataLabel",
    dataSource: "dataSource",
    emptyPointSettings: "emptyPointSettings",
    enableTooltip: "enableTooltip",
    fill: "fill",
    groupName: "groupName",
    legendImageUrl: "legendImageUrl",
    legendShape: "legendShape",
    name: "name",
    opacity: "opacity",
    pointColorMapping: "pointColorMapping",
    query: "query",
    size: "size",
    stackingGroup: "stackingGroup",
    tooltipFormat: "tooltipFormat",
    tooltipMappingName: "tooltipMappingName",
    type: "type",
    visible: "visible",
    xAxisName: "xAxisName",
    xName: "xName",
    yAxisName: "yAxisName",
    yName: "yName"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
__decorate([Template()], Chart3DSeriesDirective.prototype, "dataLabel_template", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Chart3DSeriesDirective, [{
    type: Directive,
    args: [{
      selector: "e-chart3d-series-collection>e-chart3d-series",
      inputs: input$6,
      outputs: outputs$8,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, {
    dataLabel_template: [{
      type: ContentChild,
      args: ["dataLabelTemplate"]
    }]
  });
})();
var Chart3DSeriesCollectionDirective = class extends ArrayBase {
  constructor() {
    super("series");
  }
};
Chart3DSeriesCollectionDirective.ɵfac = function Chart3DSeriesCollectionDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Chart3DSeriesCollectionDirective)();
};
Chart3DSeriesCollectionDirective.ɵdir = ɵɵdefineDirective({
  type: Chart3DSeriesCollectionDirective,
  selectors: [["e-chart3d-series-collection"]],
  contentQueries: function Chart3DSeriesCollectionDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, Chart3DSeriesDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Chart3DSeriesCollectionDirective, [{
    type: Directive,
    args: [{
      selector: "ejs-chart3d>e-chart3d-series-collection",
      queries: {
        children: new ContentChildren(Chart3DSeriesDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var input$5 = ["columnIndex", "desiredIntervals", "edgeLabelPlacement", "enableTrim", "interval", "intervalType", "isIndexed", "isInversed", "labelFormat", "labelIntersectAction", "labelPadding", "labelPlacement", "labelRotation", "labelStyle", "logBase", "majorGridLines", "majorTickLines", "maximum", "maximumLabelWidth", "maximumLabels", "minimum", "minorGridLines", "minorTickLines", "minorTicksPerInterval", "name", "opposedPosition", "plotOffset", "plotOffsetBottom", "plotOffsetLeft", "plotOffsetRight", "plotOffsetTop", "rangePadding", "rowIndex", "skeleton", "skeletonType", "span", "startFromZero", "title", "titlePadding", "titleRotation", "titleStyle", "valueType", "visible"];
var outputs$7 = [];
var Chart3DAxisDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$7);
    this.directivePropList = input$5;
  }
};
Chart3DAxisDirective.ɵfac = function Chart3DAxisDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Chart3DAxisDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
Chart3DAxisDirective.ɵdir = ɵɵdefineDirective({
  type: Chart3DAxisDirective,
  selectors: [["e-chart3daxis"]],
  inputs: {
    columnIndex: "columnIndex",
    desiredIntervals: "desiredIntervals",
    edgeLabelPlacement: "edgeLabelPlacement",
    enableTrim: "enableTrim",
    interval: "interval",
    intervalType: "intervalType",
    isIndexed: "isIndexed",
    isInversed: "isInversed",
    labelFormat: "labelFormat",
    labelIntersectAction: "labelIntersectAction",
    labelPadding: "labelPadding",
    labelPlacement: "labelPlacement",
    labelRotation: "labelRotation",
    labelStyle: "labelStyle",
    logBase: "logBase",
    majorGridLines: "majorGridLines",
    majorTickLines: "majorTickLines",
    maximum: "maximum",
    maximumLabelWidth: "maximumLabelWidth",
    maximumLabels: "maximumLabels",
    minimum: "minimum",
    minorGridLines: "minorGridLines",
    minorTickLines: "minorTickLines",
    minorTicksPerInterval: "minorTicksPerInterval",
    name: "name",
    opposedPosition: "opposedPosition",
    plotOffset: "plotOffset",
    plotOffsetBottom: "plotOffsetBottom",
    plotOffsetLeft: "plotOffsetLeft",
    plotOffsetRight: "plotOffsetRight",
    plotOffsetTop: "plotOffsetTop",
    rangePadding: "rangePadding",
    rowIndex: "rowIndex",
    skeleton: "skeleton",
    skeletonType: "skeletonType",
    span: "span",
    startFromZero: "startFromZero",
    title: "title",
    titlePadding: "titlePadding",
    titleRotation: "titleRotation",
    titleStyle: "titleStyle",
    valueType: "valueType",
    visible: "visible"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Chart3DAxisDirective, [{
    type: Directive,
    args: [{
      selector: "e-chart3daxes>e-chart3daxis",
      inputs: input$5,
      outputs: outputs$7,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, null);
})();
var Chart3DAxesDirective = class extends ArrayBase {
  constructor() {
    super("axes");
  }
};
Chart3DAxesDirective.ɵfac = function Chart3DAxesDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Chart3DAxesDirective)();
};
Chart3DAxesDirective.ɵdir = ɵɵdefineDirective({
  type: Chart3DAxesDirective,
  selectors: [["e-chart3daxes"]],
  contentQueries: function Chart3DAxesDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, Chart3DAxisDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Chart3DAxesDirective, [{
    type: Directive,
    args: [{
      selector: "ejs-chart3d>e-chart3daxes",
      queries: {
        children: new ContentChildren(Chart3DAxisDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var input$4 = ["height"];
var outputs$6 = [];
var Chart3DRowDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$6);
    this.directivePropList = input$4;
  }
};
Chart3DRowDirective.ɵfac = function Chart3DRowDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Chart3DRowDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
Chart3DRowDirective.ɵdir = ɵɵdefineDirective({
  type: Chart3DRowDirective,
  selectors: [["e-chart3d-row"]],
  inputs: {
    height: "height"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Chart3DRowDirective, [{
    type: Directive,
    args: [{
      selector: "e-chart3d-rows>e-chart3d-row",
      inputs: input$4,
      outputs: outputs$6,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, null);
})();
var Chart3DRowsDirective = class extends ArrayBase {
  constructor() {
    super("rows");
  }
};
Chart3DRowsDirective.ɵfac = function Chart3DRowsDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Chart3DRowsDirective)();
};
Chart3DRowsDirective.ɵdir = ɵɵdefineDirective({
  type: Chart3DRowsDirective,
  selectors: [["e-chart3d-rows"]],
  contentQueries: function Chart3DRowsDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, Chart3DRowDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Chart3DRowsDirective, [{
    type: Directive,
    args: [{
      selector: "ejs-chart3d>e-chart3d-rows",
      queries: {
        children: new ContentChildren(Chart3DRowDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var input$3 = ["width"];
var outputs$5 = [];
var Chart3DColumnDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$5);
    this.directivePropList = input$3;
  }
};
Chart3DColumnDirective.ɵfac = function Chart3DColumnDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Chart3DColumnDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
Chart3DColumnDirective.ɵdir = ɵɵdefineDirective({
  type: Chart3DColumnDirective,
  selectors: [["e-chart3d-columns"]],
  inputs: {
    width: "width"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Chart3DColumnDirective, [{
    type: Directive,
    args: [{
      selector: "e-chart3d-columns>e-chart3d-columns",
      inputs: input$3,
      outputs: outputs$5,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, null);
})();
var Chart3DColumnsDirective = class extends ArrayBase {
  constructor() {
    super("columns");
  }
};
Chart3DColumnsDirective.ɵfac = function Chart3DColumnsDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Chart3DColumnsDirective)();
};
Chart3DColumnsDirective.ɵdir = ɵɵdefineDirective({
  type: Chart3DColumnsDirective,
  selectors: [["e-chart3d-columns"]],
  contentQueries: function Chart3DColumnsDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, Chart3DColumnDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Chart3DColumnsDirective, [{
    type: Directive,
    args: [{
      selector: "ejs-chart3d>e-chart3d-columns",
      queries: {
        children: new ContentChildren(Chart3DColumnDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var input$2 = ["point", "series"];
var outputs$4 = [];
var Chart3DSelectedDataIndexDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$4);
    this.directivePropList = input$2;
  }
};
Chart3DSelectedDataIndexDirective.ɵfac = function Chart3DSelectedDataIndexDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Chart3DSelectedDataIndexDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
Chart3DSelectedDataIndexDirective.ɵdir = ɵɵdefineDirective({
  type: Chart3DSelectedDataIndexDirective,
  selectors: [["e-chart3d-selecteddataindex"]],
  inputs: {
    point: "point",
    series: "series"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Chart3DSelectedDataIndexDirective, [{
    type: Directive,
    args: [{
      selector: "e-chart3d-selecteddataindexes>e-chart3d-selecteddataindex",
      inputs: input$2,
      outputs: outputs$4,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, null);
})();
var Chart3DSelectedDataIndexesDirective = class extends ArrayBase {
  constructor() {
    super("selecteddataindexes");
  }
};
Chart3DSelectedDataIndexesDirective.ɵfac = function Chart3DSelectedDataIndexesDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Chart3DSelectedDataIndexesDirective)();
};
Chart3DSelectedDataIndexesDirective.ɵdir = ɵɵdefineDirective({
  type: Chart3DSelectedDataIndexesDirective,
  selectors: [["e-chart3d-selecteddataindexes"]],
  contentQueries: function Chart3DSelectedDataIndexesDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, Chart3DSelectedDataIndexDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Chart3DSelectedDataIndexesDirective, [{
    type: Directive,
    args: [{
      selector: "ejs-chart3d>e-chart3d-selecteddataindexes",
      queries: {
        children: new ContentChildren(Chart3DSelectedDataIndexDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var inputs$1 = ["axes", "background", "backgroundImage", "border", "columns", "currencyCode", "dataSource", "depth", "description", "enableExport", "enablePersistence", "enableRotation", "enableRtl", "enableSideBySidePlacement", "height", "highlightColor", "highlightMode", "highlightPattern", "isMultiSelect", "isTransposed", "legendSettings", "locale", "margin", "palettes", "perspectiveAngle", "primaryXAxis", "primaryYAxis", "rotation", "rows", "selectedDataIndexes", "selectionMode", "selectionPattern", "series", "subTitle", "subTitleStyle", "theme", "tilt", "title", "titleStyle", "tooltip", "useGroupingSeparator", "wallColor", "wallSize", "width"];
var outputs$3 = ["afterExport", "axisLabelRender", "beforeExport", "beforePrint", "beforeResize", "chart3DMouseClick", "chart3DMouseDown", "chart3DMouseLeave", "chart3DMouseMove", "chart3DMouseUp", "legendClick", "legendRender", "load", "loaded", "pointClick", "pointMove", "pointRender", "resized", "selectionComplete", "seriesRender", "textRender", "tooltipRender", "dataSourceChange"];
var twoWays$1 = ["dataSource"];
var Chart3DComponent = class Chart3DComponent2 extends Chart3D {
  constructor(ngEle, srenderer, viewContainerRef, injector) {
    super();
    this.ngEle = ngEle;
    this.srenderer = srenderer;
    this.viewContainerRef = viewContainerRef;
    this.injector = injector;
    this.tags = ["series", "axes", "rows", "columns", "selectedDataIndexes"];
    this.element = this.ngEle.nativeElement;
    this.injectedModules = this.injectedModules || [];
    try {
      let mod = this.injector.get("ChartsColumnSeries3D");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsStackingColumnSeries3D");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsBarSeries3D");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsStackingBarSeries3D");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsCategory3D");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsDateTime3D");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsDateTimeCategory3D");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsLogarithmic3D");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsTooltip3D");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsLegend3D");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsDataLabel3D");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsSelection3D");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsExport3D");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsHighlight3D");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    this.registerEvents(outputs$3);
    this.addTwoWay.call(this, twoWays$1);
    setValue("currentInstance", this, this.viewContainerRef);
    this.context = new ComponentBase();
  }
  ngOnInit() {
    this.context.ngOnInit(this);
  }
  ngAfterViewInit() {
    this.context.ngAfterViewInit(this);
  }
  ngOnDestroy() {
    this.context.ngOnDestroy(this);
  }
  ngAfterContentChecked() {
    this.tagObjects[0].instance = this.childSeries;
    if (this.childAxes) {
      this.tagObjects[1].instance = this.childAxes;
    }
    if (this.childRows) {
      this.tagObjects[2].instance = this.childRows;
    }
    if (this.childColumns) {
      this.tagObjects[3].instance = this.childColumns;
    }
    if (this.childSelectedDataIndexes) {
      this.tagObjects[4].instance = this.childSelectedDataIndexes;
    }
    this.context.ngAfterContentChecked(this);
  }
};
Chart3DComponent.ɵfac = function Chart3DComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Chart3DComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector));
};
Chart3DComponent.ɵcmp = ɵɵdefineComponent({
  type: Chart3DComponent,
  selectors: [["ejs-chart3d"]],
  contentQueries: function Chart3DComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, _c2, 5);
      ɵɵcontentQuery(dirIndex, Chart3DSeriesCollectionDirective, 5);
      ɵɵcontentQuery(dirIndex, Chart3DAxesDirective, 5);
      ɵɵcontentQuery(dirIndex, Chart3DRowsDirective, 5);
      ɵɵcontentQuery(dirIndex, Chart3DColumnsDirective, 5);
      ɵɵcontentQuery(dirIndex, Chart3DSelectedDataIndexesDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tooltip_template = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childSeries = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childAxes = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childRows = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childColumns = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childSelectedDataIndexes = _t.first);
    }
  },
  inputs: {
    axes: "axes",
    background: "background",
    backgroundImage: "backgroundImage",
    border: "border",
    columns: "columns",
    currencyCode: "currencyCode",
    dataSource: "dataSource",
    depth: "depth",
    description: "description",
    enableExport: "enableExport",
    enablePersistence: "enablePersistence",
    enableRotation: "enableRotation",
    enableRtl: "enableRtl",
    enableSideBySidePlacement: "enableSideBySidePlacement",
    height: "height",
    highlightColor: "highlightColor",
    highlightMode: "highlightMode",
    highlightPattern: "highlightPattern",
    isMultiSelect: "isMultiSelect",
    isTransposed: "isTransposed",
    legendSettings: "legendSettings",
    locale: "locale",
    margin: "margin",
    palettes: "palettes",
    perspectiveAngle: "perspectiveAngle",
    primaryXAxis: "primaryXAxis",
    primaryYAxis: "primaryYAxis",
    rotation: "rotation",
    rows: "rows",
    selectedDataIndexes: "selectedDataIndexes",
    selectionMode: "selectionMode",
    selectionPattern: "selectionPattern",
    series: "series",
    subTitle: "subTitle",
    subTitleStyle: "subTitleStyle",
    theme: "theme",
    tilt: "tilt",
    title: "title",
    titleStyle: "titleStyle",
    tooltip: "tooltip",
    useGroupingSeparator: "useGroupingSeparator",
    wallColor: "wallColor",
    wallSize: "wallSize",
    width: "width"
  },
  outputs: {
    afterExport: "afterExport",
    axisLabelRender: "axisLabelRender",
    beforeExport: "beforeExport",
    beforePrint: "beforePrint",
    beforeResize: "beforeResize",
    chart3DMouseClick: "chart3DMouseClick",
    chart3DMouseDown: "chart3DMouseDown",
    chart3DMouseLeave: "chart3DMouseLeave",
    chart3DMouseMove: "chart3DMouseMove",
    chart3DMouseUp: "chart3DMouseUp",
    legendClick: "legendClick",
    legendRender: "legendRender",
    load: "load",
    loaded: "loaded",
    pointClick: "pointClick",
    pointMove: "pointMove",
    pointRender: "pointRender",
    resized: "resized",
    selectionComplete: "selectionComplete",
    seriesRender: "seriesRender",
    textRender: "textRender",
    tooltipRender: "tooltipRender",
    dataSourceChange: "dataSourceChange"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function Chart3DComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
__decorate([Template()], Chart3DComponent.prototype, "tooltip_template", void 0);
Chart3DComponent = __decorate([ComponentMixins([ComponentBase])], Chart3DComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Chart3DComponent, [{
    type: Component,
    args: [{
      selector: "ejs-chart3d",
      inputs: inputs$1,
      outputs: outputs$3,
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush,
      queries: {
        childSeries: new ContentChild(Chart3DSeriesCollectionDirective),
        childAxes: new ContentChild(Chart3DAxesDirective),
        childRows: new ContentChild(Chart3DRowsDirective),
        childColumns: new ContentChild(Chart3DColumnsDirective),
        childSelectedDataIndexes: new ContentChild(Chart3DSelectedDataIndexesDirective)
      }
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ViewContainerRef
    }, {
      type: Injector
    }];
  }, {
    tooltip_template: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var Chart3DModule = class {
};
Chart3DModule.ɵfac = function Chart3DModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Chart3DModule)();
};
Chart3DModule.ɵmod = ɵɵdefineNgModule({
  type: Chart3DModule,
  declarations: [Chart3DComponent, Chart3DSeriesDirective, Chart3DSeriesCollectionDirective, Chart3DAxisDirective, Chart3DAxesDirective, Chart3DRowDirective, Chart3DRowsDirective, Chart3DColumnDirective, Chart3DColumnsDirective, Chart3DSelectedDataIndexDirective, Chart3DSelectedDataIndexesDirective],
  imports: [CommonModule],
  exports: [Chart3DComponent, Chart3DSeriesDirective, Chart3DSeriesCollectionDirective, Chart3DAxisDirective, Chart3DAxesDirective, Chart3DRowDirective, Chart3DRowsDirective, Chart3DColumnDirective, Chart3DColumnsDirective, Chart3DSelectedDataIndexDirective, Chart3DSelectedDataIndexesDirective]
});
Chart3DModule.ɵinj = ɵɵdefineInjector({
  imports: [[CommonModule]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Chart3DModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [Chart3DComponent, Chart3DSeriesDirective, Chart3DSeriesCollectionDirective, Chart3DAxisDirective, Chart3DAxesDirective, Chart3DRowDirective, Chart3DRowsDirective, Chart3DColumnDirective, Chart3DColumnsDirective, Chart3DSelectedDataIndexDirective, Chart3DSelectedDataIndexesDirective],
      exports: [Chart3DComponent, Chart3DSeriesDirective, Chart3DSeriesCollectionDirective, Chart3DAxisDirective, Chart3DAxesDirective, Chart3DRowDirective, Chart3DRowsDirective, Chart3DColumnDirective, Chart3DColumnsDirective, Chart3DSelectedDataIndexDirective, Chart3DSelectedDataIndexesDirective]
    }]
  }], null, null);
})();
var ColumnSeries3DService = {
  provide: "ChartsColumnSeries3D",
  useValue: ColumnSeries3D
};
var StackingColumnSeries3DService = {
  provide: "ChartsStackingColumnSeries3D",
  useValue: StackingColumnSeries3D
};
var BarSeries3DService = {
  provide: "ChartsBarSeries3D",
  useValue: BarSeries3D
};
var StackingBarSeries3DService = {
  provide: "ChartsStackingBarSeries3D",
  useValue: StackingBarSeries3D
};
var Category3DService = {
  provide: "ChartsCategory3D",
  useValue: Category3D
};
var DateTime3DService = {
  provide: "ChartsDateTime3D",
  useValue: DateTime3D
};
var DateTimeCategory3DService = {
  provide: "ChartsDateTimeCategory3D",
  useValue: DateTimeCategory3D
};
var Logarithmic3DService = {
  provide: "ChartsLogarithmic3D",
  useValue: Logarithmic3D
};
var Tooltip3DService = {
  provide: "ChartsTooltip3D",
  useValue: Tooltip3D
};
var Legend3DService = {
  provide: "ChartsLegend3D",
  useValue: Legend3D
};
var DataLabel3DService = {
  provide: "ChartsDataLabel3D",
  useValue: DataLabel3D
};
var Selection3DService = {
  provide: "ChartsSelection3D",
  useValue: Selection3D
};
var Export3DService = {
  provide: "ChartsExport3D",
  useValue: Export3D
};
var Highlight3DService = {
  provide: "ChartsHighlight3D",
  useValue: Highlight3D
};
var Chart3DAllModule = class {
};
Chart3DAllModule.ɵfac = function Chart3DAllModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Chart3DAllModule)();
};
Chart3DAllModule.ɵmod = ɵɵdefineNgModule({
  type: Chart3DAllModule,
  imports: [CommonModule, Chart3DModule],
  exports: [Chart3DModule]
});
Chart3DAllModule.ɵinj = ɵɵdefineInjector({
  providers: [ColumnSeries3DService, StackingColumnSeries3DService, BarSeries3DService, StackingBarSeries3DService, Category3DService, DateTime3DService, DateTimeCategory3DService, Logarithmic3DService, Tooltip3DService, Legend3DService, DataLabel3DService, Selection3DService, Export3DService, Highlight3DService],
  imports: [[CommonModule, Chart3DModule], Chart3DModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Chart3DAllModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, Chart3DModule],
      exports: [Chart3DModule],
      providers: [ColumnSeries3DService, StackingColumnSeries3DService, BarSeries3DService, StackingBarSeries3DService, Category3DService, DateTime3DService, DateTimeCategory3DService, Logarithmic3DService, Tooltip3DService, Legend3DService, DataLabel3DService, Selection3DService, Export3DService, Highlight3DService]
    }]
  }], null, null);
})();
var input$1 = ["animation", "dataLabel", "dataSource", "emptyPointSettings", "enableTooltip", "explode", "explodeAll", "explodeIndex", "explodeOffset", "innerRadius", "legendImageUrl", "legendShape", "name", "opacity", "palettes", "pointColorMapping", "query", "radius", "tooltipMappingName", "visible", "xName", "yName"];
var outputs$2 = [];
var CircularChart3DSeriesDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$2);
    this.directivePropList = input$1;
  }
};
CircularChart3DSeriesDirective.ɵfac = function CircularChart3DSeriesDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || CircularChart3DSeriesDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
CircularChart3DSeriesDirective.ɵdir = ɵɵdefineDirective({
  type: CircularChart3DSeriesDirective,
  selectors: [["e-circularchart3d-series"]],
  contentQueries: function CircularChart3DSeriesDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, _c0, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dataLabel_template = _t.first);
    }
  },
  inputs: {
    animation: "animation",
    dataLabel: "dataLabel",
    dataSource: "dataSource",
    emptyPointSettings: "emptyPointSettings",
    enableTooltip: "enableTooltip",
    explode: "explode",
    explodeAll: "explodeAll",
    explodeIndex: "explodeIndex",
    explodeOffset: "explodeOffset",
    innerRadius: "innerRadius",
    legendImageUrl: "legendImageUrl",
    legendShape: "legendShape",
    name: "name",
    opacity: "opacity",
    palettes: "palettes",
    pointColorMapping: "pointColorMapping",
    query: "query",
    radius: "radius",
    tooltipMappingName: "tooltipMappingName",
    visible: "visible",
    xName: "xName",
    yName: "yName"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
__decorate([Template()], CircularChart3DSeriesDirective.prototype, "dataLabel_template", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CircularChart3DSeriesDirective, [{
    type: Directive,
    args: [{
      selector: "e-circularchart3d-series-collection>e-circularchart3d-series",
      inputs: input$1,
      outputs: outputs$2,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, {
    dataLabel_template: [{
      type: ContentChild,
      args: ["dataLabelTemplate"]
    }]
  });
})();
var CircularChart3DSeriesCollectionDirective = class extends ArrayBase {
  constructor() {
    super("series");
  }
};
CircularChart3DSeriesCollectionDirective.ɵfac = function CircularChart3DSeriesCollectionDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || CircularChart3DSeriesCollectionDirective)();
};
CircularChart3DSeriesCollectionDirective.ɵdir = ɵɵdefineDirective({
  type: CircularChart3DSeriesCollectionDirective,
  selectors: [["e-circularchart3d-series-collection"]],
  contentQueries: function CircularChart3DSeriesCollectionDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, CircularChart3DSeriesDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CircularChart3DSeriesCollectionDirective, [{
    type: Directive,
    args: [{
      selector: "ej-circularchart3d>e-circularchart3d-series-collection",
      queries: {
        children: new ContentChildren(CircularChart3DSeriesDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var input = ["point", "series"];
var outputs$1 = [];
var CircularChart3DSelectedDataIndexDirective = class extends ComplexBase {
  constructor(viewContainerRef) {
    super();
    this.viewContainerRef = viewContainerRef;
    setValue("currentInstance", this, this.viewContainerRef);
    this.registerEvents(outputs$1);
    this.directivePropList = input;
  }
};
CircularChart3DSelectedDataIndexDirective.ɵfac = function CircularChart3DSelectedDataIndexDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || CircularChart3DSelectedDataIndexDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
CircularChart3DSelectedDataIndexDirective.ɵdir = ɵɵdefineDirective({
  type: CircularChart3DSelectedDataIndexDirective,
  selectors: [["e-circularchart3d-selecteddataindex"]],
  inputs: {
    point: "point",
    series: "series"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CircularChart3DSelectedDataIndexDirective, [{
    type: Directive,
    args: [{
      selector: "e-circularchart3d-selecteddataindexes>e-circularchart3d-selecteddataindex",
      inputs: input,
      outputs: outputs$1,
      queries: {}
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, null);
})();
var CircularChart3DSelectedDataIndexesDirective = class extends ArrayBase {
  constructor() {
    super("selecteddataindexes");
  }
};
CircularChart3DSelectedDataIndexesDirective.ɵfac = function CircularChart3DSelectedDataIndexesDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || CircularChart3DSelectedDataIndexesDirective)();
};
CircularChart3DSelectedDataIndexesDirective.ɵdir = ɵɵdefineDirective({
  type: CircularChart3DSelectedDataIndexesDirective,
  selectors: [["e-circularchart3d-selecteddataindexes"]],
  contentQueries: function CircularChart3DSelectedDataIndexesDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, CircularChart3DSelectedDataIndexDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CircularChart3DSelectedDataIndexesDirective, [{
    type: Directive,
    args: [{
      selector: "ejs-circularchart3d>e-circularchart3d-selecteddataindexes",
      queries: {
        children: new ContentChildren(CircularChart3DSelectedDataIndexDirective)
      }
    }]
  }], function() {
    return [];
  }, null);
})();
var inputs = ["background", "backgroundImage", "border", "dataSource", "depth", "enableAnimation", "enableExport", "enablePersistence", "enableRotation", "enableRtl", "height", "highlightColor", "highlightMode", "highlightPattern", "isMultiSelect", "legendSettings", "locale", "margin", "rotation", "selectedDataIndexes", "selectionMode", "selectionPattern", "series", "subTitle", "subTitleStyle", "theme", "tilt", "title", "titleStyle", "tooltip", "useGroupingSeparator", "width"];
var outputs = ["afterExport", "beforeExport", "beforePrint", "beforeResize", "circularChart3DMouseClick", "circularChart3DMouseDown", "circularChart3DMouseLeave", "circularChart3DMouseMove", "circularChart3DMouseUp", "legendClick", "legendRender", "load", "loaded", "pointClick", "pointMove", "pointRender", "resized", "selectionComplete", "seriesRender", "textRender", "tooltipRender", "dataSourceChange"];
var twoWays = ["dataSource"];
var CircularChart3DComponent = class CircularChart3DComponent2 extends CircularChart3D {
  constructor(ngEle, srenderer, viewContainerRef, injector) {
    super();
    this.ngEle = ngEle;
    this.srenderer = srenderer;
    this.viewContainerRef = viewContainerRef;
    this.injector = injector;
    this.tags = ["series", "selectedDataIndexes"];
    this.element = this.ngEle.nativeElement;
    this.injectedModules = this.injectedModules || [];
    try {
      let mod = this.injector.get("ChartsPieSeries3D");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsCircularChartTooltip3D");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsCircularChartLegend3D");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsCircularChartSelection3D");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsCircularChartDataLabel3D");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsCircularChartHighlight3D");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    try {
      let mod = this.injector.get("ChartsCircularChartExport3D");
      if (this.injectedModules.indexOf(mod) === -1) {
        this.injectedModules.push(mod);
      }
    } catch {
    }
    this.registerEvents(outputs);
    this.addTwoWay.call(this, twoWays);
    setValue("currentInstance", this, this.viewContainerRef);
    this.context = new ComponentBase();
  }
  ngOnInit() {
    this.context.ngOnInit(this);
  }
  ngAfterViewInit() {
    this.context.ngAfterViewInit(this);
  }
  ngOnDestroy() {
    this.context.ngOnDestroy(this);
  }
  ngAfterContentChecked() {
    this.tagObjects[0].instance = this.childSeries;
    if (this.childSelectedDataIndexes) {
      this.tagObjects[1].instance = this.childSelectedDataIndexes;
    }
    this.context.ngAfterContentChecked(this);
  }
};
CircularChart3DComponent.ɵfac = function CircularChart3DComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || CircularChart3DComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector));
};
CircularChart3DComponent.ɵcmp = ɵɵdefineComponent({
  type: CircularChart3DComponent,
  selectors: [["ejs-circularchart3d"]],
  contentQueries: function CircularChart3DComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, _c2, 5);
      ɵɵcontentQuery(dirIndex, CircularChart3DSeriesCollectionDirective, 5);
      ɵɵcontentQuery(dirIndex, CircularChart3DSelectedDataIndexesDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tooltip_template = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childSeries = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childSelectedDataIndexes = _t.first);
    }
  },
  inputs: {
    background: "background",
    backgroundImage: "backgroundImage",
    border: "border",
    dataSource: "dataSource",
    depth: "depth",
    enableAnimation: "enableAnimation",
    enableExport: "enableExport",
    enablePersistence: "enablePersistence",
    enableRotation: "enableRotation",
    enableRtl: "enableRtl",
    height: "height",
    highlightColor: "highlightColor",
    highlightMode: "highlightMode",
    highlightPattern: "highlightPattern",
    isMultiSelect: "isMultiSelect",
    legendSettings: "legendSettings",
    locale: "locale",
    margin: "margin",
    rotation: "rotation",
    selectedDataIndexes: "selectedDataIndexes",
    selectionMode: "selectionMode",
    selectionPattern: "selectionPattern",
    series: "series",
    subTitle: "subTitle",
    subTitleStyle: "subTitleStyle",
    theme: "theme",
    tilt: "tilt",
    title: "title",
    titleStyle: "titleStyle",
    tooltip: "tooltip",
    useGroupingSeparator: "useGroupingSeparator",
    width: "width"
  },
  outputs: {
    afterExport: "afterExport",
    beforeExport: "beforeExport",
    beforePrint: "beforePrint",
    beforeResize: "beforeResize",
    circularChart3DMouseClick: "circularChart3DMouseClick",
    circularChart3DMouseDown: "circularChart3DMouseDown",
    circularChart3DMouseLeave: "circularChart3DMouseLeave",
    circularChart3DMouseMove: "circularChart3DMouseMove",
    circularChart3DMouseUp: "circularChart3DMouseUp",
    legendClick: "legendClick",
    legendRender: "legendRender",
    load: "load",
    loaded: "loaded",
    pointClick: "pointClick",
    pointMove: "pointMove",
    pointRender: "pointRender",
    resized: "resized",
    selectionComplete: "selectionComplete",
    seriesRender: "seriesRender",
    textRender: "textRender",
    tooltipRender: "tooltipRender",
    dataSourceChange: "dataSourceChange"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function CircularChart3DComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
__decorate([Template()], CircularChart3DComponent.prototype, "tooltip_template", void 0);
CircularChart3DComponent = __decorate([ComponentMixins([ComponentBase])], CircularChart3DComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CircularChart3DComponent, [{
    type: Component,
    args: [{
      selector: "ejs-circularchart3d",
      inputs,
      outputs,
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush,
      queries: {
        childSeries: new ContentChild(CircularChart3DSeriesCollectionDirective),
        childSelectedDataIndexes: new ContentChild(CircularChart3DSelectedDataIndexesDirective)
      }
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ViewContainerRef
    }, {
      type: Injector
    }];
  }, {
    tooltip_template: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var CircularChart3DModule = class {
};
CircularChart3DModule.ɵfac = function CircularChart3DModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || CircularChart3DModule)();
};
CircularChart3DModule.ɵmod = ɵɵdefineNgModule({
  type: CircularChart3DModule,
  declarations: [CircularChart3DComponent, CircularChart3DSeriesDirective, CircularChart3DSeriesCollectionDirective, CircularChart3DSelectedDataIndexDirective, CircularChart3DSelectedDataIndexesDirective],
  imports: [CommonModule],
  exports: [CircularChart3DComponent, CircularChart3DSeriesDirective, CircularChart3DSeriesCollectionDirective, CircularChart3DSelectedDataIndexDirective, CircularChart3DSelectedDataIndexesDirective]
});
CircularChart3DModule.ɵinj = ɵɵdefineInjector({
  imports: [[CommonModule]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CircularChart3DModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [CircularChart3DComponent, CircularChart3DSeriesDirective, CircularChart3DSeriesCollectionDirective, CircularChart3DSelectedDataIndexDirective, CircularChart3DSelectedDataIndexesDirective],
      exports: [CircularChart3DComponent, CircularChart3DSeriesDirective, CircularChart3DSeriesCollectionDirective, CircularChart3DSelectedDataIndexDirective, CircularChart3DSelectedDataIndexesDirective]
    }]
  }], null, null);
})();
var PieSeries3DService = {
  provide: "ChartsPieSeries3D",
  useValue: PieSeries3D
};
var CircularChartTooltip3DService = {
  provide: "ChartsCircularChartTooltip3D",
  useValue: CircularChartTooltip3D
};
var CircularChartLegend3DService = {
  provide: "ChartsCircularChartLegend3D",
  useValue: CircularChartLegend3D
};
var CircularChartSelection3DService = {
  provide: "ChartsCircularChartSelection3D",
  useValue: CircularChartSelection3D
};
var CircularChartDataLabel3DService = {
  provide: "ChartsCircularChartDataLabel3D",
  useValue: CircularChartDataLabel3D
};
var CircularChartHighlight3DService = {
  provide: "ChartsCircularChartHighlight3D",
  useValue: CircularChartHighlight3D
};
var CircularChartExport3DService = {
  provide: "ChartsCircularChartExport3D",
  useValue: CircularChartExport3D
};
var CircularChart3DAllModule = class {
};
CircularChart3DAllModule.ɵfac = function CircularChart3DAllModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || CircularChart3DAllModule)();
};
CircularChart3DAllModule.ɵmod = ɵɵdefineNgModule({
  type: CircularChart3DAllModule,
  imports: [CommonModule, CircularChart3DModule],
  exports: [CircularChart3DModule]
});
CircularChart3DAllModule.ɵinj = ɵɵdefineInjector({
  providers: [PieSeries3DService, CircularChartTooltip3DService, CircularChartLegend3DService, CircularChartSelection3DService, CircularChartDataLabel3DService, CircularChartHighlight3DService, CircularChartExport3DService],
  imports: [[CommonModule, CircularChart3DModule], CircularChart3DModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CircularChart3DAllModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, CircularChart3DModule],
      exports: [CircularChart3DModule],
      providers: [PieSeries3DService, CircularChartTooltip3DService, CircularChartLegend3DService, CircularChartSelection3DService, CircularChartDataLabel3DService, CircularChartHighlight3DService, CircularChartExport3DService]
    }]
  }], null, null);
})();
export {
  AccPointData,
  AccPoints,
  Accessibility,
  AccumulationAnnotation,
  AccumulationAnnotationDirective,
  AccumulationAnnotationService,
  AccumulationAnnotationSettings,
  AccumulationAnnotationsDirective,
  AccumulationChart,
  AccumulationChartAllModule,
  AccumulationChartComponent,
  AccumulationChartModule,
  AccumulationDataLabel,
  AccumulationDataLabelService,
  AccumulationDataLabelSettings,
  AccumulationDistributionIndicator,
  AccumulationDistributionIndicatorService,
  AccumulationHighlight,
  AccumulationHighlightService,
  AccumulationLegend,
  AccumulationLegendService,
  AccumulationSelection,
  AccumulationSelectionService,
  AccumulationSeries,
  AccumulationSeriesCollectionDirective,
  AccumulationSeriesDirective,
  AccumulationTooltip,
  AccumulationTooltipService,
  Animation,
  AnnotationDirective,
  AnnotationsDirective,
  AreaSeries,
  AreaSeriesService,
  AtrIndicator,
  AtrIndicatorService,
  AxesDirective,
  Axis,
  AxisDirective,
  AxisLine,
  AxisRenderer,
  AxisSettings,
  BarSeries,
  BarSeries3D,
  BarSeries3DService,
  BarSeriesService,
  BinaryTreeBuilder,
  BollingerBands,
  BollingerBandsService,
  Border,
  BoxAndWhiskerSeries,
  BoxAndWhiskerSeriesService,
  BubbleSeries,
  BubbleSeriesService,
  BulletChart,
  BulletChartAllModule,
  BulletChartComponent,
  BulletChartLegend,
  BulletChartLegendService,
  BulletChartLegendSettings,
  BulletChartModule,
  BulletDataLabel,
  BulletLabelStyle,
  BulletRangeCollectionDirective,
  BulletRangeDirective,
  BulletTooltip,
  BulletTooltipService,
  BulletTooltipSettings,
  CandleSeries,
  CandleSeriesService,
  CartesianAxisLayoutPanel,
  CategoriesDirective,
  Category,
  Category3D,
  Category3DService,
  CategoryDirective,
  CategoryService,
  CenterLabel,
  Chart,
  Chart3D,
  Chart3DAllModule,
  Chart3DAxesDirective,
  Chart3DAxis,
  Chart3DAxisDirective,
  Chart3DColumn,
  Chart3DColumnDirective,
  Chart3DColumnsDirective,
  Chart3DComponent,
  Chart3DDataLabelSettings,
  Chart3DEmptyPointSettings,
  Chart3DLegendSettings,
  Chart3DMajorGridLines,
  Chart3DMajorTickLines,
  Chart3DMinorGridLines,
  Chart3DMinorTickLines,
  Chart3DModule,
  Chart3DPoint,
  Chart3DRender,
  Chart3DRow,
  Chart3DRowDirective,
  Chart3DRowsDirective,
  Chart3DSelectedDataIndexDirective,
  Chart3DSelectedDataIndexesDirective,
  Chart3DSeries,
  Chart3DSeriesCollectionDirective,
  Chart3DSeriesDirective,
  Chart3DTextFont,
  Chart3DTooltipSettings,
  ChartAllModule,
  ChartAnnotation,
  ChartAnnotationService,
  ChartAnnotationSettings,
  ChartArea,
  ChartComponent,
  ChartLocation,
  ChartModule,
  ChartSegment,
  ChartTransform3D,
  CircleOption,
  CircularChart3D,
  CircularChart3DAllModule,
  CircularChart3DComponent,
  CircularChart3DConnector,
  CircularChart3DDataLabelFont,
  CircularChart3DDataLabelSettings,
  CircularChart3DEmptyPointSettings,
  CircularChart3DLegendSettings,
  CircularChart3DModule,
  CircularChart3DPointData,
  CircularChart3DPoints,
  CircularChart3DSelectedDataIndexDirective,
  CircularChart3DSelectedDataIndexesDirective,
  CircularChart3DSeries,
  CircularChart3DSeriesCollectionDirective,
  CircularChart3DSeriesDirective,
  CircularChart3DTooltipSettings,
  CircularChartDataLabel3D,
  CircularChartDataLabel3DService,
  CircularChartExport3D,
  CircularChartExport3DService,
  CircularChartHighlight3D,
  CircularChartHighlight3DService,
  CircularChartLegend3D,
  CircularChartLegend3DService,
  CircularChartSelection3D,
  CircularChartSelection3DService,
  CircularChartTooltip3D,
  CircularChartTooltip3DService,
  ClosestPoint,
  CoefficientToVector,
  ColorValue,
  Column,
  ColumnDirective,
  ColumnSeries,
  ColumnSeries3D,
  ColumnSeries3DService,
  ColumnSeriesService,
  ColumnsDirective,
  Connector,
  ContainerArea,
  ContainerPadding,
  ControlPoints,
  CornerRadius,
  Crosshair,
  CrosshairService,
  CrosshairSettings,
  CrosshairTooltip,
  CustomizeOption,
  DataEditing,
  DataEditingService,
  DataLabel,
  DataLabel3D,
  DataLabel3DService,
  DataLabelService,
  DataLabelSettings,
  DataLabelTextOptions,
  DataPoint,
  DateTime,
  DateTime3D,
  DateTime3DService,
  DateTimeCategory,
  DateTimeCategory3D,
  DateTimeCategory3DService,
  DateTimeCategoryService,
  DateTimeService,
  Direction,
  Double,
  Double3D,
  DragSettings,
  EmaIndicator,
  EmaIndicatorService,
  EmptyPointSettings,
  ErrorBar,
  ErrorBarCapSettings,
  ErrorBarService,
  ErrorBarSettings,
  Export,
  Export3D,
  Export3DService,
  ExportService,
  Font,
  FunnelSeries,
  FunnelSeriesService,
  Graphics3D,
  GridArcPoints,
  Highlight,
  Highlight3D,
  Highlight3DService,
  HighlightService,
  HiloOpenCloseSeries,
  HiloOpenCloseSeriesService,
  HiloSeries,
  HiloSeriesService,
  HistogramSeries,
  HistogramSeriesService,
  HorizontalLabelCollection,
  ImageOption,
  Index,
  Indexes,
  IndicatorDirective,
  IndicatorsDirective,
  LabelBorder,
  LabelCollection,
  LabelLocation,
  LabelOffset,
  LabelOption,
  LabelRegion,
  Legend,
  Legend3D,
  Legend3DService,
  LegendBorder,
  LegendItemStyle,
  LegendItemStyleBorder,
  LegendLocation,
  LegendSeries,
  LegendService,
  LegendTitle,
  LineSegment,
  LineSeries,
  LineSeriesService,
  LineSettings,
  Location,
  Logarithmic,
  Logarithmic3D,
  Logarithmic3DService,
  LogarithmicService,
  MacdIndicator,
  MacdIndicatorService,
  MajorGridLines,
  MajorTickLines,
  MajorTickLinesSettings,
  Margin,
  MarkerOptions,
  MarkerSettings,
  Matrix3D,
  Mean,
  MinorGridLines,
  MinorTickLines,
  MinorTickLinesSettings,
  MomentumIndicator,
  MomentumIndicatorService,
  MultiColoredAreaSeries,
  MultiColoredAreaSeriesService,
  MultiColoredLineSeries,
  MultiColoredLineSeriesService,
  MultiColoredSeries,
  MultiLevelCategories,
  MultiLevelLabel,
  MultiLevelLabelDirective,
  MultiLevelLabelService,
  MultiLevelLabels,
  MultiLevelLabelsDirective,
  NiceInterval,
  NiceIntervals,
  Offset,
  Padding,
  ParetoOptions,
  ParetoSeries,
  ParetoSeriesService,
  PeriodSelector,
  PeriodSelectorService,
  PeriodSelectorSettings,
  Periods,
  PieCenter,
  PieSeries,
  PieSeries3D,
  PieSeries3DService,
  PieSeriesService,
  Point,
  Point3D,
  PointData,
  PointRegion,
  Points,
  PolarArc,
  PolarSeries,
  PolarSeriesService,
  Polygon3D,
  PolygonOption,
  PyramidSeries,
  PyramidSeriesService,
  RadarSeries,
  RadarSeriesService,
  RadialLabelCollections,
  Range,
  RangeAreaSeries,
  RangeAreaSeriesService,
  RangeBandSettingDirective,
  RangeBandSettings,
  RangeBandSettingsDirective,
  RangeColorSetting,
  RangeColorSettingDirective,
  RangeColorSettingsDirective,
  RangeColumnSeries,
  RangeColumnSeriesService,
  RangeNavigator,
  RangeNavigatorAllModule,
  RangeNavigatorAxis,
  RangeNavigatorComponent,
  RangeNavigatorModule,
  RangeNavigatorSeries,
  RangeSeries,
  RangeSlider,
  RangeStepAreaSeries,
  RangeStepAreaSeriesService,
  RangeTooltip,
  RangeTooltipService,
  RangeTooltipSettings,
  RangenavigatorSeriesCollectionDirective,
  RangenavigatorSeriesDirective,
  RectOption,
  Row,
  RowDirective,
  RowsDirective,
  RsiIndicator,
  RsiIndicatorService,
  ScatterSeries,
  ScatterSeriesService,
  ScrollBar,
  ScrollBarService,
  ScrollbarSettings,
  ScrollbarSettingsRange,
  SegmentDirective,
  SegmentsDirective,
  SelectedDataIndexDirective,
  SelectedDataIndexesDirective,
  Selection,
  Selection3D,
  Selection3DService,
  SelectionService,
  Series,
  SeriesAccessibility,
  SeriesBase,
  SeriesCollectionDirective,
  SeriesDirective,
  SeriesMarker,
  SeriesMarkerBorder,
  SeriesMarkerDataLabel,
  SeriesMarkerDataLabelBorder,
  SeriesMarkerDataLabelConnectorLine,
  SeriesTooltip,
  SeriesTooltipBorder,
  SmaIndicator,
  SmaIndicatorService,
  Smithchart,
  SmithchartAllModule,
  SmithchartAxis,
  SmithchartAxisLine,
  SmithchartBorder,
  SmithchartComponent,
  SmithchartFont,
  SmithchartLabelPosition,
  SmithchartLegend,
  SmithchartLegendService,
  SmithchartLegendSettings,
  SmithchartMajorGridLines,
  SmithchartMargin,
  SmithchartMinorGridLines,
  SmithchartModule,
  SmithchartRect,
  SmithchartSeries,
  SmithchartSeriesCollectionDirective,
  SmithchartSeriesDirective,
  SmithchartSize,
  Sparkline,
  SparklineAllModule,
  SparklineBorder,
  SparklineComponent,
  SparklineDataLabelSettings,
  SparklineFont,
  SparklineMarkerSettings,
  SparklineModule,
  SparklineTooltip,
  SparklineTooltipService,
  SparklineTooltipSettings,
  SplineAreaSeries,
  SplineAreaSeriesService,
  SplineRangeAreaSeries,
  SplineRangeAreaSeriesService,
  SplineSeries,
  SplineSeriesService,
  StackLabelSettings,
  StackLabelsFont,
  StackValues,
  StackingAreaSeries,
  StackingAreaSeriesService,
  StackingBarSeries,
  StackingBarSeries3D,
  StackingBarSeries3DService,
  StackingBarSeriesService,
  StackingColumnSeries,
  StackingColumnSeries3D,
  StackingColumnSeries3DService,
  StackingColumnSeriesService,
  StackingLineSeries,
  StackingLineSeriesService,
  StackingStepAreaSeries,
  StackingStepAreaSeriesService,
  StepAreaSeries,
  StepAreaSeriesService,
  StepLineSeries,
  StepLineSeriesService,
  StochasticIndicator,
  StochasticIndicatorService,
  StockChart,
  StockChartAllModule,
  StockChartAnnotationDirective,
  StockChartAnnotationSettings,
  StockChartAnnotationsDirective,
  StockChartArea,
  StockChartAxesDirective,
  StockChartAxis,
  StockChartAxisDirective,
  StockChartBorder,
  StockChartComponent,
  StockChartConnector,
  StockChartFont,
  StockChartIndexes,
  StockChartIndicator,
  StockChartIndicatorDirective,
  StockChartIndicatorsDirective,
  StockChartLegendSettings,
  StockChartModule,
  StockChartPeriodDirective,
  StockChartPeriodsDirective,
  StockChartRow,
  StockChartRowDirective,
  StockChartRowsDirective,
  StockChartSelectedDataIndexDirective,
  StockChartSelectedDataIndexesDirective,
  StockChartSeriesCollectionDirective,
  StockChartSeriesDirective,
  StockChartStripLineSettings,
  StockChartTrendline,
  StockChartTrendlineDirective,
  StockChartTrendlinesDirective,
  StockEmptyPointSettings,
  StockEventDirective,
  StockEventsDirective,
  StockEventsSettings,
  StockLegend,
  StockLegendService,
  StockMargin,
  StockSeries,
  StockTooltipSettings,
  StripLine,
  StripLineDirective,
  StripLineService,
  StripLineSettings,
  StripLinesDirective,
  StyleSettings,
  Subtitle,
  Svg3DRenderer,
  TechnicalIndicator,
  Thickness,
  ThumbSettings,
  Title,
  TitleBorder,
  TitleSettings,
  TitleStyleSettings,
  TmaIndicator,
  TmaIndicatorService,
  ToolbarPosition,
  Tooltip,
  Tooltip3D,
  Tooltip3DService,
  TooltipRender,
  TooltipRenderService,
  TooltipService,
  TooltipSettings,
  TrackLineSettings,
  TransformToVisible,
  Trendline,
  TrendlineDirective,
  Trendlines,
  TrendlinesDirective,
  TrendlinesService,
  Vector3D,
  Visible3DLabels,
  VisibleLabels,
  WallRenderer,
  WaterfallSeries,
  WaterfallSeriesService,
  Zoom,
  ZoomService,
  ZoomSettings,
  accReactTemplate,
  afterExport,
  animateAddPoints,
  animateRectElement,
  animateRedrawElement,
  animateTextElement,
  animationComplete,
  annotationRender,
  appendChildElement,
  appendClipElement,
  appendElement,
  applyZLight,
  axisLabelClick,
  axisLabelRender,
  axisMultiLabelRender,
  axisRangeCalculated,
  beforeExport,
  beforePrint,
  beforeResize,
  blazorTemplatesReset,
  bulletChartMouseClick,
  calculateLegendShapes,
  calculateRect,
  calculateScrollbarOffset,
  calculateShapes,
  calculateSize,
  chartDoubleClick,
  chartMouseClick,
  chartMouseDown,
  chartMouseLeave,
  chartMouseMove,
  chartMouseUp,
  chartReactTemplate,
  checkBounds,
  checkColorFormat,
  colorNameToHex,
  componentToHex,
  containsRect,
  convertHexToColor,
  convertToHexCode,
  createSvg,
  createTemplate,
  createTooltip,
  createZoomingLabels,
  degreeToLocation,
  degreeToRadian,
  drag,
  dragComplete,
  dragEnd,
  dragStart,
  drawSymbol,
  findClipRect,
  findCrosshairDirection,
  findlElement,
  firstToLowerCase,
  get3DSeriesColor,
  get3DThemeColor,
  getActualDesiredIntervalsCount,
  getAngle,
  getAnimationFunction,
  getBulletThemeColor,
  getColorByValue,
  getDraggedRectLocation,
  getElement,
  getExactData,
  getFontStyle,
  getGradientColor,
  getLabelText,
  getMedian,
  getMinPointsDelta,
  getMinPointsDeltaValue,
  getNearestValue,
  getPercentage,
  getPercentageColor,
  getPoint,
  getRangeThemeColor,
  getRangeValueXByPoint,
  getRectLocation,
  getRotatedRectangleCoordinates,
  getSaturationColor,
  getScrollbarThemeColor,
  getSeriesColor,
  getSeriesFromIndex,
  getTemplateFunction,
  getTextAnchor,
  getThemeColor,
  getTitle,
  getTransform,
  getUnicodeText,
  getValueXByPoint,
  getValueYByPoint,
  getVisiblePoints,
  getXLocation,
  indexFinder,
  inside,
  isBreakLabel,
  isCollide,
  isOverlap,
  isRotatedRectIntersect,
  isZoomSet,
  legendClick,
  legendRender,
  lineBreakLabelTrim,
  linear,
  load,
  loaded,
  logBase,
  logWithIn,
  markerAnimate,
  measureElementRect,
  minMax,
  multiLevelLabelClick,
  onZooming,
  pathAnimation,
  pointByIndex,
  pointClick,
  pointDoubleClick,
  pointMove,
  pointRender,
  rangeValueToCoefficient,
  redrawElement,
  regSub,
  regSup,
  removeElement,
  resized,
  rotateTextSize,
  scrollChanged,
  scrollEnd,
  scrollStart,
  selectionComplete,
  seriesRender,
  setRange,
  sharedTooltipRender,
  showTooltip,
  smithchartBeforePrint,
  sort,
  stockEventFont,
  stockEventRender,
  stopTimer,
  stringToNumber,
  subArray,
  subArraySum,
  subtractRect,
  subtractThickness,
  sum,
  templateAnimate,
  textElement,
  textRender,
  textTrim,
  textWrap,
  textWrapAnyWhere,
  titleBorder,
  titlePositionX,
  titleSettings,
  tooltipRender,
  triggerLabelRender,
  valueToCoefficient,
  valueToCoefficients,
  valueToPolarCoefficient,
  withIn,
  withInBounds,
  withInRange,
  zoomComplete
};
//# sourceMappingURL=@syncfusion_ej2-angular-charts.js.map
