import {
  CanvasRenderer,
  PathOption,
  Rect,
  Size,
  SvgRenderer,
  TextOption,
  Tooltip,
  getElement,
  measureText,
  removeElement,
  textElement
} from "./chunk-JYQ5LDSI.js";
import {
  DataManager,
  DataUtil,
  DateRangePicker,
  Deferred,
  DropDownButton,
  PdfBitmap,
  PdfColor,
  PdfDocument,
  PdfPageOrientation,
  PdfPageTemplateElement,
  PdfSolidBrush,
  PdfStandardFont,
  Query,
  SizeF,
  Toolbar,
  Workbook
} from "./chunk-LIV5E5HL.js";
import {
  Animation,
  Browser,
  ChildProperty,
  Collection,
  Complex,
  Component,
  Event,
  EventHandler,
  Internationalization,
  L10n,
  NotifyPropertyChanges,
  Property,
  SanitizeHtmlHelper,
  Touch,
  animationMode,
  compile,
  createElement,
  extend,
  getValue,
  isNullOrUndefined,
  merge,
  print,
  remove,
  resetBlazorTemplate,
  setValue,
  updateBlazorTemplate
} from "./chunk-J6KMUI6T.js";

// node_modules/@syncfusion/ej2-charts/src/common/model/base.js
var __extends = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Connector = (
  /** @class */
  function(_super) {
    __extends(Connector2, _super);
    function Connector2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([Property("Line")], Connector2.prototype, "type", void 0);
    __decorate([Property(null)], Connector2.prototype, "color", void 0);
    __decorate([Property(1)], Connector2.prototype, "width", void 0);
    __decorate([Property(null)], Connector2.prototype, "length", void 0);
    __decorate([Property("")], Connector2.prototype, "dashArray", void 0);
    return Connector2;
  }(ChildProperty)
);
var Location = (
  /** @class */
  function(_super) {
    __extends(Location2, _super);
    function Location2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([Property(0)], Location2.prototype, "x", void 0);
    __decorate([Property(0)], Location2.prototype, "y", void 0);
    return Location2;
  }(ChildProperty)
);
var Accessibility = (
  /** @class */
  function(_super) {
    __extends(Accessibility2, _super);
    function Accessibility2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([Property(null)], Accessibility2.prototype, "accessibilityDescription", void 0);
    __decorate([Property(null)], Accessibility2.prototype, "accessibilityRole", void 0);
    __decorate([Property(true)], Accessibility2.prototype, "focusable", void 0);
    __decorate([Property(0)], Accessibility2.prototype, "tabIndex", void 0);
    return Accessibility2;
  }(ChildProperty)
);
var SeriesAccessibility = (
  /** @class */
  function(_super) {
    __extends(SeriesAccessibility2, _super);
    function SeriesAccessibility2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([Property(null)], SeriesAccessibility2.prototype, "accessibilityDescriptionFormat", void 0);
    return SeriesAccessibility2;
  }(Accessibility)
);
var Font = (
  /** @class */
  function(_super) {
    __extends(Font2, _super);
    function Font2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([Property("Normal")], Font2.prototype, "fontStyle", void 0);
    __decorate([Property("16px")], Font2.prototype, "size", void 0);
    __decorate([Property("Normal")], Font2.prototype, "fontWeight", void 0);
    __decorate([Property("")], Font2.prototype, "color", void 0);
    __decorate([Property("Center")], Font2.prototype, "textAlignment", void 0);
    __decorate([Property("Segoe UI")], Font2.prototype, "fontFamily", void 0);
    __decorate([Property(1)], Font2.prototype, "opacity", void 0);
    __decorate([Property("Wrap")], Font2.prototype, "textOverflow", void 0);
    return Font2;
  }(ChildProperty)
);
var StackLabelsFont = (
  /** @class */
  function(_super) {
    __extends(StackLabelsFont2, _super);
    function StackLabelsFont2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([Property("Normal")], StackLabelsFont2.prototype, "fontStyle", void 0);
    __decorate([Property("16px")], StackLabelsFont2.prototype, "size", void 0);
    __decorate([Property("Normal")], StackLabelsFont2.prototype, "fontWeight", void 0);
    __decorate([Property("")], StackLabelsFont2.prototype, "color", void 0);
    __decorate([Property("Center")], StackLabelsFont2.prototype, "textAlignment", void 0);
    __decorate([Property("Segoe UI")], StackLabelsFont2.prototype, "fontFamily", void 0);
    __decorate([Property(1)], StackLabelsFont2.prototype, "opacity", void 0);
    return StackLabelsFont2;
  }(ChildProperty)
);
var CenterLabel = (
  /** @class */
  function(_super) {
    __extends(CenterLabel2, _super);
    function CenterLabel2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([Property(null)], CenterLabel2.prototype, "text", void 0);
    __decorate([Complex({
      fontFamily: null,
      size: "16px",
      fontStyle: "Normal",
      fontWeight: "600",
      color: null
    }, Font)], CenterLabel2.prototype, "textStyle", void 0);
    __decorate([Property(null)], CenterLabel2.prototype, "hoverTextFormat", void 0);
    return CenterLabel2;
  }(ChildProperty)
);
var Border = (
  /** @class */
  function(_super) {
    __extends(Border2, _super);
    function Border2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([Property("")], Border2.prototype, "color", void 0);
    __decorate([Property(1)], Border2.prototype, "width", void 0);
    __decorate([Property("")], Border2.prototype, "dashArray", void 0);
    return Border2;
  }(ChildProperty)
);
var Offset = (
  /** @class */
  function(_super) {
    __extends(Offset2, _super);
    function Offset2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([Property(0)], Offset2.prototype, "x", void 0);
    __decorate([Property(0)], Offset2.prototype, "y", void 0);
    return Offset2;
  }(ChildProperty)
);
var Margin = (
  /** @class */
  function(_super) {
    __extends(Margin2, _super);
    function Margin2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([Property(Browser.isDevice ? 5 : 10)], Margin2.prototype, "left", void 0);
    __decorate([Property(Browser.isDevice ? 5 : 10)], Margin2.prototype, "right", void 0);
    __decorate([Property(Browser.isDevice ? 5 : 10)], Margin2.prototype, "top", void 0);
    __decorate([Property(Browser.isDevice ? 5 : 10)], Margin2.prototype, "bottom", void 0);
    return Margin2;
  }(ChildProperty)
);
var Animation2 = (
  /** @class */
  function(_super) {
    __extends(Animation3, _super);
    function Animation3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([Property(true)], Animation3.prototype, "enable", void 0);
    __decorate([Property(1e3)], Animation3.prototype, "duration", void 0);
    __decorate([Property(0)], Animation3.prototype, "delay", void 0);
    return Animation3;
  }(ChildProperty)
);
var TooltipSettings = (
  /** @class */
  function(_super) {
    __extends(TooltipSettings2, _super);
    function TooltipSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([Property(false)], TooltipSettings2.prototype, "enable", void 0);
    __decorate([Property(true)], TooltipSettings2.prototype, "enableMarker", void 0);
    __decorate([Property(false)], TooltipSettings2.prototype, "shared", void 0);
    __decorate([Property(null)], TooltipSettings2.prototype, "fill", void 0);
    __decorate([Property(null)], TooltipSettings2.prototype, "header", void 0);
    __decorate([Property(null)], TooltipSettings2.prototype, "opacity", void 0);
    __decorate([Complex({
      fontFamily: null,
      size: null,
      fontStyle: "Normal",
      fontWeight: null,
      color: null
    }, Font)], TooltipSettings2.prototype, "textStyle", void 0);
    __decorate([Property(null)], TooltipSettings2.prototype, "format", void 0);
    __decorate([Property(null)], TooltipSettings2.prototype, "template", void 0);
    __decorate([Property(true)], TooltipSettings2.prototype, "enableAnimation", void 0);
    __decorate([Property(300)], TooltipSettings2.prototype, "duration", void 0);
    __decorate([Property(1e3)], TooltipSettings2.prototype, "fadeOutDuration", void 0);
    __decorate([Property("Move")], TooltipSettings2.prototype, "fadeOutMode", void 0);
    __decorate([Property(false)], TooltipSettings2.prototype, "enableTextWrap", void 0);
    __decorate([Property(true)], TooltipSettings2.prototype, "showNearestPoint", void 0);
    __decorate([Complex({
      color: null,
      width: null
    }, Border)], TooltipSettings2.prototype, "border", void 0);
    __decorate([Complex({
      x: null,
      y: null
    }, Location)], TooltipSettings2.prototype, "location", void 0);
    __decorate([Property(false)], TooltipSettings2.prototype, "enableHighlight", void 0);
    __decorate([Property(false)], TooltipSettings2.prototype, "showNearestTooltip", void 0);
    __decorate([Property(true)], TooltipSettings2.prototype, "showHeaderLine", void 0);
    return TooltipSettings2;
  }(ChildProperty)
);
var EmptyPointSettings = (
  /** @class */
  function(_super) {
    __extends(EmptyPointSettings2, _super);
    function EmptyPointSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([Property(null)], EmptyPointSettings2.prototype, "fill", void 0);
    __decorate([Complex({
      color: "",
      width: 0
    }, Border)], EmptyPointSettings2.prototype, "border", void 0);
    __decorate([Property("Gap")], EmptyPointSettings2.prototype, "mode", void 0);
    return EmptyPointSettings2;
  }(ChildProperty)
);
var Indexes = (
  /** @class */
  function(_super) {
    __extends(Indexes2, _super);
    function Indexes2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([Property(0)], Indexes2.prototype, "series", void 0);
    __decorate([Property(0)], Indexes2.prototype, "point", void 0);
    return Indexes2;
  }(ChildProperty)
);
var CornerRadius = (
  /** @class */
  function(_super) {
    __extends(CornerRadius2, _super);
    function CornerRadius2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([Property(0)], CornerRadius2.prototype, "topLeft", void 0);
    __decorate([Property(0)], CornerRadius2.prototype, "topRight", void 0);
    __decorate([Property(0)], CornerRadius2.prototype, "bottomLeft", void 0);
    __decorate([Property(0)], CornerRadius2.prototype, "bottomRight", void 0);
    return CornerRadius2;
  }(ChildProperty)
);
var ContainerPadding = (
  /** @class */
  function(_super) {
    __extends(ContainerPadding2, _super);
    function ContainerPadding2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([Property(0)], ContainerPadding2.prototype, "left", void 0);
    __decorate([Property(0)], ContainerPadding2.prototype, "right", void 0);
    __decorate([Property(0)], ContainerPadding2.prototype, "top", void 0);
    __decorate([Property(0)], ContainerPadding2.prototype, "bottom", void 0);
    return ContainerPadding2;
  }(ChildProperty)
);
var titleBorder = (
  /** @class */
  function(_super) {
    __extends(titleBorder2, _super);
    function titleBorder2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([Property("transparent")], titleBorder2.prototype, "color", void 0);
    __decorate([Property(0)], titleBorder2.prototype, "width", void 0);
    __decorate([Property(0.8)], titleBorder2.prototype, "cornerRadius", void 0);
    return titleBorder2;
  }(ChildProperty)
);
var titleSettings = (
  /** @class */
  function(_super) {
    __extends(titleSettings2, _super);
    function titleSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([Property("Normal")], titleSettings2.prototype, "fontStyle", void 0);
    __decorate([Property("15px")], titleSettings2.prototype, "size", void 0);
    __decorate([Property("500")], titleSettings2.prototype, "fontWeight", void 0);
    __decorate([Property("")], titleSettings2.prototype, "color", void 0);
    __decorate([Property("Center")], titleSettings2.prototype, "textAlignment", void 0);
    __decorate([Property("Segoe UI")], titleSettings2.prototype, "fontFamily", void 0);
    __decorate([Property(1)], titleSettings2.prototype, "opacity", void 0);
    __decorate([Property("Wrap")], titleSettings2.prototype, "textOverflow", void 0);
    __decorate([Property("Top")], titleSettings2.prototype, "position", void 0);
    __decorate([Property(0)], titleSettings2.prototype, "x", void 0);
    __decorate([Property(0)], titleSettings2.prototype, "y", void 0);
    __decorate([Property("transparent")], titleSettings2.prototype, "background", void 0);
    __decorate([Complex({}, titleBorder)], titleSettings2.prototype, "border", void 0);
    __decorate([Complex({}, Accessibility)], titleSettings2.prototype, "accessibility", void 0);
    return titleSettings2;
  }(ChildProperty)
);
var TitleStyleSettings = (
  /** @class */
  function(_super) {
    __extends(TitleStyleSettings2, _super);
    function TitleStyleSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([Property("Top")], TitleStyleSettings2.prototype, "position", void 0);
    __decorate([Property(0)], TitleStyleSettings2.prototype, "x", void 0);
    __decorate([Property(0)], TitleStyleSettings2.prototype, "y", void 0);
    return TitleStyleSettings2;
  }(Font)
);
var ChartArea = (
  /** @class */
  function(_super) {
    __extends(ChartArea2, _super);
    function ChartArea2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([Complex({}, Border)], ChartArea2.prototype, "border", void 0);
    __decorate([Property("transparent")], ChartArea2.prototype, "background", void 0);
    __decorate([Property(1)], ChartArea2.prototype, "opacity", void 0);
    __decorate([Property(null)], ChartArea2.prototype, "backgroundImage", void 0);
    __decorate([Property(null)], ChartArea2.prototype, "width", void 0);
    __decorate([Complex({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, Margin)], ChartArea2.prototype, "margin", void 0);
    return ChartArea2;
  }(ChildProperty)
);
var DragSettings = (
  /** @class */
  function(_super) {
    __extends(DragSettings2, _super);
    function DragSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([Property(false)], DragSettings2.prototype, "enable", void 0);
    __decorate([Property(null)], DragSettings2.prototype, "minY", void 0);
    __decorate([Property(null)], DragSettings2.prototype, "maxY", void 0);
    __decorate([Property(null)], DragSettings2.prototype, "fill", void 0);
    return DragSettings2;
  }(ChildProperty)
);
var Periods = (
  /** @class */
  function(_super) {
    __extends(Periods2, _super);
    function Periods2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([Property("Years")], Periods2.prototype, "intervalType", void 0);
    __decorate([Property(1)], Periods2.prototype, "interval", void 0);
    __decorate([Property(null)], Periods2.prototype, "text", void 0);
    __decorate([Property(false)], Periods2.prototype, "selected", void 0);
    return Periods2;
  }(ChildProperty)
);
var PeriodSelectorSettings = (
  /** @class */
  function(_super) {
    __extends(PeriodSelectorSettings2, _super);
    function PeriodSelectorSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([Property(43)], PeriodSelectorSettings2.prototype, "height", void 0);
    __decorate([Property("Bottom")], PeriodSelectorSettings2.prototype, "position", void 0);
    __decorate([Collection([], Periods)], PeriodSelectorSettings2.prototype, "periods", void 0);
    return PeriodSelectorSettings2;
  }(ChildProperty)
);
var StockTooltipSettings = (
  /** @class */
  function(_super) {
    __extends(StockTooltipSettings2, _super);
    function StockTooltipSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([Property(false)], StockTooltipSettings2.prototype, "enable", void 0);
    __decorate([Property(true)], StockTooltipSettings2.prototype, "enableMarker", void 0);
    __decorate([Property(false)], StockTooltipSettings2.prototype, "shared", void 0);
    __decorate([Property(null)], StockTooltipSettings2.prototype, "fill", void 0);
    __decorate([Property(null)], StockTooltipSettings2.prototype, "header", void 0);
    __decorate([Property(0.75)], StockTooltipSettings2.prototype, "opacity", void 0);
    __decorate([Complex({
      fontFamily: null,
      size: "12px",
      fontStyle: "Normal",
      fontWeight: null,
      color: null
    }, Font)], StockTooltipSettings2.prototype, "textStyle", void 0);
    __decorate([Property(null)], StockTooltipSettings2.prototype, "format", void 0);
    __decorate([Property(null)], StockTooltipSettings2.prototype, "template", void 0);
    __decorate([Property(true)], StockTooltipSettings2.prototype, "enableAnimation", void 0);
    __decorate([Property(300)], StockTooltipSettings2.prototype, "duration", void 0);
    __decorate([Property(1e3)], StockTooltipSettings2.prototype, "fadeOutDuration", void 0);
    __decorate([Property("Move")], StockTooltipSettings2.prototype, "fadeOutMode", void 0);
    __decorate([Property(false)], StockTooltipSettings2.prototype, "enableTextWrap", void 0);
    __decorate([Property(true)], StockTooltipSettings2.prototype, "showNearestPoint", void 0);
    __decorate([Complex({
      color: null,
      width: null
    }, Border)], StockTooltipSettings2.prototype, "border", void 0);
    __decorate([Property("Fixed")], StockTooltipSettings2.prototype, "position", void 0);
    __decorate([Property(false)], StockTooltipSettings2.prototype, "showNearestTooltip", void 0);
    __decorate([Property(true)], StockTooltipSettings2.prototype, "showHeaderLine", void 0);
    return StockTooltipSettings2;
  }(ChildProperty)
);
var Index = (
  /** @class */
  /* @__PURE__ */ function() {
    function Index2(seriesIndex, pointIndex) {
      this.series = seriesIndex;
      this.point = pointIndex;
    }
    return Index2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart/utils/double-range.js
var DoubleRange = (
  /** @class */
  function() {
    function DoubleRange3(start, end) {
      if (start < end) {
        this.mStart = start;
        this.mEnd = end;
      } else {
        this.mStart = end;
        this.mEnd = start;
      }
    }
    Object.defineProperty(DoubleRange3.prototype, "start", {
      //private mIsEmpty: boolean;
      /**
       * Gets the start value.
       *
       * @returns {number} - The start value.
       * @private
       */
      get: function() {
        return this.mStart;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DoubleRange3.prototype, "end", {
      /**
       * Gets the end value.
       *
       * @returns {number} - The end value.
       * @private
       */
      get: function() {
        return this.mEnd;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DoubleRange3.prototype, "delta", {
      /*
        get isEmpty(): boolean {
           return this.mIsEmpty;
       }*/
      /**
       * Gets the delta value.
       *
       * @returns {number} - The delta value.
       * @private
       */
      get: function() {
        return this.mEnd - this.mStart;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DoubleRange3.prototype, "median", {
      /**
       * Gets the median value.
       *
       * @returns {number} - The median value.
       * @private
       */
      get: function() {
        return this.mStart + (this.mEnd - this.mStart) / 2;
      },
      enumerable: true,
      configurable: true
    });
    return DoubleRange3;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/common/model/constants.js
var loaded = "loaded";
var legendClick = "legendClick";
var load = "load";
var animationComplete = "animationComplete";
var legendRender = "legendRender";
var textRender = "textRender";
var pointRender = "pointRender";
var sharedTooltipRender = "sharedTooltipRender";
var seriesRender = "seriesRender";
var axisLabelRender = "axisLabelRender";
var axisLabelClick = "axisLabelClick";
var axisRangeCalculated = "axisRangeCalculated";
var axisMultiLabelRender = "axisMultiLabelRender";
var tooltipRender = "tooltipRender";
var chartMouseMove = "chartMouseMove";
var chartMouseClick = "chartMouseClick";
var chartDoubleClick = "chartDoubleClick";
var pointClick = "pointClick";
var pointDoubleClick = "pointDoubleClick";
var pointMove = "pointMove";
var chartMouseLeave = "chartMouseLeave";
var chartMouseDown = "chartMouseDown";
var chartMouseUp = "chartMouseUp";
var zoomComplete = "zoomComplete";
var dragComplete = "dragComplete";
var selectionComplete = "selectionComplete";
var resized = "resized";
var beforeResize = "beforeResize";
var beforePrint = "beforePrint";
var annotationRender = "annotationRender";
var scrollStart = "scrollStart";
var scrollEnd = "scrollEnd";
var scrollChanged = "scrollChanged";
var stockEventRender = "stockEventRender";
var multiLevelLabelClick = "multiLevelLabelClick";
var dragStart = "dragStart";
var drag = "drag";
var dragEnd = "dragEnd";
var regSub = /~\d+~/g;
var regSup = /\^\d+\^/g;
var beforeExport = "beforeExport";
var afterExport = "afterExport";
var bulletChartMouseClick = "bulletChartMouseClick";
var onZooming = "onZooming";

// node_modules/@syncfusion/ej2-charts/src/chart/model/chart-base.js
var __extends2 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ChartAnnotationSettings = (
  /** @class */
  function(_super) {
    __extends2(ChartAnnotationSettings2, _super);
    function ChartAnnotationSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate2([Property("0")], ChartAnnotationSettings2.prototype, "x", void 0);
    __decorate2([Property("0")], ChartAnnotationSettings2.prototype, "y", void 0);
    __decorate2([Property(null)], ChartAnnotationSettings2.prototype, "content", void 0);
    __decorate2([Property("Center")], ChartAnnotationSettings2.prototype, "horizontalAlignment", void 0);
    __decorate2([Property("Pixel")], ChartAnnotationSettings2.prototype, "coordinateUnits", void 0);
    __decorate2([Property("Chart")], ChartAnnotationSettings2.prototype, "region", void 0);
    __decorate2([Property("Middle")], ChartAnnotationSettings2.prototype, "verticalAlignment", void 0);
    __decorate2([Property(null)], ChartAnnotationSettings2.prototype, "xAxisName", void 0);
    __decorate2([Property(null)], ChartAnnotationSettings2.prototype, "yAxisName", void 0);
    __decorate2([Property(null)], ChartAnnotationSettings2.prototype, "description", void 0);
    __decorate2([Complex({}, Accessibility)], ChartAnnotationSettings2.prototype, "accessibility", void 0);
    return ChartAnnotationSettings2;
  }(ChildProperty)
);
var LabelBorder = (
  /** @class */
  function(_super) {
    __extends2(LabelBorder2, _super);
    function LabelBorder2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate2([Property("")], LabelBorder2.prototype, "color", void 0);
    __decorate2([Property(1)], LabelBorder2.prototype, "width", void 0);
    __decorate2([Property("Rectangle")], LabelBorder2.prototype, "type", void 0);
    return LabelBorder2;
  }(ChildProperty)
);
var MultiLevelCategories = (
  /** @class */
  function(_super) {
    __extends2(MultiLevelCategories2, _super);
    function MultiLevelCategories2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate2([Property(null)], MultiLevelCategories2.prototype, "start", void 0);
    __decorate2([Property(null)], MultiLevelCategories2.prototype, "end", void 0);
    __decorate2([Property("")], MultiLevelCategories2.prototype, "text", void 0);
    __decorate2([Property(null)], MultiLevelCategories2.prototype, "maximumTextWidth", void 0);
    __decorate2([Property(null)], MultiLevelCategories2.prototype, "customAttributes", void 0);
    __decorate2([Property("")], MultiLevelCategories2.prototype, "type", void 0);
    return MultiLevelCategories2;
  }(ChildProperty)
);
var StripLineSettings = (
  /** @class */
  function(_super) {
    __extends2(StripLineSettings2, _super);
    function StripLineSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate2([Property(true)], StripLineSettings2.prototype, "visible", void 0);
    __decorate2([Property(false)], StripLineSettings2.prototype, "startFromAxis", void 0);
    __decorate2([Property(null)], StripLineSettings2.prototype, "start", void 0);
    __decorate2([Property(null)], StripLineSettings2.prototype, "end", void 0);
    __decorate2([Property(null)], StripLineSettings2.prototype, "size", void 0);
    __decorate2([Property("#808080")], StripLineSettings2.prototype, "color", void 0);
    __decorate2([Property(null)], StripLineSettings2.prototype, "dashArray", void 0);
    __decorate2([Property("Auto")], StripLineSettings2.prototype, "sizeType", void 0);
    __decorate2([Property(false)], StripLineSettings2.prototype, "isRepeat", void 0);
    __decorate2([Property(null)], StripLineSettings2.prototype, "repeatEvery", void 0);
    __decorate2([Property(null)], StripLineSettings2.prototype, "repeatUntil", void 0);
    __decorate2([Property(false)], StripLineSettings2.prototype, "isSegmented", void 0);
    __decorate2([Property(null)], StripLineSettings2.prototype, "segmentStart", void 0);
    __decorate2([Property(null)], StripLineSettings2.prototype, "segmentEnd", void 0);
    __decorate2([Property(null)], StripLineSettings2.prototype, "segmentAxisName", void 0);
    __decorate2([Complex({
      color: "transparent",
      width: 1
    }, Border)], StripLineSettings2.prototype, "border", void 0);
    __decorate2([Property("")], StripLineSettings2.prototype, "text", void 0);
    __decorate2([Property(null)], StripLineSettings2.prototype, "rotation", void 0);
    __decorate2([Property("Middle")], StripLineSettings2.prototype, "horizontalAlignment", void 0);
    __decorate2([Property("Middle")], StripLineSettings2.prototype, "verticalAlignment", void 0);
    __decorate2([Complex({
      size: "12px",
      color: null,
      fontStyle: "Normal",
      fontWeight: "400",
      fontFamily: null
    }, Font)], StripLineSettings2.prototype, "textStyle", void 0);
    __decorate2([Property("Behind")], StripLineSettings2.prototype, "zIndex", void 0);
    __decorate2([Property(1)], StripLineSettings2.prototype, "opacity", void 0);
    __decorate2([Property("")], StripLineSettings2.prototype, "imageUrl", void 0);
    return StripLineSettings2;
  }(ChildProperty)
);
var MultiLevelLabels = (
  /** @class */
  function(_super) {
    __extends2(MultiLevelLabels2, _super);
    function MultiLevelLabels2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate2([Property("Center")], MultiLevelLabels2.prototype, "alignment", void 0);
    __decorate2([Property("Wrap")], MultiLevelLabels2.prototype, "overflow", void 0);
    __decorate2([Complex({
      fontFamily: null,
      size: "12px",
      fontStyle: "Normal",
      fontWeight: "400",
      color: null
    }, Font)], MultiLevelLabels2.prototype, "textStyle", void 0);
    __decorate2([Complex({
      color: null,
      width: 1,
      type: "Rectangle"
    }, LabelBorder)], MultiLevelLabels2.prototype, "border", void 0);
    __decorate2([Collection([], MultiLevelCategories)], MultiLevelLabels2.prototype, "categories", void 0);
    return MultiLevelLabels2;
  }(ChildProperty)
);
var ScrollbarSettingsRange = (
  /** @class */
  function(_super) {
    __extends2(ScrollbarSettingsRange2, _super);
    function ScrollbarSettingsRange2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate2([Property(null)], ScrollbarSettingsRange2.prototype, "minimum", void 0);
    __decorate2([Property(null)], ScrollbarSettingsRange2.prototype, "maximum", void 0);
    return ScrollbarSettingsRange2;
  }(ChildProperty)
);
var ScrollbarSettings = (
  /** @class */
  function(_super) {
    __extends2(ScrollbarSettings2, _super);
    function ScrollbarSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate2([Property(false)], ScrollbarSettings2.prototype, "enable", void 0);
    __decorate2([Property(null)], ScrollbarSettings2.prototype, "pointsLength", void 0);
    __decorate2([Complex({}, ScrollbarSettingsRange)], ScrollbarSettings2.prototype, "range", void 0);
    __decorate2([Property(null)], ScrollbarSettings2.prototype, "trackColor", void 0);
    __decorate2([Property(0)], ScrollbarSettings2.prototype, "scrollbarRadius", void 0);
    __decorate2([Property(null)], ScrollbarSettings2.prototype, "scrollbarColor", void 0);
    __decorate2([Property(0)], ScrollbarSettings2.prototype, "trackRadius", void 0);
    __decorate2([Property(null)], ScrollbarSettings2.prototype, "gripColor", void 0);
    __decorate2([Property(16)], ScrollbarSettings2.prototype, "height", void 0);
    __decorate2([Property(true)], ScrollbarSettings2.prototype, "enableZoom", void 0);
    __decorate2([Property("PlaceNextToAxisLine")], ScrollbarSettings2.prototype, "position", void 0);
    return ScrollbarSettings2;
  }(ChildProperty)
);
var ToolbarPosition = (
  /** @class */
  function(_super) {
    __extends2(ToolbarPosition2, _super);
    function ToolbarPosition2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate2([Property("Far")], ToolbarPosition2.prototype, "horizontalAlignment", void 0);
    __decorate2([Property("Top")], ToolbarPosition2.prototype, "verticalAlignment", void 0);
    __decorate2([Property(0)], ToolbarPosition2.prototype, "x", void 0);
    __decorate2([Property(0)], ToolbarPosition2.prototype, "y", void 0);
    __decorate2([Property(false)], ToolbarPosition2.prototype, "draggable", void 0);
    return ToolbarPosition2;
  }(ChildProperty)
);
var StackLabelSettings = (
  /** @class */
  function(_super) {
    __extends2(StackLabelSettings2, _super);
    function StackLabelSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate2([Property(false)], StackLabelSettings2.prototype, "visible", void 0);
    __decorate2([Property("transparent")], StackLabelSettings2.prototype, "fill", void 0);
    __decorate2([Property(null)], StackLabelSettings2.prototype, "format", void 0);
    __decorate2([Property(0)], StackLabelSettings2.prototype, "angle", void 0);
    __decorate2([Property(5)], StackLabelSettings2.prototype, "rx", void 0);
    __decorate2([Property(5)], StackLabelSettings2.prototype, "ry", void 0);
    __decorate2([Complex({
      left: 5,
      right: 5,
      top: 5,
      bottom: 5
    }, Margin)], StackLabelSettings2.prototype, "margin", void 0);
    __decorate2([Complex({
      width: null,
      color: null
    }, Border)], StackLabelSettings2.prototype, "border", void 0);
    __decorate2([Complex({
      size: null,
      color: null,
      fontStyle: null,
      fontWeight: "Bold",
      fontFamily: null
    }, StackLabelsFont)], StackLabelSettings2.prototype, "font", void 0);
    return StackLabelSettings2;
  }(ChildProperty)
);

// node_modules/@syncfusion/ej2-charts/src/chart/axis/axis.js
var __extends3 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Row = (
  /** @class */
  function(_super) {
    __extends3(Row2, _super);
    function Row2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.axes = [];
      _this.nearSizes = [];
      _this.farSizes = [];
      _this.insideFarSizes = [];
      _this.insideNearSizes = [];
      return _this;
    }
    Row2.prototype.computeSize = function(axis, scrollBarHeight, definition, chart) {
      var width = 0;
      var innerPadding = 5;
      if (axis.visible && axis.internalVisibility) {
        width += axis.findTickSize(axis.crossInAxis) + (axis.scrollbarSettings.position === "Right" || axis.scrollbarSettings.position === "Left" ? 0 : scrollBarHeight) + axis.findLabelSize(axis.crossInAxis, innerPadding, definition, chart) + axis.lineStyle.width * 0.5;
      }
      if (axis.isAxisOpposedPosition) {
        this.farSizes.push(width);
      } else {
        this.nearSizes.push(width);
      }
    };
    __decorate3([Property("100%")], Row2.prototype, "height", void 0);
    __decorate3([Complex({}, Border)], Row2.prototype, "border", void 0);
    return Row2;
  }(ChildProperty)
);
var Column = (
  /** @class */
  function(_super) {
    __extends3(Column2, _super);
    function Column2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.axes = [];
      _this.nearSizes = [];
      _this.farSizes = [];
      _this.insideFarSizes = [];
      _this.insideNearSizes = [];
      _this.padding = 0;
      return _this;
    }
    Column2.prototype.computeSize = function(axis, scrollBarHeight, definition, chart) {
      var height = 0;
      var innerPadding = 5;
      if (axis.visible && axis.internalVisibility) {
        height += axis.findTickSize(axis.crossInAxis) + (axis.scrollbarSettings.position === "Top" || axis.scrollbarSettings.position === "Bottom" ? 0 : scrollBarHeight) + axis.findLabelSize(axis.crossInAxis, innerPadding, definition, chart) + axis.lineStyle.width * 0.5;
      }
      if (axis.isAxisOpposedPosition) {
        this.farSizes.push(height);
      } else {
        this.nearSizes.push(height);
      }
    };
    __decorate3([Property("100%")], Column2.prototype, "width", void 0);
    __decorate3([Complex({}, Border)], Column2.prototype, "border", void 0);
    return Column2;
  }(ChildProperty)
);
var MajorGridLines = (
  /** @class */
  function(_super) {
    __extends3(MajorGridLines2, _super);
    function MajorGridLines2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate3([Property(1)], MajorGridLines2.prototype, "width", void 0);
    __decorate3([Property("")], MajorGridLines2.prototype, "dashArray", void 0);
    __decorate3([Property(null)], MajorGridLines2.prototype, "color", void 0);
    return MajorGridLines2;
  }(ChildProperty)
);
var MinorGridLines = (
  /** @class */
  function(_super) {
    __extends3(MinorGridLines2, _super);
    function MinorGridLines2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate3([Property(0.7)], MinorGridLines2.prototype, "width", void 0);
    __decorate3([Property("")], MinorGridLines2.prototype, "dashArray", void 0);
    __decorate3([Property(null)], MinorGridLines2.prototype, "color", void 0);
    return MinorGridLines2;
  }(ChildProperty)
);
var AxisLine = (
  /** @class */
  function(_super) {
    __extends3(AxisLine2, _super);
    function AxisLine2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate3([Property(1)], AxisLine2.prototype, "width", void 0);
    __decorate3([Property("")], AxisLine2.prototype, "dashArray", void 0);
    __decorate3([Property(null)], AxisLine2.prototype, "color", void 0);
    return AxisLine2;
  }(ChildProperty)
);
var MajorTickLines = (
  /** @class */
  function(_super) {
    __extends3(MajorTickLines2, _super);
    function MajorTickLines2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate3([Property(1)], MajorTickLines2.prototype, "width", void 0);
    __decorate3([Property(5)], MajorTickLines2.prototype, "height", void 0);
    __decorate3([Property(null)], MajorTickLines2.prototype, "color", void 0);
    return MajorTickLines2;
  }(ChildProperty)
);
var MinorTickLines = (
  /** @class */
  function(_super) {
    __extends3(MinorTickLines2, _super);
    function MinorTickLines2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate3([Property(0.7)], MinorTickLines2.prototype, "width", void 0);
    __decorate3([Property(5)], MinorTickLines2.prototype, "height", void 0);
    __decorate3([Property(null)], MinorTickLines2.prototype, "color", void 0);
    return MinorTickLines2;
  }(ChildProperty)
);
var CrosshairTooltip = (
  /** @class */
  function(_super) {
    __extends3(CrosshairTooltip2, _super);
    function CrosshairTooltip2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate3([Property(false)], CrosshairTooltip2.prototype, "enable", void 0);
    __decorate3([Property(null)], CrosshairTooltip2.prototype, "fill", void 0);
    __decorate3([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, Font)], CrosshairTooltip2.prototype, "textStyle", void 0);
    return CrosshairTooltip2;
  }(ChildProperty)
);
var Axis = (
  /** @class */
  function(_super) {
    __extends3(Axis2, _super);
    function Axis2(parent, propName, defaultValue, isArray) {
      var _this = _super.call(this, parent, propName, defaultValue, isArray) || this;
      _this.visibleLabels = [];
      _this.series = [];
      _this.rect = new Rect(void 0, void 0, 0, 0);
      _this.axisBottomLine = null;
      _this.intervalDivs = [10, 5, 2, 1];
      _this.isStack100 = false;
      _this.crossAt = null;
      _this.updatedRect = null;
      _this.multiLevelLabelHeight = 0;
      _this.isChart = true;
      _this.isIntervalInDecimal = true;
      _this.titleCollection = [];
      _this.titleSize = new Size(0, 0);
      _this.internalVisibility = true;
      _this.isRTLEnabled = false;
      _this.angle = _this.labelRotation;
      return _this;
    }
    Axis2.prototype.findTickSize = function(crossAxis) {
      if (this.tickPosition === "Inside") {
        return 0;
      }
      if (crossAxis && (!crossAxis.visibleRange || this.isInside(crossAxis.visibleRange))) {
        return 0;
      }
      return this.majorTickLines.height;
    };
    Axis2.prototype.isInside = function(range) {
      return inside(this.crossAt, range) || !this.isAxisOpposedPosition && this.crossAt >= range.max || this.isAxisOpposedPosition && this.crossAt <= range.min;
    };
    Axis2.prototype.findLabelSize = function(crossAxis, innerPadding, definition, chart) {
      var titleSize = 0;
      var isHorizontal = this.orientation === "Horizontal";
      if (this.title) {
        var angle = this.titleRotation;
        if (isNullOrUndefined(angle)) {
          this.titleSize = measureText(this.title, this.titleStyle, chart.themeStyle.axisTitleFont);
          titleSize = this.titleSize.height + innerPadding;
        } else {
          this.titleSize = rotateTextSize(this.titleStyle, this.title, angle, chart, chart.themeStyle.axisTitleFont);
          titleSize = (this.orientation === "Vertical" ? this.titleSize.width : this.titleSize.height) + innerPadding;
        }
        if (this.rect.width || this.rect.height) {
          var length_1 = isHorizontal ? this.rect.width : this.rect.height;
          this.titleCollection = getTitle(this.title, this.titleStyle, length_1, chart.enableRtl, chart.themeStyle.axisTitleFont);
          titleSize = titleSize * this.titleCollection.length;
        }
      }
      var diff;
      var value;
      var labelSize = titleSize + innerPadding + this.titlePadding + this.labelPadding + (this.orientation === "Vertical" ? this.maxLabelSize.width : this.maxLabelSize.height) + this.multiLevelLabelHeight;
      if (crossAxis && this.placeNextToAxisLine) {
        var range = crossAxis.visibleRange;
        var size = crossAxis.orientation === "Horizontal" ? crossAxis.rect.width : crossAxis.rect.height;
        if (!range || !size) {
          return 0;
        } else if (this.isInside(range)) {
          value = this.findDifference(crossAxis);
          diff = value * (size / range.delta);
          diff = value * ((size - (diff < labelSize ? labelSize - diff : 0)) / range.delta);
          labelSize = diff < labelSize ? labelSize - diff : 0;
        }
      }
      var titlePadding = this.title !== "" && this.titlePadding !== 5 ? this.titlePadding : 0;
      if (this.isAxisOpposedPosition) {
        definition.insideFarSizes.push(labelSize);
      } else {
        definition.insideNearSizes.push(labelSize);
      }
      if (this.labelPosition === "Inside") {
        if (this.isAxisOpposedPosition && definition.farSizes.length < 1 || !this.isAxisOpposedPosition && definition.nearSizes.length < 1) {
          innerPadding = this.labelPosition === "Inside" && chart.axes.indexOf(this) > -1 ? -5 : 5;
          return titleSize + innerPadding + titlePadding;
        } else {
          return titleSize + innerPadding + titlePadding + this.labelPadding + (this.orientation === "Vertical" ? this.maxLabelSize.width : this.maxLabelSize.height) + this.multiLevelLabelHeight;
        }
      }
      return labelSize;
    };
    Axis2.prototype.updateCrossValue = function() {
      var value = this.crossAt;
      if (value === null || !this.isInside(this.crossInAxis.visibleRange)) {
        this.updatedRect = this.rect;
        return null;
      }
      var range = this.crossInAxis.visibleRange;
      if (!this.isAxisOpposedPosition) {
        if (this.crossAt > range.max) {
          value = range.max;
        }
      } else {
        if (this.crossAt < range.min) {
          value = range.min;
        }
      }
      this.updatedRect = extend({}, this.rect, null, true);
      if (this.orientation === "Horizontal") {
        value = this.crossInAxis.rect.height - valueToCoefficient(value, this.crossInAxis) * this.crossInAxis.rect.height;
        this.updatedRect.y = this.crossInAxis.rect.y + value;
      } else {
        value = valueToCoefficient(value, this.crossInAxis) * this.crossInAxis.rect.width;
        this.updatedRect.x = this.crossInAxis.rect.x + value;
      }
    };
    Axis2.prototype.findDifference = function(crossAxis) {
      var value = 0;
      if (this.isAxisOpposedPosition) {
        value = crossAxis.isAxisInverse ? crossAxis.visibleRange.min : crossAxis.visibleRange.max;
      } else {
        value = crossAxis.isAxisInverse ? crossAxis.visibleRange.max : crossAxis.visibleRange.min;
      }
      return Math.abs(this.crossAt - value);
    };
    Axis2.prototype.calculateVisibleRangeOnZooming = function() {
      if (isZoomSet(this)) {
        var baseRange = this.actualRange;
        var start = void 0;
        var end = void 0;
        if (!this.isAxisInverse) {
          start = this.actualRange.min + this.zoomPosition * this.actualRange.delta;
          end = start + this.zoomFactor * this.actualRange.delta;
        } else {
          start = this.actualRange.max - this.zoomPosition * this.actualRange.delta;
          end = start - this.zoomFactor * this.actualRange.delta;
        }
        if (start < baseRange.min) {
          end = end + (baseRange.min - start);
          start = baseRange.min;
        }
        if (end > baseRange.max) {
          start = start - (end - baseRange.max);
          end = baseRange.max;
        }
        this.doubleRange = new DoubleRange(start, end);
        this.visibleRange = {
          min: this.doubleRange.start,
          max: this.doubleRange.end,
          delta: this.doubleRange.delta,
          interval: this.visibleRange.interval
        };
      }
    };
    Axis2.prototype.triggerRangeRender = function(chart, minimum, maximum, interval) {
      var argsData = {
        cancel: false,
        name: axisRangeCalculated,
        axis: this,
        minimum,
        maximum,
        interval
      };
      chart.trigger(axisRangeCalculated, argsData);
      if (!argsData.cancel) {
        this.visibleRange = {
          min: argsData.minimum,
          max: argsData.maximum,
          interval: argsData.interval,
          delta: argsData.maximum - argsData.minimum
        };
      }
    };
    Axis2.prototype.getRangePadding = function(chart) {
      var padding = this.rangePadding;
      if (padding !== "Auto") {
        return padding;
      }
      switch (this.orientation) {
        case "Horizontal":
          if (chart.requireInvertedAxis) {
            padding = this.isStack100 || this.baseModule.chart.stockChart ? "Round" : "Normal";
          } else {
            padding = "None";
          }
          break;
        case "Vertical":
          if (!chart.requireInvertedAxis) {
            padding = this.isStack100 || this.baseModule.chart.stockChart ? "Round" : "Normal";
          } else {
            padding = "None";
          }
          break;
      }
      return padding;
    };
    Axis2.prototype.getMaxLabelWidth = function(chart) {
      var _this = this;
      var pointX;
      var previousEnd = 0;
      var isIntersect = false;
      var isAxisLabelBreak;
      this.angle = this.labelRotation;
      this.maxLabelSize = new Size(0, 0);
      var action = this.labelIntersectAction;
      var label;
      var _loop_1 = function(i2, len2) {
        label = this_1.visibleLabels[i2];
        isAxisLabelBreak = isBreakLabel(label.originalText);
        if (isAxisLabelBreak) {
          label.size = measureText(label.originalText.replace(/<br>/g, " "), this_1.labelStyle, chart.themeStyle.axisLabelFont);
          label.breakLabelSize = measureText(this_1.enableTrim ? label.text.join("<br>") : label.originalText, this_1.labelStyle, chart.themeStyle.axisLabelFont);
        } else if (this_1.enableWrap) {
          var maximumLabelHeight = chart.initialClipRect.height / this_1.visibleLabels.length;
          label.text = textWrap(label.text, this_1.maximumLabelWidth, this_1.labelStyle, chart.enableRtl, null, null, chart.themeStyle.axisLabelFont, this_1.orientation === "Vertical" ? maximumLabelHeight : null);
          var maxTextWidth_1 = 0;
          var maxTextHeight_1 = 0;
          label.text.forEach(function(textLine) {
            var textSize = measureText(textLine, _this.labelStyle, chart.themeStyle.axisLabelFont);
            maxTextWidth_1 = Math.max(maxTextWidth_1, textSize.width);
            maxTextHeight_1 += textSize.height;
          });
          label.size.width = maxTextWidth_1;
          label.size.height = maxTextHeight_1;
        } else {
          if ((this_1.angle === -90 || this_1.angle === 90 || this_1.angle === 270 || this_1.angle === -270) && this_1.orientation === "Vertical") {
            label.size = rotateTextSize(this_1.labelStyle, label.text, this_1.angle, chart, chart.themeStyle.axisLabelFont);
          } else {
            label.size = measureText(label.text, this_1.labelStyle, chart.themeStyle.axisLabelFont);
          }
        }
        var width = isAxisLabelBreak ? label.breakLabelSize.width : label.size.width;
        if (width > this_1.maxLabelSize.width) {
          this_1.maxLabelSize.width = width;
          this_1.rotatedLabel = label.text;
        }
        var height = isAxisLabelBreak ? label.breakLabelSize.height : label.size.height;
        if (height > this_1.maxLabelSize.height) {
          this_1.maxLabelSize.height = height;
        }
        if (isAxisLabelBreak) {
          label.text = this_1.enableTrim ? label.text : label.originalText.split("<br>");
        }
        if (action === "None" || action === "Hide" || action === "Trim") {
          return "continue";
        }
        if ((action !== "None" || this_1.angle % 360 === 0) && this_1.orientation === "Horizontal" && this_1.rect.width > 0 && !isIntersect) {
          var width1 = isAxisLabelBreak ? label.breakLabelSize.width : label.size.width;
          pointX = valueToCoefficient(label.value, this_1) * this_1.rect.width + this_1.rect.x;
          pointX -= width1 / 2;
          if (this_1.edgeLabelPlacement === "Shift") {
            if (i2 === 0 && pointX < this_1.rect.x) {
              pointX = this_1.rect.x;
            }
            if (i2 === this_1.visibleLabels.length - 1 && pointX + width1 > this_1.rect.x + this_1.rect.width) {
              pointX = this_1.rect.x + this_1.rect.width - width1;
            }
          }
          switch (action) {
            case "MultipleRows":
              if (i2 > 0) {
                this_1.findMultiRows(i2, pointX, label, isAxisLabelBreak);
              }
              break;
            case "Rotate45":
            case "Rotate90":
              if (i2 > 0 && (!this_1.isAxisInverse ? pointX <= previousEnd : pointX + width1 >= previousEnd)) {
                this_1.angle = action === "Rotate45" ? 45 : 90;
                isIntersect = true;
              }
              break;
            default: {
              if (isAxisLabelBreak) {
                var result = void 0;
                var result1 = [];
                var str = void 0;
                for (var index = 0; index < label.text.length; index++) {
                  result = textWrap(label.text[index], this_1.rect.width / this_1.visibleLabels.length, this_1.labelStyle, chart.enableRtl, null, null, chart.themeStyle.axisLabelFont);
                  if (result.length > 1) {
                    for (var j = 0; j < result.length; j++) {
                      str = result[j];
                      result1.push(str);
                    }
                  } else {
                    result1.push(result[0]);
                  }
                }
                label.text = result1;
              } else {
                label.text = textWrap(label.text, this_1.rect.width / this_1.visibleLabels.length, this_1.labelStyle, chart.enableRtl, null, null, chart.themeStyle.axisLabelFont);
              }
              var height_1 = label.size.height * label.text.length;
              if (height_1 > this_1.maxLabelSize.height) {
                this_1.maxLabelSize.height = height_1;
              }
              break;
            }
          }
          previousEnd = this_1.isAxisInverse ? pointX : pointX + width1;
        }
      };
      var this_1 = this;
      for (var i = 0, len = this.visibleLabels.length; i < len; i++) {
        _loop_1(i, len);
      }
      if (this.angle !== 0 && this.orientation === "Horizontal") {
        this.rotatedLabel = isNullOrUndefined(this.rotatedLabel) ? "" : this.rotatedLabel;
        var isHorizontalAngle = this.angle === -360 || this.angle === 0 || this.angle === -180 || this.angle === 180 || this.angle === 360;
        if (this.labelPosition === "Outside" && !isHorizontalAngle && isBreakLabel(this.rotatedLabel)) {
          this.maxLabelSize = new Size(this.maxLabelSize.height, this.maxLabelSize.width);
        } else {
          this.maxLabelSize = rotateTextSize(this.labelStyle, this.rotatedLabel, this.angle, chart, chart.themeStyle.axisLabelFont);
        }
      } else if (this.angle !== 0 && this.orientation === "Vertical") {
        this.rotatedLabel = isNullOrUndefined(this.rotatedLabel) ? "" : this.rotatedLabel;
        var isHorizontalAngle = this.angle === -360 || this.angle === 0 || this.angle === -180 || this.angle === 180 || this.angle === 360;
        if (this.labelPosition === "Outside" && !isHorizontalAngle && isBreakLabel(this.rotatedLabel)) {
          this.maxLabelSize = new Size(this.maxLabelSize.height, this.maxLabelSize.width);
        } else {
          this.maxLabelSize = rotateTextSize(this.labelStyle, this.rotatedLabel, this.angle, chart, chart.themeStyle.axisLabelFont);
        }
      }
      if (chart.multiLevelLabelModule && this.multiLevelLabels.length > 0) {
        chart.multiLevelLabelModule.getMultilevelLabelsHeight(this);
      }
    };
    Axis2.prototype.findMultiRows = function(length, currentX, currentLabel, isBreakLabels) {
      var label;
      var pointX;
      var width2;
      var store = [];
      var isMultiRows;
      for (var i = length - 1; i >= 0; i--) {
        label = this.visibleLabels[i];
        width2 = isBreakLabels ? label.breakLabelSize.width : label.size.width;
        pointX = valueToCoefficient(label.value, this) * this.rect.width + this.rect.x;
        isMultiRows = !this.isAxisInverse ? currentX < pointX + width2 * 0.5 : currentX + currentLabel.size.width > pointX - width2 * 0.5;
        if (isMultiRows) {
          store.push(label.index);
          currentLabel.index = currentLabel.index > label.index ? currentLabel.index : label.index + 1;
        } else {
          currentLabel.index = store.indexOf(label.index) > -1 ? currentLabel.index : label.index;
        }
      }
      var height = (isBreakLabels ? currentLabel.breakLabelSize.height : currentLabel.size.height) * currentLabel.index + 5 * (currentLabel.index - 1);
      if (height > this.maxLabelSize.height) {
        this.maxLabelSize.height = height;
      }
    };
    Axis2.prototype.getModule = function(chart) {
      if (this.valueType === "Double") {
        this.baseModule = new Double(chart);
      } else {
        this.baseModule = chart[firstToLowerCase(this.valueType) + "Module"];
      }
    };
    Axis2.prototype.setIsInversedAndOpposedPosition = function(isPolar) {
      if (isPolar === void 0) {
        isPolar = false;
      }
      this.isAxisOpposedPosition = this.opposedPosition || !isPolar && this.isRTLEnabled && this.orientation === "Vertical";
      if (this.opposedPosition && !isPolar && this.isRTLEnabled && this.orientation === "Vertical") {
        this.isAxisOpposedPosition = false;
      }
      this.isAxisInverse = this.isInversed || this.isRTLEnabled && this.orientation === "Horizontal";
      if (this.isInversed && !isPolar && this.isRTLEnabled && this.orientation === "Horizontal") {
        this.isAxisInverse = false;
      }
    };
    Axis2.prototype.updateAxis = function() {
      var chart = this.baseModule.chart;
      var chartAxisLayoutPanel = chart.chartAxisLayoutPanel;
      var index = chart.axisCollections.indexOf(this);
      var axisElement = getElement2(chart.element.id + "AxisInsideCollection");
      var axisLineElement = getElement2(chart.element.id + "AxisOutsideCollection");
      chartAxisLayoutPanel.element = chart.renderer.createGroup({
        id: chart.element.id + "AxisGroup" + index + "Inside"
      });
      var outsideElement = chart.renderer.createGroup({
        id: chart.element.id + "AxisGroup" + index + "Outside"
      });
      var isInside = chartAxisLayoutPanel.findAxisPosition(this);
      chartAxisLayoutPanel.drawAxis(this, index, isInside, outsideElement, axisElement, axisLineElement);
      if (!chart.enableCanvas) {
        appendChildElement(chart.enableCanvas, axisElement, chartAxisLayoutPanel.element, chart.redraw);
      }
    };
    __decorate3([Complex({
      fontFamily: null,
      size: "12px",
      fontStyle: "Normal",
      fontWeight: "400",
      color: null
    }, Font)], Axis2.prototype, "labelStyle", void 0);
    __decorate3([Complex({}, CrosshairTooltip)], Axis2.prototype, "crosshairTooltip", void 0);
    __decorate3([Property("")], Axis2.prototype, "title", void 0);
    __decorate3([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, Font)], Axis2.prototype, "titleStyle", void 0);
    __decorate3([Property("")], Axis2.prototype, "labelFormat", void 0);
    __decorate3([Property("")], Axis2.prototype, "skeleton", void 0);
    __decorate3([Property("DateTime")], Axis2.prototype, "skeletonType", void 0);
    __decorate3([Property("Center")], Axis2.prototype, "lineBreakAlignment", void 0);
    __decorate3([Property(0)], Axis2.prototype, "plotOffset", void 0);
    __decorate3([Property(null)], Axis2.prototype, "plotOffsetLeft", void 0);
    __decorate3([Property(null)], Axis2.prototype, "plotOffsetTop", void 0);
    __decorate3([Property(null)], Axis2.prototype, "plotOffsetRight", void 0);
    __decorate3([Property(null)], Axis2.prototype, "plotOffsetBottom", void 0);
    __decorate3([Property(false)], Axis2.prototype, "isIndexed", void 0);
    __decorate3([Property(10)], Axis2.prototype, "logBase", void 0);
    __decorate3([Property(0)], Axis2.prototype, "columnIndex", void 0);
    __decorate3([Property(0)], Axis2.prototype, "rowIndex", void 0);
    __decorate3([Property(1)], Axis2.prototype, "span", void 0);
    __decorate3([Property(null)], Axis2.prototype, "desiredIntervals", void 0);
    __decorate3([Property(3)], Axis2.prototype, "maximumLabels", void 0);
    __decorate3([Property(1)], Axis2.prototype, "zoomFactor", void 0);
    __decorate3([Property(0)], Axis2.prototype, "zoomPosition", void 0);
    __decorate3([Property(true)], Axis2.prototype, "enableScrollbarOnZooming", void 0);
    __decorate3([Property(false)], Axis2.prototype, "opposedPosition", void 0);
    __decorate3([Property(true)], Axis2.prototype, "enableAutoIntervalOnZooming", void 0);
    __decorate3([Property("Auto")], Axis2.prototype, "rangePadding", void 0);
    __decorate3([Property("Double")], Axis2.prototype, "valueType", void 0);
    __decorate3([Property("Shift")], Axis2.prototype, "edgeLabelPlacement", void 0);
    __decorate3([Property("Auto")], Axis2.prototype, "intervalType", void 0);
    __decorate3([Property("BetweenTicks")], Axis2.prototype, "labelPlacement", void 0);
    __decorate3([Property("Outside")], Axis2.prototype, "tickPosition", void 0);
    __decorate3([Property("Outside")], Axis2.prototype, "labelPosition", void 0);
    __decorate3([Property("")], Axis2.prototype, "name", void 0);
    __decorate3([Property(true)], Axis2.prototype, "visible", void 0);
    __decorate3([Property(0)], Axis2.prototype, "minorTicksPerInterval", void 0);
    __decorate3([Property(0)], Axis2.prototype, "labelRotation", void 0);
    __decorate3([Property(null)], Axis2.prototype, "titleRotation", void 0);
    __decorate3([Property(null)], Axis2.prototype, "crossesAt", void 0);
    __decorate3([Property(true)], Axis2.prototype, "placeNextToAxisLine", void 0);
    __decorate3([Property(null)], Axis2.prototype, "crossesInAxis", void 0);
    __decorate3([Property(null)], Axis2.prototype, "minimum", void 0);
    __decorate3([Property(null)], Axis2.prototype, "maximum", void 0);
    __decorate3([Property(null)], Axis2.prototype, "interval", void 0);
    __decorate3([Property(34)], Axis2.prototype, "maximumLabelWidth", void 0);
    __decorate3([Property(false)], Axis2.prototype, "enableTrim", void 0);
    __decorate3([Property(false)], Axis2.prototype, "enableWrap", void 0);
    __decorate3([Property(5)], Axis2.prototype, "labelPadding", void 0);
    __decorate3([Property(5)], Axis2.prototype, "titlePadding", void 0);
    __decorate3([Complex({}, MajorTickLines)], Axis2.prototype, "majorTickLines", void 0);
    __decorate3([Complex({}, MinorTickLines)], Axis2.prototype, "minorTickLines", void 0);
    __decorate3([Complex({}, MajorGridLines)], Axis2.prototype, "majorGridLines", void 0);
    __decorate3([Complex({}, MinorGridLines)], Axis2.prototype, "minorGridLines", void 0);
    __decorate3([Complex({}, AxisLine)], Axis2.prototype, "lineStyle", void 0);
    __decorate3([Property(Browser.isDevice ? "Rotate45" : "Trim")], Axis2.prototype, "labelIntersectAction", void 0);
    __decorate3([Property(false)], Axis2.prototype, "isInversed", void 0);
    __decorate3([Property(100)], Axis2.prototype, "coefficient", void 0);
    __decorate3([Property(0)], Axis2.prototype, "startAngle", void 0);
    __decorate3([Property(true)], Axis2.prototype, "startFromZero", void 0);
    __decorate3([Property(null)], Axis2.prototype, "description", void 0);
    __decorate3([Property(null)], Axis2.prototype, "intervalOffset", void 0);
    __decorate3([Property(2)], Axis2.prototype, "tabIndex", void 0);
    __decorate3([Collection([], StripLineSettings)], Axis2.prototype, "stripLines", void 0);
    __decorate3([Collection([], MultiLevelLabels)], Axis2.prototype, "multiLevelLabels", void 0);
    __decorate3([Complex({
      color: null,
      width: 0,
      type: "Rectangle"
    }, LabelBorder)], Axis2.prototype, "border", void 0);
    __decorate3([Complex({}, ScrollbarSettings)], Axis2.prototype, "scrollbarSettings", void 0);
    return Axis2;
  }(ChildProperty)
);
var VisibleLabels = (
  /** @class */
  /* @__PURE__ */ function() {
    function VisibleLabels2(text, value, labelStyle, originalText, size, breakLabelSize, index) {
      if (size === void 0) {
        size = new Size(0, 0);
      }
      if (breakLabelSize === void 0) {
        breakLabelSize = new Size(0, 0);
      }
      if (index === void 0) {
        index = 1;
      }
      this.text = text;
      this.originalText = originalText;
      this.value = value;
      this.labelStyle = labelStyle;
      this.size = size;
      this.breakLabelSize = breakLabelSize;
      this.index = index;
    }
    return VisibleLabels2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js
var __extends4 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
function sort(data, fields, isDescending) {
  var sortData = extend([], data, null);
  for (var i = 0; i < sortData.length; i++) {
    for (var j = 0; j < fields.length; j++) {
      if (sortData[i][fields[j]] instanceof Date) {
        sortData[i][fields[j]] = sortData[i][fields[j]].getTime();
      }
    }
  }
  sortData.sort(function(a, b) {
    var first = 0;
    var second = 0;
    for (var i2 = 0; i2 < fields.length; i2++) {
      first += a[fields[i2]];
      second += b[fields[i2]];
    }
    if (!isDescending && first < second || isDescending && first > second) {
      return -1;
    } else if (first === second) {
      return 0;
    }
    return 1;
  });
  return sortData;
}
function isBreakLabel(label) {
  return label.indexOf("<br>") !== -1;
}
function getVisiblePoints(series) {
  var points = extend([], series.points, null, true);
  var tempPoints = [];
  var tempPoint;
  var pointIndex = 0;
  for (var i = 0; i < points.length; i++) {
    tempPoint = points[i];
    if (isNullOrUndefined(tempPoint.x)) {
      continue;
    } else {
      tempPoint.index = pointIndex++;
      tempPoints.push(tempPoint);
    }
  }
  return tempPoints;
}
function calculateScrollbarOffset(scrollbar, isHorizontalAxis) {
  var scrollbarPadding = 5;
  var chart = scrollbar.component;
  var titleHeight = 0;
  var subTitleHeight = 0;
  var titlePadding = chart.titleStyle.position === "Top" || chart.titleStyle.position === "Bottom" && !chart.legendSettings.visible ? 15 : 5;
  if (chart.title) {
    titleHeight = measureText(chart.title, chart.titleStyle, chart.themeStyle.chartTitleFont).height * chart.titleCollection.length + titlePadding;
    if (chart.subTitle) {
      subTitleHeight = measureText(chart.subTitle, chart.subTitleStyle, chart.themeStyle.chartSubTitleFont).height * chart.subTitleCollection.length;
    }
  }
  var scrollbarOffsetValue;
  if (isHorizontalAxis) {
    if (scrollbar.axis.scrollbarSettings.position === "Top") {
      scrollbarOffsetValue = chart.margin.top + scrollbarPadding + (scrollbar.height + scrollbarPadding) * chart.scrollBarModule.topScrollBarCount + (chart.titleStyle.position === "Top" ? titleHeight + chart.titleStyle.border.width : 0) + (chart.subTitleStyle.position === "Top" ? chart.subTitleStyle.border.width + subTitleHeight : 0);
      chart.scrollBarModule.topScrollBarCount++;
    } else if (scrollbar.axis.scrollbarSettings.position === "Bottom") {
      scrollbarOffsetValue = chart.availableSize.height - ((scrollbar.height + scrollbarPadding) * chart.scrollBarModule.bottomScrollBarCount + scrollbar.height + chart.margin.bottom + scrollbarPadding + (chart.titleStyle.position === "Bottom" ? titleHeight + chart.titleStyle.border.width : 0) + (chart.subTitleStyle.position === "Bottom" ? chart.subTitleStyle.border.width + subTitleHeight : 0));
      chart.scrollBarModule.bottomScrollBarCount++;
    }
  } else {
    if (scrollbar.axis.scrollbarSettings.position === "Right") {
      scrollbarOffsetValue = chart.availableSize.width - ((scrollbar.height + scrollbarPadding) * chart.scrollBarModule.rightScrollBarCount + scrollbar.height + scrollbarPadding + chart.margin.right + (chart.titleStyle.position === "Right" ? titleHeight + chart.titleStyle.border.width : 0) + (chart.subTitleStyle.position === "Right" ? chart.subTitleStyle.border.width + subTitleHeight : 0));
      chart.scrollBarModule.rightScrollBarCount++;
    } else if (scrollbar.axis.scrollbarSettings.position === "Left") {
      scrollbarOffsetValue = chart.margin.left + scrollbarPadding + (scrollbar.height + scrollbarPadding) * chart.scrollBarModule.leftScrollBarCount + (chart.titleStyle.position === "Left" ? titleHeight + chart.titleStyle.border.width : 0) + (chart.subTitleStyle.position === "Left" ? chart.subTitleStyle.border.width + subTitleHeight : 0);
      chart.scrollBarModule.leftScrollBarCount++;
    }
  }
  return scrollbarOffsetValue;
}
function rotateTextSize(font, text, angle, chart, themeFontStyle) {
  var transformValue = chart.element.style.transform;
  if (transformValue) {
    chart.element.style.transform = "";
  }
  var renderer = new SvgRenderer(chart.element.id);
  var labelText;
  var textCollection = [];
  var height;
  var dy;
  var label;
  var tspanElement;
  var options = {
    id: "rotate_text",
    x: chart.initialClipRect.x,
    y: chart.initialClipRect.y,
    "font-size": font.size || themeFontStyle.size,
    "font-style": font.fontStyle || themeFontStyle.fontStyle,
    "font-family": font.fontFamily,
    "font-weight": font.fontWeight || themeFontStyle.fontWeight,
    "transform": "rotate(" + angle + ", 0, 0)",
    "text-anchor": "middle"
  };
  if (isBreakLabel(text)) {
    textCollection = text.split("<br>");
    labelText = textCollection[0];
  } else {
    labelText = text;
  }
  var htmlObject = renderer.createText(options, labelText);
  if (!chart.delayRedraw && !chart.redraw && !chart.stockChart) {
    chart.element.appendChild(chart.svgObject);
  }
  if (typeof textCollection !== "string" && textCollection.length > 1) {
    for (var i = 1, len = textCollection.length; i < len; i++) {
      height = measureText(textCollection[i], font, chart.themeStyle.axisLabelFont).height;
      dy = options.y + i * height;
      label = textCollection[i];
      tspanElement = renderer.createTSpan({
        "x": options.x,
        "id": options.id,
        "y": dy
      }, label);
      htmlObject.appendChild(tspanElement);
    }
  }
  var axisSvgObject = chart.svgRenderer.createSvg({
    id: "AxisLabelMax_svg",
    width: chart.availableSize.width,
    height: chart.availableSize.height
  });
  document.body.appendChild(axisSvgObject);
  axisSvgObject.appendChild(htmlObject);
  var box = htmlObject.getBoundingClientRect();
  if (transformValue) {
    chart.element.style.transform = transformValue;
  }
  remove(axisSvgObject);
  if (!chart.delayRedraw && !chart.redraw && !chart.stockChart && !chart.pointsAdded) {
    remove(chart.svgObject);
  }
  if (chart.enableCanvas) {
    var textWidth = measureText(text, font, chart.themeStyle.axisLabelFont).width;
    var textHeight = measureText(text, font, chart.themeStyle.axisLabelFont).height;
    var angleInRadians = angle * Math.PI / 180;
    var rotatedTextWidth = Math.abs(Math.cos(angleInRadians) * textWidth) + Math.abs(Math.sin(angleInRadians) * textHeight);
    var rotatedTextHeight = Math.abs(Math.sin(angleInRadians) * textWidth) + Math.abs(Math.cos(angleInRadians) * textHeight);
    return new Size(rotatedTextWidth, rotatedTextHeight);
  }
  return new Size(box.right - box.left, box.bottom - box.top);
}
function removeElement2(id) {
  if (!id) {
    return null;
  }
  var element = typeof id === "string" ? getElement2(id) : id;
  if (element) {
    remove(element);
  }
}
function logBase(value, base) {
  return Math.log(value) / Math.log(base);
}
function showTooltip(text, x, y, areaWidth, id, element, isTouch, isTitleOrLegendEnabled, bound) {
  var tooltip = document.getElementById(id);
  var size = measureText(text, {
    fontFamily: "Segoe UI",
    size: "12px",
    fontStyle: "Normal",
    fontWeight: "Regular"
  });
  var width = size.width + 5;
  x = x + width > areaWidth ? x - (width + 15) : x;
  if (bound && x < bound.x) {
    x = bound.x;
  }
  y = isTitleOrLegendEnabled ? y - size.height / 2 : y + 15;
  if (!tooltip) {
    tooltip = createElement("div", {
      id,
      styles: "top:" + y.toString() + "px;left:" + (x + 15).toString() + 'px;background-color: rgb(255, 255, 255) !important; color:black !important; position:absolute;border:1px solid rgb(112, 112, 112); padding-left : 3px; padding-right : 2px;padding-bottom : 2px; padding-top : 2px; font-size:12px; font-family: "Segoe UI"'
    });
    tooltip.innerText = text;
    element.appendChild(tooltip);
    var left = parseInt(tooltip.style.left.replace("px", ""), 10);
    if (left < 0) {
      tooltip.style.left = "0px";
    }
  } else {
    tooltip.innerText = text;
    tooltip.style.top = y.toString() + "px";
    tooltip.style.left = (x + 15).toString() + "px";
  }
  if (isTouch) {
    setTimeout(function() {
      removeElement2(id);
    }, 1500);
  }
}
function inside(value, range) {
  return value < range.max && value > range.min;
}
function withIn(value, range) {
  return value <= range.max && value >= range.min;
}
function logWithIn(value, axis) {
  return axis.valueType === "Logarithmic" ? logBase(value, axis.logBase) : value;
}
function withInRange(previousPoint, currentPoint, nextPoint, series) {
  if (series.chart.zoomModule && series.chart.zoomSettings.enableAnimation) {
    return true;
  }
  var mX2 = logWithIn(currentPoint.xValue, series.xAxis);
  var mX1 = previousPoint ? logWithIn(previousPoint.xValue, series.xAxis) : mX2;
  var mX3 = nextPoint ? logWithIn(nextPoint.xValue, series.xAxis) : mX2;
  var xStart = Math.floor(series.xAxis.visibleRange.min);
  var xEnd = Math.ceil(series.xAxis.visibleRange.max);
  return mX1 >= xStart && mX1 <= xEnd || mX2 >= xStart && mX2 <= xEnd || mX3 >= xStart && mX3 <= xEnd || xStart >= mX1 && xStart <= mX3;
}
function sum(values) {
  var sum2 = 0;
  for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
    var value = values_1[_i];
    sum2 += value;
  }
  return sum2;
}
function subArraySum(values, first, last, index, series) {
  var sum2 = 0;
  var sumIndex = 0;
  var isFirst = true;
  if (index !== null) {
    for (var i = first + 1; i < last; i++) {
      if (index.indexOf(i) === -1 && (i === series.intermediateSumIndexes[sumIndex] || series.intermediateSumIndexes[series.intermediateSumIndexes.length - 1] < i)) {
        sum2 += values[i][series.yName];
        if (i === series.intermediateSumIndexes[sumIndex]) {
          isFirst = false;
          sumIndex += 1;
        }
      }
    }
  } else {
    for (var i = first + 1; i < last; i++) {
      if (!isNullOrUndefined(values[i][series.yName]) && !isNullOrUndefined(series.sumIndexes) && series.sumIndexes.indexOf(i) === -1) {
        sum2 += values[i][series.yName];
      }
    }
  }
  return sum2;
}
function subtractThickness(rect, thickness) {
  rect.x += thickness.left;
  rect.y += thickness.top;
  rect.width -= thickness.left + thickness.right;
  rect.height -= thickness.top + thickness.bottom;
  return rect;
}
function subtractRect(rect, thickness) {
  rect.x += thickness.x;
  rect.y += thickness.y;
  rect.width -= thickness.x + thickness.width;
  rect.height -= thickness.y + thickness.height;
  return rect;
}
function degreeToLocation(degree, radius, center) {
  var radian = degree * Math.PI / 180;
  return new ChartLocation(Math.cos(radian) * radius + center.x, Math.sin(radian) * radius + center.y);
}
function degreeToRadian(degree) {
  return degree * (Math.PI / 180);
}
function getRotatedRectangleCoordinates(actualPoints, centerX, centerY, angle) {
  var coordinatesAfterRotation = [];
  for (var i = 0; i < 4; i++) {
    var point = actualPoints[i];
    var tempX = point.x - centerX;
    var tempY = point.y - centerY;
    var rotatedX = tempX * Math.cos(degreeToRadian(angle)) - tempY * Math.sin(degreeToRadian(angle));
    var rotatedY = tempX * Math.sin(degreeToRadian(angle)) + tempY * Math.cos(degreeToRadian(angle));
    point.x = rotatedX + centerX;
    point.y = rotatedY + centerY;
    coordinatesAfterRotation.push(new ChartLocation(point.x, point.y));
  }
  return coordinatesAfterRotation;
}
function isRotatedRectIntersect(a, b) {
  var polygons = [a, b];
  var minA;
  var maxA;
  var projected;
  var i;
  var i1;
  var j;
  var minB;
  var maxB;
  for (i = 0; i < polygons.length; i++) {
    var polygon = polygons[i];
    for (i1 = 0; i1 < polygon.length; i1++) {
      var i2 = (i1 + 1) % polygon.length;
      var p1 = polygon[i1];
      var p2 = polygon[i2];
      var normal = new ChartLocation(p2.y - p1.y, p1.x - p2.x);
      minA = maxA = void 0;
      for (j = 0; j < a.length; j++) {
        projected = normal.x * a[j].x + normal.y * a[j].y;
        if (isNullOrUndefined(minA) || projected < minA) {
          minA = projected;
        }
        if (isNullOrUndefined(maxA) || projected > maxA) {
          maxA = projected;
        }
      }
      minB = maxB = void 0;
      for (j = 0; j < b.length; j++) {
        projected = normal.x * b[j].x + normal.y * b[j].y;
        if (isNullOrUndefined(minB) || projected < minB) {
          minB = projected;
        }
        if (isNullOrUndefined(maxB) || projected > maxB) {
          maxB = projected;
        }
      }
      if (maxA < minB || maxB < minA) {
        return false;
      }
    }
  }
  return true;
}
function getAccumulationLegend(locX, locY, r, height, width) {
  var cartesianlarge = degreeToLocation(270, r, new ChartLocation(locX, locY));
  var cartesiansmall = degreeToLocation(270, r, new ChartLocation(locX + width / 10, locY));
  return "M " + locX + " " + locY + " L " + (locX + r) + " " + locY + " A " + r + " " + r + " 0 1 1 " + cartesianlarge.x + " " + cartesianlarge.y + " Z M " + (locX + width / 10) + " " + (locY - height / 10) + " L" + (locX + r) + " " + (locY - height / 10) + " A " + r + " " + r + " 0 0 0 " + cartesiansmall.x + " " + cartesiansmall.y + " Z";
}
function getAngle(center, point) {
  var angle = Math.atan2(point.y - center.y, point.x - center.x);
  angle = angle < 0 ? 6.283 + angle : angle;
  return angle * (180 / Math.PI);
}
function subArray(values, index) {
  var subArray2 = [];
  for (var i = 0; i <= index - 1; i++) {
    subArray2.push(values[i]);
  }
  return subArray2;
}
function valueToCoefficient(value, axis) {
  var range = axis.visibleRange;
  var result = (value - range.min) / range.delta;
  var isInverse = axis.isChart ? axis.isAxisInverse : axis.isInversed;
  return isInverse ? 1 - result : result;
}
function TransformToVisible(x, y, xAxis, yAxis, isInverted, series) {
  x = xAxis.valueType === "Logarithmic" ? logBase(x > 1 ? x : 1, xAxis.logBase) : x;
  y = yAxis.valueType === "Logarithmic" ? logBase(y > 1 ? y : 1, yAxis.logBase) : y;
  x += xAxis.valueType === "Category" && xAxis.labelPlacement === "BetweenTicks" && series.type !== "Radar" ? 0.5 : 0;
  var radius = series.chart.radius * valueToCoefficient(y, yAxis);
  var point = CoefficientToVector(valueToPolarCoefficient(x, xAxis), series.chart.primaryXAxis.startAngle);
  return {
    x: series.clipRect.width / 2 + series.clipRect.x + radius * point.x,
    y: series.clipRect.height / 2 + series.clipRect.y + radius * point.y
  };
}
function indexFinder(id, isPoint) {
  if (isPoint === void 0) {
    isPoint = false;
  }
  var ids = ["NaN", "NaN"];
  if (id.indexOf("_polygon") > -1) {
    ids = ["NaN", "NaN"];
  } else if (id.indexOf("_Point_") > -1) {
    ids = id.split("_Series_")[1].split("_Point_");
  } else if (id.indexOf("_shape_") > -1 && (!isPoint || isPoint && id.indexOf("_legend_") === -1)) {
    ids = id.split("_shape_");
    ids[0] = "0";
  } else if (id.indexOf("_text_") > -1 && (!isPoint || isPoint && id.indexOf("_legend_") === -1)) {
    ids = id.split("_text_");
    ids[0] = "0";
  } else if (id.indexOf("_datalabel_") > -1) {
    ids = id.split("_datalabel_")[1].split("_g_");
    ids[0] = ids[0].replace("Series_", "");
  } else if (id.indexOf("TextGroup") > -1) {
    ids = id.split("TextGroup");
    ids[0] = ids[1];
  } else if (id.indexOf("ShapeGroup") > -1) {
    ids = id.split("ShapeGroup");
    ids[0] = ids[1];
  }
  return new Index(parseInt(ids[0], 10), parseInt(ids[1], 10));
}
function CoefficientToVector(coefficient, startAngle) {
  startAngle = startAngle < 0 ? startAngle + 360 : startAngle;
  var angle = Math.PI * (1.5 - 2 * coefficient);
  angle = angle + startAngle * Math.PI / 180;
  return {
    x: Math.cos(angle),
    y: Math.sin(angle)
  };
}
function valueToPolarCoefficient(value, axis) {
  var range = axis.visibleRange;
  var delta;
  var length;
  if (axis.valueType !== "Category") {
    delta = range.max - (axis.valueType === "DateTime" ? axis.dateTimeInterval : range.interval) - range.min;
    length = axis.visibleLabels.length - 1;
    delta = delta === 0 ? 1 : delta;
  } else {
    delta = axis.visibleLabels.length === 1 ? 1 : axis.visibleLabels[axis.visibleLabels.length - 1].value - axis.visibleLabels[0].value;
    length = axis.visibleLabels.length;
  }
  return axis.isAxisInverse ? (value - range.min) / delta * (1 - 1 / length) : 1 - (value - range.min) / delta * (1 - 1 / length);
}
var Mean = (
  /** @class */
  /* @__PURE__ */ function() {
    function Mean2(verticalStandardMean, verticalSquareRoot, horizontalStandardMean, horizontalSquareRoot, verticalMean, horizontalMean) {
      this.verticalStandardMean = verticalStandardMean;
      this.horizontalStandardMean = horizontalStandardMean;
      this.verticalSquareRoot = verticalSquareRoot;
      this.horizontalSquareRoot = horizontalSquareRoot;
      this.verticalMean = verticalMean;
      this.horizontalMean = horizontalMean;
    }
    return Mean2;
  }()
);
var PolarArc = (
  /** @class */
  /* @__PURE__ */ function() {
    function PolarArc2(startAngle, endAngle, innerRadius, radius, currentXPosition) {
      this.startAngle = startAngle;
      this.endAngle = endAngle;
      this.innerRadius = innerRadius;
      this.radius = radius;
      this.currentXPosition = currentXPosition;
    }
    return PolarArc2;
  }()
);
function createTooltip(id, text, top, left, fontSize) {
  var tooltip = getElement2(id);
  var style = "top:" + top.toString() + "px;left:" + left.toString() + "px;color:black !important; background:#FFFFFF !important; position:absolute;border:1px solid #707070;font-size:" + fontSize + ";border-radius:2px; z-index:1";
  if (!tooltip) {
    tooltip = createElement("div", {
      id,
      innerHTML: "&nbsp;" + text + "&nbsp;",
      styles: style
    });
    document.body.appendChild(tooltip);
  } else {
    tooltip.setAttribute("innerHTML", "&nbsp;" + text + "&nbsp;");
    tooltip.style.cssText = style;
  }
}
function createZoomingLabels(chart, axis, parent, index, isVertical, rect) {
  var margin = 5;
  var opposedPosition = axis.isAxisOpposedPosition;
  var anchor = chart.enableRtl ? "end" : isVertical ? "start" : "auto";
  var size;
  var chartRect = chart.availableSize.width;
  var pathElement;
  var x;
  var y;
  var rx = 3;
  var arrowLocation;
  var direction;
  var scrollBarHeight = axis.scrollbarSettings.enable || axis.zoomingScrollBar && axis.zoomingScrollBar.svgObject ? axis.scrollBarHeight : 0;
  var isRtlEnabled = chart.enableRtl && !isVertical && !axis.isInversed || axis.isInversed && !(chart.enableRtl && !isVertical);
  for (var i = 0; i < 2; i++) {
    size = measureText(i ? isRtlEnabled ? axis.startLabel : axis.endLabel : isRtlEnabled ? axis.endLabel : axis.startLabel, axis.labelStyle, chart.themeStyle.axisLabelFont);
    if (isVertical) {
      arrowLocation = i ? new ChartLocation(rect.x - scrollBarHeight, rect.y + rx) : new ChartLocation(axis.rect.x - scrollBarHeight, rect.y + rect.height - rx);
      x = rect.x + (opposedPosition ? rect.width + margin + scrollBarHeight : -(size.width + margin + margin + scrollBarHeight));
      y = rect.y + (i ? 0 : rect.height - size.height - margin);
      x += x < 0 || chartRect < x + size.width + margin ? opposedPosition ? -(size.width / 2) : size.width / 2 : 0;
      direction = findCrosshairDirection(rx, rx, new Rect(x, y, size.width + margin, size.height + margin), arrowLocation, margin, false, false, !opposedPosition, arrowLocation.x, arrowLocation.y + (i ? -rx : rx));
    } else {
      arrowLocation = i ? new ChartLocation(rect.x + rect.width - rx, rect.y + rect.height + scrollBarHeight) : new ChartLocation(rect.x + rx, rect.y + rect.height + scrollBarHeight);
      x = rect.x + (i ? rect.width - size.width - margin : 0);
      y = opposedPosition ? rect.y - size.height - 10 - scrollBarHeight : rect.y + rect.height + margin + scrollBarHeight;
      direction = findCrosshairDirection(rx, rx, new Rect(x, y, size.width + margin, size.height + margin), arrowLocation, margin, opposedPosition, !opposedPosition, false, arrowLocation.x + (i ? rx : -rx), arrowLocation.y);
    }
    x = x + margin / 2;
    y = y + 3 * (size.height / 4) + margin / 2;
    pathElement = chart.renderer.drawPath({
      "id": chart.element.id + "_Zoom_" + index + "_AxisLabel_Shape_" + i,
      "fill": chart.themeStyle.crosshairFill,
      "width": 2,
      "color": chart.themeStyle.crosshairFill,
      "opacity": 1,
      "stroke-dasharray": null,
      "d": direction
    }, null);
    parent.appendChild(pathElement);
    if (chart.theme === "Fluent" || chart.theme === "FluentDark") {
      var shadowId = chart.element.id + "_shadow";
      pathElement.setAttribute("filter", Browser.isIE ? "" : "url(#" + shadowId + ")");
      var shadow = '<filter id="' + shadowId + '" height="130%"><feGaussianBlur in="SourceAlpha" stdDeviation="3"/>';
      shadow += '<feOffset dx="3" dy="3" result="offsetblur"/><feComponentTransfer><feFuncA type="linear" slope="0.5"/>';
      shadow += '</feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge></filter>';
      var defElement = chart.renderer.createDefs();
      defElement.setAttribute("id", chart.element.id + "SVG_tooltip_definition");
      parent.appendChild(defElement);
      defElement.innerHTML = shadow;
      pathElement.setAttribute("stroke", "#cccccc");
      pathElement.setAttribute("stroke-width", "0.5");
    }
    textElement2(chart.renderer, new TextOption(chart.element.id + "_Zoom_" + index + "_AxisLabel_" + i, x, y, anchor, i ? isRtlEnabled ? axis.startLabel : axis.endLabel : isRtlEnabled ? axis.endLabel : axis.startLabel), {
      color: chart.themeStyle.crosshairLabelFont.color,
      fontFamily: "Segoe UI",
      fontWeight: "Regular",
      size: "11px"
    }, chart.themeStyle.crosshairLabelFont.color, parent, null, null, null, null, null, null, null, null, null, null, chart.themeStyle.crosshairLabelFont);
  }
  return parent;
}
function findCrosshairDirection(rX, rY, rect, arrowLocation, arrowPadding, top, bottom, left, tipX, tipY) {
  var direction = "";
  var startX = rect.x;
  var startY = rect.y;
  var width = rect.x + rect.width;
  var height = rect.y + rect.height;
  if (top) {
    direction = direction.concat("M " + startX + " " + (startY + rY) + " Q " + startX + " " + startY + " " + (startX + rX) + " " + startY);
    direction = direction.concat(" L " + (width - rX) + " " + startY + " Q " + width + " " + startY + " " + width + " " + (startY + rY));
    direction = direction.concat(" L " + width + " " + (height - rY) + " Q " + width + " " + height + " " + (width - rX) + " " + height);
    if (arrowPadding !== 0) {
      direction = direction.concat(" L " + (arrowLocation.x + arrowPadding / 2) + " " + height);
      direction = direction.concat(" L " + tipX + " " + (height + arrowPadding) + " L " + (arrowLocation.x - arrowPadding / 2) + " " + height);
    }
    if (arrowLocation.x - arrowPadding / 2 > startX) {
      direction = direction.concat(" L " + (startX + rX) + " " + height + " Q " + startX + " " + height + " " + startX + " " + (height - rY) + " z");
    } else {
      if (arrowPadding === 0) {
        direction = direction.concat(" L " + (startX + rX) + " " + height + " Q " + startX + " " + height + " " + startX + " " + (height - rY) + " z");
      } else {
        direction = direction.concat(" L " + startX + " " + (height + rY) + " z");
      }
    }
  } else if (bottom) {
    direction = direction.concat("M " + startX + " " + (startY + rY) + " Q " + startX + " " + startY + " " + (startX + rX) + " " + startY + " L " + (arrowLocation.x - arrowPadding / 2) + " " + startY);
    direction = direction.concat(" L " + tipX + " " + arrowLocation.y);
    direction = direction.concat(" L " + (arrowLocation.x + arrowPadding / 2) + " " + startY);
    direction = direction.concat(" L " + (width - rX) + " " + startY + " Q " + width + " " + startY + " " + width + " " + (startY + rY));
    direction = direction.concat(" L " + width + " " + (height - rY) + " Q " + width + " " + height + " " + (width - rX) + " " + height);
    direction = direction.concat(" L " + (startX + rX) + " " + height + " Q " + startX + " " + height + " " + startX + " " + (height - rY) + " z");
  } else if (left) {
    direction = direction.concat("M " + startX + " " + (startY + rY) + " Q " + startX + " " + startY + " " + (startX + rX) + " " + startY);
    direction = direction.concat(" L " + (width - rX) + " " + startY + " Q " + width + " " + startY + " " + width + " " + (startY + rY) + " L " + width + " " + (arrowLocation.y - arrowPadding / 2));
    direction = direction.concat(" L " + (width + arrowPadding) + " " + tipY);
    direction = direction.concat(" L " + width + " " + (arrowLocation.y + arrowPadding / 2));
    direction = direction.concat(" L " + width + " " + (height - rY) + " Q " + width + " " + height + " " + (width - rX) + " " + height);
    direction = direction.concat(" L " + (startX + rX) + " " + height + " Q " + startX + " " + height + " " + startX + " " + (height - rY) + " z");
  } else {
    direction = direction.concat("M " + (startX + rX) + " " + startY + " Q " + startX + " " + startY + " " + startX + " " + (startY + rY) + " L " + startX + " " + (arrowLocation.y - arrowPadding / 2));
    direction = direction.concat(" L " + (startX - arrowPadding) + " " + tipY);
    direction = direction.concat(" L " + startX + " " + (arrowLocation.y + arrowPadding / 2));
    direction = direction.concat(" L " + startX + " " + (height - rY) + " Q " + startX + " " + height + " " + (startX + rX) + " " + height);
    direction = direction.concat(" L " + (width - rX) + " " + height + " Q " + width + " " + height + " " + width + " " + (height - rY));
    direction = direction.concat(" L " + width + " " + (startY + rY) + " Q " + width + " " + startY + " " + (width - rX) + " " + startY + " z");
  }
  return direction;
}
function withInBounds(x, y, bounds, width, height) {
  if (width === void 0) {
    width = 0;
  }
  if (height === void 0) {
    height = 0;
  }
  return x >= bounds.x - width && x <= bounds.x + bounds.width + width && y >= bounds.y - height && y <= bounds.y + bounds.height + height;
}
function getValueXByPoint(value, size, axis) {
  var actualValue = !axis.isAxisInverse ? value / size : 1 - value / size;
  return actualValue * axis.visibleRange.delta + axis.visibleRange.min;
}
function getValueYByPoint(value, size, axis) {
  var actualValue = axis.isAxisInverse ? value / size : 1 - value / size;
  return actualValue * axis.visibleRange.delta + axis.visibleRange.min;
}
function findClipRect(series, isCanvas) {
  if (isCanvas === void 0) {
    isCanvas = false;
  }
  var rect = series.clipRect;
  if (isCanvas && (series.type === "Polar" || series.type === "Radar")) {
    if (series.drawType === "Scatter") {
      rect.x = series.xAxis.rect.x;
      rect.y = series.yAxis.rect.y;
      rect.width = series.xAxis.rect.width;
      rect.height = series.yAxis.rect.height;
    } else {
      rect.x = series.xAxis.rect.x / 2;
      rect.y = series.yAxis.rect.y / 2;
      rect.width = series.xAxis.rect.width;
      rect.height = series.yAxis.rect.height;
    }
  } else {
    if (series.chart.requireInvertedAxis) {
      rect.x = series.yAxis.rect.x;
      rect.y = series.xAxis.rect.y;
      rect.width = series.yAxis.rect.width;
      rect.height = series.xAxis.rect.height;
    } else {
      rect.x = series.xAxis.rect.x;
      rect.y = series.yAxis.rect.y;
      rect.width = series.xAxis.rect.width;
      rect.height = series.yAxis.rect.height;
    }
  }
}
function firstToLowerCase(str) {
  return str.substr(0, 1).toLowerCase() + str.substr(1);
}
function getTransform(xAxis, yAxis, invertedAxis) {
  var x;
  var y;
  var width;
  var height;
  if (invertedAxis) {
    x = yAxis.rect.x;
    y = xAxis.rect.y;
    width = yAxis.rect.width;
    height = xAxis.rect.height;
  } else {
    x = xAxis.rect.x;
    y = yAxis.rect.y;
    width = xAxis.rect.width;
    height = yAxis.rect.height;
  }
  return new Rect(x, y, width, height);
}
function getMinPointsDelta(axis, seriesCollection) {
  var minDelta = Number.MAX_VALUE;
  var xValues;
  var minVal;
  var seriesMin;
  var stackingGroups = [];
  for (var index = 0; index < seriesCollection.length; index++) {
    var series = seriesCollection[index];
    xValues = [];
    if (series.visible && (axis.name === series.xAxisName || axis.name === "primaryXAxis" && series.xAxisName === null || axis.name === series.chart.primaryXAxis.name && !series.xAxisName)) {
      if (series.type.indexOf("Stacking") > -1 && stackingGroups.indexOf(series.stackingGroup) === -1) {
        stackingGroups.push(series.stackingGroup);
      }
      xValues = series.points.map(function(point) {
        return point.xValue;
      });
      xValues.sort(function(first, second) {
        return first - second;
      });
      if (xValues.length === 1) {
        if (axis.valueType === "Category") {
          var minValue = series.xAxis.visibleRange.min;
          var delta = xValues[0] - minValue;
          if (delta !== 0) {
            minDelta = Math.min(minDelta, delta);
          }
        } else if (axis.valueType.indexOf("DateTime") > -1) {
          var timeOffset = seriesCollection.length === 1 ? 2592e4 : 2592e6;
          seriesMin = series.xMin === series.xMax ? series.xMin - timeOffset : series.xMin;
          minVal = xValues[0] - (!isNullOrUndefined(seriesMin) ? seriesMin : axis.visibleRange.min);
          if (minVal !== 0) {
            minDelta = Math.min(minDelta, minVal);
          }
        } else {
          seriesMin = series.xMin;
          minVal = xValues[0] - (!isNullOrUndefined(seriesMin) ? seriesMin : axis.visibleRange.min);
          if (minVal !== 0) {
            minDelta = Math.min(minDelta, minVal);
          }
        }
      } else {
        for (var index_1 = 0; index_1 < xValues.length; index_1++) {
          var value = xValues[index_1];
          if (index_1 > 0 && value) {
            minVal = series.type.indexOf("Stacking") > -1 && axis.valueType === "Category" ? stackingGroups.length : value - xValues[index_1 - 1];
            if (minVal !== 0) {
              minDelta = Math.min(minDelta, minVal);
            }
          }
        }
      }
    }
  }
  if (minDelta === Number.MAX_VALUE) {
    minDelta = 1;
  }
  return minDelta;
}
function getAnimationFunction(effect) {
  var functionName;
  switch (effect) {
    case "Linear":
      functionName = linear;
      break;
  }
  return functionName;
}
function linear(currentTime, startValue, endValue, duration) {
  return -endValue * Math.cos(currentTime / duration * (Math.PI / 2)) + endValue + startValue;
}
function markerAnimate(element, delay, duration, series, pointIndex, point, isLabel) {
  var isAccumulation = series.accumulation ? true : false;
  element.style.visibility = "hidden";
  var transform = element.getAttribute("transform");
  new Animation({}).animate(element, {
    duration,
    delay,
    progress: function(args) {
      if (args.timeStamp > args.delay) {
        args.element.style.visibility = "visible";
      }
      if (isAccumulation ? args.element.id.indexOf("_datalabel_Series_") > -1 : args.element.parentElement.parentElement.id.indexOf("DataLabel") > -1 && !(series.chart.stackLabels.visible && element.getAttribute("data-collide"))) {
        args.element.style.visibility = "visible";
        var dataLabelOpacity = isAccumulation ? series.opacity : series.marker.dataLabel.opacity;
        var calculatedOpacity = args.timeStamp / 500 * dataLabelOpacity;
        if (isAccumulation) {
          element.setAttribute("opacity", Math.min(calculatedOpacity, dataLabelOpacity).toString());
        } else {
          series.textElement.setAttribute("opacity", Math.min(calculatedOpacity, dataLabelOpacity).toString());
          series.shapeElement.setAttribute("opacity", Math.min(calculatedOpacity, dataLabelOpacity).toString());
        }
      }
    },
    end: function() {
      var annotations = document.getElementById(series.chart.element.id + "_Annotation_Collections");
      if (annotations && series.type !== "Line") {
        annotations.style.visibility = "visible";
      }
      if (element.parentElement.parentElement.id.indexOf("DataLabel") > -1 || element.id.indexOf("_datalabel_Series_") > -1) {
        if (isAccumulation) {
          element.setAttribute("opacity", series.opacity.toString());
        } else {
          series.textElement.setAttribute("opacity", series.marker.dataLabel.opacity.toString());
          series.shapeElement.setAttribute("opacity", series.marker.dataLabel.opacity.toString());
        }
      }
      if (!(series.chart.stackLabels.visible && element.getAttribute("data-collide"))) {
        element.style.visibility = "";
      }
      element.setAttribute("transform", transform ? transform : "");
      if ((series.type === "Scatter" || series.type === "Bubble") && !isLabel && pointIndex === series.points.length - 1) {
        series.chart.trigger("animationComplete", {
          series: series.chart.isBlazor ? {} : series
        });
      }
    }
  });
}
function animateRectElement(element, delay, duration, currentRect, previousRect) {
  var setStyle = function(rect) {
    element.setAttribute("x", rect.x + "");
    element.setAttribute("y", rect.y + "");
    element.setAttribute("width", rect.width + "");
    element.setAttribute("height", rect.height + "");
  };
  new Animation({}).animate(createElement("div"), {
    duration,
    delay,
    //name: name,
    progress: function(args) {
      setStyle(new Rect(linear(args.timeStamp, previousRect.x, currentRect.x - previousRect.x, args.duration), linear(args.timeStamp, previousRect.y, currentRect.y - previousRect.y, args.duration), linear(args.timeStamp, previousRect.width, currentRect.width - previousRect.width, args.duration), linear(args.timeStamp, previousRect.height, currentRect.height - previousRect.height, args.duration)));
    },
    end: function() {
      setStyle(currentRect);
    }
  });
}
function pathAnimation(element, direction, redraw, previousDirection, animateDuration) {
  if (!redraw || !previousDirection && !element) {
    return null;
  }
  var duration = 300;
  if (!isNullOrUndefined(animateDuration)) {
    duration = animateDuration;
  }
  var startDirections = previousDirection || element.getAttribute("d");
  var splitDirections = startDirections.split(/(?=[LMCZAQ])/);
  var endDirections = direction.split(/(?=[LMCZAQ])/);
  var currentDireciton;
  var startPath = [];
  var endPath = [];
  var c;
  var end;
  element.setAttribute("d", startDirections);
  new Animation({}).animate(createElement("div"), {
    duration,
    progress: function(args) {
      currentDireciton = "";
      splitDirections.map(function(directions, index) {
        startPath = directions.split(" ");
        endPath = endDirections[index] ? endDirections[index].split(" ") : startPath;
        if (startPath[0] === "Z") {
          currentDireciton += "Z ";
        } else if (startPath[0] === "") {
          currentDireciton = "";
        } else {
          currentDireciton += startPath[0] + " " + linear(args.timeStamp, +startPath[1], +endPath[1] - +startPath[1], args.duration) + " " + linear(args.timeStamp, +startPath[2], +endPath[2] - +startPath[2], args.duration) + " ";
        }
        if (startPath[0] === "C" || startPath[0] === "Q") {
          c = 3;
          end = startPath[0] === "Q" ? 4 : 6;
          while (c < end) {
            currentDireciton += linear(args.timeStamp, +startPath[c], +endPath[c] - +startPath[c], args.duration) + " " + linear(args.timeStamp, +startPath[++c], +endPath[c] - +startPath[c], args.duration) + " ";
            ++c;
          }
        }
        if (startPath[0] === "A") {
          currentDireciton += "0 0 1 " + linear(args.timeStamp, +startPath[6], +endPath[6] - +startPath[6], args.duration) + " " + linear(args.timeStamp, +startPath[7], +endPath[7] - +startPath[7], args.duration) + " ";
        }
      });
      element.setAttribute("d", currentDireciton);
    },
    end: function() {
      element.setAttribute("d", direction);
    }
  });
}
function animateAddPoints(element, direction, redraw, previousDirection, animateDuration, removeDirection) {
  if (!redraw || !previousDirection && !element) {
    return null;
  }
  var duration = 300;
  if (!isNullOrUndefined(animateDuration)) {
    duration = animateDuration;
  }
  var startDirections = previousDirection || element.getAttribute("d");
  var endDirections = direction;
  var currentDirection = "";
  element.setAttribute("d", startDirections);
  new Animation({}).animate(createElement("div"), {
    duration,
    progress: function(args) {
      currentDirection = "";
      var startPathCommands = startDirections.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);
      var endPathCommands = endDirections.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);
      var maxLength = Math.max(startPathCommands.length, endPathCommands.length);
      for (var i = 0; i < maxLength; i++) {
        var startPathCommand = startPathCommands[i] || "";
        var endPathCommand = endPathCommands[i] || "";
        var startCoords = startPathCommand.trim().split(/\s+/);
        var endCoords = endPathCommand.trim().split(/\s+/);
        var interpolatedCoords = [];
        for (var j = 1; j < startCoords.length; j++) {
          var startCoord = parseFloat(startCoords[j]);
          var endCoord = parseFloat(endCoords[j]);
          if (!isNaN(startCoord) && !isNaN(endCoord) && startCoords.length === endCoords.length) {
            var interpolatedValue = linear(args.timeStamp, startCoord, endCoord - startCoord, duration);
            if (i === maxLength - 1) {
              interpolatedCoords.push(interpolatedValue);
            } else {
              interpolatedCoords.push(interpolatedValue);
            }
          }
        }
        if (startCoords.length !== endCoords.length) {
          currentDirection += "L";
        } else {
          currentDirection += startCoords[0];
        }
        currentDirection += " " + interpolatedCoords.join(" ");
        currentDirection += " ";
      }
      element.setAttribute("d", currentDirection);
    },
    end: function() {
      element.setAttribute("d", removeDirection || direction);
    }
  });
}
function appendClipElement(redraw, options, renderer, clipPath) {
  if (clipPath === void 0) {
    clipPath = "drawClipPath";
  }
  var clipElement = redrawElement(redraw, options.id, options, renderer);
  if (clipElement) {
    var def = renderer.createDefs();
    def.appendChild(clipElement);
    return def;
  } else {
    return renderer[clipPath](options);
  }
}
function triggerLabelRender(chart, tempInterval, text, labelStyle, axis) {
  var argsData = {
    cancel: false,
    name: axisLabelRender,
    axis,
    text,
    value: tempInterval,
    labelStyle
  };
  chart.trigger(axisLabelRender, argsData);
  if (!argsData.cancel) {
    var isLineBreakLabels = argsData.text.indexOf("<br>") !== -1;
    var text_1 = axis.enableTrim ? isLineBreakLabels ? lineBreakLabelTrim(axis.maximumLabelWidth, argsData.text, axis.labelStyle, chart.themeStyle.axisLabelFont) : textTrim(axis.maximumLabelWidth, argsData.text, axis.labelStyle, chart.enableRtl, chart.themeStyle.axisLabelFont) : argsData.text;
    axis.visibleLabels.push(new VisibleLabels(text_1, argsData.value, argsData.labelStyle, argsData.text));
  }
}
function setRange(axis) {
  return axis.minimum != null && axis.maximum != null;
}
function isZoomSet(axis) {
  return axis.zoomFactor < 1 && axis.zoomPosition >= 0;
}
function getActualDesiredIntervalsCount(availableSize, axis) {
  var size = axis.orientation === "Horizontal" ? availableSize.width : availableSize.height;
  if (isNullOrUndefined(axis.desiredIntervals)) {
    var desiredIntervalsCount = (axis.orientation === "Horizontal" ? 0.533 : 1) * axis.maximumLabels;
    desiredIntervalsCount = Math.max(size * (desiredIntervalsCount / 100), 1);
    return desiredIntervalsCount;
  } else {
    return axis.desiredIntervals;
  }
}
function templateAnimate(element, delay, duration, name, isRemove) {
  new Animation({}).animate(element, {
    duration,
    delay,
    name,
    progress: function(args) {
      args.element.style.visibility = "visible";
    },
    end: function(args) {
      if (isRemove) {
        remove(args.element);
      } else {
        args.element.style.visibility = "visible";
      }
    }
  });
}
function drawSymbol(location, shape, size, url, options, label, renderer, clipRect, isChartControl, control) {
  var chartRenderer = renderer ? renderer : new SvgRenderer("");
  var shapeOption = calculateShapes(location, size, shape, options, url, isChartControl, control);
  var drawElement = chartRenderer["draw" + shapeOption.functionName](shapeOption.renderOption, clipRect ? new Int32Array([clipRect.x, clipRect.y]) : null);
  return drawElement;
}
function calculateShapes(location, size, shape, options, url, isChart, control) {
  var dir;
  var functionName = "Path";
  var isBulletChart = isChart;
  var width = isBulletChart && shape === "Circle" ? size.width - 2 : size.width;
  var height = isBulletChart && shape === "Circle" ? size.height - 2 : size.height;
  var sizeBullet = isBulletChart ? control.targetWidth : 0;
  var lx = location.x;
  var ly = location.y;
  var y = location.y + -height / 2;
  var x = location.x + -width / 2;
  var eq = 72;
  var xVal;
  var yVal;
  switch (shape) {
    case "Bubble":
    case "Circle":
      functionName = "Ellipse";
      merge(options, {
        "rx": width / 2,
        "ry": height / 2,
        "cx": lx,
        "cy": ly
      });
      break;
    case "Plus":
      dir = "M " + x + " " + ly + " L " + (lx + width / 2) + " " + ly + " M " + lx + " " + (ly + height / 2) + " L " + lx + " " + (ly + -height / 2);
      merge(options, {
        "d": dir
      });
      break;
    case "Cross":
      dir = "M " + x + " " + (ly + -height / 2) + " L " + (lx + width / 2) + " " + (ly + height / 2) + " M " + x + " " + (ly + height / 2) + " L " + (lx + width / 2) + " " + (ly + -height / 2);
      merge(options, {
        "d": dir
      });
      break;
    case "Multiply":
      dir = "M " + (lx - sizeBullet) + " " + (ly - sizeBullet) + " L " + (lx + sizeBullet) + " " + (ly + sizeBullet) + " M " + (lx - sizeBullet) + " " + (ly + sizeBullet) + " L " + (lx + sizeBullet) + " " + (ly - sizeBullet);
      merge(options, {
        "d": dir,
        stroke: options.fill
      });
      break;
    case "HorizontalLine":
      dir = "M " + x + " " + ly + " L " + (lx + width / 2) + " " + ly;
      merge(options, {
        "d": dir
      });
      break;
    case "VerticalLine":
      dir = "M " + lx + " " + (ly + height / 2) + " L " + lx + " " + (ly + -height / 2);
      merge(options, {
        "d": dir
      });
      break;
    case "Diamond":
      dir = "M " + x + " " + ly + " L " + lx + " " + (ly + -height / 2) + " L " + (lx + width / 2) + " " + ly + " L " + lx + " " + (ly + height / 2) + " L " + x + " " + ly + " z";
      merge(options, {
        "d": dir
      });
      break;
    case "ActualRect":
      dir = "M " + x + " " + (ly + -height / 8) + " L " + (lx + sizeBullet) + " " + (ly + -height / 8) + " L " + (lx + sizeBullet) + " " + (ly + height / 8) + " L " + x + " " + (ly + height / 8) + " L " + x + " " + (ly + -height / 8) + " z";
      merge(options, {
        "d": dir
      });
      break;
    case "TargetRect":
      dir = "M " + (x + sizeBullet) + " " + (ly + -height / 2) + " L " + (lx + sizeBullet / 2) + " " + (ly + -height / 2) + " L " + (lx + sizeBullet / 2) + " " + (ly + height / 2) + " L " + (x + sizeBullet) + " " + (ly + height / 2) + " L " + (x + sizeBullet) + " " + (ly + -height / 2) + " z";
      merge(options, {
        "d": dir
      });
      break;
    case "Rectangle":
    case "Hilo":
    case "HiloOpenClose":
    case "Candle":
    case "Waterfall":
    case "BoxAndWhisker":
    case "StepArea":
    case "RangeStepArea":
    case "StackingStepArea":
    case "Square":
    case "Flag":
      dir = "M " + x + " " + (ly + -height / 2) + " L " + (lx + width / 2) + " " + (ly + -height / 2) + " L " + (lx + width / 2) + " " + (ly + height / 2) + " L " + x + " " + (ly + height / 2) + " L " + x + " " + (ly + -height / 2) + " z";
      merge(options, {
        "d": dir
      });
      break;
    case "Pyramid":
    case "Triangle":
      dir = "M " + x + " " + (ly + height / 2) + " L " + lx + " " + (ly + -height / 2) + " L " + (lx + width / 2) + " " + (ly + height / 2) + " L " + x + " " + (ly + height / 2) + " z";
      merge(options, {
        "d": dir
      });
      break;
    case "Funnel":
    case "InvertedTriangle":
      dir = "M " + (lx + width / 2) + " " + (ly - height / 2) + " L " + lx + " " + (ly + height / 2) + " L " + (lx - width / 2) + " " + (ly - height / 2) + " L " + (lx + width / 2) + " " + (ly - height / 2) + " z";
      merge(options, {
        "d": dir
      });
      break;
    case "Pentagon":
      for (var i = 0; i <= 5; i++) {
        xVal = width / 2 * Math.cos(Math.PI / 180 * (i * eq));
        yVal = height / 2 * Math.sin(Math.PI / 180 * (i * eq));
        if (i === 0) {
          dir = "M " + (lx + xVal) + " " + (ly + yVal) + " ";
        } else {
          dir = dir.concat("L " + (lx + xVal) + " " + (ly + yVal) + " ");
        }
      }
      dir = dir.concat("Z");
      merge(options, {
        "d": dir
      });
      break;
    case "Image":
      functionName = "Image";
      merge(options, {
        "href": url,
        "height": height,
        "width": width,
        x,
        y
      });
      break;
    case "Star": {
      var cornerPoints = 5;
      var outerRadius = Math.min(width, height) / 2;
      var innerRadius = outerRadius / 2;
      var angle = Math.PI / cornerPoints;
      var starPath = "";
      for (var i = 0; i < 2 * cornerPoints; i++) {
        var radius = i % 2 === 0 ? outerRadius : innerRadius;
        var currentX = lx + radius * Math.cos(i * angle - Math.PI / 2);
        var currentY = ly + radius * Math.sin(i * angle - Math.PI / 2);
        starPath += (i === 0 ? "M" : "L") + currentX + "," + currentY;
      }
      starPath += "Z";
      merge(options, {
        "d": starPath
      });
      break;
    }
  }
  options = calculateLegendShapes(location, new Size(width, height), shape, options).renderOption;
  return {
    renderOption: options,
    functionName
  };
}
function getRectLocation(startLocation, endLocation, outerRect) {
  var x = endLocation.x < outerRect.x ? outerRect.x : endLocation.x > outerRect.x + outerRect.width ? outerRect.x + outerRect.width : endLocation.x;
  var y = endLocation.y < outerRect.y ? outerRect.y : endLocation.y > outerRect.y + outerRect.height ? outerRect.y + outerRect.height : endLocation.y;
  return new Rect(x > startLocation.x ? startLocation.x : x, y > startLocation.y ? startLocation.y : y, Math.abs(x - startLocation.x), Math.abs(y - startLocation.y));
}
function minMax(value, min, max) {
  return value > max ? max : value < min ? min : value;
}
function getElement2(id) {
  return document.getElementById(id);
}
function getTemplateFunction(template) {
  var templateFn = null;
  try {
    if (typeof template !== "function" && document.querySelectorAll(template).length) {
      templateFn = compile(document.querySelector(template).innerHTML.trim());
    } else {
      templateFn = compile(template);
    }
  } catch (e) {
    templateFn = compile(template);
  }
  return templateFn;
}
function accReactTemplate(childElement, chart, isTemplate, points, argsData, point, datalabelGroup, id, dataLabel, redraw) {
  var clientRect = childElement.getBoundingClientRect();
  chart.accumulationDataLabelModule.calculateLabelSize(isTemplate, childElement, point, points, argsData, datalabelGroup, id, dataLabel, redraw, clientRect, true);
}
function chartReactTemplate(childElement, chart, point, series, labelIndex, redraw) {
  var parentElement = document.getElementById(chart.element.id + "_Series_" + (series.index === void 0 ? series.category : series.index) + "_DataLabelCollections");
  if (parentElement) {
    if (point.index === 0) {
      chart.dataLabelCollections = [];
    }
    chart.dataLabelModule.calculateTemplateLabelSize(parentElement, childElement, point, series, series.marker.dataLabel, labelIndex, series.clipRect, redraw, true);
  }
}
function createTemplate(childElement, pointIndex, content, chart, point, series, dataLabelId, labelIndex, argsData, isTemplate, points, datalabelGroup, id, dataLabel, redraw) {
  var templateFn = getTemplateFunction(content);
  var templateElement;
  try {
    var blazor = "Blazor";
    var tempObject = window[blazor] ? dataLabelId ? point : {
      point
    } : {
      chart,
      series,
      point
    };
    var templateId = dataLabelId ? dataLabelId + "_template" : "template";
    var elementData = templateFn ? templateFn(tempObject, chart, templateId, dataLabelId || childElement.id.replace(/[^a-zA-Z0-9]/g, "")) : [];
    if (elementData.length) {
      templateElement = Array.prototype.slice.call(elementData);
      var len = templateElement.length;
      for (var i = 0; i < len; i++) {
        childElement.appendChild(templateElement[i]);
      }
    }
    var reactCallback = void 0;
    if (chart.getModuleName() === "accumulationchart") {
      reactCallback = points.length && points[pointIndex] ? accReactTemplate.bind(this, childElement, chart, isTemplate, points, argsData, points[pointIndex], datalabelGroup, id, dataLabel, redraw) : reactCallback;
      if (chart.isReact) {
        chart.renderReactTemplates(reactCallback);
      }
    } else if (chart.getModuleName() === "chart") {
      reactCallback = point && series ? chartReactTemplate.bind(this, childElement, chart, point, series, labelIndex, redraw) : reactCallback;
      if (chart.isReact) {
        chart.renderReactTemplates(reactCallback);
      }
    }
  } catch (e) {
    return childElement;
  }
  return childElement;
}
function getFontStyle(font, themeFontStyle) {
  var style = "";
  style = "font-size:" + (font.size || themeFontStyle.size) + "; font-style:" + (font.fontStyle || themeFontStyle.fontStyle) + "; font-weight:" + (font.fontWeight || themeFontStyle.fontWeight) + "; font-family:" + font.fontFamily + ";opacity:" + font.opacity + "; color:" + font.color + ";";
  return style;
}
function measureElementRect(element, redraw, isReactCallback) {
  if (redraw === void 0) {
    redraw = false;
  }
  if (!isReactCallback) {
    document.body.appendChild(element);
  }
  var bounds = element.getBoundingClientRect();
  if (redraw) {
    remove(element);
  } else if (!isReactCallback) {
    removeElement2(element.id);
  }
  return bounds;
}
function findlElement(elements, id) {
  var element;
  for (var i = 0, length_1 = elements.length; i < length_1; i++) {
    if (elements[i].id.indexOf(id) > -1) {
      element = elements[i];
      continue;
    }
  }
  return element;
}
function getPoint(x, y, xAxis, yAxis, isInverted) {
  x = xAxis.valueType === "Logarithmic" ? logBase(x > 0 ? x : Math.pow(xAxis.logBase, xAxis.visibleRange.min), xAxis.logBase) : x;
  y = yAxis.valueType === "Logarithmic" ? logBase(y > 0 ? y : Math.pow(yAxis.logBase, yAxis.visibleRange.min), yAxis.logBase) : y;
  x = valueToCoefficient(x, xAxis);
  y = valueToCoefficient(y, yAxis);
  var xLength = isInverted ? xAxis.rect.height : xAxis.rect.width;
  var yLength = isInverted ? yAxis.rect.width : yAxis.rect.height;
  var locationX = isInverted ? y * yLength : x * xLength;
  var locationY = isInverted ? (1 - x) * xLength : (1 - y) * yLength;
  return new ChartLocation(locationX, locationY);
}
function appendElement(child, parent, redraw, animate, x, y, duration) {
  if (redraw === void 0) {
    redraw = false;
  }
  if (animate === void 0) {
    animate = false;
  }
  if (x === void 0) {
    x = "x";
  }
  if (y === void 0) {
    y = "y";
  }
  if (child && child.hasChildNodes() && parent) {
    appendChildElement(false, parent, child, redraw, animate, x, y, void 0, void 0, void 0, void 0, void 0, duration);
  } else {
    return null;
  }
}
function appendChildElement(isCanvas, parent, childElement, redraw, isAnimate, x, y, start, direction, forceAnimate, isRect, previousRect, animateDuration, scatterElement, angle, currentTransform, previousTranslate) {
  if (isAnimate === void 0) {
    isAnimate = false;
  }
  if (x === void 0) {
    x = "x";
  }
  if (y === void 0) {
    y = "y";
  }
  if (forceAnimate === void 0) {
    forceAnimate = false;
  }
  if (isRect === void 0) {
    isRect = false;
  }
  if (previousRect === void 0) {
    previousRect = null;
  }
  if (scatterElement === void 0) {
    scatterElement = false;
  }
  if (angle === void 0) {
    angle = 0;
  }
  if (isCanvas) {
    return null;
  }
  var existChild = scatterElement ? null : parent.querySelector("#" + childElement.id);
  var element = existChild || getElement2(childElement.id);
  var child = childElement;
  var duration = !isNullOrUndefined(animateDuration) ? animateDuration : 300;
  if (redraw && isAnimate && element) {
    start = start || (element.tagName === "DIV" ? new ChartLocation(+element.style[x].split("px")[0], +element.style[y].split("px")[0]) : new ChartLocation(+element.getAttribute(x), +element.getAttribute(y)));
    if (direction && direction !== "undefined") {
      pathAnimation(childElement, childElement.getAttribute("d"), redraw, direction, duration);
    } else if (isRect && previousRect) {
      animateRectElement(child, 0, duration, new Rect(+element.getAttribute("x"), +element.getAttribute("y"), +element.getAttribute("width"), +element.getAttribute("height")), previousRect);
    } else {
      var end = child.tagName === "DIV" ? new ChartLocation(+child.style[x].split("px")[0], +child.style[y].split("px")[0]) : new ChartLocation(+child.getAttribute(x), +child.getAttribute(y));
      var previousTranform = element.getAttribute("transform");
      animateRedrawElement(child, duration, start, end, x, y, angle, currentTransform, previousTranslate !== void 0 ? new ChartLocation(previousTranslate.match(/\d+/g).map(Number)[0], previousTranslate.match(/\d+/g).map(Number)[1]) : previousTranform ? new ChartLocation(parseFloat(previousTranform.split(",")[1]), parseFloat(previousTranform.split(",")[2])) : new ChartLocation(0, 0), previousTranslate !== void 0);
    }
  } else if (redraw && isAnimate && !element && forceAnimate) {
    templateAnimate(child, 0, 600, "FadeIn");
  }
  if (existChild) {
    parent.replaceChild(child, element);
  } else {
    parent.appendChild(child);
  }
}
function getDraggedRectLocation(x1, y1, x2, y2, outerRect) {
  var width = Math.abs(x1 - x2);
  var height = Math.abs(y1 - y2);
  var x = Math.max(checkBounds(Math.min(x1, x2), width, outerRect.x, outerRect.width), outerRect.x);
  var y = Math.max(checkBounds(Math.min(y1, y2), height, outerRect.y, outerRect.height), outerRect.y);
  return new Rect(x, y, Math.min(width, outerRect.width), Math.min(height, outerRect.height));
}
function checkBounds(start, size, min, max) {
  if (start < min) {
    start = min;
  } else if (start + size > max + min) {
    start = max + min - size;
  }
  return start;
}
function getLabelText(currentPoint, series, chart) {
  var labelFormat = series.marker.dataLabel.format ? series.marker.dataLabel.format : series.yAxis.labelFormat;
  var text = [];
  var customLabelFormat = labelFormat.match("{value}") !== null;
  switch (series.seriesType) {
    case "XY":
      if (series.chart.chartAreaType === "PolarRadar") {
        if (series.drawType.indexOf("Stacking") !== -1) {
          if (series.yAxis.valueType === "Logarithmic" && logWithIn(series.stackedValues.endValues[currentPoint.index], series.yAxis) || withIn(series.stackedValues.endValues[currentPoint.index], series.yAxis.visibleRange)) {
            text.push(currentPoint.text || currentPoint.yValue.toString());
          }
        } else {
          if (series.yAxis.valueType === "Logarithmic" && logWithIn(currentPoint.yValue, series.yAxis) || withIn(currentPoint.yValue, series.yAxis.visibleRange)) {
            text.push(currentPoint.text || currentPoint.yValue.toString());
          }
        }
      } else {
        text.push(currentPoint.text || currentPoint.yValue.toString());
      }
      break;
    case "HighLow":
      text.push(currentPoint.text || Math.max(currentPoint.high, currentPoint.low).toString());
      text.push(currentPoint.text || Math.min(currentPoint.high, currentPoint.low).toString());
      break;
    case "HighLowOpenClose":
      text.push(currentPoint.text || Math.max(currentPoint.high, currentPoint.low).toString());
      text.push(currentPoint.text || Math.min(currentPoint.high, currentPoint.low).toString());
      text.push(currentPoint.text || Math.max(currentPoint.open, currentPoint.close).toString());
      text.push(currentPoint.text || Math.min(currentPoint.open, currentPoint.close).toString());
      break;
    case "BoxPlot":
      text.push(currentPoint.text || currentPoint.median.toString());
      text.push(currentPoint.text || currentPoint.maximum.toString());
      text.push(currentPoint.text || currentPoint.minimum.toString());
      text.push(currentPoint.text || currentPoint.upperQuartile.toString());
      text.push(currentPoint.text || currentPoint.lowerQuartile.toString());
      for (var _i = 0, _a = currentPoint.outliers; _i < _a.length; _i++) {
        var liers = _a[_i];
        text.push(currentPoint.text || liers.toString());
      }
      break;
  }
  if ((labelFormat || chart.useGroupingSeparator) && !currentPoint.text) {
    series.yAxis.format = chart.intl.getNumberFormat({
      format: customLabelFormat ? "" : labelFormat,
      useGrouping: chart.useGroupingSeparator
    });
    for (var i = 0; i < text.length; i++) {
      text[i] = customLabelFormat ? labelFormat.replace("{value}", series.yAxis.format(parseFloat(text[i]))) : series.yAxis.format(parseFloat(text[i]));
    }
  }
  return text;
}
function stopTimer(timer) {
  window.clearInterval(timer);
}
function isCollide(rect, collections, clipRect) {
  var currentRect = new Rect(rect.x + clipRect.x, rect.y + clipRect.y, rect.width, rect.height);
  var isCollide2 = collections.some(function(rect2) {
    return currentRect.x < rect2.x + rect2.width && currentRect.x + currentRect.width > rect2.x && currentRect.y < rect2.y + rect2.height && currentRect.height + currentRect.y > rect2.y;
  });
  return isCollide2;
}
function isOverlap(currentRect, rect) {
  return currentRect.x < rect.x + rect.width && currentRect.x + currentRect.width > rect.x && currentRect.y < rect.y + rect.height && currentRect.height + currentRect.y > rect.y;
}
function containsRect(currentRect, rect) {
  return currentRect.x <= rect.x && currentRect.x + currentRect.width >= rect.x + rect.width && currentRect.y <= rect.y && currentRect.height + currentRect.y >= rect.y + rect.height;
}
function calculateRect(location, textSize, margin) {
  return new Rect(location.x - textSize.width / 2 - margin.left, location.y - textSize.height / 2 - margin.top, textSize.width + margin.left + margin.right, textSize.height + margin.top + margin.bottom);
}
function convertToHexCode(value) {
  return "#" + componentToHex(value.r) + componentToHex(value.g) + componentToHex(value.b);
}
function componentToHex(value) {
  var hex = value.toString(16);
  return hex.length === 1 ? "0" + hex : hex;
}
function convertHexToColor(hex) {
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? new ColorValue(parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)) : new ColorValue(255, 255, 255);
}
function colorNameToHex(color) {
  color = color === "transparent" ? "white" : color;
  var element = document.getElementById("chartmeasuretext");
  if (!element) {
    element = createElement("text", {
      id: "chartmeasuretext"
    });
    document.body.appendChild(element);
  }
  element.style.color = color;
  color = window.getComputedStyle(element).color;
  element.style.color = "";
  var isRGBValue;
  if (color.indexOf("rgb") === 0 || color.indexOf("hsl") === 0) {
    color = color.replace(/\s/g, "").replace(/[()]/g, "");
    isRGBValue = color.slice(3).split(",");
  }
  if (isRGBValue && isRGBValue.length) {
    var _a = isRGBValue.map(function(value) {
      return parseInt(value, 10);
    }), r = _a[0], g = _a[1], b = _a[2];
    return convertToHexCode(new ColorValue(r, g, b));
  }
  return "";
}
function checkColorFormat(color) {
  if (color.indexOf("rgba(") === 0 || color.indexOf("rgb(") === 0) {
    var rgbaValues = color.substring(color.indexOf("(") + 1, color.lastIndexOf(")")).split(",");
    if (rgbaValues.length === 3 || rgbaValues.length === 4) {
      return rgbaValues.every(function(val) {
        var num = parseFloat(val);
        return !isNaN(num) && num >= 0 && num <= 255;
      });
    }
  } else if (color.indexOf("#") === 0) {
    var hex = color.substring(1);
    return (hex.length === 3 || hex.length === 6) && /^[0-9A-Fa-f]{3,6}$/.test(hex);
  }
  return false;
}
function getSaturationColor(color, factor) {
  color = colorNameToHex(color);
  color = color.replace(/[^0-9a-f]/gi, "");
  if (color.length < 6) {
    color = color[0] + color[0] + color[1] + color[1] + color[2] + color[2];
  }
  factor = factor || 0;
  var rgb = "#";
  var colorCode;
  for (var i = 0; i < 3; i++) {
    colorCode = parseInt(color.substr(i * 2, 2), 16);
    colorCode = Math.round(Math.min(Math.max(0, colorCode + colorCode * factor), 255));
    rgb += ("00" + colorCode.toString(16)).substr(colorCode.toString(16).length);
  }
  return rgb;
}
function applyZLight(color, value) {
  var RGB = convertHexToColor(color);
  RGB.r = parseInt(Math.floor(RGB.r * value).toString(), 10);
  RGB.g = parseInt(Math.floor(RGB.g * value).toString(), 10);
  RGB.b = parseInt(Math.floor(RGB.b * value).toString(), 10);
  return "#" + componentToHex(RGB.r).toUpperCase() + componentToHex(RGB.g).toUpperCase() + componentToHex(RGB.b).toUpperCase();
}
function getMedian(values) {
  var half = Math.floor(values.length / 2);
  return values.length % 2 ? values[half] : (values[half - 1] + values[half]) / 2;
}
function calculateLegendShapes(location, size, shape, options) {
  var padding = 10;
  var dir = "";
  var space = 2;
  var height = size.height;
  var width = size.width;
  var lx = location.x;
  var ly = location.y;
  switch (shape) {
    case "MultiColoredLine":
    case "Line":
    case "StackingLine":
    case "StackingLine100":
      dir = "M " + (lx + -width * (3 / 4)) + " " + ly + " L " + (lx + width * (3 / 4)) + " " + ly;
      merge(options, {
        "d": dir
      });
      break;
    case "StepLine":
      options.fill = "transparent";
      dir = "M " + (lx + -width / 2 - padding / 4) + " " + (ly + height / 2) + " L " + (lx + -width / 2 + width / 10) + " " + (ly + height / 2) + " L " + (lx + -width / 2 + width / 10) + " " + ly + " L " + (lx + -width / 10) + " " + ly + " L " + (lx + -width / 10) + " " + (ly + height / 2) + " L " + (lx + width / 5) + " " + (ly + height / 2) + " L " + (lx + width / 5) + " " + (ly + -height / 2) + " L " + (lx + width / 2) + " " + (ly + -height / 2) + "L " + (lx + width / 2) + " " + (ly + height / 2) + " L" + (lx + width / 2 + padding / 4) + " " + (ly + height / 2);
      merge(options, {
        "d": dir
      });
      break;
    case "UpArrow":
      options.fill = options.stroke;
      options.stroke = "transparent";
      dir = "M " + (lx + -width / 2) + " " + (ly + height / 2) + " L " + lx + " " + (ly - height / 2) + " L " + (lx + width / 2) + " " + (ly + height / 2) + "L " + (lx + width / 2 - space) + " " + (ly + height / 2) + " L " + lx + " " + (ly - height / 2 + 2 * space) + "L" + (lx - width / 2 + space) + " " + (ly + height / 2) + " Z";
      merge(options, {
        "d": dir
      });
      break;
    case "DownArrow":
      dir = "M " + (lx - width / 2) + " " + (ly - height / 2) + " L " + lx + " " + (ly + height / 2) + " L " + (lx + width / 2) + " " + (ly - height / 2) + "L " + (lx + width / 2 - space) + " " + (ly - height / 2) + " L " + lx + " " + (ly + height / 2 - 2 * space) + "L" + (lx - width / 2 + space) + " " + (ly - height / 2) + " Z";
      merge(options, {
        "d": dir
      });
      break;
    case "RightArrow":
      dir = "M " + (lx + -width / 2) + " " + (ly - height / 2) + " L " + (lx + width / 2) + " " + ly + " L " + (lx + -width / 2) + " " + (ly + height / 2) + " L " + (lx + -width / 2) + " " + (ly + height / 2 - space) + " L " + (lx + width / 2 - 2 * space) + " " + ly + " L" + (lx + -width / 2) + " " + (ly - height / 2 + space) + " Z";
      merge(options, {
        "d": dir
      });
      break;
    case "LeftArrow":
      options.fill = options.stroke;
      options.stroke = "transparent";
      dir = "M " + (lx + width / 2) + " " + (ly - height / 2) + " L " + (lx + -width / 2) + " " + ly + " L " + (lx + width / 2) + " " + (ly + height / 2) + " L " + (lx + width / 2) + " " + (ly + height / 2 - space) + " L " + (lx + -width / 2 + 2 * space) + " " + ly + " L" + (lx + width / 2) + " " + (ly - height / 2 + space) + " Z";
      merge(options, {
        "d": dir
      });
      break;
    case "Column":
    case "Pareto":
    case "StackingColumn":
    case "StackingColumn100":
    case "RangeColumn":
    case "Histogram":
      dir = "M " + (lx - 3 * (width / 5)) + " " + (ly - height / 5) + " L " + (lx + 3 * (-width / 10)) + " " + (ly - height / 5) + " L " + (lx + 3 * (-width / 10)) + " " + (ly + height / 2) + " L " + (lx - 3 * (width / 5)) + " " + (ly + height / 2) + " Z M " + (lx + -width / 10 - width / 20) + " " + (ly - height / 4 - padding / 2) + " L " + (lx + width / 10 + width / 20) + " " + (ly - height / 4 - padding / 2) + " L " + (lx + width / 10 + width / 20) + " " + (ly + height / 2) + " L " + (lx + -width / 10 - width / 20) + " " + (ly + height / 2) + " Z M " + (lx + 3 * (width / 10)) + " " + ly + " L " + (lx + 3 * (width / 5)) + " " + ly + " L " + (lx + 3 * (width / 5)) + " " + (ly + height / 2) + " L " + (lx + 3 * (width / 10)) + " " + (ly + height / 2) + " Z";
      merge(options, {
        "d": dir
      });
      break;
    case "Bar":
    case "StackingBar":
    case "StackingBar100":
      dir = "M " + (lx + -width / 2 + -padding / 4) + " " + (ly - 3 * (height / 5)) + " L " + (lx + 3 * (width / 10)) + " " + (ly - 3 * (height / 5)) + " L " + (lx + 3 * (width / 10)) + " " + (ly - 3 * (height / 10)) + " L " + (lx - width / 2 + -padding / 4) + " " + (ly - 3 * (height / 10)) + " Z M " + (lx + -width / 2 + -padding / 4) + " " + (ly - height / 5 + padding / 20) + " L " + (lx + width / 2 + padding / 4) + " " + (ly - height / 5 + padding / 20) + " L " + (lx + width / 2 + padding / 4) + " " + (ly + height / 10 + padding / 20) + " L " + (lx - width / 2 + -padding / 4) + " " + (ly + height / 10 + padding / 20) + " Z M " + (lx - width / 2 + -padding / 4) + " " + (ly + height / 5 + padding / 10) + " L " + (lx + -width / 4) + " " + (ly + height / 5 + padding / 10) + " L " + (lx + -width / 4) + " " + (ly + height / 2 + padding / 10) + " L " + (lx - width / 2 + -padding / 4) + " " + (ly + height / 2 + padding / 10) + " Z";
      merge(options, {
        "d": dir
      });
      break;
    case "Spline":
      options.fill = "transparent";
      dir = "M " + (lx - width / 2) + " " + (ly + height / 5) + " Q " + lx + " " + (ly - height) + " " + lx + " " + (ly + height / 5) + " M " + lx + " " + (ly + height / 5) + " Q " + (lx + width / 2) + " " + (ly + height / 2) + " " + (lx + width / 2) + " " + (ly - height / 2);
      merge(options, {
        "d": dir
      });
      break;
    case "Area":
    case "MultiColoredArea":
    case "RangeArea":
    case "StackingArea":
    case "StackingArea100":
      dir = "M " + (lx - width / 2 - padding / 4) + " " + (ly + height / 2) + " L " + (lx + -width / 4 + -padding / 8) + " " + (ly - height / 2) + " L " + lx + " " + (ly + height / 4) + " L " + (lx + width / 4 + padding / 8) + " " + (ly + -height / 2 + height / 4) + " L " + (lx + height / 2 + padding / 4) + " " + (ly + height / 2) + " Z";
      merge(options, {
        "d": dir
      });
      break;
    case "SplineArea":
    case "SplineRangeArea":
      dir = "M " + (lx - width / 2) + " " + (ly + height / 5) + " Q " + lx + " " + (ly - height) + " " + lx + " " + (ly + height / 5) + " Z M " + lx + " " + (ly + height / 5) + " Q " + (lx + width / 2) + " " + (ly + height / 2) + " " + (lx + width / 2) + " " + (ly - height / 2) + "  Z";
      merge(options, {
        "d": dir
      });
      break;
    case "Pie":
    case "Doughnut": {
      options.stroke = "transparent";
      var r = Math.min(height, width) / 2;
      dir = getAccumulationLegend(lx, ly, r, height, width);
      merge(options, {
        "d": dir
      });
      break;
    }
  }
  return {
    renderOption: options
  };
}
function textTrim(maxWidth, text, font, isRtlEnabled, themeFontStyle) {
  var label = text;
  var size = measureText(text, font, themeFontStyle).width;
  if (size > maxWidth) {
    var textLength = text.length;
    for (var i = textLength - 1; i >= 0; --i) {
      label = isRtlEnabled ? "..." + text.substring(0, i) : text.substring(0, i) + "...";
      size = measureText(label, font, themeFontStyle).width;
      if (size <= maxWidth) {
        return label;
      }
    }
  }
  return label;
}
function lineBreakLabelTrim(maxWidth, text, font, themeFontStyle) {
  var labelCollection = [];
  var breakLabels = text.split("<br>");
  for (var i = 0; i < breakLabels.length; i++) {
    text = breakLabels[i];
    var size = measureText(text, font, themeFontStyle).width;
    if (size > maxWidth) {
      var textLength = text.length;
      for (var i_1 = textLength - 1; i_1 >= 0; --i_1) {
        text = text.substring(0, i_1) + "...";
        size = measureText(text, font, themeFontStyle).width;
        if (size <= maxWidth) {
          labelCollection.push(text);
          break;
        }
      }
    } else {
      labelCollection.push(text);
    }
  }
  return labelCollection;
}
function stringToNumber(value, containerSize) {
  if (value !== null && value !== void 0) {
    return value.indexOf("%") !== -1 ? containerSize / 100 * parseInt(value, 10) : parseInt(value, 10);
  }
  return null;
}
function redrawElement(redraw, id, options, renderer) {
  if (!redraw) {
    return null;
  }
  var element = getElement2(id);
  if (element && options) {
    renderer.setElementAttributes(options, element.tagName === "clipPath" ? element.childNodes[0] : element);
  }
  return element;
}
function animateRedrawElement(element, duration, start, end, x, y, angle, newTransform, previousTransform, pointAnimation) {
  if (x === void 0) {
    x = "x";
  }
  if (y === void 0) {
    y = "y";
  }
  if (angle === void 0) {
    angle = 0;
  }
  if (newTransform === void 0) {
    newTransform = new ChartLocation(0, 0);
  }
  if (previousTransform === void 0) {
    previousTransform = new ChartLocation(0, 0);
  }
  var isDiv = element.tagName === "DIV";
  var setStyle = function(xValue, yValue, rotateX, rotateY) {
    if (isDiv) {
      element.style[x] = xValue + "px";
      element.style[y] = yValue + "px";
    } else {
      element.setAttribute(x, xValue + "");
      element.setAttribute(y, yValue + "");
      if (angle && newTransform.x && newTransform.y && previousTransform.x && previousTransform.y && rotateX && rotateY) {
        element.setAttribute("transform", "rotate(" + angle + "," + rotateX + "," + rotateY + ")");
      }
      if (pointAnimation) {
        element.setAttribute("transform", "translate(" + rotateX + "," + rotateY + ")");
      }
    }
  };
  setStyle(start.x, start.y, previousTransform.x, previousTransform.y);
  new Animation({}).animate(createElement("div"), {
    duration,
    progress: function(args) {
      setStyle(linear(args.timeStamp, start.x, end.x - start.x, args.duration), linear(args.timeStamp, start.y, end.y - start.y, args.duration), linear(args.timeStamp, previousTransform.x, newTransform.x - previousTransform.x, args.duration), linear(args.timeStamp, previousTransform.y, newTransform.y - previousTransform.y, args.duration));
    },
    end: function() {
      setStyle(end.x, end.y, newTransform.x, newTransform.y);
    }
  });
}
function animateTextElement(element, duration, start, end, customLabelFormat) {
  if (element && start && end) {
    var formatText_1 = function(value) {
      return customLabelFormat ? customLabelFormat.replace("{value}", value.toString()) : value.toString();
    };
    new Animation({}).animate(createElement("div"), {
      duration,
      progress: function(args) {
        element.style.animation = "";
        var progress = args.timeStamp / args.duration;
        var currentValue = start + (end - start) * progress;
        if (start % 1 !== 0 || end % 1 !== 0) {
          currentValue = parseFloat(currentValue.toFixed(1));
        } else {
          currentValue = Math.round(currentValue);
        }
        element.textContent = formatText_1(currentValue);
      },
      end: function() {
        element.textContent = formatText_1(end);
      }
    });
  }
}
function textElement2(renderer, option, font, color, parent, isMinus, redraw, isAnimate, forceAnimate, animateDuration, seriesClipRect, labelSize, isRotatedLabelIntersect, isCanvas, isDataLabelWrap, themeFontStyle, transform, previousTransform) {
  if (isMinus === void 0) {
    isMinus = false;
  }
  if (forceAnimate === void 0) {
    forceAnimate = false;
  }
  var renderOptions = {};
  var tspanElement;
  var height;
  var dy;
  var label;
  var width = 0;
  var dx;
  var maxWidth = 0;
  if (option.text.length > 1 && isDataLabelWrap) {
    for (var i = 0, len = option.text.length; i < len; i++) {
      maxWidth = Math.max(maxWidth, measureText(option.text[i], font, themeFontStyle).width);
    }
    width = measureText(option.text[0], font, themeFontStyle).width;
  }
  dx = option.text.length > 1 && isDataLabelWrap ? option.x + maxWidth / 2 - width / 2 : option.x;
  renderOptions = {
    "id": option.id,
    "x": dx,
    "y": option.y,
    "fill": color ? color : "black",
    "font-size": font.size || themeFontStyle.size,
    "font-style": font.fontStyle || themeFontStyle.fontStyle,
    "font-family": font.fontFamily || themeFontStyle.fontFamily,
    "font-weight": font.fontWeight || themeFontStyle.fontWeight,
    "text-anchor": option.anchor,
    "labelRotation": option.labelRotation,
    "transform": option.transform,
    "opacity": font.opacity,
    "dominant-baseline": option.baseLine
  };
  var text = typeof option.text === "string" ? option.text : isMinus ? option.text[option.text.length - 1] : option.text[0];
  var transX = seriesClipRect ? seriesClipRect.x : 0;
  var transY = seriesClipRect ? seriesClipRect.y : 0;
  var htmlObject = renderer.createText(renderOptions, text, transX, transY);
  if (typeof option.text !== "string" && option.text.length > 1) {
    for (var i = 1, len = option.text.length; i < len; i++) {
      height = measureText(option.text[i], font, themeFontStyle).height;
      width = measureText(option.text[i], font, themeFontStyle).width;
      dy = option.y + (isMinus ? -(i * height) : i * height);
      dx = isDataLabelWrap ? option.x + maxWidth / 2 - width / 2 : option.x;
      label = isMinus ? option.text[option.text.length - (i + 1)] : option.text[i];
      if (isCanvas) {
        tspanElement = renderer.createText(renderOptions, label, null, null, dy, true);
      } else {
        tspanElement = renderer.createTSpan({
          "x": dx,
          "id": option.id,
          "y": dy
        }, label);
        htmlObject.appendChild(tspanElement);
      }
    }
  }
  if (!isRotatedLabelIntersect) {
    appendChildElement(renderer instanceof CanvasRenderer, parent, htmlObject, redraw, isAnimate, "x", "y", null, null, forceAnimate, false, null, animateDuration, false, option.labelRotation, transform, previousTransform);
  }
  return htmlObject;
}
function calculateSize(chart) {
  var containerWidth = chart.element.clientWidth || chart.element.offsetWidth;
  var containerHeight = chart.element.clientHeight;
  if (chart.stockChart) {
    containerWidth = chart.stockChart.availableSize.width;
    containerHeight = chart.stockChart.availableSize.height;
  }
  var height = 450;
  var marginHeight;
  if (chart.getModuleName() === "rangeNavigator") {
    var range = chart;
    var tooltipSpace = range.tooltip.enable ? 35 : 0;
    var periodHeight = range.periodSelectorSettings.periods.length ? range.periodSelectorSettings.height : 0;
    marginHeight = range.margin.top + range.margin.bottom + tooltipSpace;
    var labelSize = measureText("tempString", range.labelStyle, range.themeStyle.axisLabelFont).height;
    var labelPadding = 15;
    height = (chart.series.length ? Browser.isDevice ? 80 : 120 : (range.enableGrouping ? 40 + labelPadding + labelSize : 40) + marginHeight) + periodHeight;
    if (range.disableRangeSelector) {
      height = periodHeight;
    }
    if (chart.stockChart && chart.stockChart.chart && chart.stockChart.chart.axisCollections[1].labelPosition === "Outside") {
      var padding = chart.stockChart.chart.axisCollections[1].labelPadding + chart.stockChart.chart.axisCollections[1].lineStyle.width * 0.5;
      chart.width = (chart.stockChart.availableSize.width - (chart.stockChart.chart.axisCollections[1].maxLabelSize.width + padding)).toString();
    }
  }
  chart.availableSize = new Size(stringToNumber(chart.width, containerWidth) || containerWidth || 600, stringToNumber(chart.height, containerHeight || height) || containerHeight || height);
  if (chart.getModuleName() === "chart") {
    chart.scaleX = 1;
    chart.scaleY = 1;
  }
}
function createSvg(chart) {
  chart.canvasRender = new CanvasRenderer(chart.element.id);
  chart.renderer = chart.enableCanvas ? chart.canvasRender : new SvgRenderer(chart.element.id);
  calculateSize(chart);
  if (chart.stockChart && chart.getModuleName() === "chart") {
    chart.svgObject = chart.stockChart.chartObject;
  } else if (chart.stockChart && chart.getModuleName() === "rangeNavigator" && chart.stockChart.selectorObject) {
    chart.svgObject = chart.stockChart.selectorObject;
  } else {
    if (chart.enableCanvas) {
      chart.svgObject = chart.renderer.createCanvas({
        id: chart.element.id + "_canvas",
        width: chart.availableSize.width,
        height: chart.availableSize.height
      });
    } else {
      chart.svgObject = chart.renderer.createSvg({
        id: chart.element.id + "_svg",
        width: chart.availableSize.width,
        height: chart.availableSize.height
      });
    }
  }
  if (chart.enableCanvas) {
    chart.renderer.ctx.direction = chart.enableRtl ? "rtl" : "ltr";
  }
}
function getTitle(title, style, width, isRtlEnabled, themeFontStyle) {
  var titleCollection = [];
  switch (style.textOverflow) {
    case "Wrap":
      titleCollection = textWrap(title, width, style, isRtlEnabled, title.indexOf(" ") < 0 ? true : null, null, themeFontStyle);
      break;
    case "Trim":
      titleCollection.push(textTrim(width, title, style, isRtlEnabled, themeFontStyle));
      break;
    default:
      titleCollection.push(title);
      break;
  }
  return titleCollection;
}
function titlePositionX(rect, titleStyle) {
  var positionX;
  if (titleStyle.textAlignment === "Near") {
    positionX = rect.x;
  } else if (titleStyle.textAlignment === "Center") {
    positionX = rect.x + rect.width / 2;
  } else {
    positionX = rect.x + rect.width;
  }
  return positionX;
}
function textWrap(currentLabel, maximumWidth, font, isRtlEnabled, wrapAnyWhere, clip, themeFontStyle, maximumLabelHeight) {
  if (wrapAnyWhere) {
    return textWrapAnyWhere(currentLabel, maximumWidth, font, themeFontStyle);
  }
  var textCollection = currentLabel.split(" ");
  var label = "";
  var labelCollection = [];
  var text;
  var lineHeight = measureText("chartMeasureText", font, themeFontStyle).height;
  var textHeight = 0;
  for (var i = 0, len = textCollection.length; i < len; i++) {
    text = textCollection[i];
    if (measureText(label.concat(label === "" ? "" : " " + text), font, themeFontStyle).width < maximumWidth) {
      label = label.concat((label === "" ? "" : " ") + text);
    } else {
      if (label !== "") {
        textHeight += lineHeight;
        if (maximumLabelHeight && textHeight > maximumLabelHeight) {
          labelCollection[labelCollection.length - 1] += "...";
          return labelCollection;
        }
        labelCollection.push(clip ? label : textTrim(maximumWidth, label, font, isRtlEnabled, themeFontStyle));
        label = text;
      } else {
        textHeight += lineHeight;
        if (maximumLabelHeight && textHeight > maximumLabelHeight) {
          labelCollection[labelCollection.length - 1] += "...";
          return labelCollection;
        }
        labelCollection.push(clip ? text : textTrim(maximumWidth, text, font, isRtlEnabled, themeFontStyle));
      }
    }
    if (label && i === len - 1) {
      textHeight += lineHeight;
      if (maximumLabelHeight && textHeight > maximumLabelHeight) {
        labelCollection[labelCollection.length - 1] += "...";
        return labelCollection;
      }
      labelCollection.push(clip ? label : textTrim(maximumWidth, label, font, isRtlEnabled, themeFontStyle));
    }
  }
  return labelCollection;
}
function textWrapAnyWhere(currentLabel, maximumWidth, font, themeFontStyle) {
  var size = measureText(currentLabel, font, themeFontStyle).width;
  var labelCollection = [];
  if (size > maximumWidth) {
    var label = "";
    var startIndex = 0;
    var labelIndex = 1;
    while (labelIndex < currentLabel.length) {
      label = currentLabel.substring(startIndex, labelIndex);
      size = measureText(label, font, themeFontStyle).width;
      if (size < maximumWidth) {
        labelIndex++;
      } else if (size === maximumWidth) {
        startIndex = labelIndex;
        labelCollection.push(label);
        labelIndex++;
        label = "";
      } else if (size > maximumWidth) {
        label = label.slice(0, -1);
        startIndex = labelIndex - 1;
        labelCollection.push(label);
        label = "";
      }
    }
    if (label.length > 0) {
      labelCollection.push(label);
    }
  } else {
    labelCollection.push(currentLabel);
  }
  return labelCollection;
}
function getUnicodeText(text, regexp) {
  var title = text.replace(regexp, " ");
  var digit = text.match(regexp);
  var digitSpecific = " ";
  var convertedText = " ";
  var k = 0;
  var unicodeSub = {
    "0": "",
    "1": "",
    "2": "",
    "3": "",
    "4": "",
    "5": "",
    "6": "",
    "7": "",
    "8": "",
    "9": ""
  };
  var unicodeSup = {
    "0": "",
    "1": "",
    "2": "",
    "3": "",
    "4": "",
    "5": "",
    "6": "",
    "7": "",
    "8": "",
    "9": ""
  };
  for (var i = 0; i <= title.length - 1; i++) {
    if (title[i] === " ") {
      digitSpecific = regexp === regSub ? digit[k].replace(/~/g, "") : digit[k].replace(/\^/g, "");
      for (var j = 0; j < digitSpecific.length; j++) {
        convertedText += regexp === regSub ? unicodeSub[digitSpecific[j]] : unicodeSup[digitSpecific[j]];
      }
      k++;
    } else {
      convertedText += title[i];
    }
  }
  return convertedText.trim();
}
function blazorTemplatesReset(control) {
  for (var i = 0; i < control.annotations.length; i++) {
    resetBlazorTemplate((control.element.id + "_Annotation_" + i).replace(/[^a-zA-Z0-9]/g, ""), "ContentTemplate");
  }
  resetBlazorTemplate(control.element.id + "_tooltipparent_template_blazorTemplate", "Template");
  resetBlazorTemplate(control.element.id + "_DataLabel");
}
var CustomizeOption = (
  /** @class */
  /* @__PURE__ */ function() {
    function CustomizeOption2(id) {
      this.id = id;
    }
    return CustomizeOption2;
  }()
);
var StackValues = (
  /** @class */
  /* @__PURE__ */ function() {
    function StackValues2(startValue, endValue) {
      this.startValues = startValue;
      this.endValues = endValue;
    }
    return StackValues2;
  }()
);
var RectOption = (
  /** @class */
  function(_super) {
    __extends4(RectOption4, _super);
    function RectOption4(id, fill, border, opacity, rect, rx, ry, transform, dashArray) {
      var _this = _super.call(this, id, fill, border.width, border.color, opacity, dashArray) || this;
      _this.y = rect.y;
      _this.x = rect.x;
      _this.height = rect.height;
      _this.width = rect.width;
      _this.rx = rx ? rx : 0;
      _this.ry = ry ? ry : 0;
      _this.transform = transform ? transform : "";
      _this.stroke = border.width !== 0 && _this.stroke !== "" ? border.color === null ? "" : border.color : "transparent";
      return _this;
    }
    return RectOption4;
  }(PathOption)
);
var ImageOption = (
  /** @class */
  /* @__PURE__ */ function() {
    function ImageOption2(height, width, href, x, y, id, visibility, preserveAspectRatio) {
      this.height = height;
      this.width = width;
      this.href = href;
      this.x = x;
      this.y = y;
      this.id = id;
      this.visibility = visibility;
      this.preserveAspectRatio = preserveAspectRatio;
    }
    return ImageOption2;
  }()
);
var CircleOption = (
  /** @class */
  function(_super) {
    __extends4(CircleOption4, _super);
    function CircleOption4(id, fill, border, opacity, cx, cy, r) {
      var _this = _super.call(this, id, fill, border.width, border.color, opacity) || this;
      _this.cy = cy;
      _this.cx = cx;
      _this.r = r;
      return _this;
    }
    return CircleOption4;
  }(PathOption)
);
var PolygonOption = (
  /** @class */
  /* @__PURE__ */ function() {
    function PolygonOption2(id, points, fill) {
      this.id = id;
      this.points = points;
      this.fill = fill;
    }
    return PolygonOption2;
  }()
);
var ChartLocation = (
  /** @class */
  /* @__PURE__ */ function() {
    function ChartLocation2(x, y) {
      this.x = x;
      this.y = y;
    }
    return ChartLocation2;
  }()
);
var LabelLocation = (
  /** @class */
  /* @__PURE__ */ function() {
    function LabelLocation2(x, y) {
      this.x = 0;
      this.y = 0;
      this.x = x;
      this.y = y;
    }
    return LabelLocation2;
  }()
);
var Thickness = (
  /** @class */
  /* @__PURE__ */ function() {
    function Thickness2(left, right, top, bottom) {
      this.left = left;
      this.right = right;
      this.top = top;
      this.bottom = bottom;
    }
    return Thickness2;
  }()
);
var ColorValue = (
  /** @class */
  /* @__PURE__ */ function() {
    function ColorValue2(r, g, b) {
      this.r = r;
      this.g = g;
      this.b = b;
    }
    return ColorValue2;
  }()
);
var PointData = (
  /** @class */
  /* @__PURE__ */ function() {
    function PointData2(point, series, index) {
      if (index === void 0) {
        index = 0;
      }
      this.point = point;
      this.series = series;
      this.lierIndex = index;
    }
    return PointData2;
  }()
);
var AccPointData = (
  /** @class */
  /* @__PURE__ */ function() {
    function AccPointData2(point, series, index) {
      if (index === void 0) {
        index = 0;
      }
      this.point = point;
      this.series = series;
      this.index = index;
    }
    return AccPointData2;
  }()
);
var Point3D = (
  /** @class */
  /* @__PURE__ */ function() {
    function Point3D2(point, series) {
      this.point = point;
      this.series = series;
    }
    return Point3D2;
  }()
);
var ControlPoints = (
  /** @class */
  /* @__PURE__ */ function() {
    function ControlPoints2(controlPoint1, controlPoint2) {
      this.controlPoint1 = controlPoint1;
      this.controlPoint2 = controlPoint2;
    }
    return ControlPoints2;
  }()
);
function getColorByValue(colorMap, value) {
  var color = "";
  var rbgColorValue;
  if (Number(value) === colorMap.start) {
    color = colorMap.colors[0];
  } else if (Number(value) === colorMap.end) {
    color = colorMap.colors[colorMap.colors.length - 1];
  } else {
    rbgColorValue = getGradientColor(Number(value), colorMap);
    color = convertToHexCode(rbgColorValue);
  }
  return color;
}
function getGradientColor(value, colorMap) {
  var previousOffset = colorMap.start;
  var nextOffset = colorMap.end;
  var percent = 0;
  var full = nextOffset - previousOffset;
  var midColor;
  percent = (value - previousOffset) / full;
  var previousColor;
  var nextColor;
  if (colorMap.colors.length <= 2) {
    previousColor = colorMap.colors[0].charAt(0) === "#" ? colorMap.colors[0] : colorNameToHex(colorMap.colors[0]);
    nextColor = colorMap.colors[colorMap.colors.length - 1].charAt(0) === "#" ? colorMap.colors[colorMap.colors.length - 1] : colorNameToHex(colorMap.colors[colorMap.colors.length - 1]);
  } else {
    previousColor = colorMap.colors[0].charAt(0) === "#" ? colorMap.colors[0] : colorNameToHex(colorMap.colors[0]);
    nextColor = colorMap.colors[colorMap.colors.length - 1].charAt(0) === "#" ? colorMap.colors[colorMap.colors.length - 1] : colorNameToHex(colorMap.colors[colorMap.colors.length - 1]);
    var a = full / (colorMap.colors.length - 1);
    var b = void 0;
    var c = void 0;
    var length_2 = colorMap.colors.length - 1;
    var splitColorValueOffset = [];
    var splitColor = {};
    for (var j = 1; j < length_2; j++) {
      c = j * a;
      b = previousOffset + c;
      splitColor = {
        b,
        color: colorMap.colors[j]
      };
      splitColorValueOffset.push(splitColor);
    }
    for (var i = 0; i < splitColorValueOffset.length; i++) {
      if (previousOffset <= value && value <= splitColorValueOffset[i]["b"] && i === 0) {
        midColor = splitColorValueOffset[i]["color"].charAt(0) === "#" ? splitColorValueOffset[i]["color"] : colorNameToHex(splitColorValueOffset[i]["color"]);
        nextColor = midColor;
        percent = value <= splitColorValueOffset[i]["b"] ? 1 - Math.abs((value - splitColorValueOffset[i]["b"]) / a) : (value - splitColorValueOffset[i]["b"]) / a;
      } else if (splitColorValueOffset[i]["b"] <= value && value <= nextOffset && i === splitColorValueOffset.length - 1) {
        midColor = splitColorValueOffset[i]["color"].charAt(0) === "#" ? splitColorValueOffset[i]["color"] : colorNameToHex(splitColorValueOffset[i]["color"]);
        previousColor = midColor;
        percent = value < splitColorValueOffset[i]["b"] ? 1 - Math.abs((value - splitColorValueOffset[i]["b"]) / a) : (value - splitColorValueOffset[i]["b"]) / a;
      }
      if (i !== splitColorValueOffset.length - 1 && i < splitColorValueOffset.length) {
        if (splitColorValueOffset[i]["b"] <= value && value <= splitColorValueOffset[i + 1]["b"]) {
          midColor = splitColorValueOffset[i]["color"].charAt(0) === "#" ? splitColorValueOffset[i]["color"] : colorNameToHex(splitColorValueOffset[i]["color"]);
          previousColor = midColor;
          nextColor = splitColorValueOffset[i + 1]["color"].charAt(0) === "#" ? splitColorValueOffset[i + 1]["color"] : colorNameToHex(splitColorValueOffset[i + 1]["color"]);
          percent = Math.abs(value - splitColorValueOffset[i + 1]["b"]) / a;
        }
      }
    }
  }
  return getPercentageColor(percent, previousColor, nextColor);
}
function getPercentageColor(percent, previous, next) {
  var nextColor = next.split("#")[1];
  var prevColor = previous.split("#")[1];
  var r = getPercentage(percent, parseInt(prevColor.substr(0, 2), 16), parseInt(nextColor.substr(0, 2), 16));
  var g = getPercentage(percent, parseInt(prevColor.substr(2, 2), 16), parseInt(nextColor.substr(2, 2), 16));
  var b = getPercentage(percent, parseInt(prevColor.substr(4, 2), 16), parseInt(nextColor.substr(4, 2), 16));
  return new ColorValue(r, g, b);
}
function getPercentage(percent, previous, next) {
  var full = next - previous;
  return Math.round(previous + full * percent);
}
function getTextAnchor(alignment, enableRtl) {
  switch (alignment) {
    case "Near":
      return enableRtl ? "end" : "start";
    case "Far":
      return enableRtl ? "start" : "end";
    default:
      return "middle";
  }
}

// node_modules/@syncfusion/ej2-charts/src/chart/axis/double-axis.js
var Double = (
  /** @class */
  function() {
    function Double2(chart) {
      this.isColumn = 0;
      this.isStacking = false;
      this.chart = chart;
    }
    Double2.prototype.calculateNumericNiceInterval = function(axis, delta, size) {
      var actualDesiredIntervalsCount = getActualDesiredIntervalsCount(size, axis);
      var niceInterval = delta / actualDesiredIntervalsCount;
      if (!isNullOrUndefined(axis.desiredIntervals)) {
        if (this.isAutoIntervalOnBothAxis(axis)) {
          return niceInterval;
        }
      }
      var minInterval = Math.pow(10, Math.floor(logBase(niceInterval, 10)));
      for (var _i = 0, _a = axis.intervalDivs; _i < _a.length; _i++) {
        var interval = _a[_i];
        var currentInterval = minInterval * interval;
        if (actualDesiredIntervalsCount < delta / currentInterval) {
          break;
        }
        niceInterval = currentInterval;
      }
      return niceInterval;
    };
    Double2.prototype.isAutoIntervalOnBothAxis = function(axis) {
      if ((axis.zoomFactor < 1 || axis.zoomPosition > 0) && axis.enableAutoIntervalOnZooming) {
        return false;
      } else {
        return true;
      }
    };
    Double2.prototype.getActualRange = function(axis, size) {
      this.initializeDoubleRange(axis);
      if (!axis.startFromZero && this.isColumn > 0) {
        axis.actualRange.interval = axis.interval || this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);
        axis.actualRange.max = axis.doubleRange.end + axis.actualRange.interval;
        if (axis.doubleRange.start - axis.actualRange.interval < 0 && axis.doubleRange.start > 0) {
          axis.actualRange.min = 0;
        } else {
          axis.actualRange.min = axis.doubleRange.start - (this.isStacking ? 0 : axis.actualRange.interval);
        }
      } else {
        axis.actualRange.interval = axis.interval || this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);
        axis.actualRange.min = axis.doubleRange.start;
        axis.actualRange.max = axis.doubleRange.end;
      }
    };
    Double2.prototype.initializeDoubleRange = function(axis) {
      if (axis.minimum !== null) {
        this.min = axis.minimum;
      } else if (this.min === null || this.min === Number.POSITIVE_INFINITY) {
        this.min = 0;
      }
      if (axis.maximum !== null) {
        this.max = axis.maximum;
      } else if (this.max === null || this.max === Number.NEGATIVE_INFINITY) {
        this.max = 5;
      }
      if (this.min === this.max) {
        this.max = axis.valueType.indexOf("Category") > -1 ? this.max : this.min + 1;
      }
      axis.doubleRange = new DoubleRange(this.min, this.max);
      axis.actualRange = {};
    };
    Double2.prototype.calculateRangeAndInterval = function(size, axis) {
      this.calculateRange(axis);
      this.getActualRange(axis, size);
      this.applyRangePadding(axis, size);
      this.calculateVisibleLabels(axis, this.chart);
    };
    Double2.prototype.calculateRange = function(axis) {
      this.min = null;
      this.max = null;
      if (!setRange(axis)) {
        for (var _i = 0, _a = axis.series; _i < _a.length; _i++) {
          var series = _a[_i];
          if (!series.visible) {
            continue;
          }
          this.paddingInterval = 0;
          if (!isNullOrUndefined(series.points)) {
            axis.maxPointLength = series.points.length;
          }
          axis.maxPointLength = series.points.length;
          if ((series.type.indexOf("Column") > -1 || series.type.indexOf("Histogram") > -1) && axis.orientation === "Horizontal" || series.type.indexOf("Bar") > -1 && axis.orientation === "Vertical") {
            if ((series.xAxis.valueType === "Double" || series.xAxis.valueType === "DateTime") && series.xAxis.rangePadding === "Auto") {
              this.paddingInterval = getMinPointsDelta(series.xAxis, axis.series) * 0.5;
            }
          }
          if (axis.orientation === "Horizontal") {
            if (this.chart.requireInvertedAxis) {
              this.yAxisRange(axis, series);
            } else {
              this.findMinMax(series.xMin - this.paddingInterval, series.xMax + this.paddingInterval);
            }
          }
          if (axis.orientation === "Vertical") {
            this.isColumn += series.type.indexOf("Column") !== -1 || series.type.indexOf("Bar") !== -1 || series.drawType === "Column" ? 1 : 0;
            this.isStacking = series.type.indexOf("Stacking") !== -1;
            if (this.chart.requireInvertedAxis) {
              this.findMinMax(series.xMin - this.paddingInterval, series.xMax + this.paddingInterval);
            } else {
              this.yAxisRange(axis, series);
            }
          }
        }
      }
    };
    Double2.prototype.yAxisRange = function(axis, series) {
      if (series.dragSettings.enable && this.chart.dragY) {
        if (this.chart.dragY >= axis.visibleRange.max) {
          series.yMax = this.chart.dragY + axis.visibleRange.interval;
        }
        if (this.chart.dragY <= axis.visibleRange.min) {
          series.yMin = this.chart.dragY - axis.visibleRange.interval;
        }
      }
      if (series.type === "Waterfall") {
        var cumulativeMax = 0;
        var cumulativeValue = 0;
        for (var i = 0; i < series.yData.length; i++) {
          if (!(series.intermediateSumIndexes && series.intermediateSumIndexes.indexOf(i) !== -1) && !(series.sumIndexes && series.sumIndexes.indexOf(i) !== -1)) {
            cumulativeValue += series.yData[i];
          }
          if (cumulativeValue > cumulativeMax) {
            cumulativeMax = cumulativeValue;
          }
        }
        this.findMinMax(series.yMin, cumulativeMax);
      } else {
        this.findMinMax(series.yMin, series.yMax);
      }
    };
    Double2.prototype.findMinMax = function(min, max) {
      if (this.min === null || this.min > min) {
        this.min = min;
      }
      if (this.max === null || this.max < max) {
        this.max = max;
      }
      if (this.max === this.min && this.max < 0 && this.min < 0) {
        this.max = 0;
      }
    };
    Double2.prototype.applyRangePadding = function(axis, size) {
      var start = axis.actualRange.min;
      var end = axis.actualRange.max;
      if (!setRange(axis)) {
        var interval = axis.actualRange.interval;
        var padding = axis.getRangePadding(this.chart);
        if (padding === "Additional" || padding === "Round") {
          this.findAdditional(axis, start, end, interval, size);
        } else if (padding === "Normal") {
          this.findNormal(axis, start, end, interval, size);
        } else {
          this.updateActualRange(axis, start, end, interval);
        }
      }
      axis.actualRange.delta = axis.actualRange.max - axis.actualRange.min;
      this.calculateVisibleRange(size, axis);
    };
    Double2.prototype.updateActualRange = function(axis, minimum, maximum, interval) {
      axis.actualRange = {
        min: axis.minimum != null ? axis.minimum : minimum,
        max: axis.maximum != null ? axis.maximum : maximum,
        interval: axis.interval != null ? axis.interval : interval,
        delta: axis.actualRange.delta
      };
    };
    Double2.prototype.findAdditional = function(axis, start, end, interval, size) {
      var minimum;
      var maximum;
      minimum = Math.floor(start / interval) * interval;
      maximum = Math.ceil(end / interval) * interval;
      if (axis.rangePadding === "Additional") {
        minimum -= interval;
        maximum += interval;
      }
      if (!isNullOrUndefined(axis.desiredIntervals)) {
        var delta = maximum - minimum;
        interval = this.calculateNumericNiceInterval(axis, delta, size);
      }
      this.updateActualRange(axis, minimum, maximum, interval);
    };
    Double2.prototype.findNormal = function(axis, start, end, interval, size) {
      var remaining;
      var minimum;
      var maximum;
      var startValue = start;
      if (start < 0) {
        startValue = 0;
        minimum = start + start * 0.05;
        remaining = interval + minimum % interval;
        if (0.365 * interval >= remaining) {
          minimum -= interval;
        }
        if (minimum % interval < 0) {
          minimum = minimum - interval - minimum % interval;
        }
      } else {
        minimum = start < 5 / 6 * end ? 0 : start - (end - start) * 0.5;
        if (minimum % interval > 0) {
          minimum -= minimum % interval;
        }
      }
      maximum = end > 0 ? end + (end - startValue) * 0.05 : end - (end - startValue) * 0.05;
      remaining = interval - maximum % interval;
      if (0.365 * interval >= remaining) {
        maximum += interval;
      }
      if (maximum % interval > 0) {
        maximum = maximum + interval - maximum % interval;
      }
      axis.doubleRange = new DoubleRange(minimum, maximum);
      if (minimum === 0 || minimum < 0 && maximum < 0) {
        interval = this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);
        maximum = Math.ceil(maximum / interval) * interval;
      }
      this.updateActualRange(axis, minimum, maximum, interval);
    };
    Double2.prototype.calculateVisibleRange = function(size, axis) {
      axis.visibleRange = {
        max: axis.actualRange.max,
        min: axis.actualRange.min,
        delta: axis.actualRange.delta,
        interval: axis.actualRange.interval
      };
      if (this.chart.chartAreaType === "Cartesian") {
        var isLazyLoad = isNullOrUndefined(axis.zoomingScrollBar) ? false : axis.zoomingScrollBar.isLazyLoad;
        if ((axis.zoomFactor < 1 || axis.zoomPosition > 0) && !isLazyLoad) {
          axis.calculateVisibleRangeOnZooming();
          axis.visibleRange.interval = axis.enableAutoIntervalOnZooming ? this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size) : axis.visibleRange.interval;
        }
      }
      var rangeDifference = (axis.visibleRange.max - axis.visibleRange.min) % axis.visibleRange.interval;
      if (rangeDifference !== 0 && !isNaN(rangeDifference) && axis.valueType === "Double" && axis.orientation === "Vertical" && axis.rangePadding === "Auto") {
        var duplicateTempInterval = void 0;
        var tempInterval = axis.visibleRange.min;
        for (; tempInterval <= axis.visibleRange.max && duplicateTempInterval !== tempInterval; tempInterval += axis.visibleRange.interval) {
          duplicateTempInterval = tempInterval;
        }
        if (duplicateTempInterval < axis.visibleRange.max) {
          axis.visibleRange.max = duplicateTempInterval + axis.visibleRange.interval;
        }
      }
      axis.triggerRangeRender(this.chart, axis.visibleRange.min, axis.visibleRange.max, axis.visibleRange.interval);
    };
    Double2.prototype.calculateVisibleLabels = function(axis, chart) {
      axis.visibleLabels = [];
      var tempInterval = axis.visibleRange.min;
      var labelStyle;
      var controlName = chart.getModuleName();
      var isPolarRadar = controlName === "chart" && chart.chartAreaType === "PolarRadar";
      if (!isPolarRadar && (axis.zoomFactor < 1 || axis.zoomPosition > 0 || this.paddingInterval)) {
        tempInterval = axis.visibleRange.min - axis.visibleRange.min % axis.visibleRange.interval;
      }
      var format = this.getFormat(axis);
      var isCustom = format.match("{value}") !== null;
      var intervalDigits = 0;
      var formatDigits = 0;
      if (axis.labelFormat && axis.labelFormat.indexOf("n") > -1) {
        formatDigits = parseInt(axis.labelFormat.substring(1, axis.labelFormat.length), 10);
      }
      axis.format = chart.intl.getNumberFormat({
        format: isCustom ? "" : format,
        useGrouping: chart.useGroupingSeparator
      });
      axis.startLabel = axis.format(axis.visibleRange.min);
      axis.endLabel = axis.format(axis.visibleRange.max);
      if (axis.visibleRange.interval && (axis.visibleRange.interval + "").indexOf(".") >= 0) {
        intervalDigits = (axis.visibleRange.interval + "").split(".")[1].length;
      }
      var duplicateTempInterval;
      for (; tempInterval <= axis.visibleRange.max && duplicateTempInterval !== tempInterval; tempInterval += axis.visibleRange.interval) {
        duplicateTempInterval = tempInterval;
        labelStyle = extend({}, getValue("properties", axis.labelStyle), null, true);
        if (withIn(tempInterval, axis.visibleRange)) {
          triggerLabelRender(chart, tempInterval, this.formatValue(axis, isCustom, format, tempInterval), labelStyle, axis);
        }
      }
      if (tempInterval && (tempInterval + "").indexOf(".") >= 0 && (tempInterval + "").split(".")[1].length > 10) {
        tempInterval = (tempInterval + "").split(".")[1].length > (formatDigits || intervalDigits) ? +tempInterval.toFixed(formatDigits || intervalDigits) : tempInterval;
        if (tempInterval <= axis.visibleRange.max) {
          triggerLabelRender(chart, tempInterval, this.formatValue(axis, isCustom, format, tempInterval), labelStyle, axis);
        }
      }
      if (axis.getMaxLabelWidth) {
        axis.getMaxLabelWidth(this.chart);
      }
    };
    Double2.prototype.getFormat = function(axis) {
      if (axis.labelFormat) {
        if (axis.labelFormat.indexOf("p") === 0 && axis.labelFormat.indexOf("{value}") === -1 && axis.isStack100) {
          return "{value}%";
        }
        return axis.labelFormat;
      }
      return axis.isStack100 ? "{value}%" : "";
    };
    Double2.prototype.formatValue = function(axis, isCustom, format, tempInterval) {
      var labelValue = !(tempInterval % 1) ? tempInterval : Number(tempInterval.toLocaleString("en-US").split(",").join(""));
      return isCustom ? format.replace("{value}", axis.format(labelValue)) : format ? axis.format(tempInterval) : axis.format(labelValue);
    };
    Double2.prototype.getModuleName = function() {
      return "Double";
    };
    Double2.prototype.destroy = function() {
    };
    return Double2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/common/model/theme.js
var stockEventFont = {
  size: "13px",
  fontWeight: "400",
  color: null,
  fontStyle: "Normal",
  fontFamily: "Segoe UI"
};
function getSeriesColor(theme) {
  var palette;
  switch (theme) {
    case "Fabric":
      palette = ["#4472c4", "#ed7d31", "#ffc000", "#70ad47", "#5b9bd5", "#c1c1c1", "#6f6fe2", "#e269ae", "#9e480e", "#997300"];
      break;
    case "Bootstrap4":
      palette = ["#a16ee5", "#f7ce69", "#55a5c2", "#7ddf1e", "#ff6ea6", "#7953ac", "#b99b4f", "#407c92", "#5ea716", "#b91c52"];
      break;
    case "Bootstrap":
      palette = ["#a16ee5", "#f7ce69", "#55a5c2", "#7ddf1e", "#ff6ea6", "#7953ac", "#b99b4f", "#407c92", "#5ea716", "#b91c52"];
      break;
    case "HighContrastLight":
    case "HighContrast":
      palette = ["#79ECE4", "#E98272", "#DFE6B6", "#C6E773", "#BA98FF", "#FA83C3", "#00C27A", "#43ACEF", "#D681EF", "#D8BC6E"];
      break;
    case "MaterialDark":
      palette = ["#9ECB08", "#56AEFF", "#C57AFF", "#61EAA9", "#EBBB3E", "#F45C5C", "#8A77FF", "#63C7FF", "#FF84B0", "#F7C928"];
      break;
    case "FabricDark":
      palette = ["#4472c4", "#ed7d31", "#ffc000", "#70ad47", "#5b9bd5", "#c1c1c1", "#6f6fe2", "#e269ae", "#9e480e", "#997300"];
      break;
    case "BootstrapDark":
      palette = ["#a16ee5", "#f7ce69", "#55a5c2", "#7ddf1e", "#ff6ea6", "#7953ac", "#b99b4f", "#407c92", "#5ea716", "#b91c52"];
      break;
    case "Tailwind3":
      palette = ["#2F4074", "#03B4B4", "#0D72DE", "#FF5733", "#D63384", "#F39C12", "#EF291F", "#91C822"];
      break;
    case "Tailwind3Dark":
      palette = ["#8029F1", "#1ABC9C", "#0D72DE", "#FF5733", "#D63384", "#F39C12", "#EF291F", "#91C822"];
      break;
    case "Tailwind":
      palette = ["#5A61F6", "#65A30D", "#334155", "#14B8A6", "#8B5CF6", "#0369A1", "#F97316", "#9333EA", "#F59E0B", "#15803D"];
      break;
    case "TailwindDark":
      palette = ["#8B5CF6", "#22D3EE", "#F87171", "#4ADE80", "#E879F9", "#FCD34D", "#F97316", "#2DD4BF", "#F472B6", "#10B981"];
      break;
    case "Bootstrap5Dark":
    case "Bootstrap5":
      palette = ["#FD7E14", "#6610F2", "#6F42C1", "#D63384", "#DC3545", "#FFC107", "#198754", "#0DCAF0"];
      break;
    case "FluentDark":
      palette = ["#1AC9E6", "#DA4CB2", "#EDBB40", "#AF4BCF", "#FF7266", "#1BD565", "#EE993D", "#5887FF", "#EC548D", "#7D39C0"];
      break;
    case "Fluent":
      palette = ["#1AC9E6", "#DA4CB2", "#EDBB40", "#AF4BCF", "#FF7266", "#1BD565", "#EE993D", "#5887FF", "#EC548D", "#7D39C0"];
      break;
    case "Fluent2":
      palette = ["#6200EE", "#09AF74", "#0076E5", "#CB3587", "#E7910F", "#0364DE", "#66CD15", "#F3A93C", "#107C10", "#C19C00"];
      break;
    case "Fluent2Dark":
      palette = ["#9BB449", "#2A72D5", "#43B786", "#3F579A", "#584EC6", "#E85F9C", "#6E7A89", "#EA6266", "#0B6A0B", "#C19C00"];
      break;
    case "Fluent2HighContrast":
      palette = ["#9BB449", "#2A72D5", "#43B786", "#3F579A", "#584EC6", "#E85F9C", "#6E7A89", "#EA6266", "#0B6A0B", "#C19C00"];
      break;
    case "Material3":
      palette = ["#6355C7", "#00AEE0", "#FFB400", "#F7523F", "#963C70", "#FD7400", "#4BE0BC", "#2196F5", "#DE3D8A", "#162F88"];
      break;
    case "Material3Dark":
      palette = ["#4EAAFF", "#FA4EAB", "#FFF500", "#17EA58", "#38FFE7", "#FF9E45", "#B3F32F", "#B93CE4", "#FC5664", "#9B55FF"];
      break;
    default:
      palette = ["#00bdae", "#404041", "#357cd2", "#e56590", "#f8b883", "#70ad47", "#dd8abd", "#7f84e8", "#7bb4eb", "#ea7a57"];
      break;
  }
  return palette;
}
function getThemeColor(theme, canvas, chart) {
  var style;
  var darkBackground = theme === "MaterialDark" ? "#383838" : theme === "FabricDark" ? "#242424" : "#1b1b1b";
  switch (theme) {
    case "HighContrastLight":
    case "HighContrast":
      style = {
        axisLabel: "#ffffff",
        axisTitle: "#ffffff",
        axisLine: "#ffffff",
        majorGridLine: "#BFBFBF",
        minorGridLine: "#969696",
        majorTickLine: "#BFBFBF",
        minorTickLine: "#969696",
        chartTitle: "#ffffff",
        legendLabel: "#ffffff",
        background: canvas ? "#000000" : "transparent",
        areaBorder: "#ffffff",
        errorBar: "#ffffff",
        crosshairLine: "#ffffff",
        crosshairBackground: "rgba(255, 255, 255, 0.1)",
        crosshairFill: "#ffffff",
        crosshairLabel: "#000000",
        tooltipFill: "#ffffff",
        tooltipBoldLabel: "#000000",
        tooltipLightLabel: "#000000",
        tooltipHeaderLine: "#969696",
        markerShadow: "#BFBFBF",
        selectionRectFill: "rgba(255, 217, 57, 0.3)",
        selectionRectStroke: "#ffffff",
        selectionCircleStroke: "#FFD939",
        tabColor: "#FFD939",
        bearFillColor: "#2ecd71",
        bullFillColor: "#e74c3d",
        toolkitSelectionColor: "#FFD939",
        toolkitFill: "#737373",
        toolkitIconRectOverFill: "transparent",
        toolkitIconRectSelectionFill: "transparent",
        toolkitIconRect: new Rect(0, 0, 16, 16),
        chartTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: "#969696",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#969696",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#000000",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        datalabelFont: {
          color: "#969696",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        crosshairLabelFont: {
          color: "#000000",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        stripLineLabelFont: {
          color: "#969696",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "MaterialDark":
    case "FabricDark":
    case "BootstrapDark":
      style = {
        axisLabel: "#DADADA",
        axisTitle: "#ffffff",
        axisLine: " #6F6C6C",
        majorGridLine: "#414040",
        minorGridLine: "#514F4F",
        majorTickLine: "#414040",
        minorTickLine: " #4A4848",
        chartTitle: "#ffffff",
        legendLabel: "#DADADA",
        background: canvas ? darkBackground : "transparent",
        areaBorder: " #9A9A9A",
        errorBar: "#ffffff",
        crosshairLine: "#F4F4F4",
        crosshairBackground: "rgba(255, 255, 255, 0.1)",
        crosshairFill: theme === "MaterialDark" ? "#F4F4F4" : theme === "FabricDark" ? "#A19F9D" : "#F0F0F0",
        crosshairLabel: "#282727",
        tooltipFill: "#F4F4F4",
        tooltipBoldLabel: "#282727",
        tooltipLightLabel: "#333232",
        tooltipHeaderLine: "#9A9A9A",
        markerShadow: null,
        selectionRectFill: "rgba(56,169,255, 0.1)",
        selectionRectStroke: "#38A9FF",
        selectionCircleStroke: "#282727",
        tabColor: theme === "MaterialDark" ? "#00B0FF" : theme === "FabricDark" ? "#0074CC" : "#0070F0",
        bearFillColor: "#2ecd71",
        bullFillColor: "#e74c3d",
        toolkitSelectionColor: theme === "MaterialDark" ? "#00B0FF" : theme === "FabricDark" ? "#0074CC" : "#0070F0",
        toolkitFill: "#737373",
        toolkitIconRectOverFill: "transparent",
        toolkitIconRectSelectionFill: "transparent",
        toolkitIconRect: new Rect(0, 0, 16, 16),
        chartTitleFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.87)" : theme === "FabricDark" ? "#DADADA" : "#FFFFFF",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.6)" : theme === "FabricDark" ? "#A19F9D" : "#CED4DA",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.87)" : theme === "FabricDark" ? "#DADADA" : "#FFFFFF",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.6)" : theme === "FabricDark" ? "#A19F9D" : "#676767",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: theme === "MaterialDark" ? "rgba(18, 18, 18, 1)" : theme === "FabricDark" ? "#DADADA" : "#1A1A1A",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.87)" : theme === "FabricDark" ? "#DADADA" : "#FFFFFF",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        datalabelFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.6)" : theme === "FabricDark" ? "#A19F9D" : "#676767",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.87)" : theme === "FabricDark" ? "#DADADA" : "#FFFFFF",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        crosshairLabelFont: {
          color: theme === "MaterialDark" ? "rgba(18, 18, 18, 1)" : theme === "FabricDark" ? "#DADADA" : "#1A1A1A",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        stripLineLabelFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.24)" : theme === "FabricDark" ? "#6F6C6C" : "#414141",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Bootstrap4":
      style = {
        axisLabel: "#212529",
        axisTitle: "#212529",
        axisLine: "#CED4DA",
        majorGridLine: "#CED4DA",
        minorGridLine: "#DEE2E6",
        majorTickLine: "#ADB5BD",
        minorTickLine: "#CED4DA",
        chartTitle: "#212529",
        legendLabel: "#212529",
        background: canvas ? "#FFFFFF" : "transparent",
        areaBorder: "#DEE2E6",
        errorBar: "#000000",
        crosshairLine: "#6C757D",
        crosshairBackground: "rgba(0, 0, 0, 0.1)",
        crosshairFill: "#212529",
        crosshairLabel: "#FFFFFF",
        tooltipFill: "#020202",
        tooltipBoldLabel: "rgba(255,255,255)",
        tooltipLightLabel: "rgba(255,255,255, 0.9)",
        tooltipHeaderLine: "rgba(255,255,255, 0.2)",
        markerShadow: null,
        selectionRectFill: "rgba(255,255,255, 0.1)",
        selectionRectStroke: "rgba(0, 123, 255)",
        selectionCircleStroke: "#495057",
        tabColor: "#007BFF",
        bearFillColor: "#2ecd71",
        bullFillColor: "#e74c3d",
        toolkitSelectionColor: "#007BFF",
        toolkitFill: "#495057",
        toolkitIconRectOverFill: "transparent",
        toolkitIconRectSelectionFill: "transparent",
        toolkitIconRect: new Rect(-5, -5, 26, 26),
        chartTitleFont: {
          color: "#212529",
          fontFamily: "Helvetica",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: "#495057",
          fontFamily: "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#212529",
          fontFamily: "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#666666",
          fontFamily: "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#F9FAFB",
          fontFamily: "Helvetica",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#212529",
          fontFamily: "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        datalabelFont: {
          color: "#495057",
          fontFamily: "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#212529",
          fontFamily: "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        crosshairLabelFont: {
          color: "#F9FAFB",
          fontFamily: "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        stripLineLabelFont: {
          color: "#6C757D",
          fontFamily: "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Tailwind3":
      style = {
        axisLabel: "#4B5563",
        axisTitle: "#6B7280",
        axisLine: "#D1D5DB",
        majorGridLine: "#E5E7EB",
        minorGridLine: "#E5E7EB",
        majorTickLine: "#D1D5DB",
        minorTickLine: "#D1D5DB",
        chartTitle: "#111827",
        legendLabel: "#4B5563",
        background: canvas ? "rgba(255,255,255, 0.0)" : "transparent",
        areaBorder: "#D1D5DB",
        errorBar: "#1F2937",
        crosshairLine: "#1F2937",
        crosshairBackground: "rgba(107, 114, 128, 0.1)",
        crosshairFill: "#111827",
        crosshairLabel: "#F9FAFB",
        tooltipFill: "#111827",
        tooltipBoldLabel: "#F9FAFB",
        tooltipLightLabel: "#F9FAFB",
        tooltipHeaderLine: "#D1D5DB",
        markerShadow: null,
        selectionRectFill: "rgba(224, 231, 255, 0.25)",
        selectionRectStroke: "#4F46E5",
        selectionCircleStroke: "#6B7280",
        tabColor: "#4F46E5",
        bearFillColor: "#EF291F",
        bullFillColor: "#0D72DE",
        toolkitSelectionColor: "#212529",
        toolkitFill: "#6B7280",
        toolkitIconRectOverFill: "#F9FAFB",
        toolkitIconRectSelectionFill: "#F3F4F6",
        toolkitIconRect: new Rect(-6, -8, 32, 32),
        chartTitleFont: {
          color: "#111827",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        axisLabelFont: {
          color: "#4B5563",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#374151",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        legendLabelFont: {
          color: "#4B5563",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        tooltipLabelFont: {
          color: "#F9FAFB",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#6B7280",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        datalabelFont: {
          color: "#111827",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#6B7280",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        crosshairLabelFont: {
          color: "#F9FAFB",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        stripLineLabelFont: {
          color: "#374151",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Tailwind3Dark":
      style = {
        axisLabel: "#D1D5DB",
        axisTitle: "#9CA3AF",
        axisLine: " #374151",
        majorGridLine: "#282F3C",
        minorGridLine: "#282F3C",
        majorTickLine: "#374151",
        minorTickLine: " #374151",
        chartTitle: "#FFFFFF",
        legendLabel: "#D1D5DB",
        background: canvas ? "#1f2937" : "transparent",
        areaBorder: " #374151",
        errorBar: "#6B7280",
        crosshairLine: "#6B7280",
        crosshairBackground: "rgba(107, 114, 128, 0.1)",
        crosshairFill: "#F9FAFB",
        crosshairLabel: "#1F2937",
        tooltipFill: "#F9FAFB",
        tooltipBoldLabel: "#1F2937",
        tooltipLightLabel: "#1F2937",
        tooltipHeaderLine: "#374151",
        markerShadow: null,
        selectionRectFill: "rgba(30, 27, 75, 0.25)",
        selectionRectStroke: "#6366F1",
        selectionCircleStroke: "#282727",
        tabColor: "#22D3EE",
        bearFillColor: "#EF291F",
        bullFillColor: "#0D72DE",
        toolkitSelectionColor: "#FFFFFF",
        toolkitFill: "#FFFFFF",
        toolkitIconRectOverFill: "#242A38",
        toolkitIconRectSelectionFill: "#242A38",
        toolkitIconRect: new Rect(-6, -8, 32, 32),
        chartTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        axisLabelFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#E5E7EB",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        legendLabelFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        tooltipLabelFont: {
          color: "#1F2937",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#9CA3AF",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        datalabelFont: {
          color: "#FFFFFF",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#9CA3AF",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        crosshairLabelFont: {
          color: "#1F2937",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        stripLineLabelFont: {
          color: "#E5E7EB",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Tailwind":
      style = {
        axisLabel: "#6B728",
        axisTitle: "#374151",
        axisLine: " #D1D5DB",
        majorGridLine: "#E5E7EB",
        minorGridLine: "#E5E7EB",
        majorTickLine: "#D1D5DB",
        minorTickLine: " #D1D5DB",
        chartTitle: "#374151",
        legendLabel: "#374151",
        background: canvas ? "rgba(255,255,255, 0.0)" : "transparent",
        areaBorder: " #E5E7EB",
        errorBar: "#374151",
        crosshairLine: "#1F2937",
        crosshairBackground: "rgba(90, 97, 246, 0.1)",
        crosshairFill: "#111827",
        crosshairLabel: "#F9FAFB",
        tooltipFill: "#111827",
        tooltipBoldLabel: "#D1D5DB",
        tooltipLightLabel: "#F9FAFB",
        tooltipHeaderLine: "#6B7280",
        markerShadow: null,
        selectionRectFill: "rgba(79,70,229, 0.1)",
        selectionRectStroke: "#4F46E5",
        selectionCircleStroke: "#6B7280",
        tabColor: "#4F46E5",
        bearFillColor: "#2ecd71",
        bullFillColor: "#e74c3d",
        toolkitSelectionColor: "#4F46E5",
        toolkitFill: "#6B7280",
        toolkitIconRectOverFill: "transparent",
        toolkitIconRectSelectionFill: "transparent",
        toolkitIconRect: new Rect(0, 0, 16, 16),
        chartTitleFont: {
          color: "#374151",
          fontFamily: "Inter",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: "#6B7280",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#374151",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#374151",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#F9FAFB",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#374151",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        datalabelFont: {
          color: "#6B7280",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#374151",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        crosshairLabelFont: {
          color: "#F9FAFB",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        stripLineLabelFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "TailwindDark":
      style = {
        axisLabel: "#9CA3AF",
        axisTitle: "#9CA3AF",
        axisLine: " #4B5563",
        majorGridLine: "#374151",
        minorGridLine: "#374151",
        majorTickLine: "#4B5563",
        minorTickLine: " #4B5563",
        chartTitle: "#D1D5DB",
        legendLabel: "#D1D5DB",
        background: canvas ? "#1f2937" : "transparent",
        areaBorder: " #374151",
        errorBar: "#ffffff",
        crosshairLine: "#9CA3AF",
        crosshairBackground: "rgba(90, 97, 246, 0.1)",
        crosshairFill: "#F9FAFB",
        crosshairLabel: "#1F2937",
        tooltipFill: "#F9FAFB",
        tooltipBoldLabel: "#6B7280",
        tooltipLightLabel: "#1F2937",
        tooltipHeaderLine: "#9CA3AF",
        markerShadow: null,
        selectionRectFill: "rgba(34,211,238, 0.1)",
        selectionRectStroke: "#22D3EE",
        selectionCircleStroke: "#282727",
        tabColor: "#22D3EE",
        bearFillColor: "#2ecd71",
        bullFillColor: "#e74c3d",
        toolkitSelectionColor: "#22D3EE",
        toolkitFill: "#D1D5DB",
        toolkitIconRectOverFill: "transparent",
        toolkitIconRectSelectionFill: "transparent",
        toolkitIconRect: new Rect(0, 0, 16, 16),
        chartTitleFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: "#9CA3AF",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#1F2937",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        datalabelFont: {
          color: "#9CA3AF",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        crosshairLabelFont: {
          color: "#1F2937",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        stripLineLabelFont: {
          color: "#6B7280",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Bootstrap5":
      style = {
        axisLabel: "#212529",
        axisTitle: "#212529",
        axisLine: "#DEE2E6",
        majorGridLine: "#E9ECEF",
        minorGridLine: "#E9ECEF",
        majorTickLine: "#DEE2E6",
        minorTickLine: "#E9ECEF",
        chartTitle: "#212529",
        legendLabel: "#212529",
        background: canvas ? "#212529" : "transparent",
        areaBorder: "#E9ECEF",
        errorBar: "#343A40",
        crosshairLine: "#343A40",
        crosshairBackground: "rgba(52, 58, 64, 0.1)",
        crosshairFill: "#000000",
        crosshairLabel: "#FFFFFF",
        tooltipFill: "#E9ECEF",
        tooltipBoldLabel: "#FFFFFF",
        tooltipLightLabel: "#FFFFFF",
        tooltipHeaderLine: "#FFFFFF",
        markerShadow: null,
        selectionRectFill: "rgba(134,183,254, 0.1)",
        selectionRectStroke: "#0D6EFD",
        selectionCircleStroke: "#6B7280",
        tabColor: "#0D6EFD",
        bearFillColor: "#DC3545",
        bullFillColor: "#6F42C1",
        toolkitSelectionColor: "#6E757D",
        toolkitFill: "#6E757D",
        toolkitIconRectOverFill: "#F8F9FA",
        toolkitIconRectSelectionFill: "#F8F9FA",
        toolkitIconRect: new Rect(-6, -8, 32, 32),
        chartTitleFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: chart.getModuleName() === "accumulationchart" ? "16px" : "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        datalabelFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: chart.getModuleName() === "accumulationchart" ? "#21252980" : "#212529",
          fontFamily: "Segoe UI",
          size: chart.getModuleName() === "accumulationchart" ? "14px" : "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        crosshairLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        stripLineLabelFont: {
          color: "#6C757D",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Bootstrap5Dark":
      style = {
        axisLabel: "#DEE2E6",
        axisTitle: "#DEE2E6",
        axisLine: "#495057",
        majorGridLine: "#343A40",
        minorGridLine: "#343A40",
        majorTickLine: "#495057",
        minorTickLine: "#343A40",
        chartTitle: "#DEE2E6",
        legendLabel: "#DEE2E6",
        background: canvas ? "#212529" : "transparent",
        areaBorder: "#343A40",
        errorBar: "#ADB5BD",
        crosshairLine: "#ADB5BD",
        crosshairBackground: "rgba(138, 136, 134, 0.1)",
        crosshairFill: "#FFFFFF",
        crosshairLabel: "#212529",
        tooltipFill: "#FFFFFF",
        tooltipBoldLabel: "#212529",
        tooltipLightLabel: "#212529",
        tooltipHeaderLine: "#212529",
        markerShadow: null,
        selectionRectFill: "rgba(134,183,254, 0.25)",
        selectionRectStroke: "#0D6EFD",
        selectionCircleStroke: "#0D6EFD",
        tabColor: "#0D6EFD",
        bearFillColor: "#DC3545",
        bullFillColor: "#6F42C1",
        toolkitSelectionColor: "#F8F9FA",
        toolkitFill: "#ADB5BD",
        toolkitIconRectOverFill: "#2B3035",
        toolkitIconRectSelectionFill: "#343A40",
        toolkitIconRect: new Rect(-6, -8, 32, 32),
        chartTitleFont: {
          color: "#DEE2E6",
          fontFamily: "Segoe UI",
          size: chart.getModuleName() === "accumulationchart" ? "16px" : "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: "#DEE2E6",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#DEE2E6",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#DEE2E6",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#DEE2E6",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        datalabelFont: {
          color: "#DEE2E6",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: chart.getModuleName() === "accumulationchart" ? "#DEE2E680" : "#DEE2E6",
          fontFamily: "Segoe UI",
          size: chart.getModuleName() === "accumulationchart" ? "14px" : "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        crosshairLabelFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        stripLineLabelFont: {
          color: "#DEE2E6",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Fluent":
      style = {
        axisLabel: "#3B3A39",
        axisTitle: "#201F1E",
        axisLine: "#D2D0CE",
        majorGridLine: "#EDEBE9",
        minorGridLine: "#EDEBE9",
        majorTickLine: "#D2D0CE",
        minorTickLine: " #D2D0CE",
        chartTitle: "#201F1E",
        legendLabel: "#323130",
        background: canvas ? "#FFFFFF" : "transparent",
        areaBorder: "#EDEBE9",
        errorBar: "#A19F9D",
        crosshairLine: "#A19F9D",
        crosshairBackground: "rgba(161, 159, 157, 0.1)",
        crosshairFill: "#FFFFFF",
        crosshairLabel: "#323130",
        tooltipFill: "#FFFFFF",
        tooltipBoldLabel: "#323130",
        tooltipLightLabel: "#323130",
        tooltipHeaderLine: "#D2D0CE",
        markerShadow: null,
        selectionRectFill: "rgba(79,70,229, 0.1)",
        selectionRectStroke: "#4F46E5",
        selectionCircleStroke: "#6B7280",
        tabColor: "#0078D4",
        bearFillColor: "#2ecd71",
        bullFillColor: "#e74c3d",
        toolkitSelectionColor: "#0078D4",
        toolkitFill: "#A19F9D",
        toolkitIconRectOverFill: "transparent",
        toolkitIconRectSelectionFill: "transparent",
        toolkitIconRect: new Rect(0, 0, 16, 16),
        chartTitleFont: {
          color: "#201F1E",
          fontFamily: "Segoe UI",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: "#3B3A39",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#201F1E",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#49454E",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#323130",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#201F1E",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        datalabelFont: {
          color: "#3B3A39",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#323129",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        crosshairLabelFont: {
          color: "#323130",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        stripLineLabelFont: {
          color: "#A19F9D",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "FluentDark":
      style = {
        axisLabel: "#C8C6C4",
        axisTitle: "#F3F2F1",
        axisLine: "#3B3A39",
        majorGridLine: "#414040",
        minorGridLine: "#414040",
        majorTickLine: "#3B3A39",
        minorTickLine: "#3B3A39",
        chartTitle: "#F3F2F1",
        legendLabel: "#D2D0CE",
        background: canvas ? "#383838" : "transparent",
        areaBorder: "#414040",
        errorBar: "#D2D0CE",
        crosshairLine: "#D2D0CE",
        crosshairBackground: "rgba(161, 159, 157, 0.1)",
        crosshairFill: "#323130",
        crosshairLabel: "#F3F2F1",
        tooltipFill: "#252423",
        tooltipBoldLabel: "#F3F2F1",
        tooltipLightLabel: "#F3F2F1",
        tooltipHeaderLine: "#3B3A39",
        markerShadow: null,
        selectionRectFill: "rgba(79,70,229, 0.1)",
        selectionRectStroke: "#4F46E5",
        selectionCircleStroke: "#6B7280",
        tabColor: "#0078D4",
        bearFillColor: "#2ecd71",
        bullFillColor: "#e74c3d",
        toolkitSelectionColor: "#0078D4",
        toolkitFill: "#484644",
        toolkitIconRectOverFill: "transparent",
        toolkitIconRectSelectionFill: "transparent",
        toolkitIconRect: new Rect(0, 0, 16, 16),
        chartTitleFont: {
          color: "#C8C6C4",
          fontFamily: "Segoe UI",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: "#C8C6C4",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#F3F2F1",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#D2D0CE",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#F3F2F1",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#F3F2F2",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        datalabelFont: {
          color: "#D2D0CE",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#F3F2F1",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        crosshairLabelFont: {
          color: "#F3F2F1",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        stripLineLabelFont: {
          color: "#484644",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Fluent2":
      style = {
        axisLabel: "#616161",
        axisTitle: "#242424",
        axisLine: "#D2D0CE",
        majorGridLine: "#EDEBE9",
        minorGridLine: "#EDEBE9",
        majorTickLine: "#D2D0CE",
        minorTickLine: "#D2D0CE",
        chartTitle: "#242424",
        legendLabel: "#242424",
        background: canvas ? "#383838" : "transparent",
        areaBorder: "#EDEBE9",
        errorBar: "#A19F9D",
        crosshairLine: "#A19F9D",
        crosshairBackground: "rgba(138, 136, 134, 0.1)",
        crosshairFill: "#FFFFFF",
        crosshairLabel: "#242424",
        tooltipFill: "#FFFFFF",
        tooltipBoldLabel: "#242424",
        tooltipLightLabel: "#242424",
        tooltipHeaderLine: "#D2D0CE",
        markerShadow: null,
        selectionRectFill: "rgba(180, 214, 250, 0.1)",
        selectionRectStroke: "#0F6CBD",
        selectionCircleStroke: "#0F6CBD",
        tabColor: "#0078D4",
        bearFillColor: "#E7910F",
        bullFillColor: "#0076E5",
        toolkitSelectionColor: "#424242",
        toolkitFill: "#424242",
        toolkitIconRectOverFill: "#E6E6E6",
        toolkitIconRectSelectionFill: "#E6E6E6",
        toolkitIconRect: new Rect(-6, -8, 32, 32),
        chartTitleFont: {
          color: "#242424",
          fontFamily: "Segoe UI",
          size: chart.getModuleName() === "accumulationchart" ? "16px" : "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: "#616161",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#242424",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#242424",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#242424",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#242424",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        datalabelFont: {
          color: "#242424",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#616161",
          fontFamily: "Segoe UI",
          size: chart.getModuleName() === "chart" ? "12px" : "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        crosshairLabelFont: {
          color: "#242424",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "700"
        },
        stripLineLabelFont: {
          color: "#616161",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Fluent2HighContrast":
      style = {
        axisLabel: "#FFFFFF",
        axisTitle: "#FFFFFF",
        axisLine: "#3B3A39",
        majorGridLine: "#292827",
        minorGridLine: "#3B3A39",
        majorTickLine: "#292827",
        minorTickLine: "#292827",
        chartTitle: "#FFFFFF",
        legendLabel: "#FFFFFF",
        background: canvas ? "#383838" : "transparent",
        areaBorder: "#292827",
        errorBar: "#8A8886",
        crosshairLine: "#8A8886",
        crosshairBackground: "rgba(255, 255, 255, 0.1)",
        crosshairFill: "#000000",
        crosshairLabel: "#FFFFFF",
        tooltipFill: "#292929",
        tooltipBoldLabel: "#FFFFFF",
        tooltipLightLabel: "#FFFFFF",
        tooltipHeaderLine: "#3B3A39",
        markerShadow: null,
        selectionRectFill: "rgba(26, 235, 255, 0.2)",
        selectionRectStroke: "#1AEBFF",
        selectionCircleStroke: "#1AEBFF",
        tabColor: "#0078D4",
        bearFillColor: "#584EC6",
        bullFillColor: "#43B786",
        toolkitSelectionColor: "#FFFFFF",
        toolkitFill: "#FFFFFF",
        toolkitIconRectOverFill: "#1AEBFF",
        toolkitIconRectSelectionFill: "#1AEBFF",
        toolkitIconRect: new Rect(-6, -8, 32, 32),
        chartTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: chart.getModuleName() === "accumulationchart" ? "16px" : "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        datalabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: chart.getModuleName() === "chart" ? "12px" : "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        crosshairLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "700"
        },
        stripLineLabelFont: {
          color: "#ADADAD",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Fluent2Dark":
      style = {
        axisLabel: "#ADADAD",
        axisTitle: "#FFFFFF",
        axisLine: "#3B3A39",
        majorGridLine: "#3B3A39",
        minorGridLine: "#3B3A39",
        majorTickLine: "#292827",
        minorTickLine: "#292827",
        chartTitle: "#FFFFFF",
        legendLabel: "#FFFFFF",
        background: canvas ? "#383838" : "transparent",
        areaBorder: "#292827",
        errorBar: "#8A8886",
        crosshairLine: "#8A8886",
        crosshairBackground: "rgba(138, 136, 134, 0.1)",
        crosshairFill: "#292929",
        crosshairLabel: "#FFFFFF",
        tooltipFill: "#292929",
        tooltipBoldLabel: "#FFFFFF",
        tooltipLightLabel: "#FFFFFF",
        tooltipHeaderLine: "#3B3A39",
        markerShadow: null,
        selectionRectFill: "rgba(14, 71, 117, 0.1)",
        selectionRectStroke: "#115EA3",
        selectionCircleStroke: "#115EA3",
        tabColor: "#0078D4",
        bearFillColor: "#584EC6",
        bullFillColor: "#43B786",
        toolkitSelectionColor: "#D6D6D6",
        toolkitFill: "#D6D6D6",
        toolkitIconRectOverFill: "#333333",
        toolkitIconRectSelectionFill: "#333333",
        toolkitIconRect: new Rect(-6, -8, 32, 32),
        chartTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: chart.getModuleName() === "accumulationchart" ? "16px" : "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: "#ADADAD",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        datalabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#ADADAD",
          fontFamily: "Segoe UI",
          size: chart.getModuleName() === "chart" ? "12px" : "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        crosshairLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "700"
        },
        stripLineLabelFont: {
          color: "#ADADAD",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Material3":
      style = {
        axisLabel: "#1E192B",
        axisTitle: "#1C1B1F",
        axisLine: "#C4C7C5",
        majorGridLine: "#C4C7C5",
        minorGridLine: "#C4C7C5",
        majorTickLine: "#C4C7C5",
        minorTickLine: " #C4C7C5",
        chartTitle: "#1C1B1F",
        legendLabel: "#49454E",
        background: canvas ? "#FFFFFF" : "transparent",
        areaBorder: "#E7E0EC",
        errorBar: "#79747E",
        crosshairLine: "#49454E",
        crosshairBackground: "rgba(73, 69, 78, 0.1)",
        crosshairFill: "#313033",
        crosshairLabel: "#F4EFF4",
        tooltipFill: "#313033",
        tooltipBoldLabel: "#F4EFF4",
        tooltipLightLabel: "#F4EFF4",
        tooltipHeaderLine: "#F4EFF4",
        markerShadow: null,
        selectionRectFill: "rgb(98, 0, 238, 0.06)",
        selectionRectStroke: "#6200EE",
        selectionCircleStroke: "#79747E",
        tabColor: "#49454E",
        bearFillColor: "#5887FF",
        bullFillColor: "#F7523F",
        toolkitSelectionColor: "#49454E",
        toolkitFill: "#49454E",
        toolkitIconRectOverFill: "#EADDFF",
        toolkitIconRectSelectionFill: "#EADDFF",
        toolkitIconRect: new Rect(-4, -5, 26, 26),
        histogram: "#D21020",
        chartTitleFont: {
          color: "#1C1B1F",
          fontFamily: "Roboto",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: "#1E192B",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#1C1B1F",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#49454E",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#F4EFF4",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#1C1B1F",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        datalabelFont: {
          color: "#49454E",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#49454E",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        crosshairLabelFont: {
          color: "#F4EFF4",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        stripLineLabelFont: {
          color: "#79747E",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Material3Dark":
      style = {
        axisLabel: "#E6E1E5",
        axisTitle: "#E6E1E5",
        axisLine: "#49454F",
        majorGridLine: "#444746",
        minorGridLine: "#444746",
        majorTickLine: "#444746",
        minorTickLine: " #444746",
        chartTitle: "#E6E1E5",
        legendLabel: "#CAC4D0",
        background: canvas ? "#FFFFFF" : "transparent",
        areaBorder: "#49454F",
        errorBar: "#938F99",
        crosshairLine: "#CAC4D0",
        crosshairBackground: "rgba(73, 69, 78, 0.1)",
        crosshairFill: "#E6E1E5",
        crosshairLabel: "#313033",
        tooltipFill: "#E6E1E5",
        tooltipBoldLabel: "#313033",
        tooltipLightLabel: "#313033",
        tooltipHeaderLine: "#313033",
        markerShadow: null,
        selectionRectFill: "rgba(78, 170, 255, 0.06)",
        selectionRectStroke: "#4EAAFF",
        selectionCircleStroke: "#938F99",
        tabColor: "#CAC4D0",
        bearFillColor: "#B3F32F",
        bullFillColor: "#FF9E45",
        toolkitSelectionColor: "#CAC4D0",
        toolkitFill: "#CAC4D0",
        toolkitIconRectOverFill: "#4F378B",
        toolkitIconRectSelectionFill: "#4F378B",
        toolkitIconRect: new Rect(-4, -5, 26, 26),
        histogram: "#FF9E45",
        chartTitleFont: {
          color: "#E6E1E5",
          fontFamily: "Roboto",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: "#CAC4D0",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#E6E1E5",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#CAC4D0",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#313033",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#E6E1E5",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        datalabelFont: {
          color: "#CAC4D0",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#CAC4D0",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        crosshairLabelFont: {
          color: "#313033",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        stripLineLabelFont: {
          color: "#938F99",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    default:
      style = {
        axisLabel: "#686868",
        axisTitle: "#424242",
        axisLine: "#b5b5b5",
        majorGridLine: "#dbdbdb",
        minorGridLine: "#eaeaea",
        majorTickLine: "#b5b5b5",
        minorTickLine: "#d6d6d6",
        chartTitle: "#424242",
        legendLabel: "#353535",
        background: canvas ? "#FFFFFF" : "transparent",
        areaBorder: "Gray",
        errorBar: "#000000",
        crosshairLine: "#4f4f4f",
        crosshairBackground: "rgba(0, 0, 0, 0.1)",
        crosshairFill: theme === "Material" ? "#000816" : theme === "Fabric" ? "#FFFFFF" : "#212529",
        crosshairLabel: "#e5e5e5",
        tooltipFill: "#000816",
        tooltipBoldLabel: "#ffffff",
        tooltipLightLabel: "#dbdbdb",
        tooltipHeaderLine: "#ffffff",
        markerShadow: null,
        selectionRectFill: "rgba(41, 171, 226, 0.1)",
        selectionRectStroke: "#29abe2",
        selectionCircleStroke: "#29abe2",
        tabColor: theme === "Material" ? "#ff4081" : theme === "Fabric" ? "#0078D6" : "#317AB9",
        bearFillColor: "#2ecd71",
        bullFillColor: "#e74c3d",
        toolkitSelectionColor: theme === "Material" ? "#ff4081" : theme === "Fabric" ? "#0078D6" : "#317AB9",
        toolkitFill: "#737373",
        toolkitIconRectOverFill: "transparent",
        toolkitIconRectSelectionFill: "transparent",
        toolkitIconRect: new Rect(0, 0, 16, 16),
        chartTitleFont: {
          color: theme === "Material" ? "rgba(0, 0, 0, 1)" : theme === "Fabric" ? "#333333" : "#212529",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Fabric" ? "Segoe UI" : "Helvetica",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: theme === "Material" ? "rgba(97, 97, 97, 1)" : theme === "Fabric" ? "#666666" : "#676767",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Fabric" ? "Segoe UI" : "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: theme === "Material" ? "rgba(0, 0, 0, 1)" : theme === "Fabric" ? "#333333" : "#212529",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Fabric" ? "Segoe UI" : "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: theme === "Material" ? "rgba(97, 97, 97, 1)" : theme === "Fabric" ? "#666666" : "#666666",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Fabric" ? "Segoe UI" : "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: theme === "Material" ? "rgba(249, 250, 251, 1)" : theme === "Fabric" ? "#333333" : "#F9FAFB",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Fabric" ? "Segoe UI" : "Helvetica",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: theme === "Material" ? "rgba(0, 0, 0, 1)" : theme === "Fabric" ? "#333333" : "#212529",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Fabric" ? "Segoe UI" : "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        datalabelFont: {
          color: theme === "Material" ? "rgba(97, 97, 97, 1)" : theme === "Fabric" ? "#666666" : "#676767",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Fabric" ? "Segoe UI" : "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: theme === "Material" ? "rgba(0, 0, 0, 1)" : theme === "Fabric" ? "#333333" : "#212529",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Fabric" ? "Segoe UI" : "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        crosshairLabelFont: {
          color: theme === "Material" ? "rgba(249, 250, 251, 1)" : theme === "Fabric" ? "#333333" : "#F9FAFB",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Fabric" ? "Segoe UI" : "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        stripLineLabelFont: {
          color: theme === "Material" ? "rgba(158, 158, 158, 1)" : theme === "Fabric" ? "#A6A6A6" : "#676767",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Fabric" ? "Segoe UI" : "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
  }
  return style;
}
function getScrollbarThemeColor(theme) {
  var scrollStyle;
  switch (theme) {
    case "HighContrastLight":
      scrollStyle = {
        backRect: "#333",
        thumb: "#bfbfbf",
        circle: "#fff",
        circleHover: "#685708",
        arrow: "#333",
        grip: "#333",
        arrowHover: "#fff",
        backRectBorder: "#969696"
      };
      break;
    case "Bootstrap":
      scrollStyle = {
        backRect: "#f5f5f5",
        thumb: "#e6e6e6",
        circle: "#fff",
        circleHover: "#eee",
        arrow: "#8c8c8c",
        grip: "#8c8c8c"
      };
      break;
    case "Fabric":
      scrollStyle = {
        backRect: "#f8f8f8",
        thumb: "#eaeaea",
        circle: "#fff",
        circleHover: "#eaeaea",
        arrow: "#a6a6a6",
        grip: "#a6a6a6"
      };
      break;
    case "MaterialDark":
      scrollStyle = {
        backRect: "#424242",
        thumb: "#616161",
        circle: "#757575",
        circleHover: "#616161",
        arrow: "#BDBDBD",
        grip: "#BDBDBD"
      };
      break;
    case "FabricDark":
      scrollStyle = {
        backRect: "#282727",
        thumb: "#333232",
        circle: "#4A4848",
        circleHover: "#514F4F",
        arrow: "#ADB5BD",
        grip: "#DADADA"
      };
      break;
    case "BootstrapDark":
      scrollStyle = {
        backRect: "#2A2A2A",
        thumb: "#313131",
        circle: "#414141",
        circleHover: "#484848",
        arrow: "#DADADA",
        grip: "#FFFFFF"
      };
      break;
    case "Bootstrap5":
      scrollStyle = {
        backRect: "#E9ECEF",
        thumb: "#ADB5BD",
        circle: "#F8F9FA",
        circleHover: "#F8F9FA",
        arrow: "#6E757D",
        grip: "#6E757D"
      };
      break;
    case "Bootstrap5Dark":
      scrollStyle = {
        backRect: "#343A40",
        thumb: "#ADB5BD",
        circle: "#2B3035",
        circleHover: "#2B3035",
        arrow: "#ADB5BD",
        grip: "#ADB5BD"
      };
      break;
    case "HighContrast":
      scrollStyle = {
        backRect: "#757575",
        thumb: "#BFBFBF",
        circle: "#FFFFFF",
        circleHover: "#FFFFFF",
        arrow: "#ADB5BD",
        grip: "#969696"
      };
      break;
    case "Tailwind3Dark":
      scrollStyle = {
        backRect: "#282F3C",
        thumb: "#374151",
        circle: "#111827",
        circleHover: "#eee",
        arrow: "#D1D5DB",
        grip: "#D1D5DB"
      };
      break;
    case "Fluent":
      scrollStyle = {
        backRect: "#F3F2F1",
        thumb: "#E1DFDD",
        circle: "#FFFFFF",
        circleHover: "#E1DFDD",
        arrow: "#605E5C",
        grip: "#605E5C"
      };
      break;
    case "FluentDark":
      scrollStyle = {
        backRect: "#252423",
        thumb: "#323130",
        circle: "#3B3A39",
        circleHover: "#3B3A39",
        arrow: "#ADB5BD",
        grip: "#A19F9D"
      };
      break;
    case "Fluent2":
      scrollStyle = {
        backRect: "#F5F5F5",
        thumb: "#F0F0F0",
        circle: "#FAFAFA",
        circleHover: "#FAFAFA",
        arrow: "#424242",
        grip: "#424242"
      };
      break;
    case "Fluent2Dark":
      scrollStyle = {
        thumb: "#0A0A0A",
        backRect: "#141414",
        circle: "#1F1F1F",
        circleHover: "#1F1F1F",
        arrow: "#D6D6D6",
        grip: "#D6D6D6"
      };
      break;
    case "Fluent2HighContrast":
      scrollStyle = {
        thumb: "#333333",
        backRect: "#000000",
        circle: "#000000",
        circleHover: "#000000",
        arrow: "#FFFFFF",
        grip: "#FFFFFF"
      };
      break;
    case "Material3":
      scrollStyle = {
        backRect: "rgba(103, 80, 164, 0.05)",
        thumb: " rgba(103, 80, 164, 0.14)",
        circle: "#FFFFFF",
        circleHover: "#E1DFDD",
        arrow: "#49454E",
        grip: "#49454E"
      };
      break;
    case "Material3Dark":
      scrollStyle = {
        backRect: "rgba(208, 188, 255, 0.05)",
        thumb: "rgba(208, 188, 255, 0.14)",
        circle: "#FFFFFF",
        circleHover: "#E1DFDD",
        arrow: "#CAC4D0",
        grip: "#CAC4D0"
      };
      break;
    case "Tailwind3":
      scrollStyle = {
        backRect: "#E5E7EB",
        thumb: "#D1D5DB",
        circle: "#FFFFFF",
        circleHover: "#eee",
        arrow: "#6B7280",
        grip: "#6B7280"
      };
      break;
    case "TailwindDark":
      scrollStyle = {
        backRect: "#6B7280",
        thumb: "#374151",
        circle: "#4B5563",
        circleHover: "#4B5563",
        arrow: "#ADB5BD",
        grip: "#D1D5DB"
      };
      break;
    default:
      scrollStyle = {
        backRect: "#f5f5f5",
        thumb: "#e0e0e0",
        circle: "#fff",
        circleHover: "#eee",
        arrow: "#9e9e9e",
        grip: "#9e9e9e"
      };
      break;
  }
  return scrollStyle;
}

// node_modules/@syncfusion/ej2-charts/src/chart/series/chart-series.js
var __extends5 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate4 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DataLabelSettings = (
  /** @class */
  function(_super) {
    __extends5(DataLabelSettings2, _super);
    function DataLabelSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate4([Property(false)], DataLabelSettings2.prototype, "visible", void 0);
    __decorate4([Property(true)], DataLabelSettings2.prototype, "showZero", void 0);
    __decorate4([Property(null)], DataLabelSettings2.prototype, "name", void 0);
    __decorate4([Property("transparent")], DataLabelSettings2.prototype, "fill", void 0);
    __decorate4([Property(null)], DataLabelSettings2.prototype, "format", void 0);
    __decorate4([Property(1)], DataLabelSettings2.prototype, "opacity", void 0);
    __decorate4([Property(0)], DataLabelSettings2.prototype, "angle", void 0);
    __decorate4([Property(false)], DataLabelSettings2.prototype, "enableRotation", void 0);
    __decorate4([Property("Auto")], DataLabelSettings2.prototype, "position", void 0);
    __decorate4([Property(5)], DataLabelSettings2.prototype, "rx", void 0);
    __decorate4([Property(5)], DataLabelSettings2.prototype, "ry", void 0);
    __decorate4([Property("Center")], DataLabelSettings2.prototype, "alignment", void 0);
    __decorate4([Complex({
      width: null,
      color: null
    }, Border)], DataLabelSettings2.prototype, "border", void 0);
    __decorate4([Complex({
      left: 5,
      right: 5,
      top: 5,
      bottom: 5
    }, Margin)], DataLabelSettings2.prototype, "margin", void 0);
    __decorate4([Complex({
      size: null,
      color: null,
      fontStyle: null,
      fontWeight: null,
      fontFamily: null
    }, Font)], DataLabelSettings2.prototype, "font", void 0);
    __decorate4([Property(null)], DataLabelSettings2.prototype, "template", void 0);
    __decorate4([Property("Hide")], DataLabelSettings2.prototype, "labelIntersectAction", void 0);
    return DataLabelSettings2;
  }(ChildProperty)
);
var MarkerSettings = (
  /** @class */
  function(_super) {
    __extends5(MarkerSettings2, _super);
    function MarkerSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate4([Property(false)], MarkerSettings2.prototype, "visible", void 0);
    __decorate4([Property(null)], MarkerSettings2.prototype, "shape", void 0);
    __decorate4([Property("")], MarkerSettings2.prototype, "imageUrl", void 0);
    __decorate4([Property(5)], MarkerSettings2.prototype, "height", void 0);
    __decorate4([Property(false)], MarkerSettings2.prototype, "isFilled", void 0);
    __decorate4([Property(5)], MarkerSettings2.prototype, "width", void 0);
    __decorate4([Complex({
      width: 2,
      color: null
    }, Border)], MarkerSettings2.prototype, "border", void 0);
    __decorate4([Complex({
      x: 0,
      y: 0
    }, Offset)], MarkerSettings2.prototype, "offset", void 0);
    __decorate4([Property(null)], MarkerSettings2.prototype, "fill", void 0);
    __decorate4([Property(true)], MarkerSettings2.prototype, "allowHighlight", void 0);
    __decorate4([Property(1)], MarkerSettings2.prototype, "opacity", void 0);
    __decorate4([Complex({}, DataLabelSettings)], MarkerSettings2.prototype, "dataLabel", void 0);
    return MarkerSettings2;
  }(ChildProperty)
);
var ParetoOptions = (
  /** @class */
  function(_super) {
    __extends5(ParetoOptions2, _super);
    function ParetoOptions2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate4([Property(null)], ParetoOptions2.prototype, "fill", void 0);
    __decorate4([Property(1)], ParetoOptions2.prototype, "width", void 0);
    __decorate4([Property("0")], ParetoOptions2.prototype, "dashArray", void 0);
    __decorate4([Complex(null, MarkerSettings)], ParetoOptions2.prototype, "marker", void 0);
    __decorate4([Property(true)], ParetoOptions2.prototype, "showAxis", void 0);
    return ParetoOptions2;
  }(ChildProperty)
);
var Points = (
  /** @class */
  /* @__PURE__ */ function() {
    function Points2() {
      this.symbolLocations = null;
      this.regions = null;
      this.percentage = null;
      this.regionData = null;
      this.isSelect = false;
      this.marker = {
        visible: false
      };
      this.isPointInRange = true;
      this.verticalError = null;
      this.verticalNegativeError = null;
      this.horizontalError = null;
      this.horizontalNegativeError = null;
      this.verticalPositiveError = null;
      this.horizontalPositiveError = null;
    }
    return Points2;
  }()
);
var Trendline = (
  /** @class */
  function(_super) {
    __extends5(Trendline2, _super);
    function Trendline2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.clipRect = new Rect(0, 0, 0, 0);
      return _this;
    }
    Trendline2.prototype.setDataSource = function(series, chart) {
      if (series) {
        this.points = series.points;
      }
      chart.trendLineModule.initDataSource(this);
      chart.visibleSeriesCount++;
    };
    __decorate4([Property("")], Trendline2.prototype, "name", void 0);
    __decorate4([Property("")], Trendline2.prototype, "dashArray", void 0);
    __decorate4([Property(true)], Trendline2.prototype, "visible", void 0);
    __decorate4([Property("Linear")], Trendline2.prototype, "type", void 0);
    __decorate4([Property(2)], Trendline2.prototype, "period", void 0);
    __decorate4([Property(2)], Trendline2.prototype, "polynomialOrder", void 0);
    __decorate4([Property(0)], Trendline2.prototype, "backwardForecast", void 0);
    __decorate4([Property(0)], Trendline2.prototype, "forwardForecast", void 0);
    __decorate4([Complex({}, Animation2)], Trendline2.prototype, "animation", void 0);
    __decorate4([Complex({}, MarkerSettings)], Trendline2.prototype, "marker", void 0);
    __decorate4([Property(true)], Trendline2.prototype, "enableTooltip", void 0);
    __decorate4([Property(null)], Trendline2.prototype, "intercept", void 0);
    __decorate4([Property("")], Trendline2.prototype, "fill", void 0);
    __decorate4([Property(1)], Trendline2.prototype, "width", void 0);
    __decorate4([Property("SeriesType")], Trendline2.prototype, "legendShape", void 0);
    __decorate4([Complex({}, Accessibility)], Trendline2.prototype, "accessibility", void 0);
    return Trendline2;
  }(ChildProperty)
);
var ErrorBarCapSettings = (
  /** @class */
  function(_super) {
    __extends5(ErrorBarCapSettings2, _super);
    function ErrorBarCapSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate4([Property(1)], ErrorBarCapSettings2.prototype, "width", void 0);
    __decorate4([Property(10)], ErrorBarCapSettings2.prototype, "length", void 0);
    __decorate4([Property(null)], ErrorBarCapSettings2.prototype, "color", void 0);
    __decorate4([Property(1)], ErrorBarCapSettings2.prototype, "opacity", void 0);
    return ErrorBarCapSettings2;
  }(ChildProperty)
);
var ChartSegment = (
  /** @class */
  function(_super) {
    __extends5(ChartSegment2, _super);
    function ChartSegment2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate4([Property(null)], ChartSegment2.prototype, "value", void 0);
    __decorate4([Property(null)], ChartSegment2.prototype, "color", void 0);
    __decorate4([Property("0")], ChartSegment2.prototype, "dashArray", void 0);
    return ChartSegment2;
  }(ChildProperty)
);
var ErrorBarSettings = (
  /** @class */
  function(_super) {
    __extends5(ErrorBarSettings2, _super);
    function ErrorBarSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate4([Property(false)], ErrorBarSettings2.prototype, "visible", void 0);
    __decorate4([Property("Fixed")], ErrorBarSettings2.prototype, "type", void 0);
    __decorate4([Property("Both")], ErrorBarSettings2.prototype, "direction", void 0);
    __decorate4([Property("Vertical")], ErrorBarSettings2.prototype, "mode", void 0);
    __decorate4([Property(null)], ErrorBarSettings2.prototype, "color", void 0);
    __decorate4([Property(1)], ErrorBarSettings2.prototype, "verticalError", void 0);
    __decorate4([Property(1)], ErrorBarSettings2.prototype, "width", void 0);
    __decorate4([Property(1)], ErrorBarSettings2.prototype, "horizontalError", void 0);
    __decorate4([Property(3)], ErrorBarSettings2.prototype, "verticalPositiveError", void 0);
    __decorate4([Property(3)], ErrorBarSettings2.prototype, "verticalNegativeError", void 0);
    __decorate4([Property(1)], ErrorBarSettings2.prototype, "horizontalPositiveError", void 0);
    __decorate4([Property(1)], ErrorBarSettings2.prototype, "horizontalNegativeError", void 0);
    __decorate4([Complex(null, ErrorBarCapSettings)], ErrorBarSettings2.prototype, "errorBarCap", void 0);
    __decorate4([Property("")], ErrorBarSettings2.prototype, "errorBarColorMapping", void 0);
    return ErrorBarSettings2;
  }(ChildProperty)
);
var SeriesBase = (
  /** @class */
  function(_super) {
    __extends5(SeriesBase2, _super);
    function SeriesBase2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.rangeColorPoints = [];
      _this.isAdvancedColor = void 0;
      _this.currentViewData = [];
      _this.clipRect = new Rect(0, 0, 0, 0);
      _this.seriesType = "XY";
      _this.isRectTypeSeries = false;
      _this.removedPointIndex = null;
      _this.isLegendClicked = false;
      return _this;
    }
    SeriesBase2.prototype.processJsonData = function() {
      var i = 0;
      var point = new Points();
      var xName = this instanceof Series && this.type === "Histogram" ? "x" : this.xName;
      var textMappingName = this instanceof Series && this.marker.dataLabel.name ? this.marker.dataLabel.name : "";
      if (this instanceof Series) {
        if (this.type === "Waterfall" || this.type === "Histogram") {
          this.currentViewData = this.chart[firstToLowerCase(this.type) + "SeriesModule"].processInternalData(extend([], this.currentViewData, null, true), this);
        }
        if (this.category === "Pareto") {
          this.currentViewData = extend([], this.currentViewData, null, true);
          if (this.type === "Line") {
            this.currentViewData = this.chart.paretoSeriesModule.performCumulativeCalculation(this.currentViewData, this);
          }
        }
        this.isRectTypeSeries = this.type.indexOf("Column") > -1 || this.type.indexOf("Bar") > -1 || this.type.indexOf("Histogram") > -1;
      }
      var len = (this.currentViewData || []).length;
      this.points = [];
      this.xMin = Infinity;
      this.xMax = -Infinity;
      this.yMin = Infinity;
      this.yMax = -Infinity;
      this.sizeMax = -Infinity;
      this.getSeriesType();
      if (this.xAxis.valueType === "Category") {
        while (i < len) {
          this.pushCategoryPoint(point, i, textMappingName, xName);
          i++;
        }
      } else if (this.xAxis.valueType.indexOf("DateTime") > -1) {
        var option = {
          skeleton: "full",
          type: "dateTime"
        };
        var dateParser = this.chart.intl.getDateParser(option);
        var dateFormatter = this.chart.intl.getDateFormat(option);
        while (i < len) {
          this.pushDateTimePoint(point, i, textMappingName, xName, dateParser, dateFormatter);
          i++;
        }
      } else {
        while (i < len) {
          this.pushDoublePoint(point, i, textMappingName, xName);
          i++;
        }
      }
      this.updateSplineValue();
      this.updateYAxisForErrorBars();
      if (this instanceof Series && this.type === "Waterfall" && isNullOrUndefined(this.yAxis.minimum)) {
        this.yMin = Math.min.apply(Math, this.chart.waterfallSeriesModule.cumulativeSums);
      }
    };
    SeriesBase2.prototype.updateYAxisForErrorBars = function() {
      if (this instanceof Series) {
        if (this.chart.errorBarModule) {
          var maxVerticalError = void 0;
          var minVerticalError = void 0;
          if (this.errorBar.verticalError) {
            for (var i = 0; i < this.points.length; i++) {
              var verticalErrors = [];
              var minVerticalErrorValue = [];
              for (var i_1 = 0; i_1 < this.points.length; i_1++) {
                var point = this.points[i_1];
                if (point.verticalError) {
                  verticalErrors.push(point.verticalError);
                  minVerticalErrorValue.push(point.yValue - point.verticalError);
                }
              }
              maxVerticalError = verticalErrors && verticalErrors.length > 0 ? Math.max.apply(Math, verticalErrors) : 0;
              minVerticalError = verticalErrors && verticalErrors.length > 0 ? Math.min.apply(Math, minVerticalErrorValue) : 0;
            }
          }
          this.yMax += !isNaN(maxVerticalError) && isNullOrUndefined(this.yAxis.maximum) ? maxVerticalError : 0;
          this.yMin = !isNaN(minVerticalError) && minVerticalError < this.yMin && minVerticalError < 0 && isNullOrUndefined(this.yAxis.minimum) ? minVerticalError : this.yMin;
        }
      }
    };
    SeriesBase2.prototype.pushCategoryPoint = function(point, index, textMappingName, xName) {
      point = this.dataPoint(index, textMappingName, xName);
      this.pushCategoryData(point, index, point.x);
      this.pushData(point, index);
      this.setEmptyPoint(point, index);
      this.rangeColorsInterior(point);
    };
    SeriesBase2.prototype.pushDoublePoint = function(point, index, textMappingName, xName) {
      point = this.dataPoint(index, textMappingName, xName);
      point.xValue = point.x;
      this.pushData(point, index);
      this.setEmptyPoint(point, index);
    };
    SeriesBase2.prototype.pushDateTimePoint = function(point, index, textMappingName, xName, dateParser, dateFormatter) {
      point = this.dataPoint(index, textMappingName, xName);
      if (!isNullOrUndefined(point.x) && point.x !== "") {
        point.x = new Date(DataUtil.parse.parseJson({
          val: point.x
        }).val);
        if (this.xAxis.valueType === "DateTime") {
          point.xValue = Date.parse(point.x.toString());
        } else {
          if (this.chart.isBlazor) {
            this.pushCategoryData(point, index, Date.parse(point.x.toString()).toString());
          } else {
            this.pushCategoryData(point, index, Date.parse(dateParser(dateFormatter(point.x))).toString());
          }
        }
        this.pushData(point, index);
        this.setEmptyPoint(point, index);
      } else {
        point.visible = false;
      }
    };
    SeriesBase2.prototype.updateSplineValue = function() {
      if (this instanceof Series && !(this.chart.stockChart && this.xAxis.valueType === "DateTimeCategory")) {
        if (this.type.indexOf("Spline") > -1 || this.drawType.indexOf("Spline") > -1 && this.chart.chartAreaType === "PolarRadar") {
          var isArea = this.type.indexOf("Area") > -1 || this.drawType.indexOf("Area") > -1;
          var isRange = this.type.indexOf("Range") > -1;
          this.chart["spline" + (isArea ? isRange ? "RangeArea" : "Area" : "") + "SeriesModule"].findSplinePoint(this);
        } else if (this.type.indexOf("Histogram") > -1 && (this.xAxis.maximum || this.xAxis.minimum)) {
          this.chart["histogramSeriesModule"].calculateBinValues(this);
        }
        if (this.type.indexOf("Histogram") > -1 && this.points.length === 1) {
          this.xMin = this.xMin - this.histogramValues.binWidth;
          this.xMax = this.xMax + this.histogramValues.binWidth;
        }
      }
    };
    SeriesBase2.prototype.rangeColorsInterior = function(point) {
      if (this.chart.rangeColorSettings && this.chart.rangeColorSettings.length > 0 && this.chart.visibleSeries.length === 1 && (this.chart.series[0].type === "Column" || this.chart.series[0].type === "Bar" || this.chart.series[0].type === "Scatter" || this.chart.series[0].type === "Bubble")) {
        if (!this.rangeColorPoints[point.interior]) {
          this.rangeColorPoints[point.interior] = [];
        } else if (this.rangeColorPoints[point.interior] !== void 0) {
          this.rangeColorPoints[point.interior].push(point);
        }
      }
    };
    SeriesBase2.prototype.pushData = function(point, i) {
      point.index = i;
      point.yValue = point.y;
      point.series = this;
      this.xMin = Math.min(this.xMin, point.xValue);
      this.xMax = Math.max(this.xMax, point.xValue);
      this.xData.push(point.xValue);
    };
    SeriesBase2.prototype.dataPoint = function(i, textMappingName, xName) {
      this.points[i] = new Points();
      var point = this.points[i];
      var currentViewData = this.currentViewData[i];
      var getObjectValueByMappingString = this.enableComplexProperty ? getValue : this.getObjectValue;
      point.x = getObjectValueByMappingString(xName, currentViewData);
      point.high = getObjectValueByMappingString(this.high, currentViewData);
      point.low = getObjectValueByMappingString(this.low, currentViewData);
      point.open = getObjectValueByMappingString(this.open, currentViewData);
      point.close = getObjectValueByMappingString(this.close, currentViewData);
      point.volume = getObjectValueByMappingString(this.volume, currentViewData);
      point.interior = getObjectValueByMappingString(this.pointColorMapping, currentViewData);
      if (this instanceof Series) {
        if (this.errorBar.visible) {
          point.errorBarColor = getObjectValueByMappingString(this.errorBar.errorBarColorMapping, currentViewData);
          point.verticalError = typeof this.errorBar.verticalError == "string" ? getObjectValueByMappingString(this.errorBar.verticalError, currentViewData) : this.errorBar.verticalError;
          point.horizontalError = typeof this.errorBar.horizontalError == "string" ? getObjectValueByMappingString(this.errorBar.horizontalError, currentViewData) : this.errorBar.horizontalError;
          point.verticalNegativeError = typeof this.errorBar.verticalNegativeError == "string" ? getObjectValueByMappingString(this.errorBar.verticalNegativeError, currentViewData) : this.errorBar.verticalNegativeError;
          point.verticalPositiveError = typeof this.errorBar.verticalPositiveError == "string" ? getObjectValueByMappingString(this.errorBar.verticalPositiveError, currentViewData) : this.errorBar.verticalPositiveError;
          point.horizontalNegativeError = typeof this.errorBar.horizontalNegativeError == "string" ? getObjectValueByMappingString(this.errorBar.horizontalNegativeError, currentViewData) : this.errorBar.horizontalNegativeError;
          point.horizontalPositiveError = typeof this.errorBar.horizontalPositiveError == "string" ? getObjectValueByMappingString(this.errorBar.horizontalPositiveError, currentViewData) : this.errorBar.horizontalPositiveError;
        }
        point.y = getObjectValueByMappingString(this.yName, currentViewData);
        point.size = getObjectValueByMappingString(this.size, currentViewData);
        point.text = getObjectValueByMappingString(textMappingName, currentViewData);
        point.tooltip = getObjectValueByMappingString(this.tooltipMappingName, currentViewData);
        if (this.isAdvancedColorSupported()) {
          this.rangeColorName = this.colorName.length > 0 ? this.colorName : this.yName;
          point.colorValue = getObjectValueByMappingString(this.rangeColorName, currentViewData);
          point.interior = this.getPointFillColor(point.interior, point.colorValue);
        }
      }
      return point;
    };
    SeriesBase2.prototype.isAdvancedColorSupported = function() {
      if (isNullOrUndefined(this.isAdvancedColor)) {
        if (this.chart.rangeColorSettings && this.chart.rangeColorSettings.length > 0 && (this.chart.series[0].type === "Column" || this.chart.series[0].type === "Bar" || this.chart.series[0].type === "Scatter" || this.chart.series[0].type === "Bubble")) {
          this.isAdvancedColor = true;
        } else {
          this.isAdvancedColor = false;
        }
      }
      return this.isAdvancedColor;
    };
    SeriesBase2.prototype.getPointFillColor = function(pointFill, value) {
      var color = pointFill;
      if (value && this.chart.rangeColorSettings && this.chart.rangeColorSettings.length > 0) {
        for (var _i = 0, _a = this.chart.rangeColorSettings; _i < _a.length; _i++) {
          var rangeMap = _a[_i];
          if (value >= rangeMap.start && value <= rangeMap.end) {
            if (rangeMap.colors.length > 1) {
              color = getColorByValue(rangeMap, value);
            } else {
              color = rangeMap.colors[0];
            }
          }
        }
      }
      return color;
    };
    SeriesBase2.prototype.getObjectValue = function(mappingName, data) {
      return data[mappingName];
    };
    SeriesBase2.prototype.setEmptyPoint = function(point, i) {
      if (!this.findVisibility(point)) {
        point.visible = true;
        return null;
      }
      point.isEmpty = true;
      var mode = this instanceof Series && point.isPointInRange ? this.emptyPointSettings.mode : "Drop";
      switch (mode) {
        case "Zero":
          point.visible = true;
          if (this instanceof Series && this.seriesType.indexOf("HighLow") > -1) {
            point.high = point.low = 0;
            if (this.seriesType.indexOf("HighLowOpenClose") > -1) {
              point.open = point.close = 0;
            }
          } else {
            point.y = point.yValue = this.yData[i] = 0;
          }
          break;
        case "Average":
          if (this instanceof Series) {
            if (this.seriesType.indexOf("HighLow") > -1) {
              point.high = isNullOrUndefined(point.high) || isNaN(+point.high) ? this.getAverage(this.high, i) : point.high;
              point.low = isNullOrUndefined(point.low) || isNaN(+point.low) ? this.getAverage(this.low, i) : point.low;
              if (this.seriesType.indexOf("HighLowOpenClose") > -1) {
                point.open = isNullOrUndefined(point.open) || isNaN(+point.open) ? this.getAverage(this.open, i) : point.open;
                point.close = isNullOrUndefined(point.close) || isNaN(+point.close) ? this.getAverage(this.close, i) : point.close;
              }
            } else {
              point.y = point.yValue = this.yData[i] = this.getAverage(this.yName, i);
            }
          }
          point.visible = true;
          break;
        case "Drop":
        case "Gap":
          this.yData[i] = null;
          point.visible = false;
          break;
      }
    };
    SeriesBase2.prototype.findVisibility = function(point) {
      var type = this instanceof Series ? this.seriesType : "HighLowOpenClose";
      var yValues;
      var yAxisMin = this.yAxis.minimum;
      var yAxisMax = this.yAxis.maximum;
      switch (type) {
        case "XY":
          if (this.chart.chartAreaType === "PolarRadar" && (!isNullOrUndefined(yAxisMin) && point.yValue < yAxisMin || !isNullOrUndefined(yAxisMax) && point.yValue > yAxisMax)) {
            point.isPointInRange = false;
            return true;
          }
          this.setXYMinMax(point.yValue);
          this.yData.push(point.yValue);
          if (this instanceof Series && this.type === "Bubble") {
            this.sizeMax = Math.max(this.sizeMax, isNullOrUndefined(point.size) || isNaN(+point.size) ? this.sizeMax : point.size);
          }
          return isNullOrUndefined(point.x) || isNullOrUndefined(point.y) || isNaN(+point.y);
        case "HighLow":
          this.setHiloMinMax(point.high, point.low);
          return isNullOrUndefined(point.x) || isNullOrUndefined(point.low) || isNaN(+point.low) || isNullOrUndefined(point.high) || isNaN(+point.high);
        case "HighLowOpenClose":
          this.setHiloMinMax(point.high, point.low);
          return isNullOrUndefined(point.x) || isNullOrUndefined(point.low) || isNaN(+point.low) || isNullOrUndefined(point.open) || isNaN(+point.open) || isNullOrUndefined(point.close) || isNaN(+point.close) || isNullOrUndefined(point.high) || isNaN(+point.high);
        case "BoxPlot":
          yValues = (point.y || [null]).filter(function(value) {
            return !isNullOrUndefined(value) && !isNaN(value);
          }).sort(function(a, b) {
            return a - b;
          });
          point.y = yValues;
          this.yMin = Math.min(this.yMin, Math.min.apply(Math, yValues));
          this.yMax = Math.max(this.yMax, Math.max.apply(Math, yValues));
          return !yValues.length;
      }
    };
    SeriesBase2.prototype.setXYMinMax = function(yValue) {
      var isLogAxis = this.yAxis.valueType === "Logarithmic" || this.xAxis.valueType === "Logarithmic";
      var isNegativeValue = yValue < 0 || this.yAxis.rangePadding === "None";
      var seriesMinY;
      if (this.isRectTypeSeries && !setRange(this.yAxis)) {
        seriesMinY = isLogAxis ? yValue : isNegativeValue ? yValue : 0;
      } else {
        seriesMinY = yValue;
      }
      this.yMin = isLogAxis ? Math.min(this.yMin, isNullOrUndefined(seriesMinY) || isNaN(seriesMinY) || seriesMinY === 0 || seriesMinY.toString() === "0" || seriesMinY.toString() === "" ? this.yMin : seriesMinY) : Math.min(this.yMin, isNullOrUndefined(seriesMinY) || isNaN(seriesMinY) ? this.yMin : seriesMinY);
      this.yMax = Math.max(this.yMax, isNullOrUndefined(yValue) || isNaN(yValue) ? this.yMax : yValue);
    };
    SeriesBase2.prototype.setHiloMinMax = function(high, low) {
      this.yMin = Math.min(this.yMin, Math.min(isNullOrUndefined(low) || isNaN(low) ? this.yMin : low, isNullOrUndefined(high) || isNaN(high) ? this.yMin : high));
      this.yMax = Math.max(this.yMax, Math.max(isNullOrUndefined(low) || isNaN(low) ? this.yMax : low, isNullOrUndefined(high) || isNaN(high) ? this.yMax : high));
    };
    SeriesBase2.prototype.getSeriesType = function() {
      var type;
      if (this instanceof Series) {
        var seriesType = this.chart.chartAreaType === "PolarRadar" ? this.drawType : this.type;
        if (seriesType) {
          switch (seriesType) {
            case "RangeColumn":
            case "RangeArea":
            case "RangeStepArea":
            case "SplineRangeArea":
            case "Hilo":
              type = "HighLow";
              break;
            case "HiloOpenClose":
            case "Candle":
              type = "HighLowOpenClose";
              break;
            case "BoxAndWhisker":
              type = "BoxPlot";
              break;
            default:
              type = "XY";
          }
        }
      }
      this.seriesType = type;
    };
    SeriesBase2.prototype.pushCategoryData = function(point, index, pointX) {
      if (!this.chart.tooltip.shared) {
        if (!this.visible) {
          return null;
        }
      }
      if (!this.xAxis.isIndexed) {
        if (this.xAxis.indexLabels[pointX] === void 0) {
          this.xAxis.indexLabels[pointX] = this.xAxis.labels.length;
          this.xAxis.labels.push(pointX);
        }
        point.xValue = this.xAxis.indexLabels[pointX];
      } else {
        if (this.xAxis.labels[index]) {
          this.xAxis.labels[index] += ", " + pointX;
        } else {
          this.xAxis.labels.push(pointX);
        }
        point.xValue = index;
      }
    };
    SeriesBase2.prototype.getAverage = function(member, i, data) {
      if (data === void 0) {
        data = this.currentViewData;
      }
      var previous = data[i - 1] ? data[i - 1][member] || 0 : 0;
      var next = data[i + 1] ? data[i + 1][member] || 0 : 0;
      return (previous + next) / 2;
    };
    SeriesBase2.prototype.refreshDataManager = function(chart) {
      var _this = this;
      this.chart = chart;
      var dataSource;
      var isAngular = "isAngular";
      if (chart[isAngular]) {
        dataSource = Object.keys(this.dataSource).length ? this.dataSource : chart.dataSource;
      } else {
        dataSource = this.dataSource || chart.dataSource;
      }
      if (!(dataSource instanceof DataManager) && isNullOrUndefined(this.query)) {
        this.dataManagerSuccess({
          result: dataSource,
          count: dataSource.length
        }, false);
        return;
      }
      var dataManager = this.dataModule.getData(this.dataModule.generateQuery().requiresCount());
      dataManager.then(function(e) {
        return _this.dataManagerSuccess(e);
      });
    };
    SeriesBase2.prototype.dataManagerSuccess = function(e, isRemoteData) {
      if (isRemoteData === void 0) {
        isRemoteData = true;
      }
      this.currentViewData = e.count ? e.result : [];
      this.chart.allowServerDataBinding = false;
      if (this instanceof Series) {
        if (this.chart.stockChart) {
          this.chart.stockChart.series[this.index].localData = this.currentViewData;
        }
        var argsData = {
          name: seriesRender,
          series: this,
          data: this.currentViewData,
          fill: this.interior
        };
        this.chart.trigger(seriesRender, argsData);
        this.interior = argsData.fill;
        this.currentViewData = argsData.data;
      }
      if (this.chart.stockChart && !(this instanceof Series)) {
        this.currentViewData = this.chart.stockChart.findCurrentData(this.chart.stockChart.series[0].localData, this.chart.stockChart.series[0].xName);
      }
      this.processJsonData();
      this.recordsCount = e.count;
      this.refreshChart(isRemoteData);
      this.currentViewData = null;
    };
    SeriesBase2.prototype.refreshChart = function(isRemoteData) {
      var chart = this.chart;
      if (this instanceof Series) {
        chart.visibleSeriesCount += isRemoteData ? 1 : 0;
      }
      chart.refreshTechnicalIndicator(this);
      if (this instanceof Series && this.category !== "TrendLine") {
        for (var _i = 0, _a = this.trendlines; _i < _a.length; _i++) {
          var trendline = _a[_i];
          trendline.setDataSource(this, chart);
        }
      }
      if (chart.visibleSeries.length === chart.visibleSeriesCount) {
        chart.refreshBound();
        chart.trigger("loaded", {
          chart: chart.isBlazor ? {} : chart
        });
        if (this.chart.stockChart && this.chart.stockChart.initialRender) {
          this.chart.stockChart.initialRender = false;
          this.chart.stockChart.stockChartDataManagerSuccess();
        }
      }
      if (this instanceof Series) {
        chart.visibleSeriesCount += isRemoteData ? 0 : 1;
      }
    };
    __decorate4([Property("")], SeriesBase2.prototype, "xName", void 0);
    __decorate4([Property("")], SeriesBase2.prototype, "colorName", void 0);
    __decorate4([Property("")], SeriesBase2.prototype, "high", void 0);
    __decorate4([Property("")], SeriesBase2.prototype, "low", void 0);
    __decorate4([Property("")], SeriesBase2.prototype, "open", void 0);
    __decorate4([Property("")], SeriesBase2.prototype, "close", void 0);
    __decorate4([Property("")], SeriesBase2.prototype, "volume", void 0);
    __decorate4([Property("")], SeriesBase2.prototype, "pointColorMapping", void 0);
    __decorate4([Property(true)], SeriesBase2.prototype, "visible", void 0);
    __decorate4([Property(null)], SeriesBase2.prototype, "xAxisName", void 0);
    __decorate4([Property(null)], SeriesBase2.prototype, "yAxisName", void 0);
    __decorate4([Complex(null, Animation2)], SeriesBase2.prototype, "animation", void 0);
    __decorate4([Property(null)], SeriesBase2.prototype, "fill", void 0);
    __decorate4([Property(1)], SeriesBase2.prototype, "width", void 0);
    __decorate4([Property("")], SeriesBase2.prototype, "dashArray", void 0);
    __decorate4([Property("")], SeriesBase2.prototype, "dataSource", void 0);
    __decorate4([Property()], SeriesBase2.prototype, "query", void 0);
    __decorate4([Collection([], ChartSegment)], SeriesBase2.prototype, "segments", void 0);
    __decorate4([Property("X")], SeriesBase2.prototype, "segmentAxis", void 0);
    __decorate4([Property(false)], SeriesBase2.prototype, "enableComplexProperty", void 0);
    return SeriesBase2;
  }(ChildProperty)
);
var Series = (
  /** @class */
  function(_super) {
    __extends5(Series2, _super);
    function Series2(parent, propName, defaultValue, isArray) {
      var _this = _super.call(this, parent, propName, defaultValue, isArray) || this;
      _this.visibleSeriesCount = 0;
      _this.category = "Series";
      _this.isRectSeries = false;
      _this.drawPoints = [];
      _this.lowDrawPoints = [];
      _this.delayedAnimation = false;
      _this.rangeColorName = _this.colorName.length > 0 ? _this.colorName : _this.yName;
      _this.currentData = [];
      return _this;
    }
    Series2.prototype.refreshAxisLabel = function() {
      if (this.xAxis.valueType.indexOf("Category") === -1) {
        return null;
      }
      this.xAxis.labels = [];
      this.xAxis.indexLabels = {};
      var option = {
        skeleton: "full",
        type: "dateTime"
      };
      var dateParser = this.chart.intl.getDateParser(option);
      var dateFormatter = this.chart.intl.getDateFormat(option);
      for (var _i = 0, _a = this.xAxis.series; _i < _a.length; _i++) {
        var item = _a[_i];
        if (item.visible && item.category !== "TrendLine") {
          item.xMin = Infinity;
          item.xMax = -Infinity;
          for (var _b = 0, _c = item.points; _b < _c.length; _b++) {
            var point = _c[_b];
            item.pushCategoryData(point, point.index, this.xAxis.valueType === "DateTimeCategory" ? Date.parse(dateParser(dateFormatter(point.x))).toString() : point.x);
            item.xMin = Math.min(item.xMin, point.xValue);
            item.xMax = Math.max(item.xMax, point.xValue);
          }
        }
      }
    };
    Series2.prototype.findSeriesCollection = function(column, row, isStack) {
      var seriesCollection = [];
      for (var _i = 0, _a = row.axes; _i < _a.length; _i++) {
        var rowAxis = _a[_i];
        for (var _b = 0, _c = rowAxis.series; _b < _c.length; _b++) {
          var rowSeries = _c[_b];
          for (var _d = 0, _e = column.axes; _d < _e.length; _d++) {
            var axis = _e[_d];
            for (var _f = 0, _g = axis.series; _f < _g.length; _f++) {
              var series = _g[_f];
              if (series === rowSeries && series.visible && this.rectSeriesInChart(series, isStack)) {
                seriesCollection.push(series);
              }
            }
          }
        }
      }
      return seriesCollection;
    };
    Series2.prototype.rectSeriesInChart = function(series, isStack) {
      var type = series.type.toLowerCase();
      return type.indexOf("column") !== -1 || type.indexOf("bar") !== -1 || type.indexOf("histogram") !== -1 || type.indexOf("hiloopenclose") !== -1 || type.indexOf("candle") !== -1 || type.indexOf("pareto") !== -1 || type.indexOf("hilo") !== -1 || series.drawType.indexOf("Column") !== -1 || type.indexOf("waterfall") !== -1 || type.indexOf("boxandwhisker") !== -1 || isStack;
    };
    Series2.prototype.calculateStackedValue = function(isStacking100, chart) {
      for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {
        var columnItem = _a[_i];
        for (var _b = 0, _c = chart.rows; _b < _c.length; _b++) {
          var item = _c[_b];
          this.calculateStackingValues(this.findSeriesCollection(columnItem, item, true), isStacking100);
        }
      }
    };
    Series2.prototype.calculateStackingValues = function(seriesCollection, isStacking100) {
      var startValues;
      var endValues;
      var yValues = [];
      var lastPositive = [];
      var lastNegative = [];
      var stackingGroup;
      var lastValue;
      var value;
      var frequencies = [];
      if (isStacking100) {
        frequencies = this.findFrequencies(seriesCollection);
      }
      var groupingValues = [];
      var visiblePoints = [];
      for (var i = 0; i < seriesCollection.length; i++) {
        var series = seriesCollection[i];
        if (!groupingValues[series.stackingGroup]) {
          groupingValues[series.stackingGroup] = [];
          groupingValues[series.stackingGroup].push(series);
        } else if (groupingValues[series.stackingGroup] !== void 0) {
          groupingValues[series.stackingGroup].push(series);
        }
      }
      var keys = Object.keys(groupingValues);
      for (var k = 0; k < keys.length; k++) {
        var stackingSeies = [];
        var stackedValues = [];
        var seriesCollection_2 = groupingValues[keys[k]];
        for (var _i = 0, seriesCollection_1 = seriesCollection_2; _i < seriesCollection_1.length; _i++) {
          var series = seriesCollection_1[_i];
          if (series.type.indexOf("Stacking") !== -1 || series.drawType.indexOf("Stacking") !== -1 && series.chart.chartAreaType === "PolarRadar") {
            stackingGroup = series.type.indexOf("StackingArea") !== -1 ? "StackingArea100" : series.type.indexOf("StackingLine") !== -1 ? "StackingLine100" : series.stackingGroup;
            if (!lastPositive[stackingGroup]) {
              lastPositive[stackingGroup] = [];
              lastNegative[stackingGroup] = [];
            }
            yValues = series.yData;
            startValues = [];
            endValues = [];
            stackingSeies.push(series);
            visiblePoints = getVisiblePoints(series);
            for (var j = 0, pointsLength = visiblePoints.length; j < pointsLength; j++) {
              lastValue = 0;
              value = +yValues[j];
              if (lastPositive[stackingGroup][visiblePoints[j].xValue] === void 0) {
                lastPositive[stackingGroup][visiblePoints[j].xValue] = 0;
              }
              if (lastNegative[stackingGroup][visiblePoints[j].xValue] === void 0) {
                lastNegative[stackingGroup][visiblePoints[j].xValue] = 0;
              }
              if (isStacking100) {
                value = value / frequencies[stackingGroup][visiblePoints[j].xValue] * 100;
                value = !isNaN(value) ? value : 0;
                visiblePoints[j].percentage = +value.toFixed(2);
              } else {
                stackedValues[j] = stackedValues[j] ? stackedValues[j] + Math.abs(value) : Math.abs(value);
              }
              if (value >= 0) {
                lastValue = lastPositive[stackingGroup][visiblePoints[j].xValue];
                lastPositive[stackingGroup][visiblePoints[j].xValue] += value;
              } else {
                lastValue = lastNegative[stackingGroup][visiblePoints[j].xValue];
                lastNegative[stackingGroup][visiblePoints[j].xValue] += value;
              }
              startValues.push(lastValue);
              endValues.push(value + lastValue);
              if (isStacking100 && endValues[j] > 100) {
                endValues[j] = 100;
              }
            }
            series.stackedValues = new StackValues(startValues, endValues);
            var isLogAxis = series.yAxis.valueType === "Logarithmic";
            var isColumnBarType = series.type.indexOf("Column") !== -1 || series.type.indexOf("Bar") !== -1;
            series.yMin = isLogAxis && isColumnBarType && series.yMin < 1 ? series.yMin : series.yAxis.startFromZero && series.yAxis.rangePadding === "Auto" && series.yMin >= 0 ? 0 : parseFloat(Math.min.apply(0, isStacking100 ? startValues : endValues).toFixed(10));
            series.yMax = Math.max.apply(0, endValues);
            if (series.yMin > Math.min.apply(0, endValues)) {
              series.yMin = isStacking100 ? -100 : isLogAxis && isColumnBarType && series.yMin < 1 ? series.yMin : Math.min.apply(0, endValues);
            }
            if (series.yMax < Math.max.apply(0, startValues)) {
              series.yMax = 0;
            }
          }
        }
        this.findPercentageOfStacking(stackingSeies, stackedValues, isStacking100);
      }
    };
    Series2.prototype.findPercentageOfStacking = function(stackingSeies, values, isStacking100) {
      for (var _i = 0, stackingSeies_1 = stackingSeies; _i < stackingSeies_1.length; _i++) {
        var item = stackingSeies_1[_i];
        if (isStacking100) {
          return null;
        }
        for (var _a = 0, _b = getVisiblePoints(item); _a < _b.length; _a++) {
          var point = _b[_a];
          point.percentage = Math.abs(+(point.y / values[point.index] * 100).toFixed(2));
        }
      }
    };
    Series2.prototype.findFrequencies = function(seriesCollection) {
      var frequencies = [];
      var stackingGroup;
      var visiblePoints = [];
      for (var _i = 0, seriesCollection_3 = seriesCollection; _i < seriesCollection_3.length; _i++) {
        var series = seriesCollection_3[_i];
        series.yAxis.isStack100 = series.type.indexOf("100") !== -1 ? true : false;
        visiblePoints = getVisiblePoints(series);
        if (series.type.indexOf("Stacking") !== -1) {
          stackingGroup = series.type.indexOf("StackingArea") !== -1 ? "StackingArea100" : series.type.indexOf("StackingLine") !== -1 ? "StackingLine100" : series.stackingGroup;
          if (!frequencies[stackingGroup]) {
            frequencies[stackingGroup] = [];
          }
          for (var j = 0, pointsLength = visiblePoints.length; j < pointsLength; j++) {
            if (frequencies[stackingGroup][visiblePoints[j].xValue] === void 0) {
              frequencies[stackingGroup][visiblePoints[j].xValue] = 0;
            }
            if (series.yData[j] > 0) {
              frequencies[stackingGroup][visiblePoints[j].xValue] += series.yData[j];
            } else {
              frequencies[stackingGroup][visiblePoints[j].xValue] -= series.yData[j];
            }
          }
        }
      }
      return frequencies;
    };
    Series2.prototype.renderSeries = function(chart) {
      if (this.chart.stockChart && this.xAxis.valueType === "DateTimeCategory") {
        for (var i = 0; i < this.points.length; i++) {
          var index = this.xAxis.labels.indexOf(Date.parse(this.points[i].x.toString()).toString());
          this.points[i].xValue = index;
          if (chart.series.length > 1) {
            this.xData[i] = index;
            this.xMin = this.xMin > index ? index : this.xMin;
            this.xMax = this.xMax < index ? index : this.xMax;
          }
        }
        if (this instanceof Series2 && this.type.indexOf("Spline") > -1) {
          var isArea = this.type.indexOf("Area") > -1;
          var isRange = this.type.indexOf("Range") > -1;
          this.chart["spline" + (isArea ? isRange ? "RangeArea" : "Area" : "") + "SeriesModule"].findSplinePoint(this);
        }
      }
      var seriesType = firstToLowerCase(this.type);
      seriesType = seriesType.replace("100", "");
      if (chart[seriesType + "SeriesModule"]) {
        if (this.category !== "Indicator" && this.category !== "TrendLine") {
          this.createSeriesElements(chart);
        }
        this.visiblePoints = getVisiblePoints(this);
        if (this.chart.enableCanvas) {
          this.chart.canvasRender.ctx.save();
          this.chart.canvasRender.ctx.beginPath();
          if (chart.requireInvertedAxis) {
            this.chart.canvasRender.ctx.rect(this.yAxis.rect.x, this.xAxis.rect.y, this.yAxis.rect.width, this.xAxis.rect.height);
          } else {
            this.chart.canvasRender.ctx.rect(this.xAxis.rect.x, this.yAxis.rect.y, this.xAxis.rect.width, this.yAxis.rect.height);
          }
          this.chart.canvasRender.ctx.clip();
          chart[seriesType + "SeriesModule"].render(this, this.xAxis, this.yAxis, chart.requireInvertedAxis);
          this.chart.canvasRender.ctx.restore();
        } else {
          chart[seriesType + "SeriesModule"].render(this, this.xAxis, this.yAxis, chart.requireInvertedAxis);
        }
        if (this.category !== "Indicator") {
          if (this.errorBar.visible) {
            this.chart.errorBarModule.render(this);
          }
          if (this.marker.dataLabel.visible) {
            if (this.chart.enableCanvas) {
              this.chart.canvasRender.ctx.save();
              this.chart.canvasRender.ctx.beginPath();
              if (chart.requireInvertedAxis) {
                this.chart.canvasRender.ctx.rect(this.yAxis.rect.x, this.xAxis.rect.y, this.yAxis.rect.width, this.xAxis.rect.height);
              } else {
                this.chart.canvasRender.ctx.rect(this.xAxis.rect.x, this.yAxis.rect.y, this.xAxis.rect.width, this.yAxis.rect.height);
              }
              this.chart.canvasRender.ctx.clip();
              chart.dataLabelModule.render(this, this.chart, this.marker.dataLabel);
              this.chart.canvasRender.ctx.restore();
            } else {
              chart.dataLabelModule.render(this, this.chart, this.marker.dataLabel);
            }
          }
          this.appendSeriesElement(chart.seriesElements, chart);
        }
        if (!this.chart.enableCanvas) {
          this.performAnimation(chart, seriesType, this.errorBar, this.marker, this.marker.dataLabel);
        }
      }
    };
    Series2.prototype.createSeriesElements = function(chart) {
      if (this.category !== "Indicator") {
        var elementId = chart.element.id;
        var explodeValue = this.marker.border.width + 8 + 5;
        var render = this.type === "Bubble" || this.type === "Scatter" || !this.marker.visible && chart.tooltip.shared && chart.enableCanvas ? chart.svgRenderer : chart.renderer;
        var index = this.index === void 0 ? this.category : this.index;
        var markerHeight = void 0;
        var markerWidth = void 0;
        var options = void 0;
        if (this.type === "Scatter" || this.drawType === "Scatter") {
          markerHeight = (this.marker.height + explodeValue) / 2;
          markerWidth = (this.marker.width + explodeValue) / 2;
        } else {
          markerHeight = 0;
          markerWidth = 0;
        }
        if (chart.chartAreaType === "PolarRadar") {
          var markerMaxValue = this.drawType === "Scatter" ? Math.max(this.marker.width, this.marker.height) : 0;
          options = new CircleOption(elementId + "_ChartSeriesClipRect_" + index, "transparent", {
            width: 1,
            color: "Gray"
          }, 1, this.clipRect.width / 2 + this.clipRect.x, this.clipRect.height / 2 + this.clipRect.y, chart.radius + markerMaxValue);
          this.clipRectElement = appendClipElement(chart.redraw, options, render, "drawCircularClipPath");
        } else {
          options = new RectOption(elementId + "_ChartSeriesClipRect_" + index, "transparent", {
            width: 1,
            color: "Gray"
          }, 1, {
            x: this.xAxis.columnIndex === 0 ? -markerWidth : 0,
            y: this.yAxis.rowIndex === chart.rows.length - 1 ? -markerHeight : 0,
            width: this.clipRect.width + (this.xAxis.columnIndex === chart.columns.length - 1 ? markerWidth * 2 : markerWidth),
            height: this.clipRect.height + (this.yAxis.rowIndex === 0 ? markerHeight * 2 : markerHeight)
          });
          this.clipRectElement = appendClipElement(chart.redraw, options, render);
        }
        var transform = chart.chartAreaType === "Cartesian" ? "translate(" + this.clipRect.x + "," + this.clipRect.y + ")" : "";
        this.symbolElement = null;
        this.seriesElement = render.createGroup({
          "id": elementId + "SeriesGroup" + index,
          "transform": transform,
          "clip-path": "url(#" + elementId + "_ChartSeriesClipRect_" + index + ")"
        });
        if (this.seriesElement) {
          this.seriesElement.setAttribute("role", this.accessibility.accessibilityRole ? this.accessibility.accessibilityRole : "region");
          this.seriesElement.setAttribute("tabindex", this.accessibility.focusable ? String(this.accessibility.tabIndex) : "-1");
          this.seriesElement.style.outline = "none";
          this.seriesElement.setAttribute("aria-label", this.accessibility.accessibilityDescription ? this.accessibility.accessibilityDescription : this.name + "," + this.type + " series with " + this.points.length + " data points");
          this.seriesElement.setAttribute("aria-hidden", "false");
        }
        if (!this.chart.enableCanvas || this.type === "Bubble") {
          this.seriesElement.setAttribute("tabindex", this.accessibility.focusable ? index === 0 ? "0" : !this.checkTabindex(chart.visibleSeries, index) ? String(this.accessibility.tabIndex) : "" : "-1");
          this.seriesElement.style.outline = "none";
          this.seriesElement.appendChild(this.clipRectElement);
        }
      }
    };
    Series2.prototype.checkTabindex = function(visibleSeries, index) {
      for (var i = 0; i < index; i++) {
        if (visibleSeries[i].visible) {
          return true;
        }
      }
      return false;
    };
    Series2.prototype.appendSeriesElement = function(element, chart) {
      var marker = this.marker;
      var dataLabel = marker.dataLabel;
      var redraw = chart.redraw;
      if (this.category !== "TrendLine") {
        appendChildElement(chart.enableCanvas, chart.seriesElements, this.seriesElement, redraw);
        var errorBar = this.errorBar;
        if (errorBar.visible) {
          if (chart.chartAreaType === "PolarRadar") {
            appendChildElement(chart.enableCanvas, chart.seriesElements, this.seriesElement, redraw);
          } else {
            appendChildElement(chart.enableCanvas, chart.seriesElements, this.errorBarElement, redraw);
          }
        }
      }
      if (marker.visible && (chart.chartAreaType === "Cartesian" || this.drawType !== "Scatter" && chart.chartAreaType === "PolarRadar") && this.type !== "Scatter" && this.type !== "Bubble" && this.type !== "Candle" && this.type !== "Hilo" && this.type !== "HiloOpenClose" && this.symbolElement) {
        appendChildElement(chart.enableCanvas, chart.seriesElements, this.symbolElement, redraw);
      }
      if (dataLabel.visible && this.textElement) {
        appendChildElement(chart.enableCanvas, chart.dataLabelElements, this.shapeElement, redraw);
        appendChildElement(chart.enableCanvas, chart.dataLabelElements, this.textElement, redraw);
      }
      if (!chart.enableCanvas && chart.dataLabelElements.hasChildNodes()) {
        chart.seriesElements.appendChild(chart.dataLabelElements);
      }
    };
    Series2.prototype.performAnimation = function(chart, type, errorBar, marker, dataLabel) {
      if ((this.animation.enable && animationMode !== "Disable" || animationMode === "Enable") && chart.animateSeries && (!chart.stockChart || !chart.stockChart.isStockChartRendered)) {
        chart[type + "SeriesModule"].doAnimation(this);
        if (errorBar.visible) {
          chart.errorBarModule.doErrorBarAnimation(this);
        }
        if (marker.visible && (this.isRectSeries || this.type === "Line" || this.type === "Polar" || this.type === "Radar")) {
          chart.markerRender.doMarkerAnimation(this);
        }
        if (dataLabel.visible && Browser.info.name !== "edge" && !Browser.isIE) {
          chart.dataLabelModule.doDataLabelAnimation(this);
        }
      }
    };
    Series2.prototype.setPointColor = function(point, color) {
      color = point.interior || color;
      return point.isEmpty ? this.emptyPointSettings.fill || color : color;
    };
    Series2.prototype.setBorderColor = function(point, border) {
      border.width = point.isEmpty ? this.emptyPointSettings.border.width || border.width : border.width;
      border.color = point.isEmpty ? this.emptyPointSettings.border.color || border.color : border.color;
      return border;
    };
    Series2.prototype.addPoint = function(dataPoint, duration) {
      var yMin = this.yMin;
      var yMax = this.yMax;
      this.removeTrackballElements();
      this.dataSource.push(dataPoint);
      if (this.type === "Radar" || this.type === "Polar") {
        return this.chart.refresh();
      }
      if (this.type === "Histogram") {
        this.currentViewData = this.chart[firstToLowerCase(this.type) + "SeriesModule"].processInternalData(extend([], this.dataSource, null, true), this);
        for (var i = 0; i < this.currentViewData.length; i++) {
          this.updatePoint(i);
        }
      } else {
        this.currentViewData = this.dataSource;
        var pointIndex = this.points.length === 0 ? 0 : this.points[this.points.length - 1].index + 1;
        this.updatePoint(pointIndex);
      }
      if (this.category === "Pareto") {
        var dataSource = extend([], this.dataSource, null, true);
        var series = this.chart.visibleSeries[this.index + this.chart.series.length];
        series.currentViewData = this.chart.paretoSeriesModule.performCumulativeCalculation(dataSource, this);
        for (var i = 0; i < series.currentViewData.length; i++) {
          if (!series.points[i]) {
            series.updatePoint(i);
          }
          series.points[i].y = series.points[i].yValue = series.currentViewData[i][series.yName];
        }
      }
      this.updateSplineValue();
      this.chart.calculateStackValues();
      this.chart.redraw = this.chart.enableAnimation;
      var chartDuration = this.chart.duration;
      this.chart.duration = isNullOrUndefined(duration) ? 500 : duration;
      this.chart.animateSeries = false;
      this.chart.pointsAdded = true;
      if (this.chart.enableAnimation && !(this.isRectSeries || this.type === "Bubble" || this.type === "Scatter") && this.type.indexOf("step") === -1) {
        if (this.marker && this.marker.visible && this.visible) {
          for (var i = this.points.length - 2; i >= 0; i--) {
            if (this.points[i] && !isNullOrUndefined(this.points[this.points.length - 2].y) && this.points[i].symbolLocations && this.points[i].symbolLocations[0] !== void 0) {
              this.chart.markerRender.renderMarker(this, this.points[this.points.length - 2], this.points[i].symbolLocations[0], null, true);
              break;
            }
          }
        }
      }
      if (this.yMin >= yMin && this.yMax <= yMax) {
        if (!setRange(this.xAxis)) {
          this.xAxis.baseModule.calculateRangeAndInterval(new Size(this.xAxis.rect.width, this.chart.availableSize.height), this.xAxis);
          this.xAxis.updateAxis();
        }
        this.chart.pointsAdded = false;
        this.updateSeries(true, false);
      }
      if (this.yMin < yMin || this.yMax > yMax) {
        this.updateChartAxis();
        this.chart.pointsAdded = false;
        this.updateSeries(true, true);
      }
      this.chart.redraw = false;
      this.chart.duration = chartDuration;
    };
    Series2.prototype.removePoint = function(index, duration) {
      var dataSource = extend([], this.dataSource, null, true);
      var chartDuration = this.chart.duration;
      if (dataSource.length > 0 && index >= 0 && index < dataSource.length) {
        dataSource.splice(index, 1);
        this.dataSource.splice(index, 1);
        this.removeTrackballElements(index);
        if (this.type === "Radar" || this.type === "Polar") {
          return this.chart.refresh();
        }
        this.chart.redraw = this.chart.enableAnimation;
        this.chart.animateSeries = false;
        this.chart.pointsAdded = true;
        this.chart.duration = isNullOrUndefined(duration) ? 500 : duration;
        if (this.type === "Histogram") {
          var length_1 = this.points.length;
          this.points = [];
          this.visiblePoints = [];
          this.currentViewData = this.chart[firstToLowerCase(this.type) + "SeriesModule"].processInternalData(extend([], this.dataSource, null, true), this);
          for (var i = 0; i < this.currentViewData.length; i++) {
            this.updatePoint(i);
          }
          if (length_1 > this.points.length) {
            this.removedPointIndex = index;
          }
        } else {
          this.removedPointIndex = index;
          this.points.splice(index, 1);
          this.visiblePoints.splice(index, 1);
        }
        this.yData = [];
        this.xData = [];
        var yMin = this.yMin;
        var yMax = this.yMax;
        this.yMin = Infinity;
        this.xMin = Infinity;
        this.yMax = -Infinity;
        this.xMax = -Infinity;
        if (this.xAxis.valueType.indexOf("Category") > -1 && this.chart.series.length === 1) {
          this.xAxis.labels = [];
          this.xAxis.indexLabels = {};
        }
        if (index === 0) {
          this.chart.pointsRemoved = this.chart.enableAnimation;
        }
        for (var i = 0; i < this.points.length; i++) {
          this.updatePointsAfterRemoval(i);
        }
        if (this.category === "Pareto") {
          var series = this.chart.visibleSeries[this.index + this.chart.series.length];
          series.yMin = Infinity;
          series.xMin = Infinity;
          series.yMax = -Infinity;
          series.xMax = -Infinity;
          series.points.splice(index, 1);
          series.visiblePoints.splice(index, 1);
          series.currentViewData = this.chart.paretoSeriesModule.performCumulativeCalculation(this.dataSource, this);
          for (var i = 0; i < series.currentViewData.length; i++) {
            series.points[i].y = series.points[i].yValue = series.currentViewData[i][series.yName];
            series.updatePointsAfterRemoval(i);
          }
        }
        this.updateSplineValue();
        this.chart.calculateStackValues();
        if (!setRange(this.xAxis) && yMax === this.yMax && yMin === this.yMin) {
          this.xAxis.baseModule.calculateRangeAndInterval(new Size(this.xAxis.rect.width, this.chart.availableSize.height), this.xAxis);
          this.xAxis.updateAxis();
          this.createSeriesElements(this.chart);
          this.chart.pointsAdded = false;
          this.updateSeries(true, false);
        } else if (yMax < this.yMax || yMin > this.yMin || yMax > this.yMax || yMin < this.yMin) {
          this.updateChartAxis();
          this.createSeriesElements(this.chart);
          this.chart.pointsAdded = false;
          this.updateSeries(true, true);
        }
      }
      appendChildElement(this.chart.enableCanvas, this.chart.seriesElements, this.seriesElement, true);
      this.chart.redraw = false;
      this.chart.duration = chartDuration;
      this.chart.pointsRemoved = false;
      this.removedPointIndex = null;
    };
    Series2.prototype.updatePointsAfterRemoval = function(index) {
      var point = this.points[index];
      var option = {
        skeleton: "full",
        type: "dateTime"
      };
      var dateParser = this.chart.intl.getDateParser(option);
      var dateFormatter = this.chart.intl.getDateFormat(option);
      if (this.xAxis.valueType === "Category" && this.chart.series.length === 1) {
        this.pushCategoryData(point, index, point.x);
      } else if (this.xAxis.valueType === "DateTimeCategory" && this.chart.series.length === 1) {
        this.pushCategoryData(point, index, Date.parse(dateParser(dateFormatter(point.x))).toString());
      }
      this.pushData(point, index);
      this.setEmptyPoint(this.points[index], index);
    };
    Series2.prototype.removeTrackballElements = function(index) {
      if (this.marker.visible) {
        if (index !== void 0) {
          var baseId = this.chart.element.id + "_Series_" + this.index + "_Point_" + index + "_Trackball_";
          var trackball0 = getElement2(baseId + "0");
          if (trackball0) {
            trackball0.remove();
          }
          var trackball1 = getElement2(baseId + "1");
          if (trackball1) {
            trackball1.remove();
          }
          var symbolElement = getElement2(this.chart.element.id + "_Series_" + this.index + "_Point_" + index + "_Symbol");
          if (symbolElement) {
            symbolElement.setAttribute("visibility", "visible");
          }
        } else {
          var baseClassPattern = this.chart.element.id + "_EJ2-Trackball_Series_" + this.index + "_Point_";
          var elements = document.querySelectorAll('[class*="' + baseClassPattern + '"]');
          if (elements[0]) {
            var pointIndexMatch = elements[0].id.match(/_Point_(\d+)_/);
            var pointIndex = pointIndexMatch ? parseInt(pointIndexMatch[1], 10) : null;
            elements[0].remove();
            var symbolElement = getElement2(this.chart.element.id + "_Series_" + this.index + "_Point_" + pointIndex + "_Symbol");
            if (symbolElement) {
              symbolElement.setAttribute("visibility", "visible");
            }
          }
          if (elements[1]) {
            elements[1].remove();
          }
        }
      }
      if (this.chart.tooltip.enable) {
        this.chart.tooltipModule.previousPoints = [];
        var tooltipElement = getElement2(this.chart.element.id + "_tooltip");
        if (tooltipElement) {
          tooltipElement.remove();
        }
      }
    };
    Series2.prototype.setData = function(data, duration) {
      var _this = this;
      if (!data) {
        return null;
      }
      var updatedData = [];
      if (this.dataSource.length === data.length) {
        for (var i = 0; i < data.length; i++) {
          if (data[i][this.xName] instanceof Date) {
            updatedData.push(data[i][this.xName].getTime());
          } else {
            updatedData.push(data[i][this.xName]);
          }
          if (this.currentData.length < this.dataSource.length) {
            var dataSource = extend([], this.dataSource, null, true);
            if (dataSource[i][this.xName] instanceof Date) {
              this.currentData.push(dataSource[i][this.xName].getTime());
            } else {
              this.currentData.push(dataSource[i][this.xName]);
            }
          }
        }
      }
      var isSameData = updatedData.every(function(element) {
        return _this.currentData.indexOf(element) !== -1;
      });
      if (this.currentViewData) {
        isSameData = true;
      }
      var isXAxisChanged = false;
      var yMin = this.yMin;
      var yMax = this.yMax;
      this.yMin = Infinity;
      this.yMax = -Infinity;
      var points = [];
      this.chart.dataLabelCollections = [];
      this.chart.rotatedDataLabelCollections = [];
      var samePoints = false;
      var index = null;
      if (this.dataSource.length === data.length && !(this.type === "Radar" || this.type === "Polar") && isSameData) {
        samePoints = true;
        this.yData = [];
        if (this.type === "Histogram" && this.dataSource.length === data.length) {
          var newHistogramData = this.chart[firstToLowerCase(this.type) + "SeriesModule"].processInternalData(extend([], data, null, true), this);
          this.currentViewData = newHistogramData;
          for (var j = 0; j < newHistogramData.length; j++) {
            this.updatePoint(j);
          }
        } else {
          for (var i = 0; i < data.length; i++) {
            var newData = data[i][this.xName];
            var existingData = this.dataSource[i][this.xName];
            if (data[i][this.xName] instanceof Date) {
              newData = data[i][this.xName].getTime();
              existingData = this.dataSource[i][this.xName].getTime();
            }
            if (this.currentData[i] !== newData) {
              isXAxisChanged = true;
            }
            var point = this.points[i];
            var getObjectValueByMappingString = this.enableComplexProperty ? getValue : this.getObjectValue;
            var existingPoint = this.dataSource[i];
            var newPoint = data[i];
            if (this.seriesType === "XY" || this.seriesType === "BoxPlot") {
              point.y = getObjectValueByMappingString(this.yName, newPoint);
              if (this.type === "Bubble" && existingPoint[this.size] !== newPoint[this.size]) {
                point.size = getObjectValueByMappingString(this.size, newPoint);
              }
              points.push(i);
            } else if (existingPoint[this.high] !== newPoint[this.high] || existingPoint[this.low] !== newPoint[this.low] || existingPoint[this.open] !== newPoint[this.open] || existingPoint[this.close] !== newPoint[this.close] || existingPoint[this.volume] !== newPoint[this.volume]) {
              point.high = getObjectValueByMappingString(this.high, newPoint);
              point.low = getObjectValueByMappingString(this.low, newPoint);
              point.open = getObjectValueByMappingString(this.open, newPoint);
              point.close = getObjectValueByMappingString(this.close, newPoint);
              point.volume = getObjectValueByMappingString(this.volume, newPoint);
              points.push(i);
            }
            point.yValue = point.y;
            point.x = getObjectValueByMappingString(this.xName, newPoint);
            if (!this.currentViewData) {
              point.index = this.xAxis.valueType === "DateTime" && typeof point.x !== "number" ? this.currentData.indexOf(point.x.getTime()) : this.currentData.indexOf(point.x);
            }
            if ((this.xAxis.valueType === "Category" || this.xAxis.valueType === "DateTimeCategory") && i < this.xAxis.visibleLabels.length) {
              this.xAxis.visibleLabels[i].value = updatedData.indexOf(this.currentData[i * this.xAxis.visibleRange.interval]);
              this.xAxis.labels[i] = String(updatedData[i]);
            }
            this.setEmptyPoint(point, i);
            this.dataSource[i] = data[i];
          }
        }
      }
      if (!samePoints) {
        this.dataSource = data;
      } else {
        this.chart.redraw = this.chart.enableAnimation;
        this.chart.animateSeries = false;
        this.chart.pointsAdded = true;
        var chartDuration = this.chart.duration;
        this.chart.duration = isNullOrUndefined(duration) ? 500 : duration;
        if (this.type.indexOf("Stacking") !== -1) {
          this.chart.calculateStackValues();
        }
        this.updateSplineValue();
        if (yMax === this.yMax && yMin === this.yMin && this.visible) {
          this.chart.pointsAdded = false;
          this.chart[firstToLowerCase(this.category === "Pareto" ? "Column" : this.type.replace("100", "")) + "SeriesModule"].updateDirection(this, points, this.chart.requireInvertedAxis);
          if (this.chart.annotationModule) {
            this.chart.annotationModule.renderAnnotations(getElement2(this.chart.element.id + "_Secondary_Element"));
          }
          if (!setRange(this.xAxis) && isXAxisChanged) {
            this.xAxis.updateAxis();
          }
        } else if ((yMax < this.yMax || yMin > this.yMin || yMax > this.yMax || yMin < this.yMin) && this.visible) {
          var maximumLabelWidth = this.yAxis.maxLabelSize.width;
          this.yAxis.baseModule.calculateRangeAndInterval(new Size(this.chart.availableSize.width, this.yAxis.rect.height), this.yAxis);
          if (maximumLabelWidth < this.yAxis.maxLabelSize.width) {
            this.chart.calculateBounds();
            this.chart.axisCollections.forEach(function(axis) {
              if (!setRange(axis)) {
                axis.updateAxis();
              }
            });
            this.chart.chartAxisLayoutPanel.drawPaneLines(this.chart);
            this.chart.renderAreaBorder();
          } else {
            if (!setRange(this.yAxis)) {
              this.yAxis.updateAxis();
            }
            if (!setRange(this.xAxis) && isXAxisChanged) {
              this.xAxis.updateAxis();
            }
            if (this.type === "Histogram" && !setRange(this.xAxis)) {
              this.xAxis.baseModule.calculateRangeAndInterval(new Size(this.xAxis.rect.width, this.chart.availableSize.height), this.xAxis);
              this.xAxis.updateAxis();
            }
          }
          this.chart.pointsAdded = false;
          if (isXAxisChanged) {
            this.chart[firstToLowerCase(this.category === "Pareto" ? "Column" : this.type.replace("100", "")) + "SeriesModule"].updateDirection(this, points, this.chart.requireInvertedAxis);
            index = this.index;
          }
          this.updateSeries(false, true, index);
          if (this.chart.stripLineModule) {
            this.chart.stripLineModule.renderStripLine(this.chart, "Behind", this.chart.axisCollections);
          }
        }
        this.chart.redraw = false;
        this.chart.pointsRemoved = false;
        this.chart.duration = chartDuration;
      }
    };
    Series2.prototype.updateChartAxis = function() {
      var maximumLabelWidth = this.yAxis.maxLabelSize.width;
      this.yAxis.baseModule.calculateRangeAndInterval(new Size(this.chart.availableSize.width, this.yAxis.rect.height), this.yAxis);
      if (maximumLabelWidth < this.yAxis.maxLabelSize.width) {
        this.chart.calculateBounds();
        this.chart.axisCollections.forEach(function(axis) {
          if (!setRange(axis)) {
            axis.updateAxis();
          }
        });
        this.chart.chartAxisLayoutPanel.drawPaneLines(this.chart);
        this.chart.renderAreaBorder();
      } else {
        if (!setRange(this.xAxis)) {
          this.xAxis.baseModule.calculateRangeAndInterval(new Size(this.xAxis.rect.width, this.chart.availableSize.height), this.xAxis);
          this.xAxis.updateAxis();
        }
        if (!setRange(this.yAxis)) {
          this.yAxis.updateAxis();
        }
      }
      if (this.chart.stripLineModule) {
        this.chart.stripLineModule.renderStripLine(this.chart, "Behind", this.chart.axisCollections);
      }
    };
    Series2.prototype.updateSeries = function(xAxis, yAxis, index) {
      var seriesCollection = [];
      if (xAxis && yAxis) {
        var set = new Set(this.xAxis.series.concat(this.yAxis.series));
        set.forEach(function(series2) {
          seriesCollection.push(series2);
        });
      } else {
        seriesCollection = xAxis ? this.xAxis.series.slice() : this.yAxis.series.slice();
      }
      for (var _i = 0, seriesCollection_4 = seriesCollection; _i < seriesCollection_4.length; _i++) {
        var series = seriesCollection_4[_i];
        if (series.visible && series.index !== index) {
          findClipRect(series, this.chart.enableCanvas);
          var transform = "translate(" + this.clipRect.x + "," + this.clipRect.y + ")";
          series.seriesElement.setAttribute("transform", transform);
          series.chart[firstToLowerCase(series.type.replace("100", "")) + "SeriesModule"].render(series, series.xAxis, series.yAxis, series.chart.requireInvertedAxis, series.chart.enableAnimation);
          if (series.marker.visible && series.chart.chartAreaType === "Cartesian" && series.type !== "Scatter" && series.type !== "Bubble" && series.type !== "Candle" && series.type !== "Hilo" && series.type !== "HiloOpenClose" && series.symbolElement) {
            series.symbolElement.setAttribute("transform", transform);
            appendChildElement(series.chart.enableCanvas, series.chart.seriesElements, series.symbolElement, true);
          }
          if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {
            series.chart.dataLabelCollections = [];
            series.chart.dataLabelModule.render(series, series.chart, series.marker.dataLabel);
            if (series.textElement) {
              if (series.shapeElement) {
                series.shapeElement.setAttribute("transform", transform);
              }
              appendChildElement(series.chart.enableCanvas, series.chart.dataLabelElements, series.shapeElement, true);
              series.textElement.setAttribute("transform", transform);
              appendChildElement(series.chart.enableCanvas, series.chart.dataLabelElements, series.textElement, true);
            }
          }
          if (series.chart.annotationModule) {
            series.chart.annotationModule.renderAnnotations(getElement2(series.chart.element.id + "_Secondary_Element"));
          }
        }
      }
    };
    Series2.prototype.updatePoint = function(index) {
      var point = new Points();
      var textMappingName = this instanceof Series2 && this.marker.dataLabel.name ? this.marker.dataLabel.name : "";
      var xName = this instanceof Series2 && this.type === "Histogram" ? "x" : this.xName;
      if (this.xAxis.valueType === "Category") {
        this.pushCategoryPoint(point, index, textMappingName, xName);
      } else if (this.xAxis.valueType.indexOf("DateTime") > -1) {
        var point_1 = this.points[index];
        var option = {
          skeleton: "full",
          type: "dateTime"
        };
        var dateParser = this.chart.intl.getDateParser(option);
        var dateFormatter = this.chart.intl.getDateFormat(option);
        this.pushDateTimePoint(point_1, index, textMappingName, xName, dateParser, dateFormatter);
      } else {
        this.pushDoublePoint(point, index, textMappingName, xName);
      }
    };
    Series2.prototype.formatAccessibilityDescription = function(point, series) {
      var format = series.accessibility.accessibilityDescriptionFormat;
      return format.replace("${series.name}", series && series.name ? series.name : "").replace("${point.x}", point && point.x ? point.x.toString() : "").replace("${point.y}", point && point.y ? point.y.toString() : "").replace("${point.high}", point && point.high ? point.high.toString() : "").replace("${point.low}", point && point.low ? point.low.toString() : "").replace("${point.close}", point && point.close ? point.close.toString() : "").replace("${point.open}", point && point.open ? point.open.toString() : "").replace("${point.maximum}", point && point.maximum ? point.maximum.toString() : "").replace("${point.minimum}", point && point.minimum ? point.minimum.toString() : "").replace("${point.median}", point && point.median ? point.median.toString() : "").replace("${point.lowerQuartile}", point && point.lowerQuartile ? point.lowerQuartile.toString() : "").replace("${point.upperQuartile}", point && point.upperQuartile ? point.upperQuartile.toString() : "");
    };
    __decorate4([Property("")], Series2.prototype, "name", void 0);
    __decorate4([Property("")], Series2.prototype, "yName", void 0);
    __decorate4([Property("Line")], Series2.prototype, "drawType", void 0);
    __decorate4([Property(true)], Series2.prototype, "isClosed", void 0);
    __decorate4([Property(null)], Series2.prototype, "bearFillColor", void 0);
    __decorate4([Property(null)], Series2.prototype, "bullFillColor", void 0);
    __decorate4([Property(false)], Series2.prototype, "enableSolidCandles", void 0);
    __decorate4([Property("")], Series2.prototype, "size", void 0);
    __decorate4([Property(null)], Series2.prototype, "binInterval", void 0);
    __decorate4([Property(false)], Series2.prototype, "showNormalDistribution", void 0);
    __decorate4([Property("")], Series2.prototype, "stackingGroup", void 0);
    __decorate4([Complex({
      color: null,
      width: 0
    }, Border)], Series2.prototype, "border", void 0);
    __decorate4([Property(1)], Series2.prototype, "opacity", void 0);
    __decorate4([Property(0)], Series2.prototype, "zOrder", void 0);
    __decorate4([Property("")], Series2.prototype, "groupName", void 0);
    __decorate4([Property("Line")], Series2.prototype, "type", void 0);
    __decorate4([Complex(null, ErrorBarSettings)], Series2.prototype, "errorBar", void 0);
    __decorate4([Complex(null, MarkerSettings)], Series2.prototype, "marker", void 0);
    __decorate4([Complex(null, ParetoOptions)], Series2.prototype, "paretoOptions", void 0);
    __decorate4([Complex({}, DragSettings)], Series2.prototype, "dragSettings", void 0);
    __decorate4([Collection([], Trendline)], Series2.prototype, "trendlines", void 0);
    __decorate4([Property(true)], Series2.prototype, "enableTooltip", void 0);
    __decorate4([Property(true)], Series2.prototype, "showNearestTooltip", void 0);
    __decorate4([Property("")], Series2.prototype, "tooltipFormat", void 0);
    __decorate4([Property("")], Series2.prototype, "tooltipMappingName", void 0);
    __decorate4([Property("SeriesType")], Series2.prototype, "legendShape", void 0);
    __decorate4([Property("")], Series2.prototype, "legendImageUrl", void 0);
    __decorate4([Property(null)], Series2.prototype, "selectionStyle", void 0);
    __decorate4([Property(null)], Series2.prototype, "unSelectedStyle", void 0);
    __decorate4([Property(null)], Series2.prototype, "nonHighlightStyle", void 0);
    __decorate4([Property(1)], Series2.prototype, "minRadius", void 0);
    __decorate4([Property(3)], Series2.prototype, "maxRadius", void 0);
    __decorate4([Property("Natural")], Series2.prototype, "splineType", void 0);
    __decorate4([Property(0.5)], Series2.prototype, "cardinalSplineTension", void 0);
    __decorate4([Complex(null, EmptyPointSettings)], Series2.prototype, "emptyPointSettings", void 0);
    __decorate4([Property(true)], Series2.prototype, "showMean", void 0);
    __decorate4([Property("Normal")], Series2.prototype, "boxPlotMode", void 0);
    __decorate4([Property(true)], Series2.prototype, "showOutliers", void 0);
    __decorate4([Property(null)], Series2.prototype, "columnWidth", void 0);
    __decorate4([Property(null)], Series2.prototype, "columnWidthInPixel", void 0);
    __decorate4([Property("Rectangle")], Series2.prototype, "columnFacet", void 0);
    __decorate4([Property(0)], Series2.prototype, "columnSpacing", void 0);
    __decorate4([Property("#C64E4A")], Series2.prototype, "negativeFillColor", void 0);
    __decorate4([Property("#4E81BC")], Series2.prototype, "summaryFillColor", void 0);
    __decorate4([Property()], Series2.prototype, "intermediateSumIndexes", void 0);
    __decorate4([Property()], Series2.prototype, "sumIndexes", void 0);
    __decorate4([Property("Left")], Series2.prototype, "step", void 0);
    __decorate4([Property(false)], Series2.prototype, "noRisers", void 0);
    __decorate4([Complex({}, SeriesAccessibility)], Series2.prototype, "accessibility", void 0);
    __decorate4([Complex({
      color: "black",
      width: 2
    }, Connector)], Series2.prototype, "connector", void 0);
    __decorate4([Complex(null, CornerRadius)], Series2.prototype, "cornerRadius", void 0);
    return Series2;
  }(SeriesBase)
);

// node_modules/@syncfusion/ej2-charts/src/chart/technical-indicators/technical-indicator.js
var __extends6 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate5 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var TechnicalIndicator = (
  /** @class */
  function(_super) {
    __extends6(TechnicalIndicator2, _super);
    function TechnicalIndicator2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.clipRect = new Rect(0, 0, 0, 0);
      return _this;
    }
    TechnicalIndicator2.prototype.setDataSource = function(series, chart) {
      if (series) {
        this.xData = series.xData;
        this.yData = series.yData;
        this.points = series.points;
      }
      var type = firstToLowerCase(this.type);
      if (this.visible) {
        chart[type + "IndicatorModule"].initDataSource(this, chart);
      }
      chart.visibleSeriesCount += this.targetSeries.length;
    };
    __decorate5([Property("Sma")], TechnicalIndicator2.prototype, "type", void 0);
    __decorate5([Property(14)], TechnicalIndicator2.prototype, "period", void 0);
    __decorate5([Property(14)], TechnicalIndicator2.prototype, "kPeriod", void 0);
    __decorate5([Property(3)], TechnicalIndicator2.prototype, "dPeriod", void 0);
    __decorate5([Property(80)], TechnicalIndicator2.prototype, "overBought", void 0);
    __decorate5([Property(20)], TechnicalIndicator2.prototype, "overSold", void 0);
    __decorate5([Property(2)], TechnicalIndicator2.prototype, "standardDeviation", void 0);
    __decorate5([Property("Close")], TechnicalIndicator2.prototype, "field", void 0);
    __decorate5([Property(12)], TechnicalIndicator2.prototype, "slowPeriod", void 0);
    __decorate5([Property(26)], TechnicalIndicator2.prototype, "fastPeriod", void 0);
    __decorate5([Property(true)], TechnicalIndicator2.prototype, "showZones", void 0);
    __decorate5([Complex({
      color: "#ff9933",
      width: 2
    }, Connector)], TechnicalIndicator2.prototype, "macdLine", void 0);
    __decorate5([Property("Both")], TechnicalIndicator2.prototype, "macdType", void 0);
    __decorate5([Property("#2ecd71")], TechnicalIndicator2.prototype, "macdPositiveColor", void 0);
    __decorate5([Property("#e74c3d")], TechnicalIndicator2.prototype, "macdNegativeColor", void 0);
    __decorate5([Property("rgba(211,211,211,0.25)")], TechnicalIndicator2.prototype, "bandColor", void 0);
    __decorate5([Complex({
      color: "#ffb735",
      width: 1
    }, Connector)], TechnicalIndicator2.prototype, "upperLine", void 0);
    __decorate5([Complex({
      color: "#f2ec2f",
      width: 1
    }, Connector)], TechnicalIndicator2.prototype, "lowerLine", void 0);
    __decorate5([Complex({
      color: "#f2ec2f",
      width: 1
    }, Connector)], TechnicalIndicator2.prototype, "periodLine", void 0);
    __decorate5([Complex({}, Accessibility)], TechnicalIndicator2.prototype, "accessibility", void 0);
    __decorate5([Property("")], TechnicalIndicator2.prototype, "seriesName", void 0);
    return TechnicalIndicator2;
  }(SeriesBase)
);

// node_modules/@syncfusion/ej2-charts/src/chart/axis/cartesian-panel.js
var axisPadding = 10;
var CartesianAxisLayoutPanel = (
  /** @class */
  function() {
    function CartesianAxisLayoutPanel3(chartModule) {
      this.chart = chartModule;
      this.padding = 5;
    }
    CartesianAxisLayoutPanel3.prototype.measureAxis = function(rect) {
      var chart = this.chart;
      var chartAreaWidth = chart.chartArea.width ? stringToNumber(chart.chartArea.width, chart.availableSize.width) : null;
      this.crossAt(chart);
      this.seriesClipRect = new Rect(rect.x, rect.y, rect.width, rect.height);
      this.initialClipRect = rect;
      this.leftSize = 0;
      this.rightSize = 0;
      this.topSize = 0;
      this.bottomSize = 0;
      this.measureRowAxis(chart, this.initialClipRect);
      this.initialClipRect = subtractThickness(this.initialClipRect, new Thickness(this.leftSize, this.rightSize, 0, 0));
      this.measureColumnAxis(chart, this.initialClipRect);
      this.initialClipRect = subtractThickness(this.initialClipRect, new Thickness(0, 0, this.topSize, this.bottomSize));
      if (!this.chart.delayRedraw) {
        this.calculateAxisSize(this.initialClipRect);
      }
      this.leftSize = 0;
      this.rightSize = 0;
      this.topSize = 0;
      this.bottomSize = 0;
      this.measureRowAxis(chart, this.initialClipRect);
      this.seriesClipRect = subtractThickness(this.seriesClipRect, new Thickness(this.leftSize, this.rightSize, 0, 0));
      this.measureColumnAxis(chart, this.initialClipRect);
      this.seriesClipRect = subtractThickness(this.seriesClipRect, new Thickness(0, 0, this.topSize, this.bottomSize));
      if (chartAreaWidth) {
        this.calculateFixedChartArea(chart, chartAreaWidth);
      }
      if (!this.chart.delayRedraw) {
        chart.refreshAxis();
        this.calculateAxisSize(this.seriesClipRect);
      }
    };
    CartesianAxisLayoutPanel3.prototype.calculateFixedChartArea = function(chart, chartAreaWidth) {
      this.seriesClipRect.width = chartAreaWidth;
      this.seriesClipRect.x = chart.availableSize.width - chart.margin.right - chartAreaWidth - (chart.legendSettings.position === "Right" ? chart.legendModule.legendBounds.width : 0);
      for (var _i = 0, _a = chart.rows; _i < _a.length; _i++) {
        var item = _a[_i];
        this.seriesClipRect.x -= sum(item.farSizes);
      }
    };
    CartesianAxisLayoutPanel3.prototype.measureRowAxis = function(chart, rect) {
      var row;
      this.calculateRowSize(rect);
      for (var _i = 0, _a = chart.rows; _i < _a.length; _i++) {
        var item = _a[_i];
        row = item;
        row.nearSizes = [];
        row.farSizes = [];
        row.insideNearSizes = [];
        row.insideFarSizes = [];
        this.arrangeAxis(row);
        this.measureDefinition(row, chart, new Size(chart.availableSize.width, row.computedHeight));
        if (this.leftSize < sum(row.nearSizes)) {
          this.leftSize = sum(row.nearSizes);
        }
        if (this.rightSize < sum(row.farSizes)) {
          this.rightSize = sum(row.farSizes);
        }
      }
    };
    CartesianAxisLayoutPanel3.prototype.measureColumnAxis = function(chart, rect) {
      var column;
      this.calculateColumnSize(rect);
      for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {
        var item = _a[_i];
        column = item;
        column.farSizes = [];
        column.nearSizes = [];
        column.insideNearSizes = [];
        column.insideFarSizes = [];
        this.arrangeAxis(column);
        this.measureDefinition(column, chart, new Size(column.computedWidth, chart.availableSize.height));
        if (this.bottomSize < sum(column.nearSizes)) {
          this.bottomSize = sum(column.nearSizes);
        }
        if (this.topSize < sum(column.farSizes)) {
          this.topSize = sum(column.farSizes);
        }
      }
    };
    CartesianAxisLayoutPanel3.prototype.measureDefinition = function(definition, chart, size) {
      var ele;
      for (var _i = 0, _a = definition.axes; _i < _a.length; _i++) {
        var axis = _a[_i];
        ele = axis.scrollbarSettings.height;
        axis.scrollBarHeight = chart.scrollBarModule && chart.zoomModule && chart.zoomSettings.enableScrollbar && axis.enableScrollbarOnZooming && chart.zoomModule.isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0) ? ele : 0;
        axis.scrollBarHeight = chart.scrollBarModule && (chart.zoomModule && chart.zoomSettings.enableScrollbar && axis.enableScrollbarOnZooming && chart.zoomModule.isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0) || axis.scrollbarSettings.enable) ? ele : 0;
        axis.getModule(chart);
        axis.baseModule.calculateRangeAndInterval(size, axis);
        definition.computeSize(axis, axis.scrollBarHeight, definition, chart);
      }
      if (definition.farSizes.length > 0) {
        definition.farSizes[definition.farSizes.length - 1] -= axisPadding;
      }
      if (definition.nearSizes.length > 0) {
        definition.nearSizes[definition.nearSizes.length - 1] -= axisPadding;
      }
    };
    CartesianAxisLayoutPanel3.prototype.calculateAxisSize = function(rect) {
      var chart = this.chart;
      var row;
      var column;
      var definition;
      var axis;
      var nearCount = 0;
      var farCount = 0;
      var size = 0;
      var x;
      var y;
      var axisOffset;
      this.calculateRowSize(rect);
      for (var i = 0, len = chart.rows.length; i < len; i++) {
        row = chart.rows[i];
        nearCount = 0;
        farCount = 0;
        for (var j = 0, len_1 = row.axes.length; j < len_1; j++) {
          axis = row.axes[j];
          axisOffset = axis.plotOffset;
          if (axis.rect.height === 0) {
            axis.rect.height = row.computedHeight;
            size = 0;
            for (var k = i + 1, len_2 = i + axis.span; k < len_2; k++) {
              definition = chart.rows[k];
              size += definition.computedHeight;
            }
            axis.rect.y = row.computedTop - size + (axis.plotOffsetTop ? axis.plotOffsetTop : axisOffset);
            axis.rect.height = axis.rect.height + size - this.getAxisOffsetValue(axis.plotOffsetTop, axis.plotOffsetBottom, axis.plotOffset);
            axis.rect.width = 0;
          }
          if (axis.isAxisOpposedPosition) {
            if (axis.labelPosition === "Inside" && axis.orientation === "Vertical") {
              if (farCount > 0) {
                x = rect.x + rect.width + sum(subArray(row.farSizes, farCount)) + axis.maxLabelSize.width + axis.multiLevelLabelHeight + (axis.tickPosition === "Inside" ? axis.majorTickLines.height : 0) + axis.labelPadding;
              } else {
                x = rect.x + rect.width - sum(subArray(row.insideFarSizes, farCount));
              }
            } else {
              x = rect.x + rect.width + sum(subArray(row.farSizes, farCount));
            }
            axis.rect.x = axis.rect.x >= x ? axis.rect.x : x;
            farCount++;
          } else {
            if (axis.labelPosition === "Inside" && axis.orientation === "Vertical") {
              if (nearCount > 0) {
                x = rect.x - sum(subArray(row.nearSizes, nearCount)) - axis.maxLabelSize.width - axis.multiLevelLabelHeight - (axis.tickPosition === "Inside" ? axis.majorTickLines.height : 0) - axis.labelPadding;
              } else {
                x = rect.x + sum(subArray(row.insideNearSizes, nearCount));
              }
            } else {
              x = rect.x - sum(subArray(row.nearSizes, nearCount));
            }
            axis.rect.x = axis.rect.x <= x ? axis.rect.x : x;
            nearCount++;
          }
        }
      }
      this.calculateColumnSize(rect);
      for (var i = 0, len = chart.columns.length; i < len; i++) {
        column = chart.columns[i];
        nearCount = 0;
        farCount = 0;
        for (var j = 0, len_3 = column.axes.length; j < len_3; j++) {
          axis = column.axes[j];
          axisOffset = axis.plotOffset;
          if (axis.rect.width === 0) {
            for (var k = i, len_4 = i + axis.span; k < len_4; k++) {
              definition = chart.columns[k];
              axis.rect.width += definition.computedWidth;
            }
            axis.rect.x = column.computedLeft + (axis.plotOffsetLeft ? axis.plotOffsetLeft : axisOffset);
            axis.rect.width -= this.getAxisOffsetValue(axis.plotOffsetLeft, axis.plotOffsetRight, axis.plotOffset);
            axis.rect.height = 0;
          }
          if (axis.isAxisOpposedPosition) {
            if (axis.labelPosition === "Inside" && axis.orientation === "Horizontal") {
              if (farCount > 0) {
                y = rect.y - sum(subArray(column.farSizes, farCount)) - axis.maxLabelSize.height - axis.multiLevelLabelHeight - (axis.tickPosition === "Inside" ? axis.majorTickLines.height : 0) - axis.labelPadding;
              } else {
                y = rect.y + sum(subArray(column.insideFarSizes, farCount));
              }
            } else {
              y = rect.y - sum(subArray(column.farSizes, farCount));
            }
            axis.rect.y = axis.rect.y <= y ? axis.rect.y : y;
            farCount++;
          } else {
            if (axis.labelPosition === "Inside" && axis.orientation === "Horizontal") {
              if (nearCount > 0) {
                y = rect.y + rect.height + sum(subArray(column.nearSizes, nearCount)) + axis.maxLabelSize.height + axis.multiLevelLabelHeight + (axis.tickPosition === "Inside" ? axis.majorTickLines.height : 0) + axis.labelPadding;
              } else {
                y = rect.y + rect.height - sum(subArray(column.insideNearSizes, nearCount));
              }
            } else {
              y = rect.y + rect.height + sum(subArray(column.nearSizes, nearCount));
            }
            axis.rect.y = axis.rect.y >= y ? axis.rect.y : y;
            nearCount++;
          }
        }
      }
    };
    CartesianAxisLayoutPanel3.prototype.measure = function() {
      var chart = this.chart;
      var row;
      var column;
      var definition;
      var actualIndex;
      var span;
      for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {
        var axis = _a[_i];
        if (axis.orientation === "Vertical") {
          chart.verticalAxes.push(axis);
          actualIndex = this.getActualRow(axis);
          row = chart.rows[actualIndex];
          this.pushAxis(row, axis);
          span = actualIndex + axis.span > chart.rows.length ? chart.rows.length : actualIndex + axis.span;
          for (var j = actualIndex + 1; j < span; j++) {
            definition = chart.rows[j];
            definition.axes[row.axes.length - 1] = axis;
            chart.rows[j] = definition;
          }
          chart.rows[actualIndex] = row;
        } else {
          chart.horizontalAxes.push(axis);
          actualIndex = this.getActualColumn(axis);
          column = chart.columns[actualIndex];
          this.pushAxis(column, axis);
          span = actualIndex + axis.span > chart.columns.length ? chart.columns.length : actualIndex + axis.span;
          for (var j = actualIndex + 1; j < span; j++) {
            definition = chart.columns[j];
            definition.axes[column.axes.length - 1] = axis;
            chart.columns[j] = definition;
          }
          chart.columns[actualIndex] = column;
        }
        axis.isRTLEnabled = chart.enableRtl;
        axis.setIsInversedAndOpposedPosition();
      }
    };
    CartesianAxisLayoutPanel3.prototype.getAxisOffsetValue = function(position1, position2, plotOffset) {
      var rangeOffset = position1 ? position1 + (position2 ? position2 : plotOffset) : position2 ? position2 + plotOffset : 2 * plotOffset;
      return rangeOffset;
    };
    CartesianAxisLayoutPanel3.prototype.crossAt = function(chart) {
      for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {
        var axis = _a[_i];
        if (axis.crossesAt === null) {
          continue;
        }
        if (!axis.crossesInAxis) {
          if (chart.requireInvertedAxis) {
            axis.crossInAxis = axis.orientation === "Horizontal" ? chart.primaryXAxis : chart.primaryYAxis;
          } else {
            axis.crossInAxis = axis.orientation === "Horizontal" ? chart.primaryYAxis : chart.primaryXAxis;
          }
          axis.crossAt = this.updateCrossAt(axis.crossInAxis, axis.crossesAt);
          continue;
        } else {
          for (var i = 2, len = chart.axisCollections.length; i < len; i++) {
            if (axis.crossesInAxis === chart.axisCollections[i].name) {
              axis.crossInAxis = chart.axisCollections[i];
              axis.crossAt = this.updateCrossAt(axis.crossInAxis, axis.crossesAt);
              continue;
            }
          }
        }
      }
    };
    CartesianAxisLayoutPanel3.prototype.updateCrossAt = function(axis, crossAt) {
      switch (axis.valueType) {
        case "DateTime": {
          var option = {
            skeleton: "full",
            type: "dateTime"
          };
          var dateParser = this.chart.intl.getDateParser(option);
          var dateFormatter = this.chart.intl.getDateFormat(option);
          return Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({
            val: crossAt
          }).val))));
        }
        case "Category":
          return parseFloat(crossAt) ? parseFloat(crossAt) : axis.labels.indexOf(crossAt);
        case "Logarithmic":
          return logBase(crossAt, axis.logBase);
        default:
          return crossAt;
      }
    };
    CartesianAxisLayoutPanel3.prototype.pushAxis = function(definition, axis) {
      for (var i = 0, len = definition.axes.length; i <= len; i++) {
        if (!definition.axes[i]) {
          definition.axes[i] = axis;
          break;
        }
      }
    };
    CartesianAxisLayoutPanel3.prototype.arrangeAxis = function(definition) {
      var axisCollection = [];
      for (var i = 0, len = definition.axes.length; i <= len; i++) {
        if (definition.axes[i]) {
          axisCollection.push(definition.axes[i]);
        }
      }
      definition.axes = axisCollection;
    };
    CartesianAxisLayoutPanel3.prototype.getActualColumn = function(axis) {
      var actualLength = this.chart.columns.length;
      var pos = axis.columnIndex;
      var result = pos >= actualLength ? actualLength - 1 : pos < 0 ? 0 : pos;
      return result;
    };
    CartesianAxisLayoutPanel3.prototype.getActualRow = function(axis) {
      var actualLength = this.chart.rows.length;
      var pos = axis.rowIndex;
      var result = pos >= actualLength ? actualLength - 1 : pos < 0 ? 0 : pos;
      return result;
    };
    CartesianAxisLayoutPanel3.prototype.calculateRowSize = function(rect) {
      var chart = this.chart;
      var row;
      var rowTop = rect.y + rect.height;
      var height = 0;
      var remainingHeight = Math.max(0, rect.height);
      for (var i = 0, len = chart.rows.length; i < len; i++) {
        row = chart.rows[i];
        if (row.height.indexOf("%") !== -1) {
          height = Math.min(remainingHeight, rect.height * parseInt(row.height, 10) / 100);
        } else {
          height = Math.min(remainingHeight, parseInt(row.height, 10));
        }
        height = i !== len - 1 ? height : remainingHeight;
        row.computedHeight = height;
        rowTop -= height;
        row.computedTop = rowTop;
        remainingHeight -= height;
      }
    };
    CartesianAxisLayoutPanel3.prototype.calculateColumnSize = function(rect) {
      var chart = this.chart;
      var column;
      var columnLeft = rect.x;
      var width = 0;
      var remainingWidth = Math.max(0, rect.width);
      for (var i = 0, len = chart.columns.length; i < len; i++) {
        column = chart.columns[i];
        if (column.width.indexOf("%") !== -1) {
          width = Math.min(remainingWidth, rect.width * parseInt(column.width, 10) / 100);
        } else {
          width = Math.min(remainingWidth, parseInt(column.width, 10));
        }
        width = i !== len - 1 ? width : remainingWidth;
        column.computedWidth = width;
        column.computedLeft = columnLeft;
        columnLeft += width;
        remainingWidth -= width;
      }
    };
    CartesianAxisLayoutPanel3.prototype.renderAxes = function() {
      var chart = this.chart;
      var axis;
      var axisElement = chart.renderer.createGroup({
        id: chart.element.id + "AxisInsideCollection"
      });
      var axisLineElement = chart.renderer.createGroup({
        id: chart.element.id + "AxisOutsideCollection"
      });
      if (axisLineElement) {
        axisLineElement.setAttribute("aria-hidden", "true");
      }
      var outsideElement;
      var isInside;
      if (chart.scrollBarModule) {
        chart.scrollBarModule.topScrollBarCount = 0;
        chart.scrollBarModule.bottomScrollBarCount = 0;
        chart.scrollBarModule.leftScrollBarCount = 0;
        chart.scrollBarModule.rightScrollBarCount = 0;
      }
      for (var i = 0, len = chart.axisCollections.length; i < len; i++) {
        var axisVisibility = true;
        axis = chart.axisCollections[i];
        axis.index = i;
        this.element = chart.renderer.createGroup({
          id: chart.element.id + "AxisGroup" + i + "Inside"
        });
        if (this.element) {
          this.element.setAttribute("aria-hidden", "true");
        }
        outsideElement = chart.renderer.createGroup({
          id: chart.element.id + "AxisGroup" + i + "Outside"
        });
        if (outsideElement) {
          outsideElement.setAttribute("aria-hidden", "true");
        }
        for (var _i = 0, _a = axis.series; _i < _a.length; _i++) {
          var series = _a[_i];
          if (axis.name === series.yAxisName || axis.name === series.xAxisName) {
            axisVisibility = series.visible;
            if (series.category === "Pareto" && !series.paretoOptions.showAxis && series.type === "Line") {
              axisVisibility = false;
            }
            if (!axisVisibility) {
              continue;
            } else {
              break;
            }
          }
        }
        if (!axisVisibility) {
          if (axis.zoomingScrollBar) {
            axis.zoomingScrollBar.removeScrollSvg();
          }
          continue;
        }
        isInside = this.findAxisPosition(axis);
        this.drawAxis(axis, i, isInside, outsideElement, axisElement, axisLineElement);
      }
      this.drawPaneLines(chart, axisElement);
      appendChildElement(chart.enableCanvas, chart.svgObject, axisElement, chart.redraw);
      return axisLineElement;
    };
    CartesianAxisLayoutPanel3.prototype.renderScrollbar = function(chart, axis) {
      var isZoomed = isNullOrUndefined(chart.zoomModule) ? false : chart.zoomModule.isZoomed;
      if (!axis.zoomingScrollBar) {
        chart.scrollBarModule.injectTo(axis, chart);
      }
      if ((isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0) || axis.scrollbarSettings.enable && (axis.zoomFactor <= 1 || axis.zoomPosition >= 0)) && !axis.zoomingScrollBar.isScrollUI) {
        if (!chart.scrollElement) {
          chart.scrollElement = redrawElement(chart.redraw, chart.element.id + "_scrollElement") || createElement("div", {
            id: chart.element.id + "_scrollElement"
          });
        }
        appendChildElement(false, chart.scrollElement, axis.zoomingScrollBar.render(true), true);
      } else if (axis.zoomFactor === 1 && axis.zoomPosition === 0 && axis.zoomingScrollBar.svgObject && !axis.scrollbarSettings.enable) {
        axis.zoomingScrollBar.destroy();
      } else if (axis.zoomingScrollBar.svgObject) {
        var topOffset = (axis.isAxisOpposedPosition && axis.orientation === "Horizontal" ? -16 : 0) + axis.rect.y + Math.max(0.5, axis.lineStyle.width / 2);
        var leftOffset = (axis.isAxisOpposedPosition && axis.orientation !== "Horizontal" ? 16 : 0) + axis.rect.x - (axis.orientation === "Vertical" ? axis.scrollbarSettings.height : 0);
        if (axis.orientation !== "Horizontal" && (axis.scrollbarSettings.position === "Left" || axis.scrollbarSettings.position === "Right")) {
          leftOffset = calculateScrollbarOffset(axis.zoomingScrollBar, false);
        } else if (axis.orientation === "Horizontal" && (axis.scrollbarSettings.position === "Top" || axis.scrollbarSettings.position === "Bottom")) {
          topOffset = calculateScrollbarOffset(axis.zoomingScrollBar, true);
        }
        axis.zoomingScrollBar.svgObject.style.top = topOffset + "px";
        axis.zoomingScrollBar.svgObject.style.left = leftOffset + "px";
      }
      if (axis.zoomingScrollBar.isScrollUI) {
        axis.zoomingScrollBar.isScrollUI = false;
      }
    };
    CartesianAxisLayoutPanel3.prototype.drawPaneLines = function(chart, axisElement) {
      this.element = chart.renderer.createGroup({
        id: chart.element.id + "DefinitionLine"
      });
      for (var j = 0, len = chart.rows.length; j < len; j++) {
        var row = chart.rows[j];
        if (row.border.color) {
          this.drawBottomLine(row, j, true);
        }
      }
      for (var j = 0, len = chart.columns.length; j < len; j++) {
        var column = chart.columns[j];
        if (column.border.color) {
          this.drawBottomLine(column, j, false);
        }
      }
      axisElement = axisElement ? axisElement : getElement2(chart.element.id + "AxisInsideCollection");
      if (!this.chart.enableCanvas) {
        axisElement.appendChild(this.element);
      }
    };
    CartesianAxisLayoutPanel3.prototype.drawAxis = function(axis, index, isInside, outsideElement, axisElement, axisLineElement) {
      axis.updateCrossValue();
      var axisName = "";
      if (axis.orientation === "Horizontal") {
        if (axis.visible && axis.internalVisibility && axis.lineStyle.width > 0) {
          this.drawAxisLine(axis, index, axis.plotOffset, 0, 0, 0, axis.plotOffsetLeft, axis.plotOffsetRight, isInside ? outsideElement : this.element, axis.updatedRect);
        }
        axisName = "X";
      } else {
        if (axis.visible && axis.internalVisibility && axis.lineStyle.width > 0) {
          this.drawAxisLine(axis, index, 0, axis.plotOffset, axis.plotOffsetBottom, axis.plotOffsetTop, 0, 0, isInside ? outsideElement : this.element, axis.updatedRect);
        }
        axisName = "Y";
      }
      if (axis.majorGridLines.width > 0 || axis.majorTickLines.width > 0 || axis.minorTickLines.width > 0 || axis.minorGridLines.width > 0) {
        this["draw" + axisName + "AxisGridLine"](axis, index, isInside || axis.tickPosition === "Inside" ? outsideElement : this.element, axis.updatedRect);
      }
      if (axis.visible && axis.internalVisibility) {
        this["draw" + axisName + "AxisLabels"](axis, index, isInside || axis.labelPosition === "Inside" ? outsideElement : this.element, axis.placeNextToAxisLine ? axis.updatedRect : axis.rect);
        this["draw" + axisName + "AxisBorder"](axis, index, isInside || axis.labelPosition === "Inside" ? outsideElement : this.element, axis.placeNextToAxisLine ? axis.updatedRect : axis.rect);
        this["draw" + axisName + "AxisTitle"](axis, index, isInside ? outsideElement : this.element, axis.placeNextToAxisLine ? axis.updatedRect : axis.rect);
      }
      if (!this.chart.enableCanvas) {
        axisElement.appendChild(this.element);
        if (outsideElement && outsideElement.childNodes.length > 0) {
          axisLineElement.appendChild(outsideElement);
        }
      }
      if (this.chart.scrollBarModule && (this.chart.zoomSettings.enableScrollbar && axis.enableScrollbarOnZooming || axis.scrollbarSettings.enable)) {
        this.renderScrollbar(this.chart, axis);
      } else {
        if (axis.zoomingScrollBar) {
          axis.zoomingScrollBar.destroy();
        }
      }
    };
    CartesianAxisLayoutPanel3.prototype.findAxisPosition = function(axis) {
      return axis.crossAt !== null && axis.isInside(axis.crossInAxis.visibleRange);
    };
    CartesianAxisLayoutPanel3.prototype.drawBottomLine = function(definition, index, isRow) {
      var chart = this.chart;
      var optionsLine = {};
      var x1;
      var x2;
      var y1;
      var y2;
      var definitionName;
      if (isRow) {
        definition = definition;
        y1 = y2 = definition.computedTop + definition.computedHeight;
        x1 = this.seriesClipRect.x;
        x2 = x1 + this.seriesClipRect.width;
        definitionName = "Row";
      } else {
        definition = definition;
        x1 = x2 = definition.computedLeft;
        y1 = this.seriesClipRect.y;
        y2 = y1 + this.seriesClipRect.height;
        definitionName = "Column";
      }
      optionsLine = {
        "id": chart.element.id + "_AxisBottom_" + definitionName + index,
        x1,
        y1,
        x2,
        y2,
        "stroke-width": definition.border.width,
        "stroke": definition.border.color
      };
      this.htmlObject = chart.renderer.drawLine(optionsLine);
      appendChildElement(chart.enableCanvas, this.element, this.htmlObject);
    };
    CartesianAxisLayoutPanel3.prototype.drawAxisLine = function(axis, index, plotX, plotY, plotBottom, plotTop, plotLeft, plotRight, parent, rect) {
      var chart = this.chart;
      var optionsLine = {};
      var element = getElement2(chart.element.id + "AxisLine_" + index);
      var direction = element ? element.getAttribute("d") : "";
      element = null;
      optionsLine = {
        "id": chart.element.id + "AxisLine_" + index,
        "d": "M " + (rect.x - plotX - plotLeft) + " " + (rect.y - plotY - plotTop) + " L " + (rect.x + rect.width + plotX + plotRight) + " " + (rect.y + rect.height + plotY + plotBottom),
        "stroke-dasharray": axis.lineStyle.dashArray,
        "stroke-width": axis.lineStyle.width,
        "stroke": axis.lineStyle.color || chart.themeStyle.axisLine
      };
      this.htmlObject = chart.renderer.drawPath(optionsLine);
      appendChildElement(chart.enableCanvas, parent, this.htmlObject, chart.redraw, true, "x", "y", null, direction, null, null, null, chart.duration);
    };
    CartesianAxisLayoutPanel3.prototype.drawYAxisGridLine = function(axis, index, parent, rect) {
      var isLogAxis = axis.valueType === "Logarithmic";
      var isCategoryAxis = axis.valueType.indexOf("Category") > -1;
      var tempInterval;
      var pointY = 0;
      var majorGrid = "";
      var majorTick = "";
      var minorGridDirection;
      var isOpposed = axis.isAxisOpposedPosition;
      var tickSize = isOpposed ? axis.majorTickLines.height : -axis.majorTickLines.height;
      var axisLineSize = isOpposed ? axis.lineStyle.width * 0.5 : -axis.lineStyle.width * 0.5;
      var ticksbwtLabel = axis.valueType === "Category" && axis.labelPlacement === "BetweenTicks" ? 0.5 : 0;
      var scrollBarHeight = isNullOrUndefined(axis.crossesAt) && axis.scrollbarSettings.position !== "Right" && axis.scrollbarSettings.position !== "Left" ? isOpposed ? axis.scrollBarHeight : -axis.scrollBarHeight : 0;
      var isTickInside = axis.tickPosition === "Inside";
      var ticks = isTickInside ? rect.x - tickSize - axisLineSize : rect.x + tickSize + axisLineSize + scrollBarHeight;
      var length = axis.visibleLabels.length;
      var chartThemeStyle = this.chart.themeStyle;
      var count = 1;
      if (axis.valueType.indexOf("Category") > -1 && axis.labelPlacement === "BetweenTicks" && length > 0 && !this.chart.stockChart) {
        length += 1;
      }
      var minorGridLines = axis.minorGridLines;
      var minorTickLines = axis.minorTickLines;
      for (var i = 0; i < length; i++) {
        tempInterval = !axis.visibleLabels[i] ? axis.visibleLabels[i - 1].value + axis.visibleRange.interval - ticksbwtLabel : axis.visibleLabels[i].value - ticksbwtLabel;
        pointY = valueToCoefficient(tempInterval, axis) * rect.height;
        pointY = pointY * -1 + (rect.y + rect.height);
        if (pointY >= rect.y && rect.y + rect.height >= pointY) {
          if (this.chart.redraw && !this.chart.enableCanvas && this.chart.zoomRedraw && axis.visible && axis.majorGridLines.width && i !== 0 && !getElement2(this.chart.element.id + "_MajorGridLine_" + index + "_" + i)) {
            majorGrid = "M " + this.seriesClipRect.x + " " + (this.seriesClipRect.y + (axis.isInversed ? this.seriesClipRect.height + this.seriesClipRect.height / (i ? i : 1) * count : -(this.seriesClipRect.height / (i ? i : 1) * count))) + " L " + (this.seriesClipRect.x + this.seriesClipRect.width) + " " + (this.seriesClipRect.y + (axis.isInversed ? this.seriesClipRect.height + this.seriesClipRect.height / (i ? i : 1) * count : -(this.seriesClipRect.height / (i ? i : 1) * count)));
            this.updateAxisElement(axis, index, majorGrid, i, "_MajorGridLine_", this.element, false);
            getElement2(parent.id).appendChild(this.element.childNodes[this.element.childNodes.length - 1]);
          }
          if (inside(tempInterval, axis.visibleRange) || this.isBorder(axis, i, pointY)) {
            majorGrid = "M " + this.seriesClipRect.x + " " + pointY + " L " + (this.seriesClipRect.x + this.seriesClipRect.width) + " " + pointY;
            this.renderGridLine(axis, index, majorGrid, axis.majorGridLines, "_MajorGridLine_", i, this.element, chartThemeStyle.majorGridLine, axis.majorGridLines.dashArray);
          }
          if (this.chart.redraw && this.chart.zoomRedraw && axis.majorTickLines.width && i !== 0 && !getElement2(this.chart.element.id + "_MajorTickLine_" + index + "_" + i) && !this.chart.enableCanvas && axis.visible) {
            majorTick = "M " + this.seriesClipRect.x + " " + (this.seriesClipRect.y + (axis.isInversed ? this.seriesClipRect.height + this.seriesClipRect.height / (i ? i : 1) * count : -(this.seriesClipRect.height / (i ? i : 1) * count))) + " L " + ticks + " " + (this.seriesClipRect.y + (axis.isInversed ? this.seriesClipRect.height + this.seriesClipRect.height / (i ? i : 1) * count : -(this.seriesClipRect.height / (i ? i : 1) * count)));
            this.updateAxisElement(axis, index, majorTick, i, "_MajorTickLine_", parent, false);
            getElement2(parent.id).appendChild(this.element.childNodes[this.element.childNodes.length - 1]);
            count += 1;
          }
          majorTick = "M " + (rect.x + axisLineSize + (isTickInside ? scrollBarHeight : 0)) + " " + pointY + " L " + ticks + " " + pointY;
          this.renderGridLine(axis, index, majorTick, axis.majorTickLines, "_MajorTickLine_", i, parent, chartThemeStyle.majorTickLine);
          if ((minorGridLines.width > 0 || minorTickLines.width > 0) && axis.minorTicksPerInterval > 0) {
            if (i === 0 && isZoomSet(axis) && !isLogAxis && !isCategoryAxis) {
              this.renderMinorGridOnZooming(axis, tempInterval, rect, i, index, chartThemeStyle, parent);
            }
            minorGridDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i);
            this.renderGridLine(axis, index, minorGridDirection[0], minorGridLines, "_MinorGridLine_", i, this.element, chartThemeStyle.minorGridLine, minorGridLines.dashArray);
            this.renderGridLine(axis, index, minorGridDirection[1], minorTickLines, "_MinorTickLine_", i, parent, chartThemeStyle.minorTickLine);
            if (i === length - 1 && isZoomSet(axis) && isLogAxis && !isCategoryAxis) {
              this.renderMinorGridOnZooming(axis, tempInterval + axis.visibleRange.interval, rect, i, index, chartThemeStyle, parent);
            }
          }
        }
      }
      if (length && this.previousYLabel > length && !this.chart.enableCanvas && axis.visible && this.chart.zoomRedraw && this.chart.redraw) {
        for (var i = length; i < this.previousYLabel; i++) {
          var pointYValue = this.seriesClipRect.y + (axis.isInversed ? this.seriesClipRect.height / length * (i - length + 1) + this.seriesClipRect.height : -(this.seriesClipRect.height / length * (i - length + 1)));
          if (axis.majorGridLines.width) {
            majorGrid = "M " + this.seriesClipRect.x + " " + +pointYValue + " L " + (this.seriesClipRect.x + this.seriesClipRect.width) + " " + pointYValue;
            this.updateAxisElement(axis, index, majorGrid, i, "_MajorGridLine_", this.element, true);
          }
          if (axis.majorTickLines.width) {
            majorTick = "M " + this.seriesClipRect.x + " " + pointYValue + " L " + ticks + " " + pointYValue;
            this.updateAxisElement(axis, index, majorTick, i, "_MajorTickLine_", parent, true);
          }
        }
      }
    };
    CartesianAxisLayoutPanel3.prototype.isBorder = function(axis, index, value) {
      var border = this.chart.chartArea.border;
      var rect = this.seriesClipRect;
      var orientation = axis.orientation;
      var start = orientation === "Horizontal" ? rect.x : rect.y;
      var size = orientation === "Horizontal" ? rect.width : rect.height;
      var startIndex = orientation === "Horizontal" ? 0 : axis.visibleLabels.length - 1;
      var endIndex = orientation === "Horizontal" ? axis.visibleLabels.length - 1 : 0;
      if (axis.plotOffset > 0) {
        return true;
      } else if ((value === start || value === start + size) && (border.width <= 0 || border.color === "transparent")) {
        return true;
      } else if (value !== start && index === startIndex || value !== start + size && index === endIndex) {
        return true;
      }
      return false;
    };
    CartesianAxisLayoutPanel3.prototype.drawYAxisLabels = function(axis, index, parent, rect) {
      var chart = this.chart;
      var label;
      var pointX = 0;
      var pointY = 0;
      var elementSize;
      var labelSpace = axis.labelPadding;
      var options;
      var isAxisBreakLabel;
      var isLabelInside = axis.labelPosition === "Inside";
      var isOpposed = axis.isAxisOpposedPosition;
      var RotatedWidth;
      var tickSpace = axis.labelPosition === axis.tickPosition ? axis.majorTickLines.height : 0;
      var padding = tickSpace + labelSpace + axis.lineStyle.width * 0.5;
      var angle = axis.angle % 360;
      var isVerticalAngle = angle === -90 || angle === 90 || angle === 270 || angle === -270;
      padding += isVerticalAngle ? isLabelInside ? 5 : -5 : 0;
      padding = isOpposed ? padding : -padding;
      var labelElement = chart.renderer.createGroup({
        id: chart.element.id + "AxisLabels" + index
      });
      var scrollBarHeight = isNullOrUndefined(axis.crossesAt) && axis.scrollbarSettings.position !== "Left" && axis.scrollbarSettings.position !== "Right" ? axis.scrollBarHeight * (isOpposed ? 1 : -1) : 0;
      var textHeight;
      var textPadding;
      var maxLineWidth;
      var pixel = 10;
      var isInverse = axis.isAxisInverse;
      var count = 1;
      var previousEnd = isInverse ? rect.y : rect.y + rect.height;
      var labelPadding;
      var intervalLength;
      var labelHeight;
      var yAxisLabelX;
      var isLabelOnAxisLineLeft = !isOpposed && !isLabelInside || isOpposed && isLabelInside;
      if (isLabelInside) {
        labelPadding = !isLabelOnAxisLineLeft ? -padding : padding;
      } else {
        labelPadding = !isLabelOnAxisLineLeft ? -padding + (chart.enableRtl ? -scrollBarHeight : scrollBarHeight) : padding + (chart.enableRtl ? -scrollBarHeight : scrollBarHeight);
      }
      var sizeWidth = [];
      var breakLabelSizeWidth = [];
      axis.visibleLabels.map(function(item) {
        sizeWidth.push(item.size["width"]);
        breakLabelSizeWidth.push(item.breakLabelSize["width"]);
      });
      var LabelMaxWidth = Math.max.apply(Math, sizeWidth);
      var breakLabelMaxWidth = Math.max.apply(Math, breakLabelSizeWidth);
      RotatedWidth = LabelMaxWidth;
      if (angle >= -45 && angle <= 45 && angle !== 0) {
        RotatedWidth = LabelMaxWidth * Math.cos(angle * Math.PI / 180);
        if (RotatedWidth < 0) {
          RotatedWidth = -RotatedWidth;
        }
      }
      for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {
        label = axis.visibleLabels[i];
        isAxisBreakLabel = isBreakLabel(axis.visibleLabels[i].originalText);
        elementSize = isAxisBreakLabel ? axis.visibleLabels[i].breakLabelSize : axis.visibleLabels[i].size;
        pointY = valueToCoefficient(axis.visibleLabels[i].value, axis) * rect.height + (chart.stockChart ? 7 : 0);
        pointY = Math.floor(pointY * -1 + (rect.y + rect.height));
        textHeight = elementSize.height / 8 * axis.visibleLabels[i].text.length / 2;
        textPadding = chart.requireInvertedAxis && axis.labelPosition === "Inside" ? 0 : elementSize.height / 4 * 3 + 3;
        intervalLength = rect.height / axis.visibleLabels.length;
        labelHeight = (axis.labelIntersectAction === "Trim" || axis.labelIntersectAction === "Wrap") && angle !== 0 && elementSize.width > intervalLength ? intervalLength : elementSize.width;
        pointY = isAxisBreakLabel ? axis.labelPosition === "Inside" ? pointY - elementSize.height / 2 - textHeight + textPadding : pointY - textHeight : axis.labelPosition === "Inside" ? pointY + textPadding : pointY;
        if (axis.labelPosition === "Inside" && (i === 0 && !axis.isInversed || i === len - 1 && axis.isInversed)) {
          if (chart.stockChart) {
            pointY -= textPadding;
          } else {
            pointY -= textPadding - (chart.requireInvertedAxis && axis.labelPosition === "Inside" ? 0 : axis.opposedPosition ? -padding : padding);
          }
        }
        if (axis.majorGridLines.width > axis.majorTickLines.width) {
          maxLineWidth = axis.majorGridLines.width;
        } else {
          maxLineWidth = axis.majorTickLines.width;
        }
        if (axis.labelStyle.textAlignment === "Far") {
          pointY = pointY - maxLineWidth - pixel;
        } else if (axis.labelStyle.textAlignment === "Near") {
          pointY = pointY + maxLineWidth + pixel;
        }
        if (isLabelInside) {
          yAxisLabelX = labelPadding + (angle === 0 ? elementSize.width : isAxisBreakLabel ? breakLabelMaxWidth : LabelMaxWidth) / 2;
        } else {
          yAxisLabelX = labelPadding - (angle === 0 ? elementSize.width : isAxisBreakLabel ? breakLabelMaxWidth : RotatedWidth) / 2;
        }
        if (axis.enableWrap && chart.requireInvertedAxis && angle && (!axis.opposedPosition && axis.labelPosition === "Inside" || axis.opposedPosition && axis.labelPosition === "Outside")) {
          yAxisLabelX = axis.opposedPosition ? yAxisLabelX - LabelMaxWidth / 2 : yAxisLabelX + LabelMaxWidth / 2;
        }
        pointX = isOpposed ? axis.scrollBarHeight !== 0 && axis.scrollbarSettings.position !== "Right" && axis.scrollbarSettings.position !== "Left" ? rect.x + axis.scrollBarHeight + padding - yAxisLabelX : rect.x - yAxisLabelX : rect.x + yAxisLabelX;
        if (isVerticalAngle) {
          pointX += isOpposed ? 5 : -5;
        }
        yAxisLabelX = labelPadding;
        options = new TextOption(chart.element.id + index + "_AxisLabel_" + i, pointX, pointY, "middle", label.text, "", "middle", angle);
        switch (axis.edgeLabelPlacement) {
          case "None":
            break;
          case "Hide":
            if ((i === 0 || isInverse && i === len - 1) && options.y > rect.y || (i === len - 1 || isInverse && i === 0) && options.y - elementSize.height * 0.5 < rect.y) {
              options.text = "";
            }
            break;
          case "Shift":
            if ((i === 0 || isInverse && i === len - 1) && options.y > rect.y + rect.height) {
              options.y = pointY = rect.y + rect.height;
            } else if ((i === len - 1 || isInverse && i === 0) && options.y <= 0) {
              options.y = pointY = rect.y + elementSize.height * 0.5;
            }
            break;
        }
        var previousYValue = options.y;
        var currentYValue = options.y - labelHeight;
        if (isAxisBreakLabel) {
          previousYValue = options.y - labelHeight / 2;
          currentYValue = options.y + labelHeight / 2;
        }
        if ((angle === 90 || angle === 270) && axis.labelIntersectAction === "Hide" && i !== 0 && (!isInverse ? previousYValue >= previousEnd : currentYValue <= previousEnd)) {
          continue;
        }
        previousEnd = isInverse ? previousYValue : currentYValue;
        options.transform = "rotate(" + angle + "," + pointX + "," + pointY + ")";
        if (this.chart.redraw && this.chart.zoomRedraw && !getElement2(options.id) && !this.chart.enableCanvas && axis.visible) {
          var optionsY = options.y;
          options.y = this.seriesClipRect.y + (axis.isInversed ? this.seriesClipRect.height + this.seriesClipRect.height / (i ? i : 1) * count : -(this.seriesClipRect.height / (i ? i : 1) * count));
          this.updateAxisElement(axis, index, "", i, "_AxisLabel_", labelElement, false, options, label);
          options.y = optionsY;
          count += 1;
        }
        textElement2(chart.renderer, options, label.labelStyle, label.labelStyle.color || chart.themeStyle.axisLabelFont.color, labelElement, false, chart.redraw, true, true, chart.duration, null, null, null, chart.enableCanvas, null, chart.themeStyle.axisLabelFont, new ChartLocation(pointX, pointY));
      }
      if (this.previousYLabel && axis.visibleLabels.length && this.previousYLabel > axis.visibleLabels.length && !this.chart.enableCanvas && axis.visible && this.chart.zoomRedraw && chart.redraw && options.text) {
        for (var i = axis.visibleLabels.length; i < this.previousYLabel; i++) {
          options.y = this.seriesClipRect.y + (axis.isInversed ? this.seriesClipRect.height + this.seriesClipRect.height / axis.visibleLabels.length * (i - axis.visibleLabels.length + 1) : -(this.seriesClipRect.height / axis.visibleLabels.length * (i - axis.visibleLabels.length + 1)));
          options.id = chart.element.id + index + "_AxisLabel_" + i;
          this.updateAxisElement(axis, index, "", i, "_AxisLabel_", labelElement, true, options, label);
        }
      } else {
        this.previousYLabel = axis.visibleLabels.length;
      }
      if (!this.chart.enableCanvas) {
        if (!chart.delayRedraw) {
          appendChildElement(chart.enableCanvas, parent, labelElement, chart.redraw);
        } else if (axis.visible && axis.internalVisibility) {
          this.createZoomingLabel(this.chart, labelElement, axis, index, rect);
        }
      }
    };
    CartesianAxisLayoutPanel3.prototype.rangeAnimate = function(axis, element, duration, label, bounds, isRemove, i) {
      var _this = this;
      if (element) {
        new Animation({}).animate(element, {
          duration,
          progress: function() {
            var animateElement = getElement2(element.id);
            animateElement.style.animation = "";
            if (label) {
              if (withInBounds(parseFloat(animateElement.getAttribute("x")), parseFloat(animateElement.getAttribute("y")), bounds)) {
                animateElement.style.visibility = "visible";
              } else {
                animateElement.style.visibility = "hidden";
              }
            } else {
              var direction = animateElement.getAttribute("d").split(" ");
              if (withInBounds(parseFloat(direction[1]), parseFloat(direction[2]), bounds)) {
                animateElement.style.visibility = "visible";
              } else {
                animateElement.style.visibility = "hidden";
              }
            }
          },
          end: function() {
            var animateElement = getElement2(element.id);
            animateElement.style.visibility = "";
            if (isRemove && i >= axis.visibleLabels.length) {
              removeElement2(animateElement);
              if (label) {
                if (axis.orientation === "Vertical") {
                  _this.previousYLabel = axis.visibleLabels.length;
                } else {
                  _this.previousXLabel = axis.visibleLabels.length;
                }
              }
            }
          }
        });
      }
    };
    CartesianAxisLayoutPanel3.prototype.getAxisLabelXvalue = function(x, axis, textWidth) {
      var anchor = axis.lineBreakAlignment;
      var isLabelInside = axis.labelPosition === "Inside";
      var isOpposed = axis.isAxisOpposedPosition;
      if (isOpposed && isLabelInside || !isOpposed && !isLabelInside) {
        return anchor === "Right" ? x : anchor === "Center" ? x - textWidth / 2 : x - textWidth;
      } else {
        return anchor === "Left" ? x : anchor === "Center" ? x + textWidth / 2 : x + textWidth;
      }
    };
    CartesianAxisLayoutPanel3.prototype.drawYAxisBorder = function(axis, index, parent, rect) {
      if (axis.border.width > 0) {
        var startY = void 0;
        var pointY = void 0;
        var scrollBarHeight = axis.labelPosition === "Outside" && axis.scrollbarSettings.position !== "Right" && axis.scrollbarSettings.position !== "Left" ? axis.scrollBarHeight : 0;
        var isOpposed = axis.isAxisOpposedPosition;
        scrollBarHeight = (isOpposed ? 1 : -1) * scrollBarHeight;
        var gap = rect.height / axis.visibleRange.delta * (axis.valueType === "DateTime" ? axis.dateTimeInterval : axis.visibleRange.interval);
        var endY = void 0;
        var length_1 = axis.maxLabelSize.width + 10 + (axis.tickPosition === axis.labelPosition ? axis.majorTickLines.height : 0);
        var labelBorder = "";
        var ticksbwtLabel = axis.valueType === "Category" && axis.labelPlacement === "BetweenTicks" ? -0.5 : 0;
        var endX = isOpposed && axis.labelPosition === "Inside" || !isOpposed && axis.labelPosition === "Outside" ? rect.x - length_1 + scrollBarHeight : rect.x + length_1 + scrollBarHeight;
        for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {
          pointY = valueToCoefficient(axis.visibleLabels[i].value + ticksbwtLabel, axis);
          pointY = (axis.isAxisInverse ? 1 - pointY : pointY) * rect.height;
          if (axis.valueType === "Category" && axis.labelPlacement === "BetweenTicks") {
            startY = pointY * -1 + (rect.y + rect.height);
            endY = pointY * -1 - gap + (rect.y + rect.height);
          } else {
            startY = pointY * -1 + gap / 2 + (rect.y + rect.height);
            endY = pointY * -1 - gap / 2 + (rect.y + rect.height);
          }
          switch (axis.border.type) {
            case "Rectangle":
            case "WithoutTopBorder":
              if (startY > rect.y + rect.height) {
                labelBorder += "M " + endX + " " + (rect.y + rect.height) + " L " + endX + " " + endY + " ";
              } else if (Math.floor(rect.y) > endY) {
                labelBorder += "M " + (rect.x + scrollBarHeight) + " " + startY + " L " + endX + " " + startY + " L " + endX + " " + rect.y + " ";
              } else {
                labelBorder += "M " + (rect.x + scrollBarHeight) + " " + startY + " L " + endX + " " + startY + " L " + endX + " " + endY + " ";
                if (i === axis.visibleLabels.length - 1) {
                  labelBorder += "M " + (rect.x + scrollBarHeight) + " " + endY + " L " + endX + " " + endY + " ";
                }
              }
              break;
            case "WithoutTopandBottomBorder":
              if (!(startY > rect.y + rect.height) && !(endY < Math.floor(rect.y))) {
                labelBorder += "M " + (rect.x + scrollBarHeight) + " " + startY + " L " + endX + " " + startY + " M " + endX + " " + endY + " L " + (rect.x + scrollBarHeight) + " " + endY;
              }
              break;
          }
        }
        labelBorder += axis.border.type === "Rectangle" ? "M " + (rect.x + scrollBarHeight) + " " + rect.y + " L " + (rect.x + scrollBarHeight) + " " + (rect.y + rect.height) + " " : "";
        if (labelBorder !== "") {
          this.createAxisBorderElement(axis, index, labelBorder, parent);
        }
      }
      for (var i = 0; i < this.chart.visibleSeries.length; i++) {
        if (axis.multiLevelLabels.length > 0 && this.chart.multiLevelLabelModule && this.chart.visibleSeries[i].visible) {
          this.chart.multiLevelLabelModule.renderYAxisMultiLevelLabels(axis, index, parent, rect);
          break;
        }
      }
    };
    CartesianAxisLayoutPanel3.prototype.drawYAxisTitle = function(axis, index, parent, rect) {
      if (axis.title) {
        var chart = this.chart;
        var isRotated = false;
        var isOpposed = axis.isAxisOpposedPosition;
        var labelRotation = (axis.titleRotation == null ? isOpposed ? 90 : -90 : axis.titleRotation) % 360;
        var padding = (axis.tickPosition === "Inside" ? 0 : axis.majorTickLines.height + axis.titlePadding) + (axis.labelPosition === "Inside" ? 0 : axis.maxLabelSize.width + axis.multiLevelLabelHeight + this.padding);
        padding = axis.tickPosition !== "Outside" && (axis.tickPosition === "Inside" || axis.labelPosition === "Inside") ? axis.titlePadding === 5 ? padding : padding + axis.titlePadding : padding;
        padding = isOpposed ? padding + (axis.scrollbarSettings.position === "Right" || axis.scrollbarSettings.position === "Left" ? 0 : axis.scrollBarHeight) : -padding - (axis.scrollbarSettings.position === "Right" || axis.scrollbarSettings.position === "Left" ? 0 : axis.scrollBarHeight);
        if (labelRotation !== -90 && !isOpposed || labelRotation !== 90 && isOpposed) {
          padding += axis.isAxisOpposedPosition ? axis.titleSize.width / 2 + (axis.labelPosition === "Inside" ? axis.labelPadding !== 5 ? 0 : axis.labelPadding : axis.labelPadding) : -axis.titleSize.width / 2 - (axis.labelPosition === "Inside" ? axis.labelPadding !== 5 ? 0 : axis.labelPadding : axis.labelPadding);
          isRotated = true;
        }
        var x = rect.x + padding;
        var y = void 0;
        var anchor = void 0;
        if (axis.titleStyle.textAlignment === "Center") {
          anchor = "middle";
          y = rect.y + rect.height * 0.5;
        } else if (axis.titleStyle.textAlignment === "Near") {
          anchor = axis.opposedPosition ? "end" : "start";
          y = rect.height + rect.y;
        } else {
          anchor = axis.opposedPosition ? "start" : "end";
          y = rect.y;
        }
        var titleSize = axis.titleSize.height * (axis.titleCollection.length - 1);
        var options = new TextOption(chart.element.id + "_AxisTitle_" + index, x, y + (isRotated ? -titleSize : -(axis.labelPosition === "Inside" ? axis.labelPadding !== 5 ? 0 : axis.labelPadding : axis.labelPadding) - titleSize), anchor, axis.titleCollection, "rotate(" + labelRotation + "," + x + "," + y + ")", null, labelRotation);
        var element = textElement2(chart.renderer, options, axis.titleStyle, axis.titleStyle.color || chart.themeStyle.axisTitleFont.color, parent, null, null, null, null, null, null, null, null, chart.enableCanvas, null, chart.themeStyle.axisTitleFont, new ChartLocation(x, y));
        element.setAttribute("aria-hidden", "true");
      }
    };
    CartesianAxisLayoutPanel3.prototype.drawXAxisGridLine = function(axis, index, parent, rect) {
      var isLogAxis = axis.valueType === "Logarithmic";
      var isCategoryAxis = axis.valueType.indexOf("Category") > -1;
      var tempInterval;
      var pointX = 0;
      var majorGrid = "";
      var majorTick = "";
      var minorDirection;
      var count = 1;
      var isOpposed = axis.isAxisOpposedPosition;
      var tickSize = isOpposed ? -axis.majorTickLines.height : axis.majorTickLines.height;
      var axisLineSize = isOpposed ? -axis.lineStyle.width * 0.5 : axis.lineStyle.width * 0.5;
      var scrollBarHeight = isNullOrUndefined(axis.crossesAt) && axis.scrollbarSettings.position !== "Top" && axis.scrollbarSettings.position !== "Bottom" ? isOpposed ? -axis.scrollBarHeight : axis.scrollBarHeight : 0;
      var ticksbwtLabel = axis.valueType.indexOf("Category") > -1 && axis.labelPlacement === "BetweenTicks" && !this.chart.stockChart ? 0.5 : 0;
      var length = axis.visibleLabels.length;
      var isTickInside = axis.tickPosition === "Inside";
      var ticks = isTickInside ? rect.y - tickSize - axisLineSize : rect.y + tickSize + axisLineSize + scrollBarHeight;
      var chartThemeStyle = this.chart.themeStyle;
      if (axis.valueType.indexOf("Category") > -1 && length > 0 && axis.labelPlacement === "BetweenTicks" && !this.chart.stockChart) {
        length += 1;
      }
      var numericIDs = this.calculateGridLineId(parent, length);
      for (var i = 0; i < length; i++) {
        if (axis.valueType !== "DateTimeCategory") {
          tempInterval = axis.visibleLabels[i] ? axis.visibleLabels[i].value - ticksbwtLabel : axis.visibleLabels[i - 1].value + axis.visibleRange.interval - ticksbwtLabel;
        } else {
          tempInterval = axis.visibleLabels[i] ? axis.visibleLabels[i].value - ticksbwtLabel : axis.visibleRange.max;
        }
        pointX = valueToCoefficient(tempInterval, axis) * rect.width + rect.x;
        if (pointX >= rect.x && rect.x + rect.width >= pointX) {
          if (inside(tempInterval, axis.visibleRange) || this.isBorder(axis, i, pointX)) {
            if (this.chart.redraw && (this.chart.pointsAdded && !this.chart.pointsRemoved || this.chart.zoomRedraw) && axis.majorGridLines.width && i !== 0 && axis.visible && !getElement2(this.chart.element.id + "_MajorGridLine_" + index + "_" + i) && !this.chart.enableCanvas) {
              var pointXValue = this.seriesClipRect.x + (this.chart.enableRtl !== axis.isInversed ? -(this.seriesClipRect.width / length * count) : this.seriesClipRect.width + this.seriesClipRect.width / (i ? i : 1) * count);
              majorGrid = "M " + pointXValue + " " + (this.seriesClipRect.y + this.seriesClipRect.height) + " L " + pointXValue + " " + this.seriesClipRect.y;
              this.renderGridLine(axis, index, majorGrid, axis.majorGridLines, "_MajorGridLine_", i, this.element, chartThemeStyle.majorGridLine, axis.majorGridLines.dashArray, numericIDs["MajorGridLine"] && numericIDs["MajorGridLine"].ids ? numericIDs["MajorGridLine"].ids[i] : null, numericIDs["MajorGridLine"] ? numericIDs["MajorGridLine"].isPointRemoved : false);
              this.rangeAnimate(axis, this.element.childNodes[this.element.childNodes.length - 1], this.chart.duration, false, new Rect(this.seriesClipRect.x, axis.rect.y, this.seriesClipRect.x + this.seriesClipRect.width, this.chart.availableSize.height), false, i);
              if (getElement2(parent.id)) {
                getElement2(parent.id).appendChild(this.element.childNodes[this.element.childNodes.length - 1]);
              }
            }
            majorGrid = "M " + pointX + " " + (this.seriesClipRect.y + this.seriesClipRect.height) + " L " + pointX + " " + this.seriesClipRect.y;
            this.renderGridLine(axis, index, majorGrid, axis.majorGridLines, "_MajorGridLine_", i, this.element, chartThemeStyle.majorGridLine, axis.majorGridLines.dashArray, numericIDs["MajorGridLine"] && numericIDs["MajorGridLine"].ids ? numericIDs["MajorGridLine"].ids[i] : null, numericIDs["MajorGridLine"] ? numericIDs["MajorGridLine"].isPointRemoved : false);
          }
          if (this.chart.redraw && this.chart.zoomRedraw && axis.majorTickLines.width && !getElement2(this.chart.element.id + "_MajorTickLine_" + index + "_" + i) && !this.chart.enableCanvas && axis.visible) {
            majorTick = "M " + (this.seriesClipRect.x + (this.chart.enableRtl !== axis.isInversed ? -(this.seriesClipRect.width / length * count) : this.seriesClipRect.width + this.seriesClipRect.width / (i ? i : 1) * count)) + " " + (rect.y + axisLineSize + (isTickInside ? scrollBarHeight : 0)) + " L " + (this.seriesClipRect.x + (this.chart.enableRtl !== axis.isInversed ? -(this.seriesClipRect.width / length * count) : this.seriesClipRect.width + this.seriesClipRect.width / (i ? i : 1) * count)) + " " + ticks;
            this.updateAxisElement(axis, index, majorTick, i, "_MajorTickLine_", parent, false);
            getElement2(parent.id).appendChild(this.element.childNodes[this.element.childNodes.length - 1]);
            count += 1;
          }
          majorTick = "M " + pointX + " " + (rect.y + axisLineSize + (isTickInside ? scrollBarHeight : 0)) + " L " + pointX + " " + ticks;
          this.renderGridLine(axis, index, majorTick, axis.majorTickLines, "_MajorTickLine_", i, parent, chartThemeStyle.majorTickLine, null, numericIDs["MajorTickLine"] && numericIDs["MajorTickLine"].ids ? numericIDs["MajorTickLine"].ids[i] : null, numericIDs["MajorTickLine"] ? numericIDs["MajorTickLine"].isPointRemoved : false);
          if (axis.minorTicksPerInterval > 0 && (axis.minorGridLines.width > 0 || axis.minorTickLines.width > 0)) {
            if (i === 0 && isZoomSet(axis) && !isLogAxis && !isCategoryAxis) {
              this.renderMinorGridOnZooming(axis, tempInterval, rect, i, index, chartThemeStyle, parent);
            }
            minorDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i);
            this.renderGridLine(axis, index, minorDirection[0], axis.minorGridLines, "_MinorGridLine_", i, this.element, chartThemeStyle.minorGridLine, axis.minorGridLines.dashArray, numericIDs["MinorGridLine"] && numericIDs["MinorGridLine"].ids ? numericIDs["MinorGridLine"].ids[i] : null, numericIDs["MinorGridLine"] ? numericIDs["MinorGridLine"].isPointRemoved : false);
            this.renderGridLine(axis, index, minorDirection[1], axis.minorTickLines, "_MinorTickLine_", i, parent, chartThemeStyle.minorTickLine, null, numericIDs["MinorTickLine"] && numericIDs["MinorTickLine"].ids ? numericIDs["MinorTickLine"].ids[i] : null, numericIDs["MinorTickLine"] ? numericIDs["MinorTickLine"].isPointRemoved : false);
            if (i === length - 1 && isZoomSet(axis) && isLogAxis && !isCategoryAxis) {
              this.renderMinorGridOnZooming(axis, tempInterval + axis.visibleRange.interval, rect, i, index, chartThemeStyle, parent);
            }
          }
        }
      }
      if (length && this.previousXLabel > length && !this.chart.enableCanvas && axis.visible && this.chart.zoomRedraw && this.chart.redraw) {
        for (var i = length; i < this.previousXLabel; i++) {
          var pointXValue = this.seriesClipRect.x + (this.chart.enableRtl !== axis.isInversed ? -(this.seriesClipRect.width / length * (i - length + 1)) : this.seriesClipRect.width + this.seriesClipRect.width / length * (i - length + 1));
          if (axis.majorGridLines.width) {
            majorGrid = "M " + pointXValue + " " + (this.seriesClipRect.y + this.seriesClipRect.height) + " L " + pointXValue + " " + this.seriesClipRect.y;
            this.updateAxisElement(axis, index, majorGrid, i, "_MajorGridLine_", this.element, true);
          }
          if (axis.majorTickLines.width) {
            majorTick = "M " + pointXValue + " " + (rect.y + axisLineSize + (isTickInside ? scrollBarHeight : 0)) + " L " + pointXValue + " " + ticks;
            this.updateAxisElement(axis, index, majorTick, i, "_MajorTickLine_", parent, true);
          }
        }
      }
    };
    CartesianAxisLayoutPanel3.prototype.calculateGridLineId = function(parent, length) {
      var _this = this;
      var numericIDs = {};
      if (this.chart.pointsRemoved) {
        var elementTypes = ["MajorGridLine", "MajorTickLine", "MinorGridLine", "MinorTickLine"];
        elementTypes.forEach(function(type) {
          var parentElement = getElement2(parent.id);
          var elements = parentElement.querySelectorAll('[id*="_' + type + '_"]');
          var elementArray = [];
          for (var i = 0; i < elements.length; i++) {
            elementArray.push(elements[i]);
          }
          var len = type === "MajorGridLine" && _this.chart.chartArea.border.width ? length - 2 : length;
          len = type === "MinorGridLine" || type === "MinorTickLine" ? length - 1 : len;
          if (elementArray.length > 0 && elementArray.length > len) {
            var elementsLength = elementArray.length;
            for (var k = 0; k < elementsLength - len; k++) {
              if (elementArray[k]) {
                parentElement.removeChild(elementArray[k]);
              }
              elementArray.shift();
            }
            var numericIds = elementArray.map(function(element) {
              var parts = element.id.split("_");
              return parseInt(parts[parts.length - 1], 10);
            });
            numericIDs[type] = {
              ids: numericIds,
              isPointRemoved: true
            };
          }
        });
      }
      return numericIDs;
    };
    CartesianAxisLayoutPanel3.prototype.renderMinorGridOnZooming = function(axis, tempInterval, rect, i, index, chartThemeStyle, parent) {
      var minorDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i, true);
      this.renderGridLine(axis, index, minorDirection[0], axis.minorGridLines, "_MinorGridLine_", -1, this.element, chartThemeStyle.minorGridLine, axis.minorGridLines.dashArray);
      this.renderGridLine(axis, index, minorDirection[1], axis.minorTickLines, "_MinorTickLine_", -1, parent, chartThemeStyle.minorTickLine);
    };
    CartesianAxisLayoutPanel3.prototype.drawAxisMinorLine = function(axis, tempInterval, rect, labelIndex, isFirstLabel) {
      var value = tempInterval;
      var coor = 0;
      var position = 0;
      var range = axis.visibleRange;
      var isTickInside = axis.tickPosition === "Inside";
      var direction = [];
      var tickSize = axis.isAxisOpposedPosition ? -axis.minorTickLines.height : axis.minorTickLines.height;
      var logStart;
      var logEnd;
      var logInterval = 1;
      var logPosition = 1;
      var ticksX = isTickInside ? rect.y - tickSize : rect.y + tickSize;
      var ticksY = isTickInside ? rect.x + tickSize : rect.x - tickSize;
      var minorGird = "";
      var minorTick = "";
      var isInverse = axis.isAxisInverse;
      if (axis.valueType === "Logarithmic") {
        logStart = Math.pow(axis.logBase, value - range.interval);
        logEnd = Math.pow(axis.logBase, value);
        logInterval = (logEnd - logStart) / (axis.minorTicksPerInterval + 1);
        logPosition = logStart + logInterval;
      }
      if (axis.orientation === "Horizontal") {
        for (var j = 0; j < axis.minorTicksPerInterval; j++) {
          value = this.findLogNumeric(axis, logPosition, value, labelIndex, isFirstLabel);
          logPosition += logInterval;
          if (inside(value, range)) {
            position = (value - range.min) / (range.max - range.min);
            position = Math.ceil((isInverse ? 1 - position : position) * rect.width);
            coor = Math.floor(position + rect.x);
            if (this.chart.enableCanvas) {
              if (minorGird === "") {
                minorGird = "M " + coor + " " + this.seriesClipRect.y + " L " + coor + " " + (this.seriesClipRect.y + this.seriesClipRect.height);
              } else {
                minorGird = minorGird + " M " + coor + " " + this.seriesClipRect.y + " L " + coor + " " + (this.seriesClipRect.y + this.seriesClipRect.height);
              }
              coor = Math.floor(position + rect.x);
              if (minorTick === "") {
                minorTick = minorTick.concat("M " + coor + " " + rect.y + " L " + coor + " " + (ticksX + axis.scrollBarHeight));
              } else {
                minorTick = minorTick.concat(" M " + coor + " " + rect.y + " L " + coor + " " + (ticksX + axis.scrollBarHeight));
              }
            } else {
              minorGird = minorGird.concat("M " + coor + " " + this.seriesClipRect.y + "L " + coor + " " + (this.seriesClipRect.y + this.seriesClipRect.height));
              coor = Math.floor(position + rect.x);
              minorTick = minorTick.concat("M " + coor + " " + rect.y + "L " + coor + " " + (ticksX + axis.scrollBarHeight));
            }
          }
        }
      } else {
        for (var j = 0; j < axis.minorTicksPerInterval; j++) {
          value = this.findLogNumeric(axis, logPosition, value, labelIndex, isFirstLabel);
          if (inside(value, range)) {
            position = (value - range.min) / (range.max - range.min);
            position = Math.ceil((isInverse ? 1 - position : position) * rect.height) * -1;
            coor = Math.floor(position + rect.y + rect.height);
            if (this.chart.enableCanvas) {
              if (minorGird === "") {
                minorGird = "M " + this.seriesClipRect.x + " " + coor + " L " + (this.seriesClipRect.x + this.seriesClipRect.width) + " " + coor;
              } else {
                minorGird = minorGird + " M " + this.seriesClipRect.x + " " + coor + " L " + (this.seriesClipRect.x + this.seriesClipRect.width) + " " + coor;
              }
              coor = Math.floor(position + rect.y + rect.height);
              if (minorTick === "") {
                minorTick = minorTick.concat("M " + rect.x + " " + coor + " L " + (ticksY - axis.scrollBarHeight) + " " + coor + " ");
              } else {
                minorTick = minorTick.concat(" M " + rect.x + " " + coor + " L " + (ticksY - axis.scrollBarHeight) + " " + coor + " ");
              }
            } else {
              minorGird = minorGird.concat("M " + this.seriesClipRect.x + " " + coor + "L " + (this.seriesClipRect.x + this.seriesClipRect.width) + " " + coor + " ");
              coor = Math.floor(position + rect.y + rect.height);
              minorTick = minorTick.concat("M " + rect.x + " " + coor + "L " + (ticksY - axis.scrollBarHeight) + " " + coor + " ");
            }
          }
          logPosition += logInterval;
        }
      }
      direction.push(minorGird);
      direction.push(minorTick);
      return direction;
    };
    CartesianAxisLayoutPanel3.prototype.findLogNumeric = function(axis, logPosition, value, labelIndex, isFirstLabel) {
      var range = axis.visibleRange;
      var tempValue;
      if (axis.valueType === "Logarithmic") {
        value = logBase(logPosition, axis.logBase);
      } else if (axis.valueType === "DateTime") {
        tempValue = axis.dateTimeInterval / (axis.minorTicksPerInterval + 1);
        value = isFirstLabel ? value - tempValue : value + tempValue;
      } else if (axis.valueType === "DateTimeCategory") {
        var padding = axis.labelPlacement === "BetweenTicks" ? 0.5 : 0;
        value += ((axis.visibleLabels[labelIndex + 1] ? axis.visibleLabels[labelIndex + 1].value - padding : axis.visibleRange.max) - (axis.visibleLabels[labelIndex] ? axis.visibleLabels[labelIndex].value - padding : axis.visibleRange.min)) / (axis.minorTicksPerInterval + 1);
      } else {
        tempValue = range.interval / (axis.minorTicksPerInterval + 1);
        value = isFirstLabel ? value - tempValue : value + tempValue;
      }
      return value;
    };
    CartesianAxisLayoutPanel3.prototype.drawXAxisLabels = function(axis, index, parent, rect) {
      var chart = this.chart;
      var pointX = 0;
      var pointY = 0;
      var previousLabel = 0;
      var labelSpace = axis.labelPadding;
      var labelHeight;
      var elementSize;
      var labelPadding;
      var anchor;
      var pixel = 10;
      var labelElement = chart.renderer.createGroup({
        id: chart.element.id + "AxisLabels" + index
      });
      var islabelInside = axis.labelPosition === "Inside";
      var isOpposed = axis.isAxisOpposedPosition;
      var tickSpace = axis.labelPosition === axis.tickPosition ? axis.majorTickLines.height : 0;
      var padding = tickSpace + labelSpace + axis.lineStyle.width * 0.5;
      var angle = axis.angle % 360;
      var isHorizontalAngle = angle === 0 || angle === -180 || angle === 180;
      var options;
      var labelWidth;
      var isInverse = axis.isAxisInverse;
      var isLeft;
      var count = 1;
      var previousEnd = isInverse ? rect.x + rect.width : rect.x;
      var width = 0;
      var length = axis.visibleLabels.length;
      var intervalLength;
      var label;
      var isAxisBreakLabel;
      var scrollBarHeight = axis.scrollbarSettings.enable || !islabelInside && isNullOrUndefined(axis.crossesAt) && (axis.zoomFactor < 1 || axis.zoomPosition > 0) ? axis.scrollbarSettings.position === "Top" || axis.scrollbarSettings.position === "Bottom" ? 0 : axis.scrollBarHeight : 0;
      var newPoints = [];
      var isRotatedLabelIntersect = false;
      var textPoints = [];
      var rotatedLabelSize = new Size(0, 0);
      padding += angle === 90 || angle === 270 || angle === -90 || angle === -270 ? islabelInside ? 5 : -5 : 0;
      var isLabelUnderAxisLine = !isOpposed && !islabelInside || isOpposed && islabelInside;
      var axislabelElement = getElement2(chart.element.id + "AxisLabels" + index);
      var pointsRemoved = this.removeAxisLabelElements(axis, axislabelElement);
      var legendWidth = chart.legendModule && chart.legendSettings.position === "Right" && chart.legendModule.legendBounds.height + chart.legendModule.legendBounds.y >= axis.rect.y ? chart.legendModule.legendBounds.width : 0;
      var isEndAnchor = isLabelUnderAxisLine ? 360 >= angle && angle >= 180 || -1 >= angle && angle >= -180 : 1 <= angle && angle <= 180 || -181 >= angle && angle >= -360;
      for (var i = 0, len = length; i < len; i++) {
        label = axis.visibleLabels[i];
        isAxisBreakLabel = isBreakLabel(label.originalText) || axis.labelIntersectAction === "Wrap" && label.text.length > 1;
        pointX = valueToCoefficient(label.value, axis) * rect.width + rect.x;
        elementSize = label.size;
        if (axis.enableWrap) {
          elementSize.height = measureText(label.text, axis.labelStyle, chart.themeStyle.axisLabelFont).height;
        }
        intervalLength = rect.width / length;
        labelWidth = isAxisBreakLabel ? label.breakLabelSize.width : elementSize.width;
        width = (axis.labelIntersectAction === "Trim" || axis.labelIntersectAction === "Wrap") && angle === 0 && labelWidth > intervalLength ? intervalLength : labelWidth;
        labelHeight = elementSize.height / 4;
        pointX -= isAxisBreakLabel || angle !== 0 ? 0 : width / 2;
        if (angle !== 0) {
          if (isAxisBreakLabel) {
            pointX -= axis.lineBreakAlignment === "Left" ? label.breakLabelSize.width / 2 : axis.lineBreakAlignment === "Right" ? -(label.breakLabelSize.width / 2) : 0;
          } else {
            pointX -= angle === -90 || angle === 270 ? -labelHeight : angle === 90 || angle === -270 ? labelHeight : 0;
          }
        }
        if (axis.labelStyle.textAlignment === "Far") {
          pointX = pointX + width - pixel;
        } else if (axis.labelStyle.textAlignment === "Near") {
          pointX = pointX - width + pixel;
        }
        if (isAxisBreakLabel && axis.lineBreakAlignment !== "Center" && angle === 0) {
          pointX += axis.lineBreakAlignment === "Left" ? -(width / 2) : width / 2;
        }
        var paddingForBreakLabel = isAxisBreakLabel ? isHorizontalAngle ? axis.opposedPosition || islabelInside ? 0 : elementSize.height : label.breakLabelSize.width / 2 : 0;
        padding = isAxisBreakLabel ? tickSpace + labelSpace + axis.lineStyle.width * 0.5 : padding;
        if (islabelInside && angle) {
          if (isAxisBreakLabel) {
            pointY = isOpposed ? rect.y + padding + paddingForBreakLabel : rect.y - padding - paddingForBreakLabel;
          } else {
            pointY = isOpposed ? rect.y + padding + labelHeight : rect.y - padding - labelHeight;
          }
        } else {
          if (isAxisBreakLabel) {
            labelPadding = !isLabelUnderAxisLine ? -(padding + scrollBarHeight + paddingForBreakLabel) : padding + scrollBarHeight + (angle ? paddingForBreakLabel : 3 * labelHeight);
          } else {
            labelPadding = !isLabelUnderAxisLine ? -(padding + scrollBarHeight + (angle ? labelHeight : label.index > 1 ? 2 * labelHeight : 0)) : padding + scrollBarHeight + (angle ? 1 : 3) * labelHeight;
          }
          pointY = rect.y + labelPadding * label.index;
        }
        if (isAxisBreakLabel) {
          anchor = this.getAnchor(axis);
        } else {
          anchor = chart.enableRtl ? isEndAnchor ? "" : "end" : chart.isRtlEnabled || isEndAnchor ? "end" : "";
        }
        options = new TextOption(chart.element.id + index + "_AxisLabel_" + i, pointX, pointY, anchor);
        options.id = pointsRemoved && axislabelElement && axislabelElement.children[i] ? axislabelElement.children[i].id : options.id;
        if (angle !== 0) {
          rotatedLabelSize = rotateTextSize(label.labelStyle, label.originalText, angle, chart, chart.themeStyle.axisLabelFont);
          isLeft = angle < 0 && angle > -90 || angle < -180 && angle > -270 || angle > 90 && angle < 180 || angle > 270 && angle < 360;
        }
        if (axis.edgeLabelPlacement) {
          switch (axis.edgeLabelPlacement) {
            case "None":
              break;
            case "Hide":
              if ((i === 0 || isInverse && i === len - 1) && options.x < rect.x || (i === len - 1 || isInverse && i === 0) && options.x + (angle === 0 ? width : rotatedLabelSize.width) > rect.x + rect.width) {
                continue;
              }
              break;
            case "Shift":
              if (i === len - 2 && axis.labelIntersectAction !== "MultipleRows") {
                if (anchor === "start" || anchor === "") {
                  previousLabel = options.x + width;
                } else if (anchor === "middle") {
                  previousLabel = options.x + width / 2;
                } else {
                  previousLabel = options.x;
                }
              }
              if ((i === 0 || isInverse && i === len - 1) && (options.x < rect.x || angle !== 0 && isLeft && options.x < rect.x || axis.lineBreakAlignment === "Center" && options.x - label.size.width / label.text.length / 2 < rect.x && angle === 0)) {
                intervalLength -= rect.x - options.x;
                if (anchor === "") {
                  if (options.x <= 0) {
                    pointX = options.x = 0;
                  } else {
                    pointX = options.x;
                  }
                  intervalLength = rect.width / length;
                } else if (isLeft && angle !== 0) {
                  intervalLength = rect.width / length;
                  if (rect.x + intervalLength > options.x + rotatedLabelSize.width) {
                    options.x = pointX = rect.x + padding;
                  } else {
                    options.x = pointX = rect.x + intervalLength - padding;
                  }
                } else if (isAxisBreakLabel && axis.lineBreakAlignment === "Center" && axis.labelPlacement === "OnTicks" && angle === 0) {
                  var maxWidth = 0;
                  for (var i_1 = 0; i_1 < label.text.length; i_1++) {
                    var breakLabelWidth = measureText(label.text[i_1], axis.labelStyle, chart.themeStyle.axisLabelFont).width;
                    if (breakLabelWidth > maxWidth) {
                      maxWidth = breakLabelWidth;
                    }
                  }
                  options.x = pointX = rect.x + maxWidth / 2;
                } else if (!(anchor === "start" && options.x > 0)) {
                  options.x = pointX = !isHorizontalAngle ? rect.x + padding : rect.x;
                }
              } else if ((i === len - 1 || isInverse && i === 0) && (options.x + width > chart.availableSize.width - chart.border.width - legendWidth && (anchor === "start" || anchor === "") && angle === 0 || anchor === "start" && angle !== 0 && !isLeft && options.x + rotatedLabelSize.width > chart.availableSize.width - chart.border.width - legendWidth || anchor === "middle" && angle !== 0 && !isLeft && options.x + rotatedLabelSize.width / 2 > chart.availableSize.width - chart.border.width - legendWidth || anchor === "end" && angle !== 0 && !isLeft && options.x > chart.availableSize.width - chart.border.width - legendWidth || anchor === "end" && options.x > chart.availableSize.width - chart.border.width - legendWidth && angle === 0 || anchor === "middle" && options.x + width / 2 > chart.availableSize.width - chart.border.width - legendWidth && angle === 0)) {
                var axisLabelWidth = angle !== 0 ? rotatedLabelSize.width : width;
                var shiftedXValue = void 0;
                var padding_1 = 5;
                if (anchor === "start" || anchor === "") {
                  shiftedXValue = options.x - (options.x + axisLabelWidth - chart.availableSize.width + chart.border.width + padding_1 + legendWidth);
                } else if (anchor === "middle") {
                  shiftedXValue = options.x - (options.x + axisLabelWidth / 2 - chart.availableSize.width + chart.border.width + padding_1 + legendWidth);
                } else {
                  shiftedXValue = options.x - (options.x - (chart.availableSize.width + chart.border.width + padding_1 + legendWidth));
                }
                if (previousLabel !== 0 && shiftedXValue < previousLabel) {
                  var maxAvailableWidth = chart.availableSize.width - previousLabel;
                  label.text = textTrim(maxAvailableWidth, label.originalText, axis.labelStyle, chart.isRtlEnabled, chart.themeStyle.axisLabelFont);
                } else {
                  options.x = pointX = shiftedXValue;
                }
              }
              break;
          }
        }
        options.text = this.getLabelText(label, axis, intervalLength);
        options.labelRotation = angle;
        var xValue = void 0;
        var xValue2 = void 0;
        if (isAxisBreakLabel && angle === 0) {
          if (axis.lineBreakAlignment === "Right") {
            xValue = options.x - width;
            xValue2 = options.x;
          } else if (axis.lineBreakAlignment === "Center") {
            xValue = options.x - width / 2;
            xValue2 = options.x + width / 2;
          } else {
            xValue = options.x;
            xValue2 = options.x + width;
          }
        } else {
          xValue = options.x;
          xValue2 = options.x + width;
        }
        if (angle === 0 && axis.labelIntersectAction === "Hide" && i !== 0 && (!isInverse ? xValue <= previousEnd : xValue2 >= previousEnd)) {
          continue;
        }
        if (isAxisBreakLabel) {
          if (axis.lineBreakAlignment === "Right") {
            previousEnd = isInverse ? options.x - width : options.x;
          } else if (axis.lineBreakAlignment === "Center") {
            previousEnd = isInverse ? options.x - width / 2 : options.x + width / 2;
          } else {
            previousEnd = isInverse ? options.x : options.x + width;
          }
        } else {
          previousEnd = isInverse ? options.x : options.x + width;
        }
        if (angle !== 0) {
          var height = void 0;
          var rect_1 = void 0;
          if (isAxisBreakLabel) {
            var xAdjustment = 0;
            var yAdjustment = 0;
            height = label.breakLabelSize.height;
            yAdjustment = label.breakLabelSize.height - 4;
            if (axis.lineBreakAlignment === "Center") {
              xAdjustment = -(label.breakLabelSize.width / 2);
            } else if (axis.lineBreakAlignment === "Right") {
              xAdjustment = -label.breakLabelSize.width;
            }
            if (isLabelUnderAxisLine) {
              yAdjustment = label.breakLabelSize.height / (options.text.length + 1);
            }
            rect_1 = new Rect(options.x + xAdjustment, options.y - yAdjustment, label.breakLabelSize.width, height);
          } else {
            height = pointY - (options.y - label.size.height / 2);
            rect_1 = new Rect(options.x, options.y - (label.size.height / 2 - 5), label.size.width, height);
          }
          var rectCoordinates = this.getRectanglePoints(rect_1);
          var rectCenterX = isAxisBreakLabel ? rect_1.x + rect_1.width / 2 : pointX;
          var rectCenterY = isAxisBreakLabel ? rect_1.y + rect_1.height / 2 : pointY - height / 2;
          if (isAxisBreakLabel) {
            options.transform = "rotate(" + angle + "," + rectCenterX + "," + rectCenterY + ")";
          } else {
            options.transform = "rotate(" + angle + "," + pointX + "," + pointY + ")";
          }
          newPoints.push(getRotatedRectangleCoordinates(rectCoordinates, rectCenterX, rectCenterY, angle));
          isRotatedLabelIntersect = false;
          if (axis.labelIntersectAction !== "None") {
            for (var index_1 = i; index_1 > 0; index_1--) {
              if (newPoints[i] && newPoints[index_1 - 1] && isRotatedRectIntersect(newPoints[i], newPoints[index_1 - 1])) {
                isRotatedLabelIntersect = true;
                newPoints[i] = null;
                break;
              }
            }
          }
          var rotateAngle = angle > 0 && angle < 90 || angle > 180 && angle < 270 || angle < -90 && angle > -180 || angle < -270 && angle > -360;
          var textRect = new Rect(options.x, options.y - (elementSize.height / 2 + padding / 2), label.size.width, height);
          var textRectCoordinates = this.getRectanglePoints(textRect);
          var rectPoints = [];
          rectPoints.push(new ChartLocation(rotateAngle ? this.chart.availableSize.width : this.padding, axis.rect.y));
          rectPoints.push(new ChartLocation(rotateAngle ? this.chart.availableSize.width : this.padding, axis.rect.y + axis.maxLabelSize.height));
          textPoints.push(getRotatedRectangleCoordinates(textRectCoordinates, rectCenterX, rectCenterY, angle));
          var newRect = new Rect(0, axis.rect.y, this.chart.availableSize.width, axis.maxLabelSize.height * 2);
          for (var k = 0; k < textPoints[i].length; k++) {
            if (!axis.opposedPosition && !withInBounds(textPoints[i][k].x, textPoints[i][k].y, newRect) && typeof options.text === "string") {
              var interSectPoint = this.calculateIntersection(textPoints[i][0], textPoints[i][1], rectPoints[0], rectPoints[1]);
              var rectPoint1 = rotateAngle ? this.chart.availableSize.width - pointX : pointX;
              var rectPoint2 = interSectPoint.y - axis.rect.y;
              var trimValue = Math.sqrt(rectPoint1 * rectPoint1 + rectPoint2 * rectPoint2);
              options.text = textTrim(trimValue, label.text, label.labelStyle, chart.enableRtl, chart.themeStyle.axisLabelFont);
            }
          }
        }
        if (this.chart.redraw && (chart.pointsAdded && !chart.pointsRemoved || this.chart.zoomRedraw) && !getElement2(options.id) && i !== 0 && !this.chart.enableCanvas && axis.visible) {
          var optionsX = options.x;
          options.x = this.seriesClipRect.x + (chart.enableRtl !== axis.isInversed ? -(this.seriesClipRect.width / (i ? i : 1) * count) : this.seriesClipRect.width + this.seriesClipRect.width / (i ? i : 1) * count);
          var transform = options.transform;
          options.transform = angle ? "rotate(" + angle + "," + options.x + "," + parseFloat(options.transform.split(",")[2]) + ")" : "";
          var element_1 = textElement2(chart.renderer, options, label.labelStyle, label.labelStyle.color || chart.themeStyle.axisLabelFont.color, labelElement, axis.isAxisOpposedPosition !== (axis.labelPosition === "Inside"), chart.redraw, true, null, chart.duration, null, label.size, isRotatedLabelIntersect, chart.enableCanvas, null, chart.themeStyle.axisLabelFont);
          this.rangeAnimate(axis, element_1, this.chart.duration, true, new Rect(this.seriesClipRect.x, axis.rect.y, this.seriesClipRect.x + this.seriesClipRect.width, this.chart.availableSize.height), false, i);
          options.x = optionsX;
          options.transform = transform;
          count += 1;
        }
        var element = textElement2(chart.renderer, options, label.labelStyle, label.labelStyle.color || chart.themeStyle.axisLabelFont.color, labelElement, axis.isAxisOpposedPosition !== (axis.labelPosition === "Inside"), chart.redraw, true, null, chart.duration, null, label.size, isRotatedLabelIntersect, chart.enableCanvas, null, chart.themeStyle.axisLabelFont, new ChartLocation(parseFloat(options.transform.split(",")[1]), parseFloat(options.transform.split(",")[2])));
        if (pointsRemoved) {
          element.id = chart.element.id + index + "_AxisLabel_" + i;
        }
      }
      if (this.previousXLabel && length && this.previousXLabel > length && !this.chart.enableCanvas && axis.visible && this.chart.zoomRedraw && this.chart.redraw && options.text) {
        for (var i = length; i < this.previousXLabel; i++) {
          options.x = this.seriesClipRect.x + (chart.enableRtl !== axis.isInversed ? -(this.seriesClipRect.width / length * (i - length + 1)) : this.seriesClipRect.width + this.seriesClipRect.width / length * (i - length + 1));
          options.id = chart.element.id + index + "_AxisLabel_" + i;
          options.transform = angle ? "rotate(" + angle + "," + options.x + "," + parseFloat(options.transform.split(",")[2]) + ")" : "";
          this.updateAxisElement(axis, index, "", i, "_AxisLabel_", labelElement, true, options, label);
        }
      } else {
        this.previousXLabel = length;
      }
      if (!this.chart.enableCanvas) {
        if (!chart.delayRedraw) {
          parent.appendChild(labelElement);
        } else if (axis.visible && axis.internalVisibility) {
          this.createZoomingLabel(this.chart, labelElement, axis, index, rect);
        }
      }
    };
    CartesianAxisLayoutPanel3.prototype.updateAxisElement = function(axis, index, gridDirection, i, elementId, parentElement, isRemove, option, label) {
      var element;
      var isGrid = elementId.indexOf("Grid") > -1;
      var isLabel = elementId.indexOf("Label") > -1;
      if (isLabel) {
        element = textElement2(this.chart.renderer, option, label.labelStyle, label.labelStyle.color || this.chart.themeStyle.axisLabelFont.color, parentElement, axis.isAxisOpposedPosition !== (axis.labelPosition === "Inside"), this.chart.redraw, true, null, this.chart.duration, null, null, null, this.chart.enableCanvas, null, this.chart.themeStyle.axisLabelFont);
      } else {
        this.renderGridLine(axis, index, gridDirection, isGrid ? axis.majorGridLines : axis.majorTickLines, elementId, i, this.element, isGrid ? this.chart.themeStyle.majorGridLine : this.chart.themeStyle.majorTickLine, isGrid ? axis.majorGridLines.dashArray : null);
        if (this.element && parentElement.childNodes) {
          element = this.element.childNodes[parentElement.childNodes.length - 1];
        }
      }
      this.rangeAnimate(axis, element, this.chart.duration, isLabel, new Rect(axis.orientation === "Vertical" ? 0 : this.seriesClipRect.x, axis.orientation === "Vertical" ? this.seriesClipRect.y : axis.rect.y, this.seriesClipRect.width, this.seriesClipRect.height), isRemove, i);
    };
    CartesianAxisLayoutPanel3.prototype.removeAxisLabelElements = function(axis, axislabelElement) {
      if (this.chart.pointsRemoved && axislabelElement && axislabelElement.childNodes.length) {
        var pointsRemoved = false;
        if (axis.valueType.indexOf("Category") > -1) {
          var visibleLabelTexts_1 = [];
          axis.visibleLabels.map(function(label) {
            if (typeof label.text !== "string") {
              visibleLabelTexts_1.push(label.text.join(""));
            } else {
              visibleLabelTexts_1.push(label.text);
            }
          });
          for (var i = axislabelElement.childNodes.length - 1; i >= 0; i--) {
            var childNode = axislabelElement.childNodes[i];
            if (visibleLabelTexts_1.indexOf(childNode.textContent.trim()) === -1) {
              axislabelElement.removeChild(childNode);
              pointsRemoved = true;
            }
          }
        } else if (axislabelElement.childNodes.length > axis.visibleLabels.length) {
          for (var j = 0; j < axislabelElement.childNodes.length - axis.visibleLabels.length; j++) {
            axislabelElement.removeChild(axislabelElement.childNodes[j]);
            pointsRemoved = true;
          }
        }
        return pointsRemoved;
      }
      return false;
    };
    CartesianAxisLayoutPanel3.prototype.calculateIntersection = function(p1, p2, p3, p4) {
      var c2x = p3.x - p4.x;
      var c3x = p1.x - p2.x;
      var c2y = p3.y - p4.y;
      var c3y = p1.y - p2.y;
      var d = c3x * c2y - c3y * c2x;
      var u1 = p1.x * p2.y - p1.y * p2.x;
      var u4 = p3.x * p4.y - p3.y * p4.x;
      var px = (u1 * c2x - c3x * u4) / d;
      var py = (u1 * c2y - c3y * u4) / d;
      var p = {
        x: px,
        y: py
      };
      return p;
    };
    CartesianAxisLayoutPanel3.prototype.getAnchor = function(axis) {
      return axis.lineBreakAlignment === "Center" ? "middle" : this.chart.enableRtl ? axis.lineBreakAlignment === "Left" ? "end" : "start" : axis.lineBreakAlignment === "Left" ? "start" : "end";
    };
    CartesianAxisLayoutPanel3.prototype.getRectanglePoints = function(rect) {
      var point1 = new ChartLocation(rect.x, rect.y);
      var point2 = new ChartLocation(rect.x + rect.width, rect.y);
      var point3 = new ChartLocation(rect.x + rect.width, rect.y + rect.height);
      var point4 = new ChartLocation(rect.x, rect.y + rect.height);
      return [point1, point2, point3, point4];
    };
    CartesianAxisLayoutPanel3.prototype.getLabelText = function(label, axis, intervalLength) {
      if (isBreakLabel(label.originalText)) {
        var result = [];
        var str = void 0;
        for (var index = 0; index < label.text.length; index++) {
          str = this.findAxisLabel(axis, label.text[index], intervalLength);
          result.push(str);
        }
        return result;
      } else {
        return this.findAxisLabel(axis, label.text, intervalLength);
      }
    };
    CartesianAxisLayoutPanel3.prototype.drawXAxisBorder = function(axis, index, parent, axisRect) {
      if (axis.border.width > 0) {
        var scrollBarHeight = axis.labelPosition === "Outside" && axis.scrollbarSettings.position !== "Top" && axis.scrollbarSettings.position !== "Bottom" ? axis.scrollBarHeight : 0;
        var isOpposed = axis.isAxisOpposedPosition;
        var startX = void 0;
        var startY = axisRect.y + (isOpposed ? -1 : 1) * scrollBarHeight;
        var padding = 10;
        var pointX = void 0;
        var gap = axisRect.width / axis.visibleRange.delta * (axis.valueType === "DateTime" ? axis.dateTimeInterval : axis.visibleRange.interval);
        var endX = void 0;
        var length_2 = axis.maxLabelSize.height + (axis.tickPosition === axis.labelPosition ? axis.majorTickLines.height : 0);
        var labelBorder = "";
        var ticksbwtLabel = axis.valueType === "Category" && axis.labelPlacement === "BetweenTicks" ? -0.5 : 0;
        var endY = isOpposed && axis.labelPosition === "Inside" || !isOpposed && axis.labelPosition === "Outside" ? axisRect.y + length_2 + padding + scrollBarHeight : axisRect.y - length_2 - padding - scrollBarHeight;
        for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {
          pointX = valueToCoefficient(axis.visibleLabels[i].value + ticksbwtLabel, axis);
          pointX = (axis.isAxisInverse ? 1 - pointX : pointX) * axisRect.width;
          if (axis.valueType === "Category" && axis.labelPlacement === "BetweenTicks") {
            startX = pointX + axisRect.x;
            endX = pointX + gap + axisRect.x;
          } else {
            startX = pointX - gap * 0.5 + axisRect.x;
            endX = pointX + gap * 0.5 + axisRect.x;
          }
          switch (axis.border.type) {
            case "Rectangle":
            case "WithoutTopBorder":
              if (startX < axisRect.x && axis.labelPlacement !== "OnTicks") {
                labelBorder += "M " + axisRect.x + " " + endY + " L " + endX + " " + endY + " ";
              } else if (Math.floor(endX) > axisRect.width + axisRect.x && !(axis.visibleLabels.length === 1) && !(i === axis.visibleLabels.length - 1)) {
                labelBorder += "M " + startX + " " + startY + " L " + startX + " " + endY + " L " + (axisRect.width + axisRect.x) + " " + endY + " ";
              } else {
                startX = i === 0 && axis.labelPlacement === "OnTicks" ? axisRect.x : startX;
                endX = i === axis.visibleLabels.length - 1 && axis.labelPlacement === "OnTicks" ? endX - gap * 0.5 : endX;
                labelBorder += "M " + startX + " " + startY + " L " + startX + " " + endY + " L " + endX + " " + endY + " ";
                if (i === 0) {
                  labelBorder += "M " + startX + " " + startY + " L " + startX + " " + endY + " M " + startX + " " + endY + " L " + axisRect.x + " " + endY;
                }
                if (i === axis.visibleLabels.length - 1) {
                  labelBorder += "M " + endX + " " + startY + " L " + endX + " " + endY + " M " + endX + " " + endY + " L " + (axisRect.width + axisRect.x) + " " + endY;
                }
              }
              break;
            case "WithoutTopandBottomBorder":
              if (!(startX < axisRect.x) && !(Math.floor(endX) > axisRect.width + axisRect.x)) {
                labelBorder += "M " + startX + " " + startY + " L " + startX + " " + endY + " M " + endX + " " + startY + " L " + endX + " " + endY;
              }
              break;
          }
        }
        labelBorder += axis.border.type === "Rectangle" ? "M  " + axisRect.x + " " + startY + "L " + (axisRect.x + axisRect.width) + " " + startY : "";
        if (labelBorder !== "") {
          this.createAxisBorderElement(axis, index, labelBorder, parent);
        }
      }
      for (var i = 0; i < this.chart.visibleSeries.length; i++) {
        if (this.chart.multiLevelLabelModule && axis.multiLevelLabels.length > 0 && this.chart.visibleSeries[i].visible) {
          this.chart.multiLevelLabelModule.renderXAxisMultiLevelLabels(axis, index, parent, axisRect);
          break;
        }
      }
    };
    CartesianAxisLayoutPanel3.prototype.createAxisBorderElement = function(axis, index, labelBorder, parent) {
      var element = getElement2(this.chart.element.id + "_BorderLine_" + index);
      var direction = element ? element.getAttribute("d") : "";
      var borderElement = this.chart.renderer.drawPath(new PathOption(this.chart.element.id + "_BorderLine_" + index, "transparent", axis.border.width, axis.border.color || this.chart.themeStyle.axisLine, 1, "", labelBorder));
      borderElement.style.pointerEvents = "none";
      appendChildElement(this.chart.enableCanvas, parent, borderElement, this.chart.redraw, false, "x", "y", null, direction, true, null, null, this.chart.duration);
    };
    CartesianAxisLayoutPanel3.prototype.findAxisLabel = function(axis, label, width) {
      return axis.labelIntersectAction === "Trim" ? axis.angle % 360 === 0 && !axis.enableTrim ? textTrim(width, label, axis.labelStyle, this.chart.enableRtl, this.chart.themeStyle.axisLabelFont) : label : label;
    };
    CartesianAxisLayoutPanel3.prototype.drawXAxisTitle = function(axis, index, parent, rect) {
      if (axis.title) {
        var chart = this.chart;
        var elementSize = measureText(axis.title, axis.titleStyle, this.chart.themeStyle.axisTitleFont);
        var scrollBarHeight = isNullOrUndefined(axis.crossesAt) && axis.scrollbarSettings.position !== "Top" && axis.scrollbarSettings.position !== "Bottom" ? axis.scrollBarHeight : 0;
        var padding = (axis.tickPosition === "Inside" ? 0 : axis.majorTickLines.height + axis.titlePadding) + (axis.labelPosition === "Inside" ? 0 : axis.maxLabelSize.height + axis.multiLevelLabelHeight + axis.labelPadding);
        padding = axis.tickPosition !== "Outside" && (axis.tickPosition === "Inside" || axis.labelPosition === "Inside") ? axis.titlePadding === 5 ? padding : padding + axis.titlePadding : padding;
        var titleSize = axis.titleSize.height * (axis.titleCollection.length - 1);
        padding = axis.isAxisOpposedPosition ? -(padding + elementSize.height / 4 + scrollBarHeight + titleSize) : padding + 3 * elementSize.height / 4 + scrollBarHeight;
        var labelRotation = axis.titleRotation ? axis.titleRotation : 0;
        var x = void 0;
        var y = rect.y + padding;
        var anchor = void 0;
        if (axis.titleStyle.textAlignment === "Center") {
          anchor = "middle";
          x = rect.x + rect.width * 0.5;
        } else if (axis.titleStyle.textAlignment === "Near") {
          anchor = "start";
          x = rect.x;
        } else {
          anchor = "end";
          x = rect.x + rect.width;
        }
        if (labelRotation !== 0) {
          y += axis.opposedPosition ? -(axis.titleSize.height / 2 + elementSize.height / 4) : axis.titleSize.height / 2 - elementSize.height / 4;
        }
        var options = new TextOption(chart.element.id + "_AxisTitle_" + index, x, y, anchor, axis.titleCollection, "rotate(" + labelRotation + "," + x + "," + y + ")", null, labelRotation);
        var element = textElement2(chart.renderer, options, axis.titleStyle, axis.titleStyle.color || chart.themeStyle.axisTitleFont.color, parent, null, chart.redraw, chart.redraw, null, null, null, null, null, chart.enableCanvas, null, chart.themeStyle.axisTitleFont, new ChartLocation(x, y));
        element.setAttribute("aria-hidden", "true");
      }
    };
    CartesianAxisLayoutPanel3.prototype.renderGridLine = function(axis, index, gridDirection, gridModel, gridId, gridIndex, parent, themeColor, dashArray, removeIndex, isRemoved) {
      if (dashArray === void 0) {
        dashArray = null;
      }
      if (removeIndex === void 0) {
        removeIndex = null;
      }
      if (isRemoved === void 0) {
        isRemoved = false;
      }
      var chart = this.chart;
      var direction;
      var element;
      if (gridModel.width > 0 && axis.visible && axis.internalVisibility && gridDirection) {
        element = getElement2(chart.element.id + gridId + index + "_" + (isRemoved ? removeIndex : gridIndex));
        direction = element ? element.getAttribute("d") : null;
        element = null;
        this.htmlObject = chart.renderer.drawPath(new PathOption(chart.element.id + gridId + index + "_" + (isRemoved ? removeIndex : gridIndex), "transparent", gridModel.width, gridModel.color || themeColor, null, dashArray, gridDirection));
        appendChildElement(chart.enableCanvas, parent, this.htmlObject, chart.redraw, true, "x", "y", null, direction, true, null, null, chart.duration);
        if (isRemoved) {
          this.htmlObject.id = chart.element.id + gridId + index + "_" + gridIndex;
        }
      }
    };
    CartesianAxisLayoutPanel3.prototype.findParentNode = function(elementId, label, index) {
      if (document.getElementById(elementId + "AxisGroup" + index + "Inside").contains(document.getElementById(label.id))) {
        return document.getElementById(elementId + "AxisGroup" + index + "Inside");
      } else {
        return document.getElementById(elementId + "AxisGroup" + index + "Outside");
      }
    };
    CartesianAxisLayoutPanel3.prototype.createZoomingLabel = function(chart, labelElement, axis, index, rect) {
      var parentNode = this.findParentNode(chart.element.id, labelElement, index);
      labelElement.setAttribute("opacity", "0.3");
      var zoomElement = chart.renderer.createGroup({
        id: chart.element.id + "AxisLabels_Zoom" + index
      });
      zoomElement = createZoomingLabels(chart, axis, zoomElement, index, axis.orientation === "Vertical", rect);
      parentNode.replaceChild(labelElement, document.getElementById(labelElement.id));
      if (getElement2(chart.element.id + "AxisLabels_Zoom" + index)) {
        parentNode.replaceChild(zoomElement, document.getElementById(zoomElement.id));
      } else {
        parentNode.appendChild(zoomElement);
      }
    };
    return CartesianAxisLayoutPanel3;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart/utils/get-data.js
var ChartData = (
  /** @class */
  function() {
    function ChartData2(chart) {
      this.currentPoints = [];
      this.previousPoints = [];
      this.insideRegion = false;
      this.commonXvalues = [];
      this.chart = chart;
      this.lierIndex = 0;
    }
    ChartData2.prototype.getData = function() {
      var chart = this.chart;
      var point = null;
      var series = null;
      var width;
      var height;
      var mouseX;
      var mouseY;
      for (var len = chart.visibleSeries.length, i = len - 1; i >= 0; i--) {
        series = chart.visibleSeries[i];
        width = series.type === "Scatter" || series.drawType === "Scatter" || series.marker.visible ? (series.marker.height + 5) / 2 : 0;
        height = series.type === "Scatter" || series.drawType === "Scatter" || series.marker.visible ? (series.marker.width + 5) / 2 : 0;
        mouseX = chart.mouseX;
        mouseY = chart.mouseY;
        if (series.dragSettings.enable && series.isRectSeries) {
          if (!(series.type === "Bar" && chart.isTransposed) && (chart.isTransposed || series.type === "Bar")) {
            var markerWidth = series.marker.width / 2;
            mouseX = series.yAxis.isAxisInverse ? mouseX + markerWidth : mouseX - markerWidth;
          } else {
            var markerHeight = series.marker.height / 2;
            mouseY = series.yAxis.isAxisInverse ? mouseY - markerHeight : mouseY + markerHeight;
          }
        }
        if (series.visible && withInBounds(mouseX, mouseY, series.clipRect, width, height)) {
          point = this.getRectPoint(series, series.clipRect, mouseX, mouseY);
        }
        if (point) {
          return new PointData(point, series);
        }
      }
      return new PointData(point, series);
    };
    ChartData2.prototype.isSelected = function(chart) {
      return (chart.selectionMode.indexOf("Drag") > -1 || chart.selectionMode.indexOf("Lasso") > -1) && chart.selectionModule && chart.selectionModule.rectPoints !== null;
    };
    ChartData2.prototype.getRectPoint = function(series, rect, x, y) {
      var chart = this.chart;
      var fromCenterX;
      var fromCenterY;
      var clickAngle;
      var arcAngle = 0;
      var startAngle;
      var endAngle;
      var distanceFromCenter;
      if (chart.isScrolling) {
        return null;
      }
      for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
        var point = _a[_i];
        if (!point.regionData) {
          if (!point.regions || !point.regions.length) {
            continue;
          }
        }
        if (point.regionData && this.chart.chartAreaType === "PolarRadar" && series.drawType.indexOf("Column") > -1) {
          fromCenterX = x - (series.clipRect.width / 2 + series.clipRect.x);
          fromCenterY = y - (series.clipRect.height / 2 + series.clipRect.y);
          arcAngle = 2 * Math.PI * (point.regionData.currentXPosition < 0 ? 1 + point.regionData.currentXPosition : point.regionData.currentXPosition);
          clickAngle = (Math.atan2(fromCenterY, fromCenterX) + 0.5 * Math.PI - arcAngle) % (2 * Math.PI);
          clickAngle = clickAngle < 0 ? 2 * Math.PI + clickAngle : clickAngle;
          clickAngle = clickAngle + 2 * Math.PI * series.chart.primaryXAxis.startAngle;
          startAngle = point.regionData.startAngle;
          startAngle -= arcAngle;
          startAngle = startAngle < 0 ? 2 * Math.PI + startAngle : startAngle;
          endAngle = point.regionData.endAngle;
          endAngle -= arcAngle;
          endAngle = endAngle < 0 ? 2 * Math.PI + endAngle : endAngle;
          distanceFromCenter = Math.sqrt(Math.pow(Math.abs(fromCenterX), 2) + Math.pow(Math.abs(fromCenterY), 2));
          if (clickAngle >= startAngle && clickAngle <= endAngle && (distanceFromCenter >= point.regionData.innerRadius && distanceFromCenter <= point.regionData.radius || distanceFromCenter <= point.regionData.innerRadius && distanceFromCenter >= point.regionData.radius) && distanceFromCenter <= series.chart.radius) {
            return point;
          }
        }
        if (series.dragSettings.enable && series.isRectSeries || series.isRectSeries && series.marker.visible && this.chart.chartAreaType !== "PolarRadar") {
          if (this.isPointInThresholdRegion(x, y, point, rect, series)) {
            this.insideRegion = true;
            return point;
          }
        }
        if (!this.insideRegion && this.checkRegionContainsPoint(point.regions, rect, x, y)) {
          return point;
        } else if (this.insideRegion && this.checkRegionContainsPoint(point.regions, rect, x, y)) {
          return point;
        }
      }
      return null;
    };
    ChartData2.prototype.checkRegionContainsPoint = function(regionRect, rect, x, y) {
      var _this = this;
      return regionRect.some(function(region, index) {
        _this.lierIndex = index;
        return withInBounds(x, y, new Rect((_this.chart.chartAreaType === "Cartesian" ? rect.x : 0) + region.x, (_this.chart.chartAreaType === "Cartesian" ? rect.y : 0) + region.y, region.width, region.height));
      });
    };
    ChartData2.prototype.isPointInThresholdRegion = function(x, y, point, rect, series) {
      var _this = this;
      var isBar = series.type === "Bar";
      var isInversed = series.yAxis.isAxisInverse;
      var isTransposed = series.chart.isTransposed;
      var heightValue = 10;
      var yValue = 0;
      var xValue = 0;
      var width;
      var height = width = 2 * heightValue;
      if (isInversed && isTransposed) {
        if (isBar) {
          yValue = point.regions[0].height - heightValue;
          width = point.regions[0].width;
        } else {
          xValue = -heightValue;
          height = point.regions[0].height;
        }
      } else if (isInversed || point.yValue < 0) {
        if (isBar) {
          xValue = -heightValue;
          height = point.regions[0].height;
        } else {
          yValue = point.regions[0].height - heightValue;
          width = point.regions[0].width;
        }
      } else if (isTransposed) {
        if (isBar) {
          yValue = -heightValue;
          width = point.regions[0].width;
        } else {
          xValue = point.regions[0].width - heightValue;
          height = point.regions[0].height;
        }
      } else {
        if (isBar) {
          xValue = point.regions[0].width - heightValue;
          height = point.regions[0].height;
        } else {
          yValue = -heightValue;
          width = point.regions[0].width;
        }
      }
      return point.regions.some(function(region) {
        return withInBounds(x, y, new Rect((_this.chart.chartAreaType === "Cartesian" ? rect.x : 0) + region.x + xValue, (_this.chart.chartAreaType === "Cartesian" ? rect.y : 0) + region.y + yValue, width, height));
      });
    };
    ChartData2.prototype.getClosest = function(series, value, xvalues) {
      var closest;
      var data;
      var xData = xvalues ? xvalues : series.xData;
      var xLength = xData.length;
      var leftSideNearest = 0.5;
      var rightSideNearest = 0.5;
      if (series.xAxis.valueType === "DateTime" && series.points.length === 1) {
        leftSideNearest = series.xAxis.visibleRange.min;
        rightSideNearest = series.xAxis.visibleRange.max;
        for (var index = 0; index < series.chart.visibleSeries.length; index++) {
          var visibleSeries = series.chart.visibleSeries[index];
          if (visibleSeries.xMin >= leftSideNearest && visibleSeries.xMin < series.xMin) {
            leftSideNearest = visibleSeries.xMin + 0.1;
          }
          if (visibleSeries.xMax <= rightSideNearest && visibleSeries.xMax > series.xMax) {
            rightSideNearest = visibleSeries.xMax - 0.1;
          }
          if (visibleSeries.visible && visibleSeries.points.length > 1) {
            if (visibleSeries.xMax >= leftSideNearest && visibleSeries.xMax < series.xMin) {
              leftSideNearest = visibleSeries.xMax + 0.1;
            }
            if (visibleSeries.xMin <= rightSideNearest && visibleSeries.xMin > series.xMax) {
              rightSideNearest = visibleSeries.xMin - 0.1;
            }
          }
        }
        if (leftSideNearest !== series.xAxis.visibleRange.min) {
          leftSideNearest = Math.abs(series.xMin - leftSideNearest) / 2;
        }
        if (rightSideNearest !== series.xAxis.visibleRange.max) {
          rightSideNearest = Math.abs(series.xMax - rightSideNearest) / 2;
        }
      }
      if (value >= series.xMin - leftSideNearest && value <= series.xMax + rightSideNearest) {
        for (var i = 0; i < xLength; i++) {
          data = xData[i];
          if (closest == null || Math.abs(data - value) < Math.abs(closest - value)) {
            closest = data;
          }
        }
      }
      var isDataExist = series.xData.indexOf(closest) !== -1;
      if (isDataExist) {
        return closest;
      } else {
        return null;
      }
    };
    ChartData2.prototype.binarySearch = function(target, list) {
      var first = 0;
      var last = list.length;
      var position = -1;
      var found = false;
      var middle;
      while (found === false && first <= last) {
        middle = Math.floor((first + last) / 2);
        if (list[middle].xValue === target) {
          found = true;
          position = middle;
        } else if (list[middle].xValue > target) {
          last = middle - 1;
        } else {
          first = middle + 1;
        }
      }
      return position !== -1 ? list[position] : null;
    };
    ChartData2.prototype.getClosestX = function(chart, series, xvalues) {
      var value;
      var rect = series.clipRect;
      if (chart.mouseX <= rect.x + rect.width && chart.mouseX >= rect.x) {
        if (!chart.requireInvertedAxis) {
          value = getValueXByPoint(chart.mouseX - rect.x, rect.width, series.xAxis);
        } else {
          value = getValueYByPoint(chart.mouseY - rect.y, rect.height, series.xAxis);
        }
      }
      var closest = this.getClosest(series, value, xvalues);
      var point = (closest || closest === 0) && series.points.length > 0 ? this.binarySearch(closest, sort(series.points, ["xValue"])) : null;
      if (point && point.visible) {
        if (!(this.chart.chartAreaType === "Cartesian" && (series.category === "Indicator" && series.name === "Histogram" || point.symbolLocations && point.symbolLocations.length > 0 && point.symbolLocations[0].x >= 0 && point.symbolLocations[0].x <= rect.width))) {
          return null;
        }
        return new PointData(point, series);
      }
      return null;
    };
    ChartData2.prototype.mergeXvalues = function(visibleSeries) {
      if (visibleSeries.length && (!this.commonXvalues.length || this.commonXvalues.length !== visibleSeries[0].xData.length)) {
        this.commonXvalues = visibleSeries[0].xData;
        for (var index = 1; index < visibleSeries.length; index++) {
          this.commonXvalues = this.getDistinctValues(this.commonXvalues, visibleSeries[index].xData);
        }
      }
      return this.commonXvalues;
    };
    ChartData2.prototype.commonXValue = function(visibleSeries) {
      var commonXValues = [];
      for (var j = 0; j < visibleSeries.length; j++) {
        for (var i = 0; visibleSeries[j].points && i < visibleSeries[j].points.length; i++) {
          var point = visibleSeries[j].points[i];
          if (point && (point.index === 0 || point.index === visibleSeries[j].points.length - 1 || point.symbolLocations && point.symbolLocations.length > 0)) {
            commonXValues.push(point.xValue);
          }
        }
      }
      return commonXValues;
    };
    ChartData2.prototype.getDistinctValues = function(first, second) {
      if (first === void 0) {
        first = [];
      }
      if (second === void 0) {
        second = [];
      }
      var intial = {};
      var result = [];
      var index;
      for (index = 0; index < first.length; index++) {
        var temp = first[index];
        if (!intial[temp]) {
          intial[temp] = true;
          result.push(temp);
        }
      }
      for (index = 0; index < second.length; index++) {
        var temp = second[index];
        if (!intial[temp]) {
          intial[temp] = true;
          result.push(temp);
        }
      }
      return result;
    };
    ChartData2.prototype.findMouseValues = function(data, chart, interactionElement) {
      if (!chart.requireInvertedAxis) {
        if (chart.chartAreaType === "PolarRadar") {
          interactionElement.valueX = valueToPolarCoefficient(data.point.xValue, data.series.xAxis) * data.series.xAxis.rect.width + data.series.xAxis.rect.x;
        } else {
          interactionElement.valueX = data.series.category === "TrendLine" && chart.tooltip.shared ? interactionElement.valueX : valueToCoefficient(data.point.xValue, data.series.xAxis) * data.series.xAxis.rect.width + data.series.xAxis.rect.x;
        }
        interactionElement.valueY = chart.mouseY;
        if (chart.crosshair.snapToData) {
          if (data.series.type === "BoxAndWhisker" && data.point.regions.length) {
            interactionElement.valueY = data.point.regions[0].y + data.series.clipRect.y;
          } else {
            interactionElement.valueY = data.point.symbolLocations[0].y + data.series.clipRect.y;
          }
        }
      } else {
        interactionElement.valueY = (1 - valueToCoefficient(data.point.xValue, data.series.xAxis)) * data.series.xAxis.rect.height + data.series.xAxis.rect.y;
        interactionElement.valueX = chart.mouseX;
        if (chart.crosshair.snapToData) {
          if (data.series.type === "BoxAndWhisker" && data.point.regions.length) {
            interactionElement.valueX = data.point.regions[0].x + data.series.clipRect.x;
          } else {
            if (!chart.tooltip.shared) {
              interactionElement.valueX = data.point.symbolLocations[0].x + data.series.clipRect.x;
            } else {
              chart.crosshairModule.valueX = data.point.symbolLocations[0].x + data.series.clipRect.x;
            }
          }
        }
      }
    };
    return ChartData2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/common/model/data.js
var Data = (
  /** @class */
  function() {
    function Data2(dataSource, query) {
      this.initDataManager(dataSource, query);
    }
    Data2.prototype.initDataManager = function(dataSource, query) {
      this.dataManager = dataSource instanceof DataManager ? dataSource : new DataManager(dataSource);
      this.query = query instanceof Query ? query : new Query();
    };
    Data2.prototype.generateQuery = function() {
      var query = this.query.clone();
      return query;
    };
    Data2.prototype.getData = function(dataQuery) {
      var _this = this;
      if (this.dataManager.ready) {
        var dataManagerDeferred_1 = new Deferred();
        var ready = this.dataManager.ready;
        ready.then(function() {
          _this.dataManager.executeQuery(dataQuery).then(function(result) {
            dataManagerDeferred_1.resolve(result);
          });
        }).catch(function(e) {
          dataManagerDeferred_1.reject(e);
        });
        return dataManagerDeferred_1.promise;
      } else {
        return this.dataManager.executeQuery(dataQuery);
      }
    };
    return Data2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/marker-explode.js
var __extends7 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var MarkerExplode = (
  /** @class */
  function(_super) {
    __extends7(MarkerExplode2, _super);
    function MarkerExplode2(chart) {
      var _this = _super.call(this, chart) || this;
      _this.elementId = chart.element.id;
      _this.commonXvalues = [];
      return _this;
    }
    MarkerExplode2.prototype.addEventListener = function() {
      if (this.chart.isDestroyed) {
        return;
      }
      this.chart.on(Browser.touchMoveEvent, this.mouseMoveHandler, this);
      this.chart.on(Browser.touchEndEvent, this.mouseUpHandler, this);
    };
    MarkerExplode2.prototype.removeEventListener = function() {
      if (this.chart.isDestroyed) {
        return;
      }
      this.chart.off(Browser.touchMoveEvent, this.mouseMoveHandler);
      this.chart.off(Browser.touchEndEvent, this.mouseUpHandler);
    };
    MarkerExplode2.prototype.mouseUpHandler = function() {
      var chart = this.chart;
      if (chart.isTouch && !chart.crosshair.enable && !this.isSelected(chart) && !(this.chart.zoomModule && getElement2(this.elementId + "_ZoomArea"))) {
        this.markerMove(true);
      }
    };
    MarkerExplode2.prototype.mouseMoveHandler = function() {
      var chart = this.chart;
      if ((chart.highlightMode !== "None" || chart.tooltip.enable) && (!chart.isTouch || chart.startMove) && !this.isSelected(chart) && !(this.chart.zoomModule && (getElement2(this.elementId + "_ZoomArea") || this.chart.zoomModule.startPanning))) {
        this.markerMove(false);
      }
    };
    MarkerExplode2.prototype.markerMove = function(remove2) {
      var _this = this;
      var chart = this.chart;
      this.currentPoints = [];
      var data;
      var previous;
      var explodeSeries;
      var series;
      if (!chart.tooltip.shared || !chart.tooltip.enable) {
        data = this.getData();
        series = data.series;
        previous = this.previousPoints[0];
        explodeSeries = series && (series.type === "Bubble" || series.drawType === "Scatter" || series.type === "Scatter" || series.type !== "Candle" && series.type !== "Hilo" && series.type !== "HiloOpenClose" && series.marker.visible && series.marker.width !== 0 && series.marker.height !== 0);
        data.lierIndex = this.lierIndex;
        if (data.point && explodeSeries && (!previous || previous.point !== data.point || previous && previous.lierIndex > 3 && previous.lierIndex !== this.lierIndex)) {
          this.currentPoints.push(data);
        }
        if (data.point && explodeSeries && chart.isPointMouseDown) {
          this.currentPoints.push(data);
        }
        if (this.currentPoints.length === 0 && data.point && !explodeSeries && !isNullOrUndefined(previous) && previous.point !== data.point) {
          this.removeHighlightedMarker(previous.series, previous.point);
          this.previousPoints = extend([], data, null, true);
        }
        if (chart.tooltip.showNearestTooltip && this.chart.tooltipModule && this.chart.tooltipModule.currentPoints && (explodeSeries || series.type === "Pareto" && series.paretoOptions.marker.visible) && this.currentPoints.length === 0 && withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect)) {
          this.currentPoints = this.chart.tooltipModule.currentPoints;
        }
      } else {
        if (!withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect)) {
          return null;
        }
        if (chart.tooltip.enable) {
          var pointData = chart.chartAreaType === "PolarRadar" ? this.getData() : null;
          if (!this.chart.tooltip.showNearestPoint) {
            this.currentPoints = this.chart.tooltipModule.currentPoints;
          } else {
            for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
              var chartSeries = _a[_i];
              if (!chartSeries.enableTooltip || chartSeries.category === "Indicator") {
                continue;
              }
              if (chart.chartAreaType === "Cartesian" && chartSeries.visible) {
                data = this.getClosestX(chart, chartSeries, this.commonXValue(this.chart.visibleSeries));
              } else if (chart.chartAreaType === "PolarRadar" && chartSeries.visible && pointData.point !== null) {
                data = new PointData(chartSeries.points[pointData.point.index], chartSeries);
              }
              if (data) {
                this.currentPoints.push(data);
                data = null;
              }
            }
          }
        }
      }
      var length = this.previousPoints.length;
      if (this.currentPoints.length > 0 || length > 0 && chart.tooltip.shared) {
        if (length === 0 || chart.isPointMouseDown || length > 0 && (this.currentPoints.length === 0 || this.previousPoints[0].point !== this.currentPoints[0].point)) {
          if (length > 0) {
            for (var _b = 0, _c = this.previousPoints; _b < _c.length; _b++) {
              var previousPoint = _c[_b];
              if (!isNullOrUndefined(previousPoint)) {
                this.removeHighlightedMarker(previousPoint.series, previousPoint.point);
              }
            }
          }
          var _loop_1 = function(data_12) {
            if (data_12 && data_12.point || series.type !== "Candle" && series.type !== "Hilo" && series.type !== "HiloOpenClose") {
              stopTimer(this_1.markerExplode);
              this_1.isRemove = true;
              data_12.point.symbolLocations.map(function(location, index) {
                if (data_12.series.marker.allowHighlight && (!data_12.series.isRectSeries || data_12.point.marker.visible)) {
                  _this.drawTrackBall(data_12.series, data_12.point, location, index);
                }
              });
            }
          };
          var this_1 = this;
          for (var _d = 0, _e = this.currentPoints; _d < _e.length; _d++) {
            var data_1 = _e[_d];
            _loop_1(data_1);
          }
          this.previousPoints = extend([], this.currentPoints, null, true);
        }
      }
      if (!chart.tooltip.enable && (this.currentPoints.length === 0 && this.isRemove || remove2 && this.isRemove || !withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect))) {
        this.isRemove = false;
        if (!isNullOrUndefined(this.previousPoints[0])) {
          this.markerExplode = +setTimeout(function() {
            if (_this.previousPoints[0]) {
              _this.removeHighlightedMarker(_this.previousPoints[0].series, _this.previousPoints[0].point);
            }
          }, 2e3);
        }
      }
      this.currentPoints = [];
    };
    MarkerExplode2.prototype.animationDuration = function() {
      var duration = 200;
      if (this.chart.maxPointCount > 100) {
        duration = 10;
      } else if (this.chart.maxPointCount > 50) {
        duration = 100;
      }
      return duration;
    };
    MarkerExplode2.prototype.drawTrackBall = function(series, point, location, index) {
      var marker = point.marker;
      var seriesMarker = series.marker;
      var shape = marker.shape || seriesMarker.shape || "Circle";
      var svg;
      if (shape === "None" || shape === "Image") {
        return null;
      }
      var element = series.symbolElement || series.seriesElement;
      var className;
      if (this.chart.highlightModule && this.chart.highlightMode !== "None") {
        className = this.chart.highlightModule.generateStyle(series);
      }
      if (this.chart.selectionModule && this.chart.selectionMode !== "None") {
        className = this.chart.selectionModule.generateStyle(series);
      }
      var symbolId = this.elementId + "_Series_" + series.index + "_Point_" + point.index + "_Trackball" + (index ? index : "");
      if (getElement2(symbolId + "_1") && getElement2(symbolId + "_1").getAttribute("e-animate")) {
        Animation.stop(getElement2(symbolId + "_1"));
        remove(getElement2(symbolId + "_1"));
      }
      var size = new Size((marker.width || seriesMarker.width) + 3, (marker.height || seriesMarker.height) + 3);
      var border = marker.border || series.border;
      var explodeSeries = series.type === "BoxAndWhisker" || series.type === "Bubble" || series.type === "Scatter";
      var borderColor = border.color && border.color !== "transparent" ? border.color : marker.fill || point.interior || (explodeSeries ? point.color : series.interior);
      var colorValue = convertHexToColor(colorNameToHex(borderColor));
      var borderWidth = marker.border ? marker.border.width : seriesMarker.border.width;
      var markerShadow = series.chart.themeStyle.markerShadow || "rgba(" + colorValue.r + "," + colorValue.g + "," + colorValue.b + ",0.2)";
      var markerElement = document.getElementById(this.elementId + "_Series_" + series.index + "_Point_" + point.index + "_Symbol");
      if (!isNullOrUndefined(markerElement)) {
        markerElement.setAttribute("visibility", "visible");
      }
      if (this.chart.enableCanvas) {
        var trackElement = document.getElementById(this.chart.element.id + "_Secondary_Element");
        svg = this.chart.svgRenderer.createSvg({
          id: this.chart.element.id + "_trackball_svg",
          width: this.chart.availableSize.width,
          height: this.chart.availableSize.height
        });
        svg.style.cssText = "position: absolute; display:block; pointer-events: none";
        trackElement.appendChild(svg);
      }
      for (var i = 0; i < 2; i++) {
        var options = new PathOption(symbolId + "_" + i, i ? marker.fill || point.color || (explodeSeries ? series.interior : "#ffffff") : "transparent", borderWidth + (i ? 0 : 8), i ? borderColor : markerShadow, marker.opacity || seriesMarker.opacity, series.marker.border.dashArray, "");
        var symbol = drawSymbol(location, shape, size, marker.imageUrl, options, "", this.chart.svgRenderer, series.clipRect);
        symbol.setAttribute("class", this.elementId + "_EJ2-Trackball_Series_" + series.index + "_Point_" + point.index);
        var selectionId = element.id.indexOf("Symbol") !== -1 ? "_Symbol" : "";
        var seletionElem = document.getElementById(this.elementId + "_Series_" + series.index + "_Point_" + point.index + selectionId);
        if (className !== "" && !isNullOrUndefined(className) && !isNullOrUndefined(seletionElem) && seletionElem.hasAttribute("class") && className === seletionElem.getAttribute("class")) {
          symbol.classList.add(className);
        }
        symbol.setAttribute("clip-path", element.getAttribute("clip-path"));
        symbol.setAttribute("transform", element.getAttribute("transform"));
        if (this.chart.enableCanvas) {
          svg.appendChild(symbol);
        } else {
          this.chart.svgObject.appendChild(symbol);
        }
        if (point.symbolLocations.length > 1 && series.marker.visible && series.type !== "Bubble" && series.type !== "Scatter") {
          this.trackballAnimate(symbol, 0, this.animationDuration(), series, point.index, location, false, false);
        }
      }
      if (point.symbolLocations.length < 2 && series.marker.visible) {
        this.doAnimation(series, point, false);
      }
    };
    MarkerExplode2.prototype.doAnimation = function(series, point, endAnimate) {
      if (endAnimate === void 0) {
        endAnimate = false;
      }
      if (series.type === "Bubble" || series.type === "Scatter") {
        return;
      }
      var duration = this.animationDuration();
      var delay = 0;
      var rectElements = document.getElementsByClassName(this.elementId + "_EJ2-Trackball_Series_" + series.index + "_Point_" + point.index);
      for (var i = 0, len = rectElements.length; i < len; i++) {
        this.trackballAnimate(rectElements[i], delay, duration, series, point.index, point.symbolLocations[0], false, endAnimate);
      }
    };
    MarkerExplode2.prototype.trackballAnimate = function(elements, delays, durations, series, pointIndex, point, isLabel, endAnimate, isRemove) {
      var centerX = point.x;
      var centerY = point.y;
      var clipX = series.type !== "Polar" && series.type !== "Radar" ? series.clipRect.x : 0;
      var clipY = series.type !== "Polar" && series.type !== "Radar" ? series.clipRect.y : 0;
      var transform = elements.getAttribute("transform");
      var scaleX = series.marker.width / (series.marker.width + 3);
      var scaleY = series.marker.height / (series.marker.height + 3);
      var scaleValue = Math.min(scaleX, scaleY);
      if (!isRemove) {
        elements.setAttribute("transform", "translate(" + (centerX + clipX) + " " + (centerY + clipY) + ") scale(" + scaleValue + ") translate(" + -centerX + " " + -centerY + ")");
      }
      new Animation({}).animate(elements, {
        duration: durations,
        delay: delays,
        progress: function(args) {
          args.element.style.animation = "";
          if (args.timeStamp > args.delay) {
            if (!series.visible && isRemove) {
              remove(elements);
              return;
            }
            var progress = args.timeStamp / args.duration;
            var currentScale = isRemove ? Math.max(scaleValue, 1 - (1 - scaleValue) * progress) : Math.min(1, scaleValue + (1 - scaleValue) * progress);
            elements.setAttribute("transform", "translate(" + (centerX + clipX) + " " + (centerY + clipY) + ") scale(" + currentScale + ") translate(" + -centerX + " " + -centerY + ")");
          }
        },
        end: function() {
          elements.style.visibility = "";
          elements.setAttribute("transform", transform);
          if (!isLabel && pointIndex === series.points.length - 1) {
            series.chart.trigger("animationComplete", {
              series: series.chart.isBlazor ? {} : series
            });
          }
          if (isRemove || endAnimate) {
            remove(elements);
          }
        }
      });
    };
    MarkerExplode2.prototype.removeHighlightedMarker = function(series, point, fadeOut) {
      if (series === void 0) {
        series = null;
      }
      if (point === void 0) {
        point = null;
      }
      if (fadeOut === void 0) {
        fadeOut = false;
      }
      if (!isNullOrUndefined(series) && !isNullOrUndefined(point)) {
        var markerElement = document.getElementById(this.elementId + "_Series_" + series.index + "_Point_" + point.index + "_Symbol");
        var trackballElements = document.getElementsByClassName(this.elementId + "_EJ2-Trackball_Series_" + series.index + "_Point_" + point.index);
        if (trackballElements.length === 0) {
          var elements = document.querySelectorAll('[class*="' + (this.elementId + "_EJ2-Trackball_Series_" + series.index + "_Point_" + point.index) + '"]');
          if (elements[1]) {
            elements[1].remove();
          }
          if (elements[0]) {
            elements[0].remove();
          }
        }
        for (var i = trackballElements.length - 1; i >= 0; i--) {
          if (!series.marker.visible || trackballElements[i] && trackballElements[i].id[trackballElements[i].id.length - 1] === "0") {
            remove(trackballElements[i]);
          }
        }
        for (var i = trackballElements.length - 1; i >= 0; i--) {
          if (trackballElements[i] && trackballElements[i].id[trackballElements[i].id.length - 1] === "1" && series.type !== "Bubble" && series.type !== "Scatter" && series.marker.visible) {
            trackballElements[i].setAttribute("opacity", markerElement ? markerElement.getAttribute("opacity") : trackballElements[i].getAttribute("opacity"));
            this.trackballAnimate(trackballElements[i], 0, this.animationDuration(), series, point.index, point.symbolLocations[i], null, null, true);
          }
        }
        if (!isNullOrUndefined(markerElement)) {
          markerElement.setAttribute("visibility", "visible");
        }
      } else {
        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
          var point_1 = _a[_i];
          var elements = document.getElementsByClassName(this.elementId + "_EJ2-Trackball_Series_" + series.index + "_Point_" + point_1.index);
          var markerElement = document.getElementById(this.elementId + "_Series_" + series.index + "_Point_" + point_1.index + "_Symbol");
          for (var i = 0, len = elements.length; i < len; i++) {
            if (!isNullOrUndefined(markerElement)) {
              markerElement.setAttribute("visibility", "visible");
            }
            remove(elements[0]);
          }
        }
      }
      if (fadeOut) {
        this.previousPoints = [];
      }
    };
    return MarkerExplode2;
  }(ChartData)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/marker.js
var __extends8 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var markerShapes = ["Circle", "Triangle", "Diamond", "Rectangle", "Pentagon", "InvertedTriangle", "VerticalLine", "Cross", "Plus", "HorizontalLine", "Star"];
var Marker = (
  /** @class */
  function(_super) {
    __extends8(Marker3, _super);
    function Marker3(chart) {
      var _this = _super.call(this, chart) || this;
      _this.addEventListener();
      return _this;
    }
    Marker3.prototype.render = function(series) {
      var _this = this;
      var redraw = series.chart.redraw;
      this.createElement(series, redraw);
      var _loop_1 = function(point2) {
        if (point2.visible && point2.symbolLocations && point2.symbolLocations.length) {
          point2.symbolLocations.map(function(location, index) {
            if (series.marker.shape !== "None") {
              _this.renderMarker(series, point2, location, index, redraw);
            }
          });
        }
      };
      for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
        var point = _a[_i];
        _loop_1(point);
      }
    };
    Marker3.prototype.renderMarker = function(series, point, location, index, redraw) {
      var seriesIndex = series.index === void 0 ? series.category : series.index;
      var marker = series.marker;
      series.marker.shape = series.marker.shape ? series.marker.shape : markerShapes[seriesIndex % 10];
      var border = {
        color: marker.border.color,
        width: marker.border.width
      };
      var borderColor = marker.border.color;
      var previousLocation;
      var previousPath;
      var circlePath;
      var shapeOption;
      location.x = location.x + marker.offset.x;
      location.y = location.y - marker.offset.y;
      var isBoxPlot = series.type === "BoxAndWhisker";
      var fill = marker.fill || (isBoxPlot || series.marker.isFilled ? point.interior || series.interior : "#ffffff");
      var markerElement;
      var parentElement = isBoxPlot && !this.chart.enableCanvas ? findlElement(series.seriesElement.childNodes, "Series_" + series.index + "_Point_" + point.index) : series.symbolElement;
      border.color = borderColor || series.setPointColor(point, series.interior);
      var symbolId = this.elementId + "_Series_" + seriesIndex + "_Point_" + (series.removedPointIndex !== null && series.removedPointIndex <= point.index || this.chart.pointsAdded ? point.index + 1 : point.index) + "_Symbol" + (index ? index : "");
      var argsData = {
        cancel: false,
        name: pointRender,
        series,
        point,
        fill: point.isEmpty ? series.emptyPointSettings.fill || fill : fill,
        border: {
          color: series.type === "BoxAndWhisker" ? !isNullOrUndefined(borderColor) && borderColor !== "transparent" ? borderColor : getSaturationColor(fill, -0.6) : border.color,
          width: border.width
        },
        height: marker.height,
        width: marker.width,
        shape: marker.shape
      };
      argsData.border = series.setBorderColor(point, {
        width: argsData.border.width,
        color: argsData.border.color
      });
      if (!series.isRectSeries || series.type === "BoxAndWhisker") {
        this.chart.trigger(pointRender, argsData);
        point.color = argsData.fill;
      }
      if (!argsData.cancel) {
        var y = void 0;
        if (series.type === "RangeArea" || series.type === "RangeColumn" || series.drawType === "RangeColumn" || series.type === "SplineRangeArea" || series.type === "RangeStepArea") {
          y = index ? point.low : point.high;
        } else if (isBoxPlot) {
          y = point.outliers[index];
        } else {
          y = point.y;
        }
        var markerFill = argsData.point.marker.fill || argsData.fill;
        var markerBorder = void 0;
        if (!isNullOrUndefined(argsData.point.marker.border)) {
          markerBorder = {
            color: argsData.point.marker.border.color || argsData.border.color,
            width: argsData.point.marker.border.width || argsData.border.width
          };
        } else {
          markerBorder = {
            color: argsData.border.color,
            width: argsData.border.width
          };
        }
        var markerWidth = argsData.point.marker.width || argsData.width;
        var markerHeight = argsData.point.marker.height || argsData.height;
        var markerOpacity = argsData.point.marker.opacity || marker.opacity;
        var markerShape = argsData.point.marker.shape || argsData.shape;
        var imageURL = argsData.point.marker.imageUrl || marker.imageUrl;
        shapeOption = new PathOption(symbolId, markerFill, markerBorder.width, markerBorder.color, markerOpacity, series.marker.border.dashArray);
        if (parentElement !== void 0 && parentElement !== null || this.chart.enableCanvas) {
          if (redraw && getElement2(shapeOption.id)) {
            markerElement = getElement2(shapeOption.id);
            circlePath = markerShape === "Circle" ? "c" : "";
            previousLocation = {
              x: +markerElement.getAttribute(circlePath + "x"),
              y: +markerElement.getAttribute(circlePath + "y")
            };
            previousPath = markerElement.getAttribute("d");
          }
          markerElement = drawSymbol(location, markerShape, new Size(markerWidth, markerHeight), imageURL, shapeOption, point.x.toString() + ":" + y.toString(), this.chart.renderer, series.clipRect);
          if (markerElement) {
            markerElement.setAttribute("role", "img");
            if (series.category === "TrendLine" && shapeOption.id === this.elementId + "_Series_0_Point_0_Symbol") {
              markerElement.setAttribute("tabindex", "0");
              markerElement.setAttribute("class", "e-chart-focused");
            }
            markerElement.setAttribute("aria-label", series.accessibility.accessibilityDescriptionFormat ? series.formatAccessibilityDescription(point, series) : point.x + ": " + point.y + ", " + series.name);
          }
          appendChildElement(this.chart.enableCanvas, parentElement, markerElement, redraw, true, circlePath + "x", circlePath + "y", previousLocation, previousPath, false, false, null, series.chart.duration);
          if (series.removedPointIndex !== null && series.removedPointIndex <= point.index) {
            parentElement.lastChild.id = this.elementId + "_Series_" + seriesIndex + "_Point_" + point.index + "_Symbol" + (index ? index : "");
          }
        }
        point.marker = {
          border: markerBorder,
          fill: markerFill,
          height: markerHeight,
          visible: true,
          shape: markerShape,
          width: markerWidth,
          imageUrl: imageURL
        };
      } else {
        location = null;
        point.marker = {
          visible: false
        };
      }
    };
    Marker3.prototype.createElement = function(series, redraw) {
      var markerClipRect;
      var marker = series.marker;
      var explodeValue = marker.border.width + (this.chart.zoomModule && this.chart.zoomModule.isAxisZoomed(this.chart.axisCollections) ? 0 : 8 + 5);
      var render = series.chart.svgRenderer;
      var index = series.index === void 0 ? series.category : series.index;
      var options;
      var transform = series.chart.chartAreaType === "Cartesian" ? "translate(" + series.clipRect.x + "," + series.clipRect.y + ")" : "";
      if (marker.visible) {
        var markerHeight = (marker.height + explodeValue) / 2;
        var markerWidth = (marker.width + explodeValue) / 2;
        if (series.chart.chartAreaType === "Cartesian") {
          options = new RectOption(this.elementId + "_ChartMarkerClipRect_" + index, "transparent", {
            width: 1,
            color: "Gray"
          }, 1, {
            x: -markerWidth,
            y: -markerHeight,
            width: series.clipRect.width + markerWidth * 2,
            height: series.clipRect.height + markerHeight * 2
          }, 0, 0, "", series.marker.border.dashArray);
          markerClipRect = appendClipElement(redraw, options, render);
        } else {
          options = new CircleOption(this.elementId + "_ChartMarkerClipRect_" + index, "transparent", {
            width: 1,
            color: "Gray"
          }, 1, series.clipRect.width / 2 + series.clipRect.x, series.clipRect.height / 2 + series.clipRect.y, series.chart.radius + Math.max(markerHeight, markerWidth));
          markerClipRect = appendClipElement(redraw, options, render, "drawCircularClipPath");
        }
        options = {
          "id": this.elementId + "SymbolGroup" + index,
          "transform": transform,
          "clip-path": "url(#" + this.elementId + "_ChartMarkerClipRect_" + index + ")"
        };
        series.symbolElement = render.createGroup(options);
        series.symbolElement.appendChild(markerClipRect);
        if (this.chart.enableCanvas) {
          var element = document.getElementById(this.chart.element.id + "_tooltip_svg");
          element.appendChild(series.symbolElement);
        }
      }
    };
    Marker3.prototype.getRangeLowPoint = function(region, series) {
      var x = region.x;
      var y = region.y;
      if (series.chart.requireInvertedAxis) {
        y += region.height / 2;
        x += series.yAxis.isAxisInverse ? region.width : 0;
      } else {
        y += series.yAxis.isAxisInverse ? 0 : region.height;
        x += region.width / 2;
      }
      return {
        x,
        y
      };
    };
    Marker3.prototype.calculateDistance = function(startPoint, endPoint) {
      var dx = endPoint.x - startPoint.x;
      var dy = endPoint.y - startPoint.y;
      return Math.sqrt(dx * dx + dy * dy);
    };
    Marker3.prototype.doMarkerAnimation = function(series) {
      if (!(series.type === "Scatter" || series.type === "Bubble" || series.type === "Candle" || series.type === "Hilo" || series.type === "HiloOpenClose" || series.chart.chartAreaType === "PolarRadar" && series.drawType === "Scatter")) {
        var markerElements = series.symbolElement.childNodes;
        var delay = series.animation.delay + (series.animation.duration === 0 && animationMode === "Enable" ? 1e3 : series.animation.duration);
        var duration = series.chart.animated ? series.chart.duration : 200;
        var markerDelay = delay;
        var pathLength = series.pathElement ? series.pathElement.getTotalLength() : 0;
        var distances = [];
        for (var i = 1; series.type === "Line" && i < series.points.length; i++) {
          if (series.points[i - 1].symbolLocations[0] && series.points[i].symbolLocations[0]) {
            var distance = this.calculateDistance(series.points[i - 1].symbolLocations[0], series.points[i].symbolLocations[0]);
            distances.push(distance);
          }
        }
        var j = 1;
        var incFactor = series.type === "RangeArea" || series.type === "RangeColumn" || series.type === "SplineRangeArea" || series.type === "RangeStepArea" ? 2 : 1;
        for (var i = 0; i < series.points.length; i++) {
          if (series.points[i].symbolLocations) {
            if (!series.points[i].symbolLocations.length || !markerElements[j]) {
              continue;
            }
            if (series.type === "Line") {
              if (i === 0) {
                markerDelay = 0;
              }
              if (i > 0) {
                markerDelay += distances[i - 1] / pathLength * delay;
                duration = 0;
              }
            }
            markerAnimate(markerElements[j], markerDelay, duration, series, i, series.points[i].symbolLocations[0], false);
            if (incFactor === 2) {
              var lowPoint = this.getRangeLowPoint(series.points[i].regions[0], series);
              markerAnimate(markerElements[j + 1], markerDelay, duration, series, i, lowPoint, false);
            }
            j += incFactor;
          }
        }
      }
    };
    return Marker3;
  }(MarkerExplode)
);

// node_modules/@syncfusion/ej2-charts/src/common/legend/legend.js
var __extends9 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate6 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var LegendSettings = (
  /** @class */
  function(_super) {
    __extends9(LegendSettings2, _super);
    function LegendSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate6([Property(true)], LegendSettings2.prototype, "visible", void 0);
    __decorate6([Property(null)], LegendSettings2.prototype, "height", void 0);
    __decorate6([Property(null)], LegendSettings2.prototype, "width", void 0);
    __decorate6([Complex({
      x: 0,
      y: 0
    }, Location)], LegendSettings2.prototype, "location", void 0);
    __decorate6([Property("Auto")], LegendSettings2.prototype, "position", void 0);
    __decorate6([Property("Series")], LegendSettings2.prototype, "mode", void 0);
    __decorate6([Property(8)], LegendSettings2.prototype, "padding", void 0);
    __decorate6([Property(null)], LegendSettings2.prototype, "itemPadding", void 0);
    __decorate6([Property("Center")], LegendSettings2.prototype, "alignment", void 0);
    __decorate6([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, Font)], LegendSettings2.prototype, "textStyle", void 0);
    __decorate6([Property(10)], LegendSettings2.prototype, "shapeHeight", void 0);
    __decorate6([Property(10)], LegendSettings2.prototype, "shapeWidth", void 0);
    __decorate6([Complex({}, Border)], LegendSettings2.prototype, "border", void 0);
    __decorate6([Complex({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, Margin)], LegendSettings2.prototype, "margin", void 0);
    __decorate6([Complex({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, ContainerPadding)], LegendSettings2.prototype, "containerPadding", void 0);
    __decorate6([Property(8)], LegendSettings2.prototype, "shapePadding", void 0);
    __decorate6([Property("transparent")], LegendSettings2.prototype, "background", void 0);
    __decorate6([Property(1)], LegendSettings2.prototype, "opacity", void 0);
    __decorate6([Property(true)], LegendSettings2.prototype, "toggleVisibility", void 0);
    __decorate6([Property(false)], LegendSettings2.prototype, "enableHighlight", void 0);
    __decorate6([Property(null)], LegendSettings2.prototype, "description", void 0);
    __decorate6([Property(3)], LegendSettings2.prototype, "tabIndex", void 0);
    __decorate6([Property(null)], LegendSettings2.prototype, "title", void 0);
    __decorate6([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, Font)], LegendSettings2.prototype, "titleStyle", void 0);
    __decorate6([Property("Top")], LegendSettings2.prototype, "titlePosition", void 0);
    __decorate6([Property("Normal")], LegendSettings2.prototype, "textWrap", void 0);
    __decorate6([Property("Ellipsis")], LegendSettings2.prototype, "textOverflow", void 0);
    __decorate6([Property(100)], LegendSettings2.prototype, "maximumTitleWidth", void 0);
    __decorate6([Property(null)], LegendSettings2.prototype, "maximumLabelWidth", void 0);
    __decorate6([Property(true)], LegendSettings2.prototype, "enablePages", void 0);
    __decorate6([Property(false)], LegendSettings2.prototype, "isInversed", void 0);
    __decorate6([Property(false)], LegendSettings2.prototype, "reverse", void 0);
    __decorate6([Property("Auto")], LegendSettings2.prototype, "layout", void 0);
    __decorate6([Property(null)], LegendSettings2.prototype, "maximumColumns", void 0);
    __decorate6([Property(false)], LegendSettings2.prototype, "fixedWidth", void 0);
    __decorate6([Complex({}, Accessibility)], LegendSettings2.prototype, "accessibility", void 0);
    return LegendSettings2;
  }(ChildProperty)
);
var BaseLegend = (
  /** @class */
  function() {
    function BaseLegend2(chart) {
      this.maxItemHeight = 0;
      this.rowHeights = [];
      this.pageHeights = [];
      this.columnHeights = [];
      this.pageXCollections = [];
      this.chartRowCount = 1;
      this.legendTitleCollections = [];
      this.legendRegions = [];
      this.pagingRegions = [];
      this.chart = chart;
      this.legend = chart.legendSettings;
      this.legendID = chart.element.id + "_chart_legend";
      this.isChartControl = chart.getModuleName() === "chart" || chart.getModuleName() === "chart3d";
      this.isAccChartControl = chart.getModuleName() === "accumulationchart" || chart.getModuleName() === "circularchart3d";
      this.isBulletChartControl = chart.getModuleName() === "bulletChart";
      this.isStockChartControl = chart.getModuleName() === "stockChart";
      this.bulletChart = this.chart;
      this.fivePixel = 5;
      this.rowCount = 0;
      this.pageButtonSize = 8;
      this.maxColumns = 0;
      this.maxWidth = 0;
      this.currentPage = 1;
      this.backwardArrowOpacity = 0;
      this.forwardArrowOpacity = 1;
      this.arrowWidth = 2 * (this.fivePixel + this.pageButtonSize + this.fivePixel);
      this.arrowHeight = this.arrowWidth;
      this.isTop = false;
      this.isTitle = false;
      this.currentPageNumber = 1;
    }
    BaseLegend2.prototype.calculateLegendBounds = function(rect, availableSize, maxLabelSize, previousLegendBounds, pointAnimation) {
      var legend = this.legend;
      var defaultValue = this.isBulletChartControl || (this.chart.getModuleName() === "accumulationchart" || this.chart.getModuleName() === "chart") && (this.legend.layout !== "Auto" || this.legend.maximumColumns > 0) ? "40%" : "20%";
      this.getPosition(legend.position, availableSize);
      this.legendBounds = new Rect(rect.x, rect.y, 0, 0);
      this.isVertical = this.position === "Left" || this.position === "Right";
      this.itemPadding = this.legend.itemPadding ? this.legend.itemPadding : this.isVertical ? 8 : 20;
      if (this.isVertical) {
        this.legendBounds.height = stringToNumber(legend.height, availableSize.height - (rect.y - this.chart.margin.top)) || rect.height;
        this.legendBounds.width = stringToNumber(legend.width || defaultValue, availableSize.width);
      } else {
        this.legendBounds.width = stringToNumber(legend.width, availableSize.width) || rect.width;
        this.legendBounds.height = stringToNumber(legend.height || defaultValue, availableSize.height);
      }
      if (this.chart.getModuleName() === "chart3d") {
        this.library.get3DLegendBounds(availableSize, this.legendBounds, legend);
      } else {
        this.library.getLegendBounds(availableSize, this.legendBounds, legend);
      }
      if (!this.isBulletChartControl) {
        this.legendBounds.width += this.legend.containerPadding.left + this.legend.containerPadding.right;
        this.legendBounds.height += this.legend.containerPadding.top + this.legend.containerPadding.bottom;
      }
      this.getLocation(this.position, legend.alignment, this.legendBounds, rect, availableSize, maxLabelSize, previousLegendBounds, pointAnimation);
    };
    BaseLegend2.prototype.getPosition = function(position, availableSize) {
      var chart = this.chart;
      var accumulation = this.chart;
      if (this.isChartControl || this.isBulletChartControl || this.isStockChartControl) {
        this.position = position !== "Auto" ? position : "Bottom";
      } else {
        if (position === "Auto" && ((chart || accumulation).visibleSeries && (chart || accumulation).visibleSeries[0].type === "Funnel" || (chart || accumulation).visibleSeries[0].type === "Pyramid")) {
          position = "Top";
        }
        this.position = position !== "Auto" ? position : availableSize.width > availableSize.height ? "Right" : "Bottom";
      }
    };
    BaseLegend2.prototype.setBounds = function(computedWidth, computedHeight, legend, legendBounds) {
      var titleHeight = legend.title && legend.titlePosition === "Top" ? this.legendTitleSize.height + this.fivePixel : 0;
      if (this.isVertical && this.isPaging && !legend.enablePages && !this.isBulletChartControl) {
        titleHeight = legend.title && legend.titlePosition === "Top" ? this.legendTitleSize.height + this.fivePixel : 0;
        titleHeight += this.pageButtonSize + this.fivePixel;
      }
      computedWidth = Math.min(computedWidth, legendBounds.width);
      computedHeight = Math.min(computedHeight, legendBounds.height);
      if (legend.mode === "Gradient") {
        legendBounds.width = legend.width ? legendBounds.width : this.isVertical ? computedWidth : 0.75 * legendBounds.width;
        legendBounds.height = legend.height ? legendBounds.height : this.isVertical ? 0.75 * legendBounds.height : computedHeight;
      } else {
        legendBounds.width = !legend.width ? computedWidth : legendBounds.width;
        legendBounds.height = !legend.height ? computedHeight : legendBounds.height;
      }
      if (!this.isBulletChartControl) {
        if (this.isTop && legend.titleStyle.textOverflow !== "None") {
          this.calculateLegendTitle(legend, legendBounds);
          legendBounds.height += legend.titleStyle.textOverflow === "Wrap" && this.legendTitleCollections.length > 1 ? this.legendTitleSize.height - this.legendTitleSize.height / this.legendTitleCollections.length : 0;
        }
      }
      this.rowCount = Math.max(1, Math.ceil((legendBounds.height - legend.padding - titleHeight) / (this.maxItemHeight + legend.padding)));
    };
    BaseLegend2.prototype.getLocation = function(position, alignment, legendBounds, rect, availableSize, maxLabelSize, previousLegendBounds, pointAnimation) {
      var padding = this.legend.border.width;
      var isBulletChart = this.isBulletChartControl;
      var bulletChart = this.bulletChart;
      var labelIns = bulletChart.labelPosition === "Inside";
      var ticklIns = bulletChart.tickPosition === "Inside";
      var isVertical = bulletChart.orientation === "Vertical";
      var categoryFieldValue = isBulletChart && bulletChart.categoryField !== "" ? maxLabelSize.width + this.chart.border.width + padding * 3 : 0;
      var marginBottom = this.chart.margin.bottom;
      var legendHeight = legendBounds.height + padding + this.legend.margin.top + this.legend.margin.bottom;
      var legendWidth = legendBounds.width + padding + this.legend.margin.left + this.legend.margin.right;
      if (position === "Bottom") {
        legendBounds.x = this.alignLegend(legendBounds.x, availableSize.width, legendBounds.width, alignment);
        legendBounds.y = previousLegendBounds && (legendBounds.height === previousLegendBounds.height || this.chart.series[0].type !== "Pie") ? previousLegendBounds.y : rect.y + (rect.height - legendHeight) + padding + this.legend.margin.top;
        legendBounds.y += isBulletChart && !bulletChart.opposedPosition && !labelIns && !ticklIns && !isVertical ? bulletChart.majorTickLines.height + marginBottom + this.legend.border.width + padding * 2 : isVertical && bulletChart.categoryField !== "" ? maxLabelSize.height + padding * 2 : 0;
        if (!pointAnimation || legendBounds.height !== previousLegendBounds.height) {
          {
            subtractThickness(rect, new Thickness(0, 0, 0, legendHeight));
          }
        }
      } else if (position === "Top") {
        var axisTextSize = void 0;
        if (this.isChartControl) {
          axisTextSize = measureText("100", this.chart.verticalAxes[0].labelStyle, this.chart.themeStyle.legendLabelFont);
        }
        legendBounds.x = this.alignLegend(legendBounds.x, availableSize.width, legendBounds.width, alignment);
        legendBounds.y = previousLegendBounds && (legendBounds.height === previousLegendBounds.height || this.chart.series[0].type !== "Pie") ? previousLegendBounds.y : rect.y + padding + this.legend.margin.top;
        legendBounds.y -= isBulletChart && bulletChart.opposedPosition && !labelIns && !ticklIns && !isVertical ? bulletChart.majorTickLines.height + this.chart.margin.top : 0;
        legendHeight -= isBulletChart ? -padding * 2 : this.isChartControl ? -padding * 2 - axisTextSize.height / 2 : 0;
        if (!pointAnimation || legendBounds.height !== previousLegendBounds.height) {
          subtractThickness(rect, new Thickness(0, 0, legendHeight, 0));
        }
      } else if (position === "Right") {
        legendBounds.x = previousLegendBounds && (legendBounds.width === previousLegendBounds.width || this.chart.series[0].type !== "Pie") ? previousLegendBounds.x : rect.x + (rect.width - legendBounds.width) - this.legend.margin.right;
        legendBounds.y = rect.y + this.alignLegend(0, availableSize.height - (rect.y + marginBottom), legendBounds.height, alignment);
        legendWidth += isBulletChart && bulletChart.opposedPosition && !labelIns && !ticklIns && isVertical ? this.chart.margin.left + this.chart.margin.right + bulletChart.majorTickLines.height : 0;
        if (!pointAnimation || legendBounds.width !== previousLegendBounds.width) {
          subtractThickness(rect, new Thickness(0, legendWidth, 0, 0));
        }
      } else if (position === "Left") {
        legendBounds.x = previousLegendBounds && (legendBounds.width === previousLegendBounds.width || this.chart.series[0].type !== "Pie") ? previousLegendBounds.x : legendBounds.x + this.legend.margin.left;
        legendBounds.y = rect.y + this.alignLegend(0, availableSize.height - (rect.y + marginBottom), legendBounds.height, alignment);
        legendWidth += isBulletChart && !bulletChart.opposedPosition && !labelIns && !ticklIns && isVertical ? legendBounds.x - this.chart.margin.left + padding + bulletChart.majorTickLines.height : bulletChart.orientation !== "Vertical" && bulletChart.categoryField !== "" ? categoryFieldValue : 0;
        if (!pointAnimation || legendBounds.width !== previousLegendBounds.width) {
          subtractThickness(rect, new Thickness(legendWidth, 0, 0, 0));
        }
      } else {
        legendBounds.x = this.legend.location.x;
        legendBounds.y = this.legend.location.y;
        subtractThickness(rect, new Thickness(0, 0, 0, 0));
      }
    };
    BaseLegend2.prototype.alignLegend = function(start, size, legendSize, alignment) {
      switch (alignment) {
        case "Far":
          start = size - legendSize - start;
          break;
        case "Center":
          start = (size - legendSize) / 2;
          break;
      }
      return start;
    };
    BaseLegend2.prototype.renderLegend = function(chart, legend, legendBounds, redraw, pointAnimation) {
      var titleHeight = 0;
      var titlePlusArrowWidth = 0;
      var pagingLegendBounds = new Rect(0, 0, 0, 0);
      var requireLegendBounds = new Rect(0, 0, 0, 0);
      var xValue;
      var yValue;
      if (pointAnimation) {
        xValue = getElement2(this.legendID + "_element").getAttribute("x");
        yValue = getElement2(this.legendID + "_element").getAttribute("y");
      }
      var firstLegend = this.findFirstLegendPosition(this.legendCollections);
      var padding = legend.padding;
      this.itemPadding = this.isBulletChartControl ? legend.padding : this.itemPadding;
      var isPaging = legend.enablePages;
      var titlePosition = legend.titlePosition;
      var upArrowHeight = this.isPaging && !legend.enablePages && this.isVertical && (chart.getModuleName() !== "accumulationchart" && chart.getModuleName() !== "chart" || this.legend.layout === "Auto") ? this.pageButtonSize : 0;
      var legendGroup = chart.renderer.createGroup({
        id: this.legendID + "_g"
      });
      var legendTranslateGroup = this.createLegendElements(chart, legendBounds, legendGroup, legend, this.legendID, redraw);
      this.legendRegions = [];
      this.chartRowCount = 1;
      var maxHeight = 0;
      titleHeight = !this.isTitle ? 0 : this.isTop || this.isVertical ? this.legendTitleSize.height : 0;
      if (this.isChartControl || this.isAccChartControl && (!this.isVertical || legend.layout && legend.layout !== "Auto")) {
        var pageCount = 1;
        var rowHeights = this.rowHeights[0] + (this.isVertical || this.rowHeights.length > 1 && this.legend.itemPadding && this.chart.getModuleName() === "chart" ? this.itemPadding : padding);
        for (var i = 1; i < this.rowHeights.length; i++) {
          if (rowHeights + this.rowHeights[i] + ((this.isVertical || this.rowHeights.length > 1 && this.chart.getModuleName() === "chart") && this.legend.itemPadding ? this.itemPadding : padding) > this.legendBounds.height - this.pageButtonSize - this.maxItemHeight / 2 - this.legend.containerPadding.top - this.legend.containerPadding.bottom) {
            this.pageHeights[pageCount - 1] = rowHeights + titleHeight;
            pageCount++;
            rowHeights = 0;
          }
          rowHeights += this.rowHeights[i] + (this.isVertical || this.rowHeights.length > 1 && this.legend.itemPadding && this.chart.getModuleName() === "chart" ? this.itemPadding : padding);
        }
        this.pageHeights[pageCount - 1] = rowHeights + titleHeight;
        this.totalPages = pageCount;
      }
      for (var i = 0; i < this.legendCollections.length; i++) {
        if (this.legendCollections[i].text !== "") {
          maxHeight = Math.max(this.legendCollections[i].textSize.height, maxHeight);
          break;
        } else {
          continue;
        }
      }
      if (!this.isChartControl && !this.isAccChartControl) {
        this.maxItemHeight = Math.max(maxHeight, legend.shapeHeight);
      }
      if (!isPaging && this.isPaging && !this.isVertical) {
        titlePlusArrowWidth = !this.isTitle ? 0 : titlePosition === "Left" ? this.legendTitleSize.width : 0;
        titlePlusArrowWidth += this.pageButtonSize + 2 * this.fivePixel;
      } else if (this.isTitle && !this.isVertical) {
        titlePlusArrowWidth = titlePosition === (!this.isRtlEnable ? "Left" : "Right") ? this.fivePixel + this.legendTitleSize.width : 0;
      }
      if (chart.legendSettings.mode === "Gradient" && this.legendCollections.length > 1) {
        this.getLinearLegend(legendBounds, chart, legend, legendTranslateGroup);
        this.totalPages = 1;
      } else if (firstLegend !== this.legendCollections.length) {
        var legendSeriesGroup = void 0;
        var count = 0;
        var previousLegend = this.legendCollections[firstLegend];
        var startPadding = this.isBulletChartControl ? padding : titlePlusArrowWidth + padding + legend.shapeWidth / 2 + legend.containerPadding.left;
        var xLocation = this.isBulletChartControl && !this.isRtlEnable ? legendBounds.x + titlePlusArrowWidth + padding + legend.shapeWidth / 2 : !this.isRtlEnable ? legendBounds.x + startPadding : legendBounds.x + (this.chart.getModuleName() === "accumulationchart" && this.isVertical && legend.layout === "Auto" && !(legend.maximumColumns > 0) ? this.maxWidth : legendBounds.width) - startPadding;
        var start = new ChartLocation(xLocation, this.isBulletChartControl ? legendBounds.y + titleHeight + upArrowHeight + padding + this.maxItemHeight / 2 : legendBounds.y + titleHeight + upArrowHeight + padding + this.maxItemHeight / 2 + legend.containerPadding.top);
        var anchor = chart.isRtlEnabled || chart.enableRtl ? "end" : "start";
        var textOptions = new TextOption("", start.x, start.y, anchor);
        var textPadding = legend.shapePadding + this.itemPadding + legend.shapeWidth;
        this.totalPages = this.totalPages = this.isAccChartControl || this.isChartControl || this.isBulletChartControl || this.isStockChartControl ? this.totalPages : 0;
        this.pageXCollections = [];
        this.legendCollections[firstLegend].location = start;
        var legendIndex = void 0;
        if (!legend.enablePages && this.isPaging) {
          var x = start.x - this.fivePixel;
          var y = start.y - this.fivePixel;
          var leftSpace = this.isTitle && !this.isVertical && titlePosition === "Left" ? this.legendTitleSize.width + this.fivePixel : 0;
          var bottomSapce = this.isVertical ? this.pageButtonSize + Math.abs(y - legendBounds.y) : 0;
          var rightSpace = this.isTitle && !this.isVertical && titlePosition === "Right" ? this.legendTitleSize.width + this.fivePixel : 0;
          rightSpace += this.isVertical ? 0 : this.fivePixel + this.pageButtonSize + this.fivePixel;
          pagingLegendBounds = new Rect(x, y, legendBounds.width - rightSpace - leftSpace, legendBounds.height - bottomSapce);
          requireLegendBounds = pagingLegendBounds;
        } else {
          requireLegendBounds = legendBounds;
        }
        var legendOption = void 0;
        for (var i = 0; i < this.legendCollections.length; i++) {
          legendOption = this.legendCollections[i];
          legendIndex = !this.isReverse ? count : this.legendCollections.length - 1 - count;
          if (this.chart.getModuleName() === "accumulationchart") {
            legendOption.fill = (this.chart || this.chart || this.chart || this.chart).visibleSeries[0].points[legendOption.pointIndex].color;
          }
          if (this.chart.getModuleName() === "stockChart") {
            legendOption.type = this.chart.visibleSeries[count].type;
          }
          this.accessbilityText = this.isBulletChartControl ? "Legend of bullet chart" + legendOption.text : "Click to show or hide the " + legendOption.text + " series";
          if (legendOption.render && legendOption.text && legendOption.text !== "") {
            legendSeriesGroup = chart.renderer.createGroup({
              id: this.legendID + this.generateId(legendOption, "_g_", legendIndex)
            });
            if (legendSeriesGroup && (this.chart.getModuleName() === "chart" || this.chart.getModuleName() === "accumulationchart")) {
              legendSeriesGroup.setAttribute("tabindex", i === 0 && legend.accessibility.focusable ? String(legend.accessibility.tabIndex) : "");
              legendSeriesGroup.style.outline = "none";
              legendSeriesGroup.setAttribute("aria-label", legend.accessibility.accessibilityDescription ? legend.accessibility.accessibilityDescription : legendOption.text + " series is " + (legendOption.visible ? "showing, press enter to hide the " : "hidden, press enter to show the ") + legendOption.text + " series");
              legendSeriesGroup.setAttribute("role", legend.accessibility.accessibilityRole ? legend.accessibility.accessibilityRole : "button");
              legendSeriesGroup.setAttribute("aria-pressed", legendOption.visible ? "true" : "false");
            } else if (legendSeriesGroup) {
              legendSeriesGroup.setAttribute("tabindex", i === 0 ? "0" : "");
              legendSeriesGroup.style.outline = "none";
              legendSeriesGroup.setAttribute("aria-label", legend.description || legendOption.text + " series is " + (legendOption.visible ? "showing, press enter to hide the " : "hidden, press enter to show the ") + legendOption.text + " series");
              legendSeriesGroup.setAttribute("role", "button");
              legendSeriesGroup.setAttribute("aria-pressed", legendOption.visible ? "true" : "false");
            }
            this.library.getRenderPoint(legendOption, start, textPadding, previousLegend, requireLegendBounds, count, firstLegend);
            this.renderSymbol(legendOption, legendSeriesGroup, legendIndex);
            this.renderText(chart, legendOption, legendSeriesGroup, textOptions, count, legendIndex);
            if (legendSeriesGroup) {
              legendSeriesGroup.style.cssText = "pointer-events: bounding-box; cursor: " + (!legend.toggleVisibility && (chart.selectionMode === "None" || chart.highlightMode === "None" || chart.selectionMode === "None") || this.isBulletChartControl ? "auto" : "pointer");
            }
            if (legendTranslateGroup) {
              legendTranslateGroup.appendChild(legendSeriesGroup);
            }
            previousLegend = legendOption;
          }
          count++;
        }
        this.totalPages = this.isPaging && !this.isBulletChartControl && !this.legend.enablePages && !this.isVertical && this.totalPages > this.chartRowCount ? this.chartRowCount : this.totalPages;
        this.currentPage = this.currentPage > 1 && this.currentPage > this.totalPages ? this.totalPages : this.currentPage;
        if (this.isPaging && this.totalPages > 1) {
          this.renderPagingElements(chart, legendBounds, textOptions, legendGroup);
        } else {
          this.totalPages = 1;
        }
      }
      if (pointAnimation) {
        var translateX = "translate(" + (this.rowCount > 1 ? 0 : Math.round(Number(xValue)) - Math.round(this.legendBounds.x)) + " \n              + ',' + " + (Math.round(Number(yValue)) - Math.round(this.legendBounds.y)) + ")";
        var translateY = "translate(" + (Math.round(Number(xValue)) - Math.round(this.legendBounds.x)) + ", " + (Math.round(Number(yValue)) - Math.round(this.legendBounds.y)) + ")";
        appendChildElement(chart.enableCanvas, chart.svgObject, legendGroup, redraw, true, "x", "y", void 0, void 0, void 0, void 0, void 0, chart.duration, void 0, void 0, new ChartLocation(0, 0), this.position === "Top" || this.position === "Bottom" ? translateX : translateY);
      } else {
        appendChildElement(chart.enableCanvas, chart.svgObject, legendGroup, redraw);
      }
    };
    BaseLegend2.prototype.getLinearLegend = function(legendBounds, chart, legend, legendTranslateGroup) {
      var xmlns = "http://www.w3.org/2000/svg";
      var previousLegend = this.legendCollections[0];
      var nextLegend = this.legendCollections[1];
      var defElement = this.chart.renderer.createDefs();
      var gradientLegendCount = 0;
      var linerGradientEle = document.createElementNS(xmlns, "linearGradient");
      var opacity = 1;
      var fillColors = [];
      var numberItems = [];
      if (legend.title) {
        if (!this.isVertical) {
          if (legend.titlePosition === "Left") {
            legendBounds.x += this.legendTitleSize.width;
            legendBounds.width -= this.legendTitleSize.width;
          } else if (legend.titlePosition === "Right") {
            legendBounds.width -= this.legendTitleSize.width;
          } else if (legend.titlePosition === "Top") {
            legendBounds.y += this.legendTitleSize.height;
            legendBounds.height -= this.legendTitleSize.height;
          }
        } else {
          legendBounds.y += this.legendTitleSize.height;
          legendBounds.height -= this.legendTitleSize.height;
        }
      }
      for (var _i = 0, _a = this.chart.rangeColorSettings; _i < _a.length; _i++) {
        var colorMap = _a[_i];
        if (numberItems.indexOf(colorMap.start) < 0) {
          numberItems.push(colorMap.start);
        }
        if (colorMap.colors.length > 2) {
          var diffValue = colorMap.end - colorMap.start;
          var colorsLength = colorMap.colors.length - 1;
          if (diffValue > 0) {
            diffValue = diffValue / colorsLength;
            for (var index = 1; index < colorsLength; index++) {
              var calculatedValue = colorMap.start + diffValue * index;
              numberItems.push(calculatedValue);
            }
          } else {
            for (var index = 1; index < colorsLength; index++) {
              numberItems.push(colorMap.start);
            }
          }
        }
        if (numberItems.indexOf(colorMap.end) < 0) {
          numberItems.push(colorMap.end);
        }
        for (var _b = 0, _c = colorMap.colors; _b < _c.length; _b++) {
          var fillColor = _c[_b];
          if (fillColors.indexOf(fillColor) < 0) {
            fillColors.push(fillColor);
          }
        }
        if (colorMap.colors.length > 0 && colorMap.colors.length < 2) {
          fillColors.push(colorMap.colors[0]);
        }
      }
      var x1 = this.isRtlEnable && !this.isVertical ? "100%" : "0%";
      var x2 = this.isVertical || this.isRtlEnable ? "0%" : "100%";
      var y2 = this.isVertical ? "100%" : "0%";
      linerGradientEle.setAttribute("id", this.generateId(previousLegend, "linearGradient", gradientLegendCount));
      linerGradientEle.setAttribute("x1", x1);
      linerGradientEle.setAttribute("y1", "0%");
      linerGradientEle.setAttribute("x2", x2);
      linerGradientEle.setAttribute("y2", y2);
      var full = numberItems[numberItems.length - 1] - numberItems[0];
      for (var b = 0; b < fillColors.length; b++) {
        var offsetValue = numberItems[b] - numberItems[0];
        offsetValue = offsetValue / full;
        var stopEle = document.createElementNS(xmlns, "stop");
        stopEle.setAttribute("offset", offsetValue.toString());
        stopEle.setAttribute("stop-color", fillColors[b]);
        stopEle.setAttribute("stop-opacity", opacity.toString());
        linerGradientEle.appendChild(stopEle);
      }
      var startLabel = previousLegend.text.toString();
      var endLabel = nextLegend.text.toString();
      var startTextSize = measureText(startLabel, legend.textStyle, this.chart.themeStyle.legendLabelFont);
      var endTextSize = measureText(endLabel, legend.textStyle, this.chart.themeStyle.legendLabelFont);
      var textWidth = startTextSize.width > endTextSize.width ? startTextSize.width : endTextSize.width;
      var textHeight = startTextSize.height > endTextSize.height ? startTextSize.height : endTextSize.height;
      var otherSpaces = 2 * textWidth + 4 * legend.padding;
      var linearBarWidth = legendBounds.width;
      var linearBarHeight = legendBounds.height;
      var xValue = legendBounds.x + textWidth + 2 * legend.padding;
      var yValue = legendBounds.y + legend.padding;
      var startLabelY;
      var endLabelY;
      var startLabelX;
      var endLabelX;
      if (this.isVertical) {
        otherSpaces = 2 * textHeight + 4 * legend.padding;
        linearBarWidth = legendBounds.width - 2 * legend.padding;
        linearBarHeight = legendBounds.height - otherSpaces;
        xValue = legendBounds.x + legend.padding;
        yValue = legendBounds.y + textHeight + 2 * legend.padding;
        startLabelY = legendBounds.y + legend.padding + textHeight;
        endLabelY = yValue + linearBarHeight + textHeight;
        startLabelX = legendBounds.x + legendBounds.width * 0.5 - textWidth * 0.5;
        endLabelX = startLabelX;
        if (linearBarWidth > 30) {
          var diffWidth = linearBarWidth - 30;
          linearBarWidth = 30;
          xValue = xValue + diffWidth / 2;
        }
      } else {
        linearBarWidth = legendBounds.width - otherSpaces;
        linearBarHeight = legendBounds.height - 2 * legend.padding;
        startLabelX = legendBounds.x + (!this.isRtlEnable ? legend.padding + (textWidth - startTextSize.width) : linearBarWidth + 3 * legend.padding + textWidth);
        endLabelX = legendBounds.x + (!this.isRtlEnable ? linearBarWidth + 3 * legend.padding + textWidth : legend.padding + (textWidth - endTextSize.width));
        startLabelY = legendBounds.y + legendBounds.height * 0.5 + textHeight * 0.25;
        endLabelY = startLabelY;
        if (linearBarHeight > 30) {
          var diffHeight = linearBarHeight - 30;
          linearBarHeight = 30;
          yValue = yValue + diffHeight / 2;
        }
      }
      var anchor = chart.enableRtl ? "end" : "";
      var textOptions = new TextOption("", startLabelX, startLabelY, anchor, startLabel);
      var hiddenColor = "#D3D3D3";
      textOptions.id = this.legendID + this.generateId(previousLegend, "_text_", 1);
      var fontcolor = previousLegend.visible ? legend.textStyle.color || chart.themeStyle.legendLabelFont.color : hiddenColor;
      var isCanvas = this.isStockChartControl ? false : this.chart.enableCanvas;
      textElement2(chart.renderer, textOptions, legend.textStyle, fontcolor, legendTranslateGroup, false, false, false, false, null, this.currentPageNumber && isCanvas ? new Rect(0, -this.translatePage(isCanvas, null, this.currentPageNumber - 1, this.currentPageNumber), 0, 0) : null, null, null, null, null, this.chart.themeStyle.legendLabelFont);
      textOptions = new TextOption("", endLabelX, endLabelY, anchor, endLabel);
      textOptions.id = this.legendID + this.generateId(previousLegend, "_text_", 2);
      textElement2(chart.renderer, textOptions, legend.textStyle, fontcolor, legendTranslateGroup, false, false, false, false, null, this.currentPageNumber && isCanvas ? new Rect(0, -this.translatePage(isCanvas, null, this.currentPageNumber - 1, this.currentPageNumber), 0, 0) : null, null, null, null, null, this.chart.themeStyle.legendLabelFont);
      var gradientLegend = chart.renderer.drawRectangle({
        width: linearBarWidth,
        height: linearBarHeight,
        x: xValue,
        y: yValue,
        fill: "url(#" + this.generateId(previousLegend, "linearGradient", gradientLegendCount) + ")"
      });
      defElement.appendChild(linerGradientEle);
      legendTranslateGroup.appendChild(defElement);
      legendTranslateGroup.appendChild(gradientLegend);
    };
    BaseLegend2.prototype.findFirstLegendPosition = function(legendCollection) {
      var count = 0;
      for (var _i = 0, legendCollection_1 = legendCollection; _i < legendCollection_1.length; _i++) {
        var legend = legendCollection_1[_i];
        if (legend.render && legend.text && legend.text !== "") {
          break;
        }
        count++;
      }
      return count;
    };
    BaseLegend2.prototype.calculateLegendTitle = function(legend, legendBounds) {
      if (legend.title) {
        this.isTop = legend.titlePosition === "Top";
        var padding = legend.titleStyle.textOverflow === "Trim" ? 2 * legend.padding : 0;
        if (this.isTop || this.isVertical) {
          this.legendTitleCollections = getTitle(legend.title, legend.titleStyle, legendBounds.width - padding, this.chart.enableRtl, this.chart.themeStyle.legendTitleFont);
        } else {
          this.legendTitleCollections[0] = textTrim(legend.maximumTitleWidth, legend.title, legend.titleStyle, this.chart.enableRtl, this.chart.themeStyle.legendTitleFont);
        }
        var text = this.isTop ? legend.title : this.legendTitleCollections[0];
        this.legendTitleSize = measureText(text, legend.titleStyle, this.chart.themeStyle.legendTitleFont);
        this.legendTitleSize.height *= this.legendTitleCollections.length;
      } else {
        this.legendTitleSize = new Size(0, 0);
      }
    };
    BaseLegend2.prototype.renderLegendTitle = function(chart, legend, legendBounds, legendGroup) {
      var padding = legend.padding;
      var alignment = legend.titleStyle.textAlignment;
      this.isTop = legend.titlePosition === "Top";
      var anchor = getTextAnchor(legend.titleStyle.textAlignment, chart.enableRtl);
      var x = titlePositionX(legendBounds, legend.titleStyle);
      anchor = this.isTop || this.isVertical ? anchor : chart.enableRtl ? "end" : "";
      x = alignment === "Near" ? x + padding : alignment === "Far" ? x - padding : x;
      x = this.isTop || this.isVertical ? x : legendBounds.x + (legend.titlePosition === "Left" ? 5 : legendBounds.width - this.legendTitleSize.width - 5);
      var topPadding = legendBounds.height / 2 + this.legendTitleSize.height / 4;
      var y = legendBounds.y + (!this.isTop && !this.isVertical ? topPadding : this.legendTitleSize.height / this.legendTitleCollections.length);
      var legendTitleTextOptions = new TextOption(this.legendID + "_title", x, y, anchor, this.legendTitleCollections);
      textElement2(chart.renderer, legendTitleTextOptions, legend.titleStyle, legend.titleStyle.color || this.chart.themeStyle.legendTitleFont.color, legendGroup, null, null, null, null, null, null, null, null, null, null, this.chart.themeStyle.legendTitleFont);
    };
    BaseLegend2.prototype.createLegendElements = function(chart, legendBounds, legendGroup, legend, id, redraw) {
      var padding = legend.padding;
      var options = new RectOption(id + "_element", legend.background, legend.border, legend.opacity, legendBounds, 0, 0, "", this.legend.border.dashArray);
      var legendItemsGroup = chart.renderer.createGroup({
        id: id + "_collections"
      });
      var isCanvas = this.isStockChartControl ? false : chart.enableCanvas;
      var clippath = chart.renderer.createClipPath({
        id: id + "_clipPath"
      });
      options.width = this.isRtlEnable && this.chart.getModuleName() === "accumulationchart" && this.isVertical && legend.layout === "Auto" && !(legend.maximumColumns > 0) ? this.maxWidth : legendBounds.width;
      if (legendGroup) {
        legendGroup.appendChild(chart.renderer.drawRectangle(options));
      } else {
        chart.renderer.drawRectangle(options);
      }
      if (legend.title) {
        this.renderLegendTitle(chart, legend, legendBounds, legendGroup);
      }
      if (!isCanvas) {
        legendGroup.appendChild(legendItemsGroup);
      }
      this.legendTranslateGroup = chart.renderer.createGroup({
        id: id + "_translate_g"
      });
      if (!isCanvas) {
        legendItemsGroup.appendChild(this.legendTranslateGroup);
      }
      options.y += (this.isTop ? this.legendTitleSize.height : 0) + (!this.isBulletChartControl ? legend.containerPadding.top : 0);
      options.height -= (this.isTop && (this.isChartControl || !this.isVertical || legend.layout !== "Auto") ? this.legendTitleSize.height : 0) + (this.isBulletChartControl ? 0 : legend.containerPadding.top);
      options.id += "_clipPath_rect";
      options.width = !this.isChartControl && chart.getModuleName() !== "bulletChart" && !this.isStockChartControl && !(chart.getModuleName() === "accumulationchart" && (legend.layout !== "Auto" || legend.maximumColumns > 0)) && this.isVertical ? this.maxWidth - padding + legend.containerPadding.left + legend.containerPadding.right : legendBounds.width;
      if (!isCanvas) {
        this.clipRect = chart.renderer.drawRectangle(options);
        clippath.appendChild(this.clipRect);
      } else {
        this.pagingClipRect = options;
      }
      appendChildElement(isCanvas, chart.svgObject, clippath, redraw);
      if (!isCanvas) {
        legendItemsGroup.style.cssText = "clip-path:url(#" + clippath.id + ")";
      }
      return this.legendTranslateGroup;
    };
    BaseLegend2.prototype.renderSymbol = function(legendOption, group, legendIndex) {
      var control = this.isBulletChartControl ? this.chart : null;
      var symbolColor = legendOption.visible ? legendOption.fill : "#D3D3D3";
      var isStrokeWidth = (this.chart.getModuleName() === "chart" || this.chart.getModuleName() === "stockChart") && (legendOption.shape === "SeriesType" && legendOption.type.toLowerCase().indexOf("line") > -1 && legendOption.type.toLowerCase().indexOf("area") === -1 || legendOption.shape === "HorizontalLine" || legendOption.shape === "VerticalLine" || legendOption.shape === "Cross");
      var isCustomBorder = (this.chart.getModuleName() === "chart" || this.chart.getModuleName() === "stockChart") && (legendOption.type === "Scatter" || legendOption.type === "Bubble");
      var isCanvas = this.isStockChartControl ? false : this.chart.enableCanvas;
      var borderColor;
      var shape = legendOption.shape === "SeriesType" ? legendOption.type : legendOption.shape;
      var strokewidth = isStrokeWidth ? this.legend.mode === "Series" ? this.chart.visibleSeries[legendIndex].width : this.chart.visibleSeries[0].width : this.isBulletChartControl && legendOption.shape === "Multiply" ? 4 : 1;
      var regionPadding;
      shape = shape === "Scatter" ? legendOption.markerShape : shape;
      if (isCustomBorder && legendIndex < this.chart.visibleSeries.length) {
        var series = this.chart.visibleSeries[legendIndex];
        var seriesBorder = series.border;
        var isLineShapemarker = shape === "HorizontalLine" || shape === "VerticalLine";
        borderColor = isLineShapemarker ? symbolColor : seriesBorder.color ? seriesBorder.color : symbolColor;
        strokewidth = isLineShapemarker ? series.width : seriesBorder.width ? seriesBorder.width : 1;
      }
      var symbolOption = new PathOption(this.legendID + this.generateId(legendOption, "_shape_", legendIndex), symbolColor, strokewidth, isCustomBorder ? borderColor : symbolColor, this.legend.opacity, legendOption.dashArray, "");
      var textSize = measureText(legendOption.text, this.legend.textStyle, this.chart.themeStyle.legendLabelFont);
      var x = this.legend.isInversed && !this.isRtlEnable ? legendOption.location.x + textSize.width + this.legend.shapePadding : legendOption.location.x;
      var y = legendOption.location.y;
      if (!isCanvas) {
        group.appendChild(drawSymbol({
          x,
          y
        }, shape, new Size(this.legend.shapeWidth, this.legend.shapeHeight), legendOption.url, symbolOption, this.accessbilityText, this.chart.renderer, null, this.isBulletChartControl, control));
      } else {
        regionPadding = -this.translatePage(isCanvas, null, this.currentPageNumber - 1, this.currentPageNumber);
        drawSymbol({
          x,
          y
        }, shape, new Size(this.legend.shapeWidth, this.legend.shapeHeight), "", symbolOption, this.accessbilityText, this.chart.renderer, this.currentPageNumber ? new Rect(0, regionPadding, 0, 0) : null, this.isBulletChartControl, control);
        this.legendRegions.push({
          rect: new Rect(legendOption.location.x - this.legend.shapeWidth, legendOption.location.y, this.legend.shapeWidth + this.legend.shapePadding, this.legend.shapeHeight + regionPadding),
          index: legendIndex
        });
      }
      if (shape === "Line" && legendOption.markerVisibility && legendOption.markerShape !== "Image" || legendOption.type === "Doughnut" && shape === "Doughnut") {
        symbolOption.id = this.legendID + this.generateId(legendOption, "_shape_marker_", legendIndex);
        shape = legendOption.type === "Doughnut" ? "Circle" : legendOption.markerShape;
        symbolOption.fill = legendOption.type === "Doughnut" ? "#FFFFFF" : symbolOption.fill;
        if (!isCanvas) {
          group.appendChild(drawSymbol({
            x,
            y
          }, shape, new Size(this.legend.shapeWidth / 2, this.legend.shapeHeight / 2), "", symbolOption, this.accessbilityText, null, null, this.isBulletChartControl, control));
        } else {
          drawSymbol({
            x,
            y
          }, shape, new Size(this.legend.shapeWidth / 2, this.legend.shapeHeight / 2), "", symbolOption, this.accessbilityText, this.chart.renderer, this.currentPageNumber ? new Rect(0, -this.translatePage(isCanvas, null, this.currentPageNumber - 1, this.currentPageNumber), 0, 0) : null, this.isBulletChartControl, control);
        }
      }
    };
    BaseLegend2.prototype.renderText = function(chart, legendOption, group, textOptions, i, legendIndex) {
      var legend = chart.legendSettings;
      var hiddenColor = "#D3D3D3";
      var fontcolor = legendOption.visible ? legend.textStyle.color || chart.themeStyle.legendLabelFont.color : hiddenColor;
      var isCanvas = this.isStockChartControl ? false : this.chart.enableCanvas;
      textOptions.id = this.legendID + this.generateId(legendOption, "_text_", legendIndex);
      textOptions.text = legendOption.textCollection.length > 0 ? legendOption.textCollection : legendOption.text;
      if (legend.isInversed && !this.isRtlEnable) {
        textOptions.x = legendOption.location.x - legend.shapeWidth / 2;
      } else if (this.isRtlEnable) {
        var textWidth = measureText(legendOption.text, legend.textStyle, this.chart.themeStyle.legendLabelFont).width;
        textOptions.x = this.chart.getModuleName() === "bulletChart" ? legendOption.location.x - legend.shapeWidth : legendOption.location.x - ((legendOption.textCollection.length > 1 ? textWidth / legendOption.textCollection.length : textWidth) + legend.shapeWidth / 2 + legend.shapePadding);
      } else {
        textOptions.x = legendOption.location.x + legend.shapeWidth / 2 + legend.shapePadding;
      }
      textOptions.y = legendOption.location.y + this.maxItemHeight / 4;
      textElement2(chart.renderer, textOptions, legend.textStyle, fontcolor, group, false, false, false, false, null, this.currentPageNumber && isCanvas ? new Rect(0, -this.translatePage(isCanvas, null, this.currentPageNumber - 1, this.currentPageNumber), 0, 0) : null, null, null, null, null, this.chart.themeStyle.legendLabelFont);
      if (isCanvas) {
        var textSize = measureText(legendOption.text, legend.textStyle, this.chart.themeStyle.legendLabelFont);
        var region = void 0;
        for (var j = 0; j < this.legendRegions.length; j++) {
          if (this.legendRegions[j].index === i) {
            region = this.legendRegions[j];
            break;
          }
        }
        region.rect.y = textOptions.y < region.rect.y ? textOptions.y : region.rect.y;
        region.rect.width += textSize.width;
        region.rect.height = textSize.height;
        region.rect.y -= textSize.height * 0.5;
        region.rect.x -= this.isRtlEnable ? region.rect.width : 0;
      }
    };
    BaseLegend2.prototype.renderPagingElements = function(chart, bounds, textOption, legendGroup) {
      var paginggroup = chart.renderer.createGroup({
        id: this.legendID + "_navigation"
      });
      var isCanvas = this.isStockChartControl ? false : chart.enableCanvas;
      var titleHeight = this.isBulletChartControl ? 0 : this.legendTitleSize.height;
      var grayColor = this.chart.theme.indexOf("Dark") > -1 || this.chart.theme.indexOf("Contrast") > -1 ? "#FFFFFF" : "#545454";
      var legend = chart.legendSettings;
      var padding = 8;
      var pageUp = this.legendID + (!this.isRtlEnable ? "_pageup" : "_pagedown");
      var pageDown = this.legendID + (!this.isRtlEnable ? "_pagedown" : "_pageup");
      var symbolOption = new PathOption(pageUp, "transparent", 5, grayColor, 1, "", "");
      var iconSize = chart.availableSize.width < 110 || chart.availableSize.height < 190 ? 4 : this.pageButtonSize;
      var legendFontSize = extend({}, getValue("properties", legend.textStyle), null, true);
      legendFontSize.size = chart.availableSize.width < 110 || chart.availableSize.height < 190 && !this.isBulletChartControl && this.chart.getModuleName() === "accumulationchart" ? "8px" : legend.textStyle.size;
      var rowCount = !legend.enablePages && this.isPaging && !this.isVertical && !this.isBulletChartControl ? 1 : this.rowCount - 1;
      var titleWidth = this.isTitle && legend.titlePosition === "Left" ? this.legendTitleSize.width : 0;
      this.pagingRegions = [];
      this.backwardArrowOpacity = this.currentPage !== 1 ? 1 : 0;
      this.forwardArrowOpacity = this.currentPage === this.totalPages ? 0 : 1;
      if (!isCanvas) {
        legendGroup.appendChild(paginggroup);
      }
      if (!this.isChartControl && !this.isAccChartControl) {
        if (this.isBulletChartControl || this.isStockChartControl || !this.isVertical) {
          this.totalPages = Math.ceil(this.totalPages / Math.max(1, this.rowCount - 1));
        } else {
          this.totalPages = Math.ceil(this.totalPages / this.maxColumns);
        }
      }
      if (paginggroup) {
        paginggroup.style.cursor = "pointer";
      }
      if ((this.isChartControl || this.isAccChartControl) && !(!legend.enablePages && this.isPaging)) {
        this.clipPathHeight = this.pageHeights[0] - (this.isTitle && this.isTop && (this.isChartControl || !this.isVertical || legend.layout !== "Auto") ? this.legendTitleSize.height : 0) - legend.containerPadding.top - legend.containerPadding.bottom;
      } else {
        this.clipPathHeight = rowCount * (this.maxItemHeight + legend.padding);
      }
      if (!isCanvas) {
        this.clipRect.setAttribute("height", this.clipPathHeight.toString());
      } else {
        this.pagingClipRect.height = this.legendBounds.height - this.clipPathHeight - (this.pagingClipRect.y - this.legendBounds.y) - legend.border.width;
        this.pagingClipRect.y = this.pagingClipRect.y + this.clipPathHeight;
        this.pagingClipRect.x += legend.border.width;
        this.pagingClipRect.width -= legend.border.width + legend.border.width / 2;
        this.chart.renderer.clearRect(new Rect(this.pagingClipRect.x, this.pagingClipRect.y, this.pagingClipRect.width, this.pagingClipRect.height));
      }
      var pageTextElement;
      var x = bounds.x + iconSize / 2;
      var y = bounds.y + this.clipPathHeight + (titleHeight + bounds.height - this.clipPathHeight) / 2;
      if (this.isPaging && !legend.enablePages && !this.isVertical && !this.isBulletChartControl) {
        x = bounds.x + this.pageButtonSize + titleWidth;
        y = legend.title && this.isTop ? bounds.y + padding + titleHeight + iconSize / 1 + 0.5 : bounds.y + padding + iconSize + 0.5;
      }
      var size = measureText(this.totalPages + "/" + this.totalPages, legendFontSize, this.chart.themeStyle.legendLabelFont);
      var translateX = this.isRtlEnable ? legend.border.width + iconSize / 2 : bounds.width - (2 * (iconSize + padding) + padding + size.width);
      if (!isCanvas) {
        if (this.isVertical && !legend.enablePages && !this.isBulletChartControl) {
          x = bounds.x + bounds.width / 2;
          y = bounds.y + iconSize / 2 + padding / 2 + titleHeight;
          symbolOption.opacity = this.backwardArrowOpacity;
          paginggroup.appendChild(drawSymbol({
            x,
            y
          }, "UpArrow", new Size(iconSize, iconSize), "", symbolOption, "UpArrow"));
        } else {
          symbolOption.opacity = this.isBulletChartControl ? symbolOption.opacity : legend.enablePages ? 1 : !this.isRtlEnable ? this.backwardArrowOpacity : this.forwardArrowOpacity;
          paginggroup.appendChild(drawSymbol({
            x,
            y
          }, "LeftArrow", new Size(iconSize, iconSize), "", symbolOption, "LeftArrow"));
        }
      } else {
        drawSymbol({
          x,
          y
        }, "LeftArrow", new Size(iconSize, iconSize), "", symbolOption, "LeftArrow", this.chart.renderer, new Rect(translateX, 0, 0, 0));
      }
      this.pagingRegions.push(new Rect(!this.isRtlEnable ? x + bounds.width - (2 * (iconSize + padding) + padding + size.width) - iconSize * 0.5 : x, y - iconSize * 0.5, iconSize, iconSize));
      textOption.x = x + iconSize / 2 + padding;
      textOption.y = y + size.height / 4;
      textOption.id = this.legendID + "_pagenumber";
      textOption.text = !this.isRtlEnable ? "1/" + this.totalPages : this.totalPages + "/1";
      var color = this.chart.theme.indexOf("Dark") > -1 || this.chart.theme.indexOf("Contrast") > -1 ? "#FFFFFF" : legend.textStyle.color || this.chart.theme === "Tailwind3" ? "#111827" : this.chart.theme === "Tailwind3Dark" ? "#FFFFFF" : this.chart.themeStyle.legendLabelFont.color;
      if (isCanvas && this.totalNoOfPages) {
        textOption.text = !this.isRtlEnable ? this.currentPageNumber + "/" + this.totalNoOfPages : this.totalNoOfPages + "/" + this.currentPageNumber;
      }
      if (legend.enablePages || this.isBulletChartControl) {
        pageTextElement = textElement2(chart.renderer, textOption, legendFontSize, color, paginggroup, false, false, false, false, null, new Rect(translateX, 0, 0, 0), null, null, null, null, this.chart.themeStyle.legendLabelFont);
      }
      x = textOption.x + padding + iconSize / 2 + size.width;
      if (this.isPaging && !legend.enablePages && !this.isBulletChartControl && !this.isVertical) {
        x = bounds.x + bounds.width - (this.isBulletChartControl ? this.fivePixel : 0) - this.pageButtonSize - (legend.title && legend.titlePosition === "Right" ? this.legendTitleSize.width + this.fivePixel : 0);
      }
      symbolOption.id = pageDown;
      symbolOption.opacity = !legend.enablePages ? !this.isRtlEnable ? this.forwardArrowOpacity : this.backwardArrowOpacity : 1;
      if (!isCanvas) {
        if (this.isVertical && !legend.enablePages && !this.isBulletChartControl) {
          x = bounds.x + bounds.width / 2;
          y = bounds.y + bounds.height - iconSize / 2;
          paginggroup.appendChild(drawSymbol({
            x,
            y
          }, "DownArrow", new Size(iconSize, iconSize), "", symbolOption, "DownArrow"));
        } else {
          paginggroup.appendChild(drawSymbol({
            x,
            y
          }, "RightArrow", new Size(iconSize, iconSize), "", symbolOption, "RightArrow"));
        }
      } else {
        drawSymbol({
          x,
          y
        }, "RightArrow", new Size(iconSize, iconSize), "", symbolOption, "RightArrow", this.chart.renderer, new Rect(translateX, 0, 0, 0));
      }
      this.pagingRegions.push(new Rect(!this.isRtlEnable ? x + (bounds.width - (2 * (iconSize + padding) + padding + size.width) - iconSize * 0.5) : x, y - iconSize * 0.5, iconSize, iconSize));
      if (!isCanvas && (legend.enablePages || this.isBulletChartControl)) {
        paginggroup.setAttribute("transform", "translate(" + translateX + ", 0)");
      } else {
        if (this.currentPageNumber === 1 && this.calTotalPage && (legend.enablePages || this.isBulletChartControl)) {
          this.totalNoOfPages = this.totalPages;
          this.calTotalPage = false;
        }
        if (!legend.enablePages && !this.isBulletChartControl) {
          this.translatePage(isCanvas, null, this.currentPage - 1, this.currentPage, legend);
        }
      }
      if (legend.enablePages || this.isBulletChartControl) {
        this.translatePage(isCanvas, pageTextElement, this.currentPage - 1, this.currentPage, legend);
      }
    };
    BaseLegend2.prototype.getPageHeight = function(pageHeights, pageCount) {
      var sum2 = 0;
      for (var i = 0; i < pageCount; i++) {
        sum2 += pageHeights[i] - (this.isTitle && this.isTop ? this.legendTitleSize.height : 0);
      }
      return sum2;
    };
    BaseLegend2.prototype.translatePage = function(isCanvas, pagingText, page, pageNumber, legend) {
      var size = this.isChartControl || this.isAccChartControl ? page ? this.getPageHeight(this.pageHeights, page) : 0 : this.clipPathHeight * page;
      if (!isCanvas && (this.isChartControl || this.isAccChartControl)) {
        this.clipRect.setAttribute("height", (this.pageHeights[page] - (this.isTitle && this.isTop && (this.isChartControl || !this.isVertical || legend.layout !== "Auto") ? this.legendTitleSize.height : 0) - legend.containerPadding.top - legend.containerPadding.bottom).toString());
        if (this.isAccChartControl && this.isPaging && !legend.enablePages && this.isVertical && (this.chart.getModuleName() !== "accumulationchart" || legend.layout === "Auto")) {
          this.clipRect.setAttribute("height", this.legendBounds.height.toString());
        }
      }
      var translate = "translate(0,-" + size + ")";
      if (!this.isChartControl && !this.isBulletChartControl && !this.isStockChartControl && !(this.chart.getModuleName() === "accumulationchart" && legend.layout !== "Auto") && this.isVertical) {
        var pageX = this.pageXCollections[page * this.maxColumns];
        size = !this.isRtlEnable ? pageX - this.legendBounds.x : this.legendBounds.x + this.maxWidth - pageX;
        size = size < 0 ? 0 : size;
        translate = (!this.isRtlEnable ? "translate(-" : "translate(") + size + ",0)";
      }
      if (!this.chart.enableCanvas) {
        this.legendTranslateGroup.setAttribute("transform", translate);
      }
      if (!this.chart.enableCanvas && (legend.enablePages || this.isBulletChartControl)) {
        pagingText.textContent = pageNumber + "/" + this.totalPages;
      }
      this.currentPage = pageNumber;
      return size;
    };
    BaseLegend2.prototype.changePage = function(event2, pageUp) {
      var legend = this.chart.legendSettings;
      var backwardArrow = document.getElementById(this.legendID + "_pageup");
      var forwardArrow = document.getElementById(this.legendID + "_pagedown");
      var isCanvas = this.isStockChartControl ? false : this.chart.enableCanvas;
      var pageText = legend.enablePages || this.isBulletChartControl ? document.getElementById(this.legendID + "_pagenumber") : null;
      var page = legend.enablePages || this.isBulletChartControl ? parseInt(pageText.textContent.split("/")[0], 10) : this.currentPage;
      if (pageUp && page > 1) {
        this.translatePage(isCanvas, pageText, page - 2, page - 1, legend);
      } else if (!pageUp && page < this.totalPages) {
        this.translatePage(isCanvas, pageText, page, page + 1, legend);
      }
      if (this.isPaging && !legend.enablePages && !this.isBulletChartControl) {
        if (this.currentPage === this.totalPages) {
          this.hideArrow(forwardArrow);
        } else {
          this.showArrow(forwardArrow);
        }
        if (this.currentPage === 1) {
          this.hideArrow(backwardArrow);
        } else {
          this.showArrow(backwardArrow);
        }
      }
    };
    BaseLegend2.prototype.hideArrow = function(arrowElement) {
      arrowElement.setAttribute("opacity", "0");
    };
    BaseLegend2.prototype.showArrow = function(arrowElement) {
      arrowElement.setAttribute("opacity", "1");
    };
    BaseLegend2.prototype.generateId = function(option, prefix, count) {
      if (this.isChartControl || this.isStockChartControl) {
        return prefix + count;
      } else {
        return prefix + option.pointIndex;
      }
    };
    BaseLegend2.prototype.move = function(event2) {
      var _this = this;
      var x = this.chart.mouseX;
      var y = this.chart.mouseY;
      if (event2.target.textContent.indexOf("...") > -1) {
        var targetId = event2.target.id.split(this.legendID + "_text_");
        if (targetId.length === 2) {
          var index = parseInt(targetId[1], 10);
          var element = this.chart.element;
          if (!isNaN(index)) {
            if (this.chart.isTouch) {
              removeElement2(this.chart.element.id + "_EJ2_Legend_Tooltip");
            }
            if (this.isChartControl) {
              showTooltip(this.chart.series[index].name, x, y, element.offsetWidth, element.id + "_EJ2_Legend_Tooltip", getElement2(this.chart.element.id + "_Secondary_Element"));
            } else {
              showTooltip(this.chart.getModuleName() === "accumulationchart" ? this.legendCollections[index].originalText : this.chart.visibleSeries[0].points[index].x.toString(), x + 10, y + 10, element.offsetWidth, element.id + "_EJ2_Legend_Tooltip", getElement2(this.chart.element.id + "_Secondary_Element"));
            }
          }
        }
      } else {
        removeElement2(this.chart.element.id + "_EJ2_Legend_Tooltip");
      }
      if (this.chart.isTouch) {
        clearTimeout(this.clearTooltip);
        this.clearTooltip = +setTimeout(function() {
          removeElement2(_this.chart.element.id + "_EJ2_Legend_Tooltip");
        }, 1e3);
      }
    };
    return BaseLegend2;
  }()
);
var LegendOptions = (
  /** @class */
  /* @__PURE__ */ function() {
    function LegendOptions2(text, fill, shape, visible, type, url, markerShape, markerVisibility, pointIndex, seriesIndex, dashArray, originalText) {
      this.location = {
        x: 0,
        y: 0
      };
      this.textCollection = [];
      this.text = text;
      this.fill = fill;
      this.shape = shape;
      this.url = url;
      this.visible = visible;
      this.type = type;
      this.markerVisibility = markerVisibility;
      this.markerShape = markerShape;
      this.pointIndex = pointIndex;
      this.seriesIndex = seriesIndex;
      this.dashArray = dashArray;
      this.originalText = originalText;
    }
    return LegendOptions2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/common/utils/print.js
var PrintUtils = (
  /** @class */
  function() {
    function PrintUtils2(control) {
      this.control = control;
    }
    PrintUtils2.prototype.print = function(elements) {
      this.printWindow = window.open("", "print", "height=" + window.outerHeight + ",width=" + window.outerWidth + ",tabbar=no");
      this.printWindow.moveTo(0, 0);
      this.printWindow.resizeTo(screen.availWidth, screen.availHeight);
      var argsData = {
        cancel: false,
        htmlContent: this.getHTMLContent(elements),
        name: beforePrint
      };
      this.control.trigger(beforePrint, argsData);
      if (!argsData.cancel) {
        print(argsData.htmlContent, this.printWindow);
      }
    };
    PrintUtils2.prototype.getHTMLContent = function(elements) {
      var div = createElement("div");
      if (elements) {
        if (elements instanceof Array) {
          for (var j = 0; j < elements.length; j++) {
            var value = elements[j];
            div.appendChild(getElement2(value).cloneNode(true));
          }
        } else if (elements instanceof Element) {
          div.appendChild(elements.cloneNode(true));
        } else {
          div.appendChild(getElement2(elements).cloneNode(true));
        }
      } else {
        div.appendChild(this.control.element.cloneNode(true));
      }
      for (var index = 0; index < div.children.length; index++) {
        var backgroundColor = this.control.theme.indexOf("Dark") > -1 || this.control.theme.indexOf("HighContrast") > -1 ? "rgba(0, 0, 0, 1)" : "rgba(255, 255, 255, 1)";
        var svg = div.children[index];
        for (var childIndex = 0; childIndex < svg.children.length; childIndex++) {
          var actualBackgroundColor = void 0;
          var isSVG = false;
          if (svg.id.indexOf("_stockChart_svg") > -1) {
            actualBackgroundColor = svg.children[0].getAttribute("fill");
            isSVG = true;
          } else if (svg.children[childIndex].id.indexOf("_svg") > -1) {
            actualBackgroundColor = svg.children[childIndex].children[0].getAttribute("fill");
            isSVG = true;
          }
          if (isSVG) {
            actualBackgroundColor = actualBackgroundColor === "transparent" ? backgroundColor : actualBackgroundColor;
            svg.children[childIndex].children[0].setAttribute("fill", actualBackgroundColor);
          }
        }
        div[index] = svg;
      }
      return div;
    };
    return PrintUtils2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart/chart.js
var __extends10 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate7 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var RangeColorSetting = (
  /** @class */
  function(_super) {
    __extends10(RangeColorSetting2, _super);
    function RangeColorSetting2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate7([Property()], RangeColorSetting2.prototype, "start", void 0);
    __decorate7([Property()], RangeColorSetting2.prototype, "end", void 0);
    __decorate7([Property([])], RangeColorSetting2.prototype, "colors", void 0);
    __decorate7([Property("")], RangeColorSetting2.prototype, "label", void 0);
    return RangeColorSetting2;
  }(ChildProperty)
);
var CrosshairSettings = (
  /** @class */
  function(_super) {
    __extends10(CrosshairSettings2, _super);
    function CrosshairSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate7([Property(false)], CrosshairSettings2.prototype, "enable", void 0);
    __decorate7([Property("")], CrosshairSettings2.prototype, "dashArray", void 0);
    __decorate7([Complex({
      color: null,
      width: 1
    }, Border)], CrosshairSettings2.prototype, "line", void 0);
    __decorate7([Property("Both")], CrosshairSettings2.prototype, "lineType", void 0);
    __decorate7([Property("")], CrosshairSettings2.prototype, "verticalLineColor", void 0);
    __decorate7([Property("")], CrosshairSettings2.prototype, "horizontalLineColor", void 0);
    __decorate7([Property(1)], CrosshairSettings2.prototype, "opacity", void 0);
    __decorate7([Property(false)], CrosshairSettings2.prototype, "snapToData", void 0);
    __decorate7([Property(false)], CrosshairSettings2.prototype, "highlightCategory", void 0);
    return CrosshairSettings2;
  }(ChildProperty)
);
var ZoomSettings = (
  /** @class */
  function(_super) {
    __extends10(ZoomSettings2, _super);
    function ZoomSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate7([Property(false)], ZoomSettings2.prototype, "enableSelectionZooming", void 0);
    __decorate7([Property(false)], ZoomSettings2.prototype, "enablePinchZooming", void 0);
    __decorate7([Property(false)], ZoomSettings2.prototype, "showToolbar", void 0);
    __decorate7([Property(false)], ZoomSettings2.prototype, "enableMouseWheelZooming", void 0);
    __decorate7([Property(true)], ZoomSettings2.prototype, "enableDeferredZooming", void 0);
    __decorate7([Property("XY")], ZoomSettings2.prototype, "mode", void 0);
    __decorate7([Property(["Zoom", "ZoomIn", "ZoomOut", "Pan", "Reset"])], ZoomSettings2.prototype, "toolbarItems", void 0);
    __decorate7([Property(false)], ZoomSettings2.prototype, "enablePan", void 0);
    __decorate7([Property(false)], ZoomSettings2.prototype, "enableScrollbar", void 0);
    __decorate7([Property(false)], ZoomSettings2.prototype, "enableAnimation", void 0);
    __decorate7([Complex({}, ToolbarPosition)], ZoomSettings2.prototype, "toolbarPosition", void 0);
    __decorate7([Complex({}, Accessibility)], ZoomSettings2.prototype, "accessibility", void 0);
    return ZoomSettings2;
  }(ChildProperty)
);
var Chart = (
  /** @class */
  function(_super) {
    __extends10(Chart2, _super);
    function Chart2(options, element) {
      var _this = _super.call(this, options, element) || this;
      _this.rotatedDataLabelCollections = [];
      _this.animated = false;
      _this.isPointMouseDown = false;
      _this.isScrolling = false;
      _this.checkResize = 0;
      _this.visible = 0;
      _this.clickCount = 0;
      _this.maxPointCount = 0;
      _this.singleClickTimer = 0;
      _this.chartAreaType = "Cartesian";
      _this.isRtlEnabled = false;
      _this.isCrosshair = true;
      _this.chartid = 57723;
      _this.isLegendClicked = false;
      _this.isZoomed = false;
      _this.previousTargetId = "";
      _this.currentPointIndex = 0;
      _this.currentSeriesIndex = 0;
      _this.currentLegendIndex = 0;
      _this.previousPageX = null;
      _this.previousPageY = null;
      _this.allowPan = false;
      _this.pointsRemoved = false;
      _this.pointsAdded = false;
      _this.zoomRedraw = false;
      setValue("mergePersistData", _this.mergePersistChartData, _this);
      return _this;
    }
    Chart2.prototype.mergePersistChartData = function() {
      var data = window.localStorage.getItem(this.getModuleName() + this.element.id);
      if (!(isNullOrUndefined(data) || data === "")) {
        var dataObj = JSON.parse(data);
        var keys = Object.keys(dataObj);
        this.isProtectedOnChange = true;
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
          var key = keys_1[_i];
          if (typeof this[key] === "object" && !isNullOrUndefined(this[key])) {
            extend(this[key], dataObj[key]);
          } else {
            this[key] = dataObj[key];
          }
        }
        this.isProtectedOnChange = false;
      }
    };
    Chart2.prototype.isIdHasSpecialCharacter = function(elementId) {
      var regex = /^[A-Za-z ]+$/;
      var numberRegex = /^[0-9 ]+$/;
      var childElementId = "";
      if (!regex.test(elementId)) {
        var start = 0;
        if (numberRegex.test(elementId[0])) {
          childElementId += "\\3" + elementId[0];
          start = 1;
        }
        for (var i = start; i < elementId.length; i++) {
          if (!regex.test(elementId[i]) && elementId.indexOf("-") === -1 && elementId.indexOf("_") === -1 && elementId.indexOf("\\") === -1 && !numberRegex.test(elementId[i])) {
            childElementId += "\\" + elementId[i];
          } else {
            childElementId += elementId[i];
          }
        }
        return childElementId;
      } else {
        return elementId;
      }
    };
    Chart2.prototype.preRender = function() {
      this.element.id = this.isIdHasSpecialCharacter(this.element.id);
      var blazor = "Blazor";
      this.isBlazor = window[blazor];
      this.allowServerDataBinding = false;
      this.markerIndex = 0;
      this.unWireEvents();
      this.initPrivateVariable();
      this.setCulture();
      this.wireEvents();
      if (this.stockChart) {
        if (this.stockChart.tooltip.header === null) {
          this.tooltip.header = this.stockChart.theme.indexOf("Tailwind3") > -1 ? "${point.x}" : "<b>${point.x}</b>";
        }
        if (this.stockChart.tooltip.format === null) {
          this.tooltip.format = this.stockChart.theme.indexOf("Tailwind3") > -1 ? "High : ${point.high}<br/>Low : ${point.low}<br/>Open : ${point.open}<br/>Close : ${point.close}" : "High : <b>${point.high}</b><br/>Low : <b>${point.low}</b><br/>Open : <b>${point.open}</b><br/>Close : <b>${point.close}</b>";
        }
      }
      this.element.setAttribute("dir", this.enableRtl ? "rtl" : "ltr");
    };
    Chart2.prototype.initPrivateVariable = function() {
      this.animateSeries = true;
      this.delayRedraw = false;
      this.dragY = null;
      this.horizontalAxes = [];
      this.verticalAxes = [];
      this.refreshAxis();
      this.refreshDefinition(this.rows);
      this.refreshDefinition(this.columns);
      if (this.tooltipModule) {
        this.tooltipModule.previousPoints = [];
      }
      this.element.setAttribute("role", this.accessibility.accessibilityRole ? this.accessibility.accessibilityRole : "region");
      this.element.setAttribute("tabindex", this.accessibility.focusable ? String(this.accessibility.tabIndex) : "-1");
      this.element.style.outline = "none";
      this.element.setAttribute("aria-label", this.accessibility.accessibilityDescription ? this.accessibility.accessibilityDescription : this.title + ". Syncfusion interactive chart.");
      if (!this.element.classList.contains("e-chart-focused")) {
        this.element.setAttribute("class", this.element.getAttribute("class") + " e-chart-focused");
      }
      if (this.element.id === "") {
        var collection = document.getElementsByClassName("e-chart").length;
        var elementid = "chart_" + this.chartid + "_" + collection;
        while (document.getElementById(elementid)) {
          collection++;
          elementid = "chart_" + this.chartid + "_" + collection;
        }
        this.element.id = "chart_" + this.chartid + "_" + collection;
      }
      this.svgId = this.stockChart ? this.stockChart.element.id + "_stockChart_chart" : this.element.id + (this.enableCanvas ? "_canvas" : "_svg");
    };
    Chart2.prototype.render = function() {
      var _this = this;
      this.svgRenderer = new SvgRenderer(this.element.id);
      var loadEventData = {
        chart: this.isBlazor ? {} : this,
        theme: this.theme,
        name: load,
        cancel: false
      };
      if (!this.stockChart) {
        this.trigger(load, loadEventData, function() {
          if (!loadEventData.cancel) {
            _this.cartesianChartRendering(loadEventData);
          }
        });
      } else {
        this.isRtlEnabled = window.getComputedStyle(document.querySelector("body")).direction === "rtl";
        this.cartesianChartRendering(loadEventData);
      }
      this.applyZoomkit();
    };
    Chart2.prototype.cartesianChartRendering = function(beforeRenderData) {
      this.theme = this.isBlazor ? beforeRenderData.theme : this.theme;
      this.setTheme();
      this.createChartSvg();
      this.markerRender = new Marker(this);
      this.calculateAreaType();
      this.calculateVisibleSeries();
      this.initTechnicalIndicators();
      this.initTrendLines();
      this.calculateVisibleAxis();
      this.processData();
      this.renderComplete();
      this.mouseMoveEvent();
      this.allowServerDataBinding = true;
    };
    Chart2.prototype.getLocalizedLabel = function(key) {
      return this.localeObject.getConstant(key);
    };
    Chart2.prototype.animate = function(duration) {
      this.redraw = true;
      this.animated = true;
      this.duration = duration ? duration : 1e3;
      if (this.tooltipModule) {
        this.tooltipModule.removeHighlightedMarker(this.tooltipModule.previousPoints, true);
      } else if (this.markerRender.previousPoints) {
        for (var previousPoint = 0; previousPoint < this.markerRender.previousPoints.length; previousPoint++) {
          this.markerRender.removeHighlightedMarker(this.markerRender.previousPoints[previousPoint].series, this.markerRender.previousPoints[previousPoint].point);
        }
      }
    };
    Chart2.prototype.refreshBound = function() {
      this.rotatedDataLabelCollections = [];
      if (this.legendModule && this.legendSettings.visible) {
        this.legendModule.getLegendOptions(this.visibleSeries, this);
      }
      if (this.tooltip.enable && this.tooltipModule) {
        this.tooltipModule.previousPoints = [];
      }
      this.calculateStackValues();
      this.calculateBounds();
      if (this.stockChart && !this.stockChart.rangeFound) {
        if (this.stockChart.enablePeriodSelector || this.stockChart.enableSelector) {
          return null;
        }
      }
      this.renderElements();
      removeElement2("chartmeasuretext");
      this.removeSelection();
      if (this.markerRender) {
        this.markerRender.mergeXvalues(this.visibleSeries);
      }
    };
    Chart2.prototype.calculateStackValues = function() {
      var series;
      var isCalculateStacking = false;
      for (var i = 0, len = this.visibleSeries.length; i < len; i++) {
        series = this.visibleSeries[i];
        if (series.visible) {
          series.position = series.rectCount = void 0;
        }
        if ((series.type.indexOf("Stacking") !== -1 || series.drawType.indexOf("Stacking") !== -1 && this.chartAreaType === "PolarRadar") && !isCalculateStacking) {
          series.calculateStackedValue(series.type.indexOf("100") > -1, this);
          isCalculateStacking = true;
        }
      }
    };
    Chart2.prototype.removeSelection = function() {
      for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
        var series = _a[_i];
        if (series.visible) {
          for (var _b = 0, _c = series.points; _b < _c.length; _b++) {
            var point = _c[_b];
            point.isSelect = false;
          }
        }
      }
      if (getElement2(this.element.id + "_ej2_drag_multi_group")) {
        if (this.selectionMode.indexOf("Drag") > -1) {
          this.selectionModule.filterArray = [];
        }
        removeElement2(this.element.id + "_ej2_drag_multi_group");
        this.selectionModule.calculateDragSelectedElements(this, new Rect(0, 0, 0, 0), true);
      } else if (getElement2(this.element.id + "_ej2_drag_group")) {
        if (this.selectionMode !== "Lasso") {
          this.selectionModule.filterArray = [];
        }
        removeElement2(this.element.id + "_ej2_drag_group");
        this.selectionModule.calculateDragSelectedElements(this, new Rect(0, 0, 0, 0), true);
      }
    };
    Chart2.prototype.renderElements = function() {
      this.renderBorder();
      this.renderTitle();
      this.renderAreaBorder();
      this.renderSeriesElements(this.renderAxes());
      this.renderLegend();
      this.applyZoomkit();
      this.performSelection();
      this.setSecondaryElementPosition();
      for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
        var value = _a[_i];
        updateBlazorTemplate(this.element.id + "_DataLabel", "Template", value.marker.dataLabel);
      }
      this.renderAnnotation();
      if (this.stackLabels.visible && this.visibleSeries.some(function(series) {
        return series.type && series.type.indexOf("Stacking") > -1;
      }) && this.dataLabelModule) {
        this.dataLabelModule.renderStackLabels();
      }
    };
    Chart2.prototype.renderAxes = function() {
      this.yAxisElements = this.renderer.createGroup({
        id: this.element.id + "yAxisCollection"
      });
      var axisElement;
      if (this.rows.length > 0 && this.columns.length > 0) {
        axisElement = this.chartAxisLayoutPanel.renderAxes();
      }
      if (this.stripLineModule) {
        this.stripLineModule.renderStripLine(this, "Behind", this.axisCollections);
      }
      return axisElement;
    };
    Chart2.prototype.renderLegend = function() {
      if (this.legendModule && this.legendModule.legendCollections.length && this.legendSettings.visible) {
        this.legendModule.calTotalPage = true;
        var borderWidth = this.legendSettings.border.width;
        var bounds = this.legendModule.legendBounds;
        var rect = new Rect(bounds.x, bounds.y, bounds.width, bounds.height);
        if (this.enableCanvas) {
          this.canvasRender.ctx.beginPath();
          rect = new Rect(rect.x - borderWidth / 2, rect.y - borderWidth / 2, rect.width + borderWidth, rect.height + borderWidth);
          this.renderer.canvasClip(rect);
        }
        this.legendModule.renderLegend(this, this.legendSettings, bounds);
        if (this.enableCanvas) {
          this.renderer.canvasRestore();
        }
      }
      if (!this.redraw) {
        if (!this.stockChart) {
          this.element.appendChild(this.svgObject);
        } else {
          if (!getElement2(this.stockChart.chartObject.id)) {
            this.stockChart.mainObject.appendChild(this.svgObject);
          }
        }
      }
    };
    Chart2.prototype.setSecondaryElementPosition = function() {
      var element = getElement2(this.element.id + "_Secondary_Element");
      if (!element) {
        return;
      }
      var rect = this.element.getBoundingClientRect();
      var svgRect = getElement2(this.svgId).getBoundingClientRect();
      element.style.left = Math.max((svgRect.left - rect.left) / this.scaleX, 0) + "px";
      element.style.top = Math.max((svgRect.top - rect.top) / this.scaleY, 0) + "px";
    };
    Chart2.prototype.initializeModuleElements = function() {
      this.dataLabelCollections = [];
      var elementId = this.element.id;
      if (this.series.length) {
        this.seriesElements = this.svgRenderer.createGroup({
          id: elementId + "SeriesCollection"
        });
      }
      if (this.indicators.length) {
        this.indicatorElements = this.renderer.createGroup({
          id: elementId + "IndicatorCollection"
        });
      }
      if (this.hasTrendlines()) {
        this.trendLineElements = this.renderer.createGroup({
          id: elementId + "TrendLineCollection"
        });
      }
      this.dataLabelElements = this.renderer.createGroup({
        id: elementId + "DataLabelCollection"
      });
    };
    Chart2.prototype.hasTrendlines = function() {
      var isTrendline;
      for (var _i = 0, _a = this.series; _i < _a.length; _i++) {
        var series = _a[_i];
        isTrendline = series.trendlines.length ? true : false;
        if (isTrendline) {
          break;
        }
      }
      return isTrendline;
    };
    Chart2.prototype.renderSeriesElements = function(axisElement) {
      this.initializeModuleElements();
      var elementId = this.element.id;
      if (this.element.tagName !== "g") {
        var tooltipDiv = redrawElement(this.redraw, elementId + "_Secondary_Element") || this.createElement("div");
        tooltipDiv.id = elementId + "_Secondary_Element";
        tooltipDiv.style.cssText = "position: relative";
        appendChildElement(false, this.element, tooltipDiv, this.redraw);
      }
      if (this.enableCanvas) {
        var tooltipdiv = document.getElementById(elementId + "_Secondary_Element");
        tooltipdiv = !tooltipdiv ? this.createElement("div", {
          id: elementId + "_Secondary_Element",
          attrs: {
            "style": "position: relative; left:0px; top:0px"
          }
        }) : tooltipdiv;
        var svg = this.svgRenderer.createSvg({
          id: elementId + "_tooltip_svg",
          width: this.availableSize.width,
          height: this.availableSize.height
        });
        svg.style.cssText = "position: absolute; pointer-events: none";
        tooltipdiv.appendChild(svg);
      }
      if (this.tooltip.enable && !this.stockChart) {
        appendChildElement(this.enableCanvas, this.svgObject, this.renderer.createGroup({
          id: elementId + "_UserInteraction",
          style: "pointer-events:none;"
        }), this.redraw);
      }
      if (this.rows.length > 0 && this.columns.length > 0) {
        this.initializeIndicator();
        this.initializeTrendLine();
        this.renderSeries();
        if (this.trendLineElements) {
          appendChildElement(this.enableCanvas, this.svgObject, this.trendLineElements, this.redraw);
        }
        this.appendElementsAfterSeries(axisElement);
      }
    };
    Chart2.prototype.renderSeries = function() {
      var visibility;
      if (this.enableCanvas) {
        this.renderer.canvasClip(this.chartAxisLayoutPanel.seriesClipRect);
      }
      for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
        var item = _a[_i];
        if (item.category === "TrendLine") {
          visibility = this.series[item.sourceIndex].trendlines[item.index].visible;
        } else {
          visibility = item.visible;
        }
        if (visibility) {
          this.visible++;
          findClipRect(item, this.enableCanvas);
          if (this.enableCanvas) {
            this.renderCanvasSeries();
          }
          item.renderSeries(this);
        } else if (item.isLegendClicked && (item.type.indexOf("StackingArea") > -1 || item.type.indexOf("StackingBar") > -1 || item.type.indexOf("StackingColumn") > -1)) {
          findClipRect(item, this.enableCanvas);
          item.renderSeries(this);
        }
      }
      if (this.enableCanvas) {
        this.renderer.canvasRestore();
      }
      this.visible = 0;
      var options = {
        "id": this.element.id + "_ChartAreaClipRect_",
        "x": this.chartAxisLayoutPanel.seriesClipRect.x,
        "y": this.chartAxisLayoutPanel.seriesClipRect.y,
        "width": this.chartAxisLayoutPanel.seriesClipRect.width,
        "height": this.chartAxisLayoutPanel.seriesClipRect.height,
        "fill": "transparent",
        "stroke-width": 1,
        "stroke": "Gray"
      };
      if (!this.seriesElements || options.height < 0 || options.width < 0) {
        return;
      }
      var clipRectElement;
      if (this.chartAreaType === "PolarRadar") {
        clipRectElement = appendClipElement(this.redraw, options, this.renderer, "drawCircularClipPath");
      } else {
        clipRectElement = appendClipElement(this.redraw, options, this.renderer);
      }
      if (!this.enableCanvas) {
        this.seriesElements.appendChild(clipRectElement);
      }
      var seriesSvg = document.getElementById(this.element.id + "_series_svg");
      if (seriesSvg) {
        appendChildElement(false, seriesSvg, this.seriesElements, this.redraw);
      } else {
        appendChildElement(this.enableCanvas, this.svgObject, this.seriesElements, this.redraw);
      }
    };
    Chart2.prototype.renderCanvasSeries = function() {
      var svgElement;
      if (this.enableCanvas) {
        var tempSvgElement = svgElement;
        svgElement = tempSvgElement;
      } else {
        svgElement = this.svgObject;
      }
    };
    Chart2.prototype.initializeIndicator = function() {
      for (var _i = 0, _a = this.indicators; _i < _a.length; _i++) {
        var indicator = _a[_i];
        if (this[firstToLowerCase(indicator.type) + "IndicatorModule"]) {
          this[firstToLowerCase(indicator.type) + "IndicatorModule"].createIndicatorElements(this, indicator, indicator.index);
        }
      }
      if (this.indicatorElements) {
        appendChildElement(this.enableCanvas, this.svgObject, this.indicatorElements, this.redraw);
      }
    };
    Chart2.prototype.initializeTrendLine = function() {
      for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
        var series = _a[_i];
        if (series.trendlines.length) {
          this.trendLineModule.getTrendLineElements(series, this);
        }
      }
    };
    Chart2.prototype.appendElementsAfterSeries = function(axisElement) {
      if (this.chartAreaType === "PolarRadar") {
        appendChildElement(this.enableCanvas, this.svgObject, this.yAxisElements, this.redraw);
      }
      appendChildElement(this.enableCanvas, this.svgObject, axisElement, this.redraw);
      if (this.zoomModule && this.zoomSettings.enableScrollbar && this.scrollElement && this.scrollElement.childElementCount || this.scrollElement && this.scrollElement.childElementCount) {
        appendChildElement(false, getElement2(this.element.id + "_Secondary_Element"), this.scrollElement, this.redraw);
      }
      if (this.stripLineModule) {
        this.stripLineModule.renderStripLine(this, "Over", this.axisCollections);
      }
      if (!this.tooltip.enable || this.stockChart) {
        appendChildElement(this.enableCanvas, this.svgObject, this.renderer.createGroup({
          id: this.element.id + "_UserInteraction",
          style: "pointer-events:none;"
        }), this.redraw);
      }
      if (this.stockChart) {
        this.stockChart.calculateStockEvents();
      }
    };
    Chart2.prototype.applyZoomkit = function() {
      if (this.chartAreaType === "PolarRadar") {
        return;
      }
      if ((!this.redraw || this.zoomRedraw) && this.zoomModule && (!this.zoomSettings.enablePan || this.zoomModule.performedUI || this.zoomSettings.showToolbar)) {
        this.zoomModule.applyZoomToolkit(this, this.axisCollections);
      }
    };
    Chart2.prototype.renderAnnotation = function() {
      if (this.annotationModule) {
        this.annotationModule.renderAnnotations(getElement2((this.stockChart ? this.stockChart.element.id : this.element.id) + "_Secondary_Element"));
      }
    };
    Chart2.prototype.performSelection = function() {
      var selectedDataIndexes = [];
      if (this.selectionModule) {
        selectedDataIndexes = extend([], this.selectionModule.selectedDataIndexes, null, true);
        this.selectionModule.invokeSelection(this);
      }
      if (this.highlightModule) {
        this.highlightModule.invokeHighlight(this);
      }
      if (selectedDataIndexes.length > 0) {
        this.selectionModule.selectedDataIndexes = selectedDataIndexes;
        this.selectionModule.redrawSelection(this, this.selectionMode);
      }
    };
    Chart2.prototype.processData = function(render) {
      if (render === void 0) {
        render = true;
      }
      this.visibleSeriesCount = 0;
      var check = true;
      var prevPointCount = 0;
      for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
        var series = _a[_i];
        if (!series.visible && !this.legendSettings.visible) {
          this.visibleSeriesCount++;
          continue;
        }
        if (series.category !== "Indicator" && series.category !== "TrendLine") {
          this.initializeDataModule(series);
        }
      }
      for (var _b = 0, _c = this.indicators; _b < _c.length; _b++) {
        var indicator = _c[_b];
        if (indicator.dataSource) {
          var techIndicator = indicator;
          this.initializeDataModule(techIndicator);
          check = false;
        }
      }
      if (render && (!this.visibleSeries.length || this.visibleSeriesCount === this.visibleSeries.length && check)) {
        this.refreshBound();
        this.trigger("loaded", {
          chart: this.isBlazor ? {} : this
        });
      }
      if (!this.stockChart && this.visibleSeries.length > 0) {
        for (var _d = 0, _e = this.visibleSeries; _d < _e.length; _d++) {
          var series = _e[_d];
          if (!isNullOrUndefined(series.points)) {
            this.maxPointCount = Math.max(prevPointCount, series.points.length);
            prevPointCount = series.points.length;
          }
        }
      }
    };
    Chart2.prototype.initializeDataModule = function(series) {
      series.xData = [];
      series.yData = [];
      var dataSource;
      var isAngular = "isAngular";
      if (this[isAngular]) {
        dataSource = Object.keys(series.dataSource).length ? series.dataSource : this.dataSource;
      } else {
        dataSource = series.dataSource || this.dataSource;
      }
      series.dataModule = new Data(dataSource, series.query);
      series.points = [];
      series.refreshDataManager(this);
    };
    Chart2.prototype.calculateBounds = function() {
      var margin = this.margin;
      var titleHeight = 0;
      var subTitleHeight = 0;
      var padding = this.titleStyle.position === "Top" || this.titleStyle.position === "Bottom" && !this.legendSettings.visible ? 15 : 5;
      var left = margin.left + this.border.width;
      var width = this.availableSize.width - left - margin.right - this.border.width;
      var elementSpacing = 0;
      this.titleCollection = [];
      this.subTitleCollection = [];
      if (this.title) {
        this.titleCollection = getTitle(this.title, this.titleStyle, width, this.enableRtl, this.themeStyle.chartTitleFont);
        titleHeight = measureText(this.title, this.titleStyle, this.themeStyle.chartTitleFont).height * this.titleCollection.length + padding;
        if (this.subTitle) {
          this.subTitleCollection = getTitle(this.subTitle, this.subTitleStyle, width, this.enableRtl, this.themeStyle.chartSubTitleFont);
          subTitleHeight = measureText(this.subTitle, this.subTitleStyle, this.themeStyle.chartSubTitleFont).height * this.subTitleCollection.length + padding;
        }
      } else if (this.legendSettings.position !== "Top" && this.border.width) {
        elementSpacing = 10;
      }
      var top = margin.top + elementSpacing + this.border.width + this.chartArea.border.width * 0.5;
      var height = this.availableSize.height - top - this.border.width - margin.bottom;
      var marginTotal = subTitleHeight + titleHeight + this.titleStyle.border.width + this.subTitleStyle.border.width;
      switch (this.titleStyle.position) {
        case "Top":
          top += marginTotal;
          height -= marginTotal;
          break;
        case "Bottom":
          height -= marginTotal;
          break;
        case "Left":
          left += marginTotal;
          width -= marginTotal;
          break;
        case "Right":
          left -= this.titleStyle.border.width + this.subTitleStyle.border.width;
          width -= marginTotal;
          break;
      }
      if (this.stockChart && this.stockChart.legendSettings.visible && this.stockChart.stockLegendModule) {
        if (this.stockChart.legendSettings.position === "Top") {
          top += this.stockChart.stockLegendModule.legendBounds.height;
        } else if (this.stockChart.legendSettings.position === "Left") {
          left += this.stockChart.stockLegendModule.legendBounds.width;
        }
      }
      if (this.scrollBarModule && (this.zoomModule && this.zoomSettings.enableScrollbar && this.zoomModule.isZoomed || this.scrollSettingEnabled)) {
        var scrollbarPadding = 10;
        for (var i = 0, len = this.axisCollections.length; i < len; i++) {
          var axis = this.axisCollections[i];
          if (axis.orientation === "Horizontal" && axis.scrollbarSettings.position === "Bottom") {
            height -= axis.scrollbarSettings.height + scrollbarPadding;
          } else if (axis.orientation === "Horizontal" && axis.scrollbarSettings.position === "Top") {
            height -= axis.scrollbarSettings.height + scrollbarPadding;
            top += axis.scrollbarSettings.height + scrollbarPadding;
          } else if (axis.orientation === "Vertical" && axis.scrollbarSettings.position === "Right") {
            width -= axis.scrollbarSettings.height + scrollbarPadding;
          } else if (axis.orientation === "Vertical" && axis.scrollbarSettings.position === "Left") {
            width -= axis.scrollbarSettings.height + scrollbarPadding;
            left += axis.scrollbarSettings.height + scrollbarPadding;
          }
        }
      }
      this.initialClipRect = new Rect(left, top, width, height);
      if (this.legendModule && this.legendSettings.visible) {
        this.legendModule.calculateLegendBounds(this.initialClipRect, this.availableSize, null);
      }
      this.initialClipRect.y += this.chartArea.margin.top;
      this.initialClipRect.height -= this.chartArea.margin.top + this.chartArea.margin.bottom;
      this.initialClipRect.x += this.chartArea.margin.left;
      this.initialClipRect.width -= this.chartArea.margin.left + this.chartArea.margin.right;
      this.chartAxisLayoutPanel.measureAxis(this.initialClipRect);
    };
    Chart2.prototype.print = function(id) {
      var exportChart = new PrintUtils(this);
      var width = this.width;
      if (this.getModuleName() === "chart" && parseInt(this.width, 10) >= 80 && this.width.indexOf("%") > -1) {
        this.width = "80%";
        this.dataBind();
      }
      exportChart.print(id);
      if (this.getModuleName() === "chart" && parseInt(this.width, 10) >= 80 && this.width.indexOf("%") > -1) {
        this.width = width;
        this.dataBind();
      }
    };
    Chart2.prototype.initTrendLines = function() {
      this.isProtectedOnChange = true;
      for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
        var series = _a[_i];
        var trendIndex = 0;
        for (var _b = 0, _c = series.trendlines; _b < _c.length; _b++) {
          var trendline = _c[_b];
          var trendLine = trendline;
          if (this.trendLineModule) {
            trendLine.index = trendIndex;
            trendLine.sourceIndex = series.index;
            this.trendLineModule.initSeriesCollection(trendLine, this);
            if (trendLine.targetSeries) {
              trendLine.targetSeries.xAxisName = series.xAxisName;
              trendLine.targetSeries.yAxisName = series.yAxisName;
              this.visibleSeries.push(trendLine.targetSeries);
            }
          }
          trendIndex++;
        }
      }
      this.isProtectedOnChange = false;
    };
    Chart2.prototype.calculateAreaType = function() {
      var series = this.series[0];
      this.chartArea.border.width = this.stockChart ? 0 : this.chartArea.border.width;
      if (series) {
        this.requireInvertedAxis = series.type.indexOf("Bar") !== -1 && !this.isTransposed || series.type.indexOf("Bar") === -1 && this.isTransposed && this.chartAreaType !== "PolarRadar";
      }
      this.chartAxisLayoutPanel = this.chartAreaType === "PolarRadar" ? this.polarSeriesModule || this.radarSeriesModule : new CartesianAxisLayoutPanel(this);
    };
    Chart2.prototype.calculateVisibleAxis = function() {
      var axis;
      var axes = [this.primaryXAxis, this.primaryYAxis];
      axes = this.chartAreaType === "Cartesian" ? axes.concat(this.axes) : axes;
      if (this.paretoSeriesModule && this.series[0].type === "Pareto") {
        axes = axes.concat(this.paretoSeriesModule.paretoAxes);
      }
      this.axisCollections = [];
      if (this.zoomModule) {
        this.zoomModule.isPanning = this.zoomModule.isAxisZoomed(axes) && this.zoomSettings.enablePan;
        this.svgObject.setAttribute("cursor", this.zoomModule.isPanning ? "pointer" : "auto");
        if (this.scrollBarModule) {
          this.scrollBarModule.axes = axes;
        }
      }
      if (this.scrollSettingEnabled) {
        if (this.scrollBarModule) {
          this.scrollBarModule.axes = axes;
        }
      }
      for (var i = 0, len = axes.length; i < len; i++) {
        axis = axes[i];
        axis.series = [];
        axis.labels = [];
        axis.indexLabels = {};
        for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
          var series = _a[_i];
          this.initAxis(series, axis, true);
          if (series.category === "Pareto" && series.type === "Line" && series.yAxis) {
            series.yAxis.internalVisibility = series.paretoOptions.showAxis;
          }
        }
        for (var _b = 0, _c = this.indicators; _b < _c.length; _b++) {
          var indicator = _c[_b];
          this.initAxis(indicator, axis, false);
        }
        if (this.scrollBarModule && !axis.zoomingScrollBar) {
          this.scrollBarModule.injectTo(axis, this);
        }
        if (axis.orientation != null) {
          this.axisCollections.push(axis);
        }
      }
      if (this.rows.length > 0 && this.columns.length > 0) {
        this.chartAxisLayoutPanel.measure();
      }
    };
    Chart2.prototype.initAxis = function(series, axis, isSeries) {
      if (series.xAxisName === axis.name || series.xAxisName == null && axis.name === "primaryXAxis") {
        axis.orientation = this.requireInvertedAxis ? "Vertical" : "Horizontal";
        series.xAxis = axis;
        if (isSeries) {
          axis.series.push(series);
        }
      } else if (series.yAxisName === axis.name || series.yAxisName == null && axis.name === "primaryYAxis") {
        axis.orientation = this.requireInvertedAxis ? "Horizontal" : "Vertical";
        series.yAxis = axis;
        if (isSeries) {
          axis.series.push(series);
        }
      }
    };
    Chart2.prototype.initTechnicalIndicators = function() {
      var i = 0;
      for (var _i = 0, _a = this.indicators; _i < _a.length; _i++) {
        var indicator = _a[_i];
        var techIndicator = indicator;
        var type = firstToLowerCase(techIndicator.type);
        if (this[type + "IndicatorModule"]) {
          techIndicator.index = i;
          this[type + "IndicatorModule"].initSeriesCollection(techIndicator, this);
          for (var _b = 0, _c = techIndicator.targetSeries; _b < _c.length; _b++) {
            var targetSeries = _c[_b];
            if (indicator.seriesName || indicator.dataSource) {
              this.visibleSeries.push(targetSeries);
            }
          }
        }
        i++;
      }
    };
    Chart2.prototype.refreshTechnicalIndicator = function(series) {
      if (this.indicators.length) {
        var targetIndicator = null;
        if (series instanceof Series && series.category !== "Indicator") {
          for (var _i = 0, _a = this.indicators; _i < _a.length; _i++) {
            var indicator = _a[_i];
            if (indicator.seriesName === series.name && !indicator.dataSource) {
              targetIndicator = indicator;
              targetIndicator.setDataSource(series, this);
            }
          }
        } else if (series instanceof TechnicalIndicator) {
          targetIndicator = series;
          targetIndicator.setDataSource(series instanceof Series ? series : null, this);
        }
      }
    };
    Chart2.prototype.calculateVisibleSeries = function() {
      var series;
      this.visibleSeries = [];
      var colors = this.palettes.length ? this.palettes : getSeriesColor(this.theme);
      var count = colors.length;
      var seriesCollection = this.series.sort(function(a, b) {
        return a.zOrder - b.zOrder;
      });
      for (var i = 0, len = seriesCollection.length; i < len; i++) {
        series = seriesCollection[i];
        series.category = seriesCollection[0].type === "Pareto" ? "Pareto" : "Series";
        series.index = i;
        series.interior = series.fill || colors[i % count];
        if (!series.marker.shape && (series.marker.visible || series.type === "Scatter" || series.drawType === "Scatter")) {
          series.marker.shape = markerShapes[this.markerIndex % 10];
          this.markerIndex++;
        }
        if (this.isSecondaryAxis(series.xAxis)) {
          series.xAxis.internalVisibility = series.xAxis.series.some(function(value) {
            return value.visible;
          });
        }
        if (this.isSecondaryAxis(series.yAxis)) {
          series.yAxis.internalVisibility = series.yAxis.series.some(function(value) {
            return value.visible;
          });
        }
        switch (series.type) {
          case "Bar":
          case "StackingBar":
          case "StackingBar100":
            if (seriesCollection[0].type.indexOf("Bar") === -1) {
              continue;
            }
            break;
          case "Polar":
          case "Radar":
            if (this.chartAreaType !== "PolarRadar") {
              continue;
            }
            if (this.chartAreaType === "PolarRadar" && (series.xAxisName !== null && this.primaryXAxis.name !== series.xAxisName || series.yAxisName !== null && this.primaryYAxis.name !== series.yAxisName)) {
              continue;
            }
            break;
          case "Pareto":
            this.visibleSeries.push(series);
            this.paretoSeriesModule.initSeries(series, this);
            continue;
          default:
            if (this.chartAreaType === "PolarRadar" || seriesCollection[0].type.indexOf("Bar") > -1) {
              continue;
            }
            break;
        }
        this.visibleSeries.push(series);
        seriesCollection[i] = series;
      }
    };
    Chart2.prototype.isSecondaryAxis = function(axis) {
      return this.axes.indexOf(axis) > -1;
    };
    Chart2.prototype.renderTitle = function() {
      var rect;
      var margin = this.margin;
      var elementSpacing = 5;
      if (this.title) {
        var getAnchor = getTextAnchor(this.titleStyle.textAlignment, this.enableRtl);
        var elementSize = measureText(this.title, this.titleStyle, this.themeStyle.chartTitleFont);
        rect = new Rect(margin.left, 0, this.availableSize.width - margin.left - margin.right, 0);
        var borderWidth = this.titleStyle.border.width;
        var positionY = this.margin.top + elementSize.height * 3 / 4;
        var positionX = titlePositionX(rect, this.titleStyle || this.themeStyle.chartTitleFont) + borderWidth;
        var rotation = void 0;
        var alignment = this.titleStyle.textAlignment;
        var subtitleSize = measureText(this.subTitle, this.subTitleStyle, this.themeStyle.chartSubTitleFont);
        switch (this.titleStyle.position) {
          case "Top":
            positionY += borderWidth * 0.5;
            positionX += getAnchor === "start" ? borderWidth * 0.5 + this.border.width : getAnchor === "end" ? -borderWidth * 2 - this.border.width : 0;
            break;
          case "Bottom":
            positionX += getAnchor === "start" ? borderWidth * 0.5 + this.border.width : getAnchor === "end" ? -borderWidth * 2 - this.border.width : 0;
            positionY = this.availableSize.height - this.margin.bottom - subtitleSize.height - elementSize.height / 2 - borderWidth * 0.5 - this.subTitleStyle.border.width * 0.5;
            break;
          case "Left":
            positionX = this.margin.left + elementSize.height * 3 / 4 + borderWidth * 0.5;
            positionY = alignment === "Near" ? margin.bottom + borderWidth * 0.5 + this.border.width : alignment === "Far" ? this.availableSize.height - margin.bottom - borderWidth * 0.5 - this.border.width : this.availableSize.height / 2;
            getAnchor = alignment === "Near" ? "end" : alignment === "Far" ? "start" : "middle";
            getAnchor = this.enableRtl ? getAnchor === "end" ? "start" : getAnchor === "start" ? "end" : getAnchor : getAnchor;
            rotation = "rotate(-90," + positionX + "," + positionY + ")";
            break;
          case "Right":
            positionX = this.availableSize.width - this.margin.right - elementSize.height * 3 / 4 - borderWidth * 0.5;
            positionY = alignment === "Near" ? margin.bottom + borderWidth * 0.5 + this.border.width : alignment === "Far" ? this.availableSize.height - margin.bottom - borderWidth * 0.5 - this.border.width : this.availableSize.height / 2;
            getAnchor = alignment === "Near" ? "start" : alignment === "Far" ? "end" : "middle";
            getAnchor = this.enableRtl ? getAnchor === "end" ? "start" : getAnchor === "start" ? "end" : getAnchor : getAnchor;
            rotation = "rotate(90," + positionX + "," + positionY + ")";
            break;
          case "Custom":
            positionX = this.titleStyle.x;
            positionY = this.titleStyle.y;
            getAnchor = "middle";
            break;
        }
        var borderOptions = {
          "id": this.element.id + "_ChartTitleBorder",
          "x": positionX - (getAnchor === "middle" ? elementSize.width / 2 + elementSpacing : getAnchor === "end" ? elementSize.width + elementSpacing : elementSpacing),
          "y": positionY - elementSize.height + elementSize.height / 4,
          "rx": this.titleStyle.border.cornerRadius,
          "ry": this.titleStyle.border.cornerRadius,
          "width": elementSize.width + elementSpacing * 2,
          "height": elementSize.height * this.titleCollection.length,
          "fill": this.titleStyle.background,
          "stroke-width": borderWidth,
          "stroke": this.titleStyle.border.color,
          "transform": rotation ? rotation : "",
          "d": ""
        };
        var htmlObject = redrawElement(this.redraw, this.element.id + "_ChartTitleBorder", borderOptions, this.renderer) || this.renderer.drawRectangle(borderOptions);
        appendChildElement(this.enableCanvas, this.svgObject, htmlObject, this.redraw);
        var options = new TextOption(this.element.id + "_ChartTitle", positionX, positionY, getAnchor, this.titleCollection, rotation, "auto");
        var element = redrawElement(this.redraw, this.element.id + "_ChartTitle", options, this.renderer) || textElement2(this.renderer, options, this.titleStyle, this.titleStyle.color || this.themeStyle.chartTitleFont.color, this.svgObject, null, null, null, null, null, null, null, null, this.enableCanvas, null, this.themeStyle.chartTitleFont);
        if (element && !this.enableCanvas) {
          element.setAttribute("tabindex", this.titleStyle.accessibility.focusable ? String(this.titleStyle.accessibility.tabIndex) : "-1");
          element.style.outline = "none";
          element.setAttribute("class", "e-chart-focused");
          element.setAttribute("role", this.titleStyle.accessibility.accessibilityRole);
          element.setAttribute("aria-label", this.titleStyle.accessibility.accessibilityDescription);
        }
        if (this.subTitle) {
          this.renderSubTitle(options);
        }
      }
    };
    Chart2.prototype.renderSubTitle = function(options) {
      var maxWidth = 0;
      var subMaxWidth = 0;
      var titleWidth = 0;
      var subTitleWidth = 0;
      var padding = 10;
      var alignment = this.titleStyle.textAlignment;
      for (var _i = 0, _a = this.titleCollection; _i < _a.length; _i++) {
        var titleText = _a[_i];
        titleWidth = measureText(titleText, this.titleStyle, this.themeStyle.chartTitleFont).width;
        maxWidth = titleWidth > maxWidth ? titleWidth : maxWidth;
      }
      for (var _b = 0, _c = this.subTitleCollection; _b < _c.length; _b++) {
        var subTitleText = _c[_b];
        subTitleWidth = measureText(subTitleText, this.subTitleStyle, this.themeStyle.chartSubTitleFont).width;
        subMaxWidth = subTitleWidth > subMaxWidth ? subTitleWidth : subMaxWidth;
      }
      maxWidth = Math.max(titleWidth, subMaxWidth);
      var subTitleElementSize = measureText(this.subTitleCollection.reduce(function(a, b) {
        return a.length > b.length ? a : b;
      }), this.subTitleStyle, this.themeStyle.chartSubTitleFont);
      var getAnchor = getTextAnchor(this.subTitleStyle.textAlignment, this.enableRtl);
      var rect = new Rect(alignment === "Center" ? options.x - maxWidth * 0.5 : alignment === "Far" ? options.x - maxWidth : options.x, 0, maxWidth, 0);
      if (this.titleStyle.position === "Left") {
        rect.x = alignment === "Center" ? options.x - maxWidth * 0.5 : alignment === "Far" ? this.margin.left + subTitleElementSize.height * 3 / 4 : options.x - maxWidth;
      }
      var elementSize = measureText(this.title, this.titleStyle, this.themeStyle.chartTitleFont);
      var positionY = options.y * options.text.length + subTitleElementSize.height + padding / 2 + this.titleStyle.border.width + this.subTitleStyle.border.width * 0.5;
      if (this.titleStyle.position === "Bottom") {
        positionY = options.y * options.text.length + padding / 2 + elementSize.height / 2 + subTitleElementSize.height / 2;
      }
      var borderOptions = {
        "id": this.element.id + "_ChartSubTitleBorder",
        "x": titlePositionX(rect, this.subTitleStyle) - (getAnchor === "middle" ? subTitleElementSize.width / 2 + padding / 2 : getAnchor === "end" ? subTitleElementSize.width + padding / 2 : padding / 2),
        "y": positionY - subTitleElementSize.height + subTitleElementSize.height / 4,
        "rx": this.subTitleStyle.border.cornerRadius,
        "ry": this.subTitleStyle.border.cornerRadius,
        "width": subTitleElementSize.width + padding,
        "height": subTitleElementSize.height * this.subTitleCollection.length,
        "fill": this.subTitleStyle.background,
        "stroke-width": this.subTitleStyle.border.width,
        "stroke": this.subTitleStyle.border.color,
        "transform": options.transform,
        "d": ""
      };
      var htmlObject = redrawElement(this.redraw, this.element.id + "_ChartSubTitleBorder", borderOptions, this.renderer) || this.renderer.drawRectangle(borderOptions);
      appendChildElement(this.enableCanvas, this.svgObject, htmlObject, this.redraw);
      var subTitleOptions = new TextOption(this.element.id + "_ChartSubTitle", titlePositionX(rect, this.subTitleStyle), positionY, getTextAnchor(this.subTitleStyle.textAlignment, this.enableRtl), this.subTitleCollection, options.transform, "auto");
      var element = redrawElement(this.redraw, this.element.id + "_ChartSubTitle", subTitleOptions, this.renderer) || textElement2(this.renderer, subTitleOptions, this.subTitleStyle, this.subTitleStyle.color || this.themeStyle.chartSubTitleFont.color, this.svgObject, null, null, null, null, null, null, null, null, this.enableCanvas, null, this.themeStyle.chartSubTitleFont);
      if (element && !this.enableCanvas) {
        element.setAttribute("tabindex", this.subTitleStyle.accessibility.focusable ? String(this.subTitleStyle.accessibility.tabIndex) : "-1");
        if (this.subTitleStyle.accessibility.focusable) {
          element.style.outline = "none";
        }
        element.setAttribute("class", "e-chart-focused");
        element.setAttribute("role", this.subTitleStyle.accessibility.accessibilityRole);
        element.setAttribute("aria-label", this.subTitleStyle.accessibility.accessibilityDescription);
      }
    };
    Chart2.prototype.renderBorder = function() {
      var x = 0;
      var y = 0;
      var width = this.border.width;
      var backGroundImage = this.backgroundImage;
      var fillColor = backGroundImage ? "transparent" : this.background || this.themeStyle.background;
      if (this.stockChart && this.stockChart.legendSettings.visible && this.stockChart.stockLegendModule) {
        if (this.stockChart.legendSettings.position === "Top") {
          y += this.stockChart.stockLegendModule.legendBounds.height;
        } else if (this.stockChart.legendSettings.position === "Left") {
          x += this.stockChart.stockLegendModule.legendBounds.width;
        }
      }
      var rect = new RectOption(this.element.id + "_ChartBorder", fillColor, this.border, 1, new Rect(width * 0.5 + x, width * 0.5 + y, this.availableSize.width - width, this.availableSize.height - width), 0, 0, "", this.border.dashArray);
      this.htmlObject = redrawElement(this.redraw, this.element.id + "_ChartBorder", rect, this.renderer) || this.renderer.drawRectangle(rect);
      this.htmlObject.setAttribute("aria-hidden", "true");
      appendChildElement(this.enableCanvas, this.svgObject, this.htmlObject, this.redraw);
      if (backGroundImage) {
        var image = new ImageOption(this.availableSize.height - width, this.availableSize.width - width, backGroundImage, 0, 0, this.element.id + "_ChartBackground", "visible", "none");
        this.htmlObject = redrawElement(this.redraw, this.element.id + "_ChartBackground", image, this.renderer) || this.renderer.drawImage(image);
        appendChildElement(this.enableCanvas, this.svgObject, this.htmlObject, this.redraw);
      }
    };
    Chart2.prototype.renderAreaBorder = function() {
      if (this.chartAreaType === "PolarRadar") {
        return null;
      } else {
        var element = getElement2(this.element.id + "_ChartAreaBorder");
        var previousRect = element ? new Rect(+element.getAttribute("x"), +element.getAttribute("y"), +element.getAttribute("width"), +element.getAttribute("height")) : null;
        var rect = new RectOption(this.element.id + "_ChartAreaBorder", this.chartArea.background, {
          width: this.chartArea.border.width,
          color: this.chartArea.border.color || this.themeStyle.areaBorder
        }, this.chartArea.opacity, this.chartAxisLayoutPanel.seriesClipRect, 0, 0, "", this.chartArea.border.dashArray);
        if (rect.height < 0 || rect.width < 0) {
          return null;
        }
        this.htmlObject = this.renderer.drawRectangle(rect);
        this.htmlObject.setAttribute("aria-hidden", "true");
        appendChildElement(this.enableCanvas, this.svgObject, this.htmlObject, this.redraw, true, "x", "y", null, null, true, true, previousRect);
        this.htmlObject = null;
      }
      var backGroundImage = this.chartArea.backgroundImage;
      if (backGroundImage) {
        var width = this.chartArea.border.width;
        var image = new ImageOption(this.initialClipRect.height - width, this.initialClipRect.width - width, backGroundImage, this.initialClipRect.x, this.initialClipRect.y, this.element.id + "_ChartAreaBackground", "visible", "none");
        this.htmlObject = this.renderer.drawImage(image);
        appendChildElement(this.enableCanvas, this.svgObject, this.htmlObject, this.redraw, true, "x", "y", null, null, true, true);
      }
    };
    Chart2.prototype.addSeries = function(seriesCollection) {
      var scrollTop = window.scrollY || document.documentElement.scrollTop;
      for (var _i = 0, seriesCollection_1 = seriesCollection; _i < seriesCollection_1.length; _i++) {
        var series = seriesCollection_1[_i];
        series = new Series(this, "series", series);
        this.series.push(series);
      }
      this.refresh();
      window.scrollTo(0, scrollTop);
    };
    Chart2.prototype.removeSeries = function(index) {
      this.redraw = false;
      var scrollTop = window.scrollY || document.documentElement.scrollTop;
      var series = this.visibleSeries[index];
      if (series) {
        if (series.xAxis.series.length <= 1) {
          series.xAxis.orientation = null;
        }
        if (series.yAxis.series.length <= 1) {
          series.yAxis.orientation = null;
        }
      }
      for (var i = 0; i < this.axes.length; i++) {
        if (this.axes[i].orientation === null) {
          this.axes.splice(i, 1);
        }
      }
      this.series.splice(index, 1);
      this.refresh();
      window.scrollTo(0, scrollTop);
    };
    Chart2.prototype.clearSeries = function() {
      this.series = [];
      var scrollTop = window.scrollY || document.documentElement.scrollTop;
      this.refresh();
      window.scrollTo(0, scrollTop);
    };
    Chart2.prototype.addAxes = function(axisCollection) {
      for (var _i = 0, axisCollection_1 = axisCollection; _i < axisCollection_1.length; _i++) {
        var axis = axisCollection_1[_i];
        axis = new Axis(this, "axes", axis);
        if (this.isBlazor) {
          axis.interval = isNaN(axis.interval) ? null : axis.interval;
          axis.desiredIntervals = isNaN(axis.desiredIntervals) ? null : axis.desiredIntervals;
        }
        this.axes.push(axis);
      }
      this.refresh();
    };
    Chart2.prototype.removeAxis = function(index) {
      this.redraw = false;
      this.axes.splice(index, 1);
      this.refresh();
    };
    Chart2.prototype.destroy = function() {
      if (this.scrollBarModule) {
        this.scrollBarModule.destroy();
      }
      if (this.markerRender) {
        this.markerRender.removeEventListener();
        this.markerRender = null;
      }
      this.horizontalAxes = [];
      this.verticalAxes = [];
      this.visibleSeries = [];
      this.axisCollections = [];
      this.rotatedDataLabelCollections = [];
      this.seriesElements = null;
      this.chartAxisLayoutPanel = null;
      this.dataLabelCollections = null;
      this.visibleSeriesCount = null;
      this.dataLabelElements = null;
      this.yAxisElements = null;
      var element = document.getElementById(this.element.id + "Keyboard_chart_focus");
      if (element) {
        element.remove();
      }
      var highlightElement = document.getElementById(this.element.id + "_ej2_chart_highlight");
      if (highlightElement) {
        highlightElement.remove();
      }
      var selectionElement = document.getElementById(this.element.id + "_ej2_chart_selection");
      if (selectionElement) {
        selectionElement.remove();
      }
      removeElement2("chartmeasuretext");
      if (this.element) {
        this.unWireEvents();
        if (this.isReact) {
          this.clearTemplate();
        }
        _super.prototype.destroy.call(this);
        if (!this.enableCanvas) {
          this.removeSvg();
          this.svgObject = null;
        }
      }
    };
    Chart2.prototype.getModuleName = function() {
      return "chart";
    };
    Chart2.prototype.getPersistData = function() {
      var keyEntity = ["loaded", "animationComplete", "primaryXAxis", "primaryYAxis"];
      return this.addOnPersist(keyEntity);
    };
    Chart2.prototype.createChartSvg = function() {
      this.removeSvg();
      createSvg(this);
    };
    Chart2.prototype.unWireEvents = function() {
      var startEvent = Browser.touchStartEvent;
      var moveEvent = Browser.touchMoveEvent;
      var stopEvent = Browser.touchEndEvent;
      var cancelEvent = Browser.isPointer ? "pointerleave" : "mouseleave";
      EventHandler.remove(this.element, startEvent, this.chartOnMouseDown);
      EventHandler.remove(this.element, moveEvent, this.mouseMove);
      EventHandler.remove(this.element, stopEvent, this.mouseEnd);
      EventHandler.remove(this.element, "click", this.chartOnMouseClick);
      EventHandler.remove(this.element, "dblclick", this.chartOnDoubleClick);
      EventHandler.remove(this.element, "contextmenu", this.chartRightClick);
      EventHandler.remove(this.element, cancelEvent, this.mouseLeave);
      EventHandler.remove(this.element, "keydown", this.chartKeyDown);
      EventHandler.remove(document.body, "keydown", this.documentKeyHandler);
      EventHandler.remove(this.element, "keyup", this.chartKeyUp);
      window.removeEventListener(Browser.isTouch && "orientation" in window && "onorientationchange" in window ? "orientationchange" : "resize", this.resizeBound);
      if (this.touchObject) {
        this.touchObject.destroy();
        this.touchObject = null;
      }
    };
    Chart2.prototype.wireEvents = function() {
      if (!this.element) {
        return;
      }
      var cancelEvent = Browser.isPointer ? "pointerleave" : "mouseleave";
      EventHandler.add(this.element, Browser.touchStartEvent, this.chartOnMouseDown, this);
      EventHandler.add(this.element, Browser.touchMoveEvent, this.mouseMove, this);
      EventHandler.add(this.element, Browser.touchEndEvent, this.mouseEnd, this);
      EventHandler.add(this.element, "click", this.chartOnMouseClick, this);
      EventHandler.add(this.element, "dblclick", this.chartOnDoubleClick, this);
      EventHandler.add(this.element, "contextmenu", this.chartRightClick, this);
      EventHandler.add(this.element, cancelEvent, this.mouseLeave, this);
      EventHandler.add(this.element, "keydown", this.chartKeyDown, this);
      EventHandler.add(document.body, "keydown", this.documentKeyHandler, this);
      EventHandler.add(this.element, "keyup", this.chartKeyUp, this);
      this.resizeBound = this.chartResize.bind(this);
      window.addEventListener(Browser.isTouch && "orientation" in window && "onorientationchange" in window ? "orientationchange" : "resize", this.resizeBound);
      this.longPressBound = this.longPress.bind(this);
      this.touchObject = new Touch(this.element, {
        tapHold: this.longPressBound,
        tapHoldThreshold: 500
      });
      this.setStyle(this.element);
    };
    Chart2.prototype.chartRightClick = function(event2) {
      if (this.crosshair.enable && this.crosshairModule && (event2.buttons === 2 || event2.which === 0 || event2.pointerType === "touch")) {
        event2.preventDefault();
        event2.stopPropagation();
        return false;
      }
      return true;
    };
    Chart2.prototype.setStyle = function(element) {
      var zooming = this.zoomSettings;
      var disableScroll = zooming.enableSelectionZooming || zooming.enablePinchZooming || this.selectionMode !== "None" || this.highlightMode !== "None";
      element.style.touchAction = disableScroll ? "none" : "element";
      element.style.msTouchAction = disableScroll ? "none" : "element";
      element.style.msContentZooming = "none";
      element.style.msUserSelect = "none";
      element.style.webkitUserSelect = "none";
      element.style.position = "relative";
      element.style.display = "block";
      element.style.overflow = "hidden";
      element.style.height = element.style.height || this.height && this.height.indexOf("%") === -1 ? element.style.height : "inherit";
    };
    Chart2.prototype.isOrientation = function() {
      return "orientation" in window && "onorientationchange" in window;
    };
    Chart2.prototype.longPress = function(e) {
      this.mouseX = e && e.originalEvent.changedTouches ? e.originalEvent.changedTouches[0].clientX : 0;
      this.mouseY = e && e.originalEvent.changedTouches ? e.originalEvent.changedTouches[0].clientY : 0;
      this.startMove = true;
      this.allowPan = this.stockChart ? false : this.allowPan;
      this.setMouseXY(this.mouseX, this.mouseY);
      this.notify("tapHold", e);
      return false;
    };
    Chart2.prototype.setMouseXY = function(pageX, pageY) {
      if (getElement2(this.svgId)) {
        var svgRect = getElement2(this.svgId).getBoundingClientRect();
        var rect = this.element.getBoundingClientRect();
        this.scaleX = svgRect.width / this.availableSize.width;
        this.scaleY = svgRect.height / this.availableSize.height;
        this.mouseY = (pageY - rect.top - Math.max(svgRect.top - rect.top, 0)) / this.scaleY;
        this.mouseX = (pageX - rect.left - Math.max(svgRect.left - rect.left, 0)) / this.scaleX;
        if (this.stockChart) {
          this.mouseX += this.stockChart.legendSettings.position === "Left" ? this.stockChart.stockLegendModule.legendBounds.width : 0;
          this.mouseY += this.stockChart.legendSettings.position === "Top" ? this.stockChart.stockLegendModule.legendBounds.height : 0;
        }
      }
    };
    Chart2.prototype.export = function(type, fileName) {
      if (this.exportModule) {
        this.exportModule.export(type, fileName);
        if (this.afterExport) {
          this.exportModule.getDataUrl(this);
        }
      }
    };
    Chart2.prototype.chartResize = function() {
      var _this = this;
      this.animateSeries = false;
      var arg = {
        chart: this,
        name: resized,
        currentSize: new Size(0, 0),
        previousSize: new Size(this.availableSize.width, this.availableSize.height)
      };
      var beforeResizeArgs = {
        name: "beforeResize",
        cancelResizedEvent: false
      };
      if (this.resizeTo) {
        clearTimeout(this.resizeTo);
      }
      this.trigger(beforeResize, beforeResizeArgs);
      if (!beforeResizeArgs.cancelResizedEvent) {
        this.resizeTo = +setTimeout(function() {
          if (_this.isDestroyed || _this.stockChart) {
            clearTimeout(_this.resizeTo);
            return;
          }
          _this.createChartSvg();
          arg.currentSize = _this.availableSize;
          _this.trigger(resized, arg);
          _this.refreshAxis();
          _this.refreshBound();
          _this.trigger("loaded", {
            chart: _this.isBlazor ? {} : _this
          });
        }, 500);
      }
      return false;
    };
    Chart2.prototype.mouseMove = function(e) {
      var pageX;
      var pageY;
      var touchArg;
      if (this.allowPan) {
        return false;
      }
      if (e.type === "touchmove") {
        this.isTouch = true;
        touchArg = e;
        pageX = touchArg.changedTouches[0].clientX;
        pageY = touchArg.changedTouches[0].clientY;
      } else {
        this.isTouch = e.pointerType === "touch" || e.pointerType === "2" || this.isTouch;
        pageX = e.clientX;
        pageY = e.clientY;
      }
      this.previousPageX = pageX;
      this.previousPageY = pageY;
      if (getElement2(this.svgId)) {
        this.setMouseXY(pageX, pageY);
        this.chartOnMouseMove(e);
      }
      return false;
    };
    Chart2.prototype.mouseLeave = function(e) {
      var pageX;
      var pageY;
      var touchArg;
      if (this.stockChart && this.stockChart.onPanning) {
        return false;
      }
      if (e.type === "touchleave") {
        this.isTouch = true;
        touchArg = e;
        pageX = touchArg.changedTouches[0].clientX;
        pageY = touchArg.changedTouches[0].clientY;
      } else {
        this.isTouch = e.pointerType === "touch" || e.pointerType === "2";
        pageX = e.clientX;
        pageY = e.clientY;
      }
      this.previousPageX = null;
      this.previousPageY = null;
      this.setMouseXY(pageX, pageY);
      this.chartOnMouseLeave(e);
      return false;
    };
    Chart2.prototype.chartOnMouseLeave = function(e) {
      var element = e.target;
      var cancelEvent = Browser.isPointer ? "pointerleave" : "mouseleave";
      this.trigger(chartMouseLeave, {
        target: element.id,
        x: this.mouseX,
        y: this.mouseY
      });
      removeElement2(this.element.id + "_EJ2_AxisLabel_Tooltip");
      this.isChartDrag = this.isPointMouseDown = false;
      this.notify(cancelEvent, e);
      return false;
    };
    Chart2.prototype.chartOnDoubleClick = function(e) {
      var element = e.target;
      this.trigger(chartDoubleClick, {
        target: element.id,
        x: this.mouseX,
        y: this.mouseY
      });
      return false;
    };
    Chart2.prototype.chartKeyDown = function(e) {
      var actionKey = "";
      if (this.isZoomed && e.code === "Tab" || e.code === "Space") {
        e.preventDefault();
      }
      if (this.tooltip.enable && (e.code === "Tab" && this.previousTargetId.indexOf("Series") > -1 || e.code === "Escape")) {
        actionKey = "ESC";
      }
      if (this.highlightMode !== "None" && e.code === "Tab" && this.previousTargetId.indexOf("_chart_legend_") > -1) {
        if (this.highlightModule) {
          this.highlightModule.removeLegendHighlightStyles();
        }
      }
      if (e.ctrlKey && (e.key === "+" || e.code === "Equal" || e.key === "-" || e.code === "Minus")) {
        e.preventDefault();
        this.isZoomed = this.zoomModule && (this.zoomSettings.enableDeferredZooming || this.zoomSettings.enableSelectionZooming || this.zoomSettings.enablePinchZooming || this.zoomSettings.enableMouseWheelZooming);
        actionKey = this.isZoomed ? e.code : "";
      } else if (e["keyCode"] === 82 && this.isZoomed) {
        e.preventDefault();
        this.isZoomed = false;
        actionKey = "R";
      } else if (e.code.indexOf("Arrow") > -1) {
        e.preventDefault();
        actionKey = this.isZoomed ? e.code : "";
      }
      if (e.ctrlKey && e.key === "p") {
        e.preventDefault();
        actionKey = "CtrlP";
      }
      if (actionKey !== "") {
        this.chartKeyboardNavigations(e, e.target.id, actionKey);
      }
      if (e.code === "Tab") {
        this.removeNavigationStyle();
      }
      return false;
    };
    Chart2.prototype.chartKeyUp = function(e) {
      var actionKey = "";
      var targetId = e.target["id"];
      var groupElement;
      var markerGroup;
      var targetElement = e.target;
      var titleElement = getElement2(this.element.id + "_ChartTitle");
      var seriesElement = getElement2(this.element.id + "SeriesCollection");
      var legendElement = getElement2(this.element.id + "_chart_legend_translate_g");
      var pagingElement = getElement2(this.element.id + "_chart_legend_pageup");
      if (titleElement) {
        titleElement.setAttribute("class", "e-chart-focused");
      }
      if (seriesElement && seriesElement.firstElementChild && seriesElement.firstElementChild.children[1]) {
        var firstChild = seriesElement.firstElementChild.children[1];
        var className = firstChild.getAttribute("class");
        if (className && className.indexOf("e-chart-focused") === -1) {
          className = className + " e-chart-focused";
        } else if (!className) {
          className = "e-chart-focused";
        }
        firstChild.setAttribute("class", className);
      }
      if (legendElement) {
        var firstChild = legendElement.firstElementChild;
        var className = firstChild.getAttribute("class");
        if (className && className.indexOf("e-chart-focused") === -1) {
          className = className + " e-chart-focused";
        } else if (!className) {
          className = "e-chart-focused";
        }
        firstChild.setAttribute("class", className);
      }
      if (pagingElement) {
        pagingElement.setAttribute("class", "e-chart-focused");
      }
      if (e.code === "Tab") {
        if (this.previousTargetId !== "") {
          if (this.previousTargetId.indexOf("_Series_") > -1 && targetId.indexOf("_Series_") === -1) {
            groupElement = getElement2(this.element.id + "SeriesCollection");
            var previousElement = void 0;
            if (this.previousTargetId.indexOf("_Symbol") > -1 ? getElement2(this.element.id + "SymbolGroup" + this.currentSeriesIndex) : groupElement.children[this.currentSeriesIndex]) {
              previousElement = this.previousTargetId.indexOf("_Symbol") > -1 ? getElement2(this.element.id + "SymbolGroup" + this.currentSeriesIndex).children[this.currentPointIndex + 1] : this.previousTargetId.indexOf("_Point_") > -1 ? groupElement.children[this.currentSeriesIndex].children[this.currentPointIndex + 1] : groupElement.children[this.currentSeriesIndex];
            }
            this.currentPointIndex = 0;
            this.currentSeriesIndex = 0;
          } else if (this.previousTargetId.indexOf("_chart_legend_page") > -1 && targetId.indexOf("_chart_legend_page") === -1 && targetId.indexOf("_chart_legend_g_") === -1) {
            this.setTabIndex(e.target, getElement2(this.element.id + "_chart_legend_pageup"));
          } else if (this.previousTargetId.indexOf("_chart_legend_g_") > -1 && targetId.indexOf("_chart_legend_g_") === -1) {
            groupElement = getElement2(this.element.id + "_chart_legend_translate_g");
            this.setTabIndex(groupElement.children[this.currentLegendIndex], groupElement.firstElementChild);
          }
        }
        this.previousTargetId = targetId;
        if (targetId.indexOf("SeriesGroup") > -1) {
          this.currentSeriesIndex = +targetId.split("SeriesGroup")[1];
          targetElement.removeAttribute("tabindex");
          targetElement.blur();
          if (targetElement.children[1].id.indexOf("_Point_") === -1) {
            markerGroup = getElement2(this.element.id + "SymbolGroup" + targetId.split("SeriesGroup")[1]);
          }
          targetId = this.focusChild(markerGroup != null ? markerGroup.children[1] : targetElement.children[1]);
        } else if (targetId.indexOf("_ChartTitle") > -1) {
          this.setNavigationStyle(targetId);
        }
        actionKey = targetId !== this.element.id ? "Tab" : "";
      } else if (e.code.indexOf("Arrow") > -1) {
        e.preventDefault();
        this.previousTargetId = targetId;
        if (targetId.indexOf("_chart_legend_page") > -1) {
          if (e.code === "ArrowLeft") {
            getElement2(this.element.id + "_chart_legend_pagedown").removeAttribute("tabindex");
            this.focusChild(getElement2(this.element.id + "_chart_legend_pageup"));
          } else if (e.code === "ArrowRight") {
            getElement2(this.element.id + "_chart_legend_pageup").removeAttribute("tabindex");
            this.focusChild(getElement2(this.element.id + "_chart_legend_pagedown"));
          }
        } else if (targetId.indexOf("_chart_legend_") > -1) {
          var legendElement_1 = targetElement.parentElement.children;
          legendElement_1[this.currentLegendIndex].removeAttribute("tabindex");
          this.currentLegendIndex += e.code === "ArrowUp" || e.code === "ArrowRight" ? 1 : -1;
          this.currentLegendIndex = this.getActualIndex(this.currentLegendIndex, legendElement_1.length);
          var currentLegend = legendElement_1[this.currentLegendIndex];
          this.focusChild(currentLegend);
          this.removeNavigationStyle();
          this.setNavigationStyle(currentLegend.id);
          targetId = currentLegend.children[1].id;
          actionKey = this.highlightMode !== "None" ? "ArrowMove" : "";
        } else if (targetId.indexOf("_Series_") > -1) {
          groupElement = targetElement.parentElement.parentElement;
          var currentPoint = e.target;
          targetElement.removeAttribute("tabindex");
          targetElement.blur();
          if (e.code === "ArrowRight" || e.code === "ArrowLeft") {
            var seriesIndexes = [];
            for (var i = 0; i < groupElement.children.length; i++) {
              if (groupElement.children[i].id.indexOf("SeriesGroup") > -1) {
                seriesIndexes.push(+groupElement.children[i].id.split("SeriesGroup")[1]);
              }
            }
            this.currentSeriesIndex = seriesIndexes.indexOf(this.currentSeriesIndex) + (e.code === "ArrowRight" ? 1 : -1);
            this.currentSeriesIndex = seriesIndexes[this.getActualIndex(this.currentSeriesIndex, seriesIndexes.length)];
          } else {
            this.currentPointIndex += e.code === "ArrowUp" ? 1 : -1;
          }
          if (targetId.indexOf("_Symbol") > -1) {
            this.currentPointIndex = this.getActualIndex(this.currentPointIndex, getElement2(this.element.id + "SymbolGroup" + this.currentSeriesIndex).childElementCount - 1);
            currentPoint = getElement2(this.element.id + "_Series_" + this.currentSeriesIndex + "_Point_" + this.currentPointIndex + "_Symbol");
          } else if (targetId.indexOf("_Point_") > -1) {
            this.currentPointIndex = this.getActualIndex(this.currentPointIndex, getElement2(this.element.id + "SeriesGroup" + this.currentSeriesIndex).childElementCount - 1);
            currentPoint = getElement2(this.element.id + "_Series_" + this.currentSeriesIndex + "_Point_" + this.currentPointIndex);
          }
          targetId = this.focusChild(currentPoint);
          actionKey = "ArrowMove";
        }
      } else if ((e.code === "Enter" || e.code === "Space") && (targetId.indexOf("_chart_legend_") > -1 || targetId.indexOf("_Point_") > -1)) {
        targetId = targetId.indexOf("_chart_legend_page") > -1 ? targetId : targetId.indexOf("_chart_legend_") > -1 ? targetElement.children[1].id : targetId;
        actionKey = "Enter";
      }
      if (actionKey !== "") {
        this.chartKeyboardNavigations(e, targetId, actionKey);
      }
      return false;
    };
    Chart2.prototype.setTabIndex = function(previousElement, currentElement) {
      if (previousElement) {
        previousElement.removeAttribute("tabindex");
      }
      if (currentElement) {
        currentElement.setAttribute("tabindex", "0");
      }
    };
    Chart2.prototype.getActualIndex = function(index, totalLength) {
      return index > totalLength - 1 ? 0 : index < 0 ? totalLength - 1 : index;
    };
    Chart2.prototype.focusChild = function(element) {
      element.setAttribute("tabindex", "0");
      var className = element.getAttribute("class");
      element.setAttribute("tabindex", "0");
      if (className && className.indexOf("e-chart-focused") === -1) {
        className = "e-chart-focused " + className;
      } else if (!className) {
        className = "e-chart-focused";
      }
      element.setAttribute("class", className);
      element.focus();
      return element.id;
    };
    Chart2.prototype.documentKeyHandler = function(e) {
      if (e.altKey && e.keyCode === 74 && !isNullOrUndefined(this.element)) {
        this.element.focus();
        this.setNavigationStyle(this.element.id);
      }
    };
    Chart2.prototype.setNavigationStyle = function(target) {
      var currentElement = document.getElementById(target);
      if (currentElement) {
        currentElement.style.setProperty("outline", this.focusBorderWidth + "px solid " + (this.focusBorderColor || this.themeStyle.tabColor));
        currentElement.style.setProperty("margin", this.focusBorderMargin + "px");
      }
    };
    Chart2.prototype.removeNavigationStyle = function() {
      var currentElement = document.querySelectorAll("[id*=_Point_], [id*=" + this.element.id + "], [id*=_ChartBorder], text[id*=_ChartTitle],g[id*=_chart_legend],  text[id*=_ChartSubTitle], div[id*=_Annotation], g[id*=IndicatorGroup], g[id*=_Zooming_Zoom], g[id*=_Zooming_ZoomIn], g[id*=_Zooming_ZoomOut], g[id*=_Zooming_Pan], g[id*=_Zooming_Reset], path[id*=_TrendLine_]");
      if (currentElement) {
        currentElement.forEach(function(element) {
          if (element instanceof HTMLElement || element instanceof SVGElement) {
            element.style.setProperty("outline", "none");
            element.style.setProperty("margin", "");
          }
        });
      }
    };
    Chart2.prototype.chartKeyboardNavigations = function(e, targetId, actionKey) {
      this.isLegendClicked = false;
      this.removeNavigationStyle();
      if (actionKey !== "Enter" && actionKey !== "Space") {
        this.setNavigationStyle(targetId);
      }
      switch (actionKey) {
        case "Tab":
        case "ArrowMove":
          if (this.highlightModule) {
            this.highlightModule.removeLegendHighlightStyles();
          }
          if (targetId.indexOf("_Point_") > -1) {
            var seriesIndex = +targetId.split("_Series_")[1].split("_Point_")[0];
            var pointIndex = +targetId.split("_Series_")[1].replace("_Symbol", "").split("_Point_")[1];
            var pointRegion = this.visibleSeries[seriesIndex].points[pointIndex].symbolLocations[0];
            this.mouseX = pointRegion.x + this.initialClipRect.x - (this.visibleSeries[seriesIndex].type.indexOf("StackingBar") > -1 ? this.visibleSeries[seriesIndex].marker.height / 2 : 0);
            this.mouseY = pointRegion.y + this.initialClipRect.y + (this.visibleSeries[seriesIndex].type.indexOf("StackingColumn") > -1 ? this.visibleSeries[seriesIndex].marker.height / 2 : 0);
            if (this.highlightModule) {
              this.highlightModule.highlightChart(document.getElementById(targetId), "mousemove");
              this.highlightModule.completeSelection(document.getElementById(targetId), "mousemove");
            }
            if (this.tooltipModule) {
              this.tooltipModule.tooltip();
            }
          }
          if (this.highlightModule && this.highlightMode !== "None") {
            targetId = targetId.indexOf("_chart_legend_g_") > -1 ? document.getElementById(targetId).firstChild["id"] : targetId;
            var legendID = this.element.id + "_chart_legend";
            var legendItemsId = [legendID + "_text_", legendID + "_shape_marker_", legendID + "_shape_"];
            for (var i = 0; i < legendItemsId.length; i++) {
              var id = legendItemsId[i];
              if (targetId.indexOf(id) > -1) {
                document.getElementById(targetId).setAttribute("class", "");
                this.highlightModule.legendSelection(this, parseInt(targetId.split(id)[1], 10), document.getElementById(targetId), "mousemove");
                break;
              }
            }
          }
          break;
        case "Enter":
        case "Space":
          if (targetId.indexOf("_chart_legend_") > -1) {
            this.isLegendClicked = true;
            this.legendModule.click(e);
            this.focusChild(document.getElementById(targetId).parentElement);
            this.setNavigationStyle(document.getElementById(targetId).parentElement.id);
          } else {
            if (this.selectionModule) {
              this.selectionModule.calculateSelectedElements(document.getElementById(targetId), "click");
            }
            this.setNavigationStyle(targetId);
          }
          break;
        case "CtrlP":
          this.print();
          break;
        case "ESC":
          this.tooltipModule.removeTooltip(1);
          break;
        case "Equal":
        case "Minus":
          this.zoomModule.isZoomed = this.zoomModule.performedUI = true;
          this.zoomModule.isPanning = this.isChartDrag = false;
          if (actionKey === "Equal") {
            this.zoomModule.toolkit.zoomInOutCalculation(1, this, this.axisCollections, this.zoomSettings.mode);
          } else {
            this.zoomModule.toolkit.zoomInOutCalculation(-1, this, this.axisCollections, this.zoomSettings.mode);
          }
          this.zoomModule.performZoomRedraw(this);
          this.element.focus();
          break;
        case "ArrowUp":
        case "ArrowDown":
        case "ArrowLeft":
        case "ArrowRight": {
          var yArrowPadding = actionKey === "ArrowUp" ? 10 : actionKey === "ArrowDown" ? -10 : 0;
          var xArrowPadding = actionKey === "ArrowLeft" ? -10 : actionKey === "ArrowRight" ? 10 : 0;
          this.zoomModule.isPanning = this.isChartDrag = true;
          this.zoomModule.doPan(this, this.axisCollections, xArrowPadding, yArrowPadding);
          this.zoomModule.performZoomRedraw(this);
          this.element.focus();
          break;
        }
        case "R":
          this.zoomModule.toolkit.reset(e);
          break;
      }
    };
    Chart2.prototype.chartOnMouseClick = function(e) {
      var _this = this;
      var element = e.target;
      var chart = this;
      this.clickCount++;
      var XYvalues = this.FindXYPointValue(chart.mouseX, chart.mouseY);
      var timeInterval = 400;
      if (this.clickCount === 1) {
        this.singleClickTimer = +setTimeout(function() {
          chart.clickCount = 0;
          chart.trigger(chartMouseClick, {
            target: element.id,
            x: chart.mouseX,
            y: chart.mouseY,
            axisData: XYvalues
          });
        }, timeInterval);
      } else if (this.clickCount === 2 && !this.pointDoubleClick) {
        clearTimeout(this.singleClickTimer);
        this.clickCount = 0;
      }
      var isAngular = "isAngular";
      if (this[isAngular]) {
        var observers = "observers";
        timeInterval = this.pointDoubleClick[observers].length > 0 ? 400 : 0;
      } else {
        timeInterval = this.pointDoubleClick ? 400 : 0;
      }
      if (this.clickCount === 1 && this.pointClick) {
        this.singleClickTimer = +setTimeout(function() {
          _this.clickCount = 0;
          _this.triggerPointEvent(pointClick, e);
        }, timeInterval);
      } else if (this.clickCount === 2 && this.pointDoubleClick) {
        clearTimeout(this.singleClickTimer);
        this.clickCount = 0;
        this.triggerPointEvent(pointDoubleClick, e);
      }
      if (this.axisLabelClick) {
        this.triggerAxisLabelClickEvent(axisLabelClick, e);
      }
      this.removeNavigationStyle();
      this.notify("click", e);
      return false;
    };
    Chart2.prototype.FindXYPointValue = function(mouseX, mouseY) {
      if (withInBounds(mouseX, mouseY, this.chartAxisLayoutPanel.seriesClipRect) && this.series.some(function(series) {
        return series.visible;
      })) {
        var axis = void 0;
        var Xvalue = void 0;
        var Yvalue = void 0;
        var axisData = {};
        for (var k = 0, length_1 = this.axisCollections.length; k < length_1; k++) {
          axis = this.axisCollections[k];
          if (axis.orientation === "Horizontal") {
            Xvalue = getValueXByPoint(Math.abs(mouseX - axis.rect.x), axis.rect.width, axis);
            axisData[this.axisCollections[k].name] = Xvalue;
          } else {
            Yvalue = getValueYByPoint(Math.abs(mouseY - axis.rect.y), axis.rect.height, axis);
            axisData[this.axisCollections[k].name] = Yvalue;
          }
        }
        return axisData;
      }
      return null;
    };
    Chart2.prototype.triggerPointEvent = function(event2, e) {
      var evt = e;
      var data = new ChartData(this);
      var pointData = data.getData();
      if (pointData.series && pointData.point) {
        this.trigger(event2, {
          series: this.isBlazor ? {} : pointData.series,
          point: pointData.point,
          seriesIndex: pointData.series.index,
          pointIndex: pointData.point.index,
          x: this.mouseX,
          y: this.mouseY,
          pageX: evt.pageX,
          pageY: evt.pageY
        });
      }
    };
    Chart2.prototype.triggerAxisLabelClickEvent = function(event2, e) {
      var targetElement = e.target;
      var clickEvt = e;
      if (targetElement.id.indexOf("_AxisLabel_") !== -1) {
        var index = targetElement.id.split("_AxisLabel_");
        var axisIndex = +index[0].slice(-1);
        var labelIndex = +index[1];
        var currentAxis = this.axisCollections[axisIndex];
        if (currentAxis.visible && (axisIndex === 0 || axisIndex === 1)) {
          this.trigger(event2, {
            chart: this,
            axis: currentAxis,
            text: currentAxis.visibleLabels[labelIndex].text,
            labelID: targetElement.id,
            index: labelIndex,
            location: new ChartLocation(clickEvt.pageX, clickEvt.pageY),
            value: currentAxis.visibleLabels[labelIndex].value
          });
        }
      }
    };
    Chart2.prototype.chartOnMouseMove = function(e) {
      var element = e.target;
      var XYvalues = this.FindXYPointValue(this.mouseX, this.mouseY);
      this.trigger(chartMouseMove, {
        target: element.id,
        x: this.mouseX,
        y: this.mouseY,
        axisData: XYvalues
      });
      if (this.pointMove) {
        this.triggerPointEvent(pointMove, e);
      }
      if (!this.isTouch) {
        this.titleTooltip(e, this.mouseX, this.mouseY);
        this.axisTooltip(e, this.mouseX, this.mouseY);
      }
      if (this.dataEditingModule) {
        this.dataEditingModule.pointMouseMove(e);
      }
      if (this.crosshair.enable && this.startMove) {
        e.preventDefault();
      }
      this.notify(Browser.touchMoveEvent, e);
      this.isTouch = false;
      return false;
    };
    Chart2.prototype.titleTooltip = function(event2, x, y, isTouch) {
      var targetId = event2.target.id;
      var id = targetId === this.element.id + "_ChartTitle" || targetId === this.element.id + "_ChartSubTitle" || targetId.indexOf("_AxisTitle") > -1 || targetId.indexOf("_legend_title") > -1;
      var index = 0;
      if (targetId.indexOf("_AxisTitle") > -1) {
        index = parseInt(targetId.replace(this.element.id, "").replace("AxisLabel_", "").split("_")[2], 10);
      }
      if (id && event2.target.textContent.indexOf("...") > -1) {
        var title = targetId === this.element.id + "_ChartTitle" ? this.title : targetId.indexOf("_AxisTitle") > -1 ? this.axisCollections[index].title : targetId.indexOf("_ChartSubTitle") > -1 ? this.subTitle : this.legendSettings.title;
        showTooltip(title, x, y, this.element.offsetWidth, this.element.id + "_EJ2_Title_Tooltip", getElement2(this.element.id + "_Secondary_Element"), isTouch);
      } else {
        removeElement2(this.element.id + "_EJ2_Title_Tooltip");
      }
    };
    Chart2.prototype.axisTooltip = function(event2, x, y, isTouch) {
      var targetId = event2.target.id;
      if ((targetId.indexOf("AxisLabel") > -1 || targetId.indexOf("Axis_MultiLevelLabel") > -1) && event2.target.textContent.indexOf("...") > -1) {
        var isTitleOrLegendEnabled = this.legendSettings.visible || this.primaryXAxis.title === "";
        showTooltip(this.findAxisLabel(targetId), x, y, this.element.offsetWidth, this.element.id + "_EJ2_AxisLabel_Tooltip", getElement2(this.element.id + "_Secondary_Element"), isTouch, isTitleOrLegendEnabled);
      } else {
        removeElement2(this.element.id + "_EJ2_AxisLabel_Tooltip");
      }
    };
    Chart2.prototype.findAxisLabel = function(text) {
      var texts;
      if (text.indexOf("AxisLabel") > -1) {
        texts = text.replace(this.element.id, "").replace("AxisLabel_", "").split("_");
        return this.axisCollections[parseInt(texts[0], 10)].visibleLabels[parseInt(texts[1], 10)].originalText;
      } else {
        texts = text.replace(this.element.id, "").replace("Axis_MultiLevelLabel_Level_", "").replace("Text_", "").split("_");
        return this.axisCollections[parseInt(texts[0], 10)].multiLevelLabels[parseInt(texts[1], 10)].categories[parseInt(texts[2], 10)].text;
      }
    };
    Chart2.prototype.chartOnMouseDown = function(e) {
      var pageX;
      var pageY;
      var target;
      var touchArg;
      var XYvalues = this.FindXYPointValue(this.mouseX, this.mouseY);
      var offset = Browser.isDevice ? 20 : 30;
      var rect = this.element.getBoundingClientRect();
      var element = e.target;
      if (this.stockChart && this.stockChart.zoomSettings.enablePan) {
        this.allowPan = true;
      }
      this.trigger(chartMouseDown, {
        target: element.id,
        x: this.mouseX,
        y: this.mouseY,
        axisData: XYvalues
      });
      if (e.type === "touchstart") {
        this.isTouch = true;
        touchArg = e;
        pageX = touchArg.changedTouches[0].clientX;
        pageY = touchArg.changedTouches[0].clientY;
        target = touchArg.target;
      } else {
        this.isTouch = e.pointerType === "touch";
        pageX = e.clientX;
        pageY = e.clientY;
        target = e.target;
      }
      var svgRect = getElement2(this.svgId).getBoundingClientRect();
      this.mouseDownX = this.previousMouseMoveX = pageX - rect.left - Math.max(svgRect.left - rect.left, 0);
      this.mouseDownY = this.previousMouseMoveY = pageY - rect.top - Math.max(svgRect.top - rect.top, 0);
      if (this.isTouch) {
        this.isDoubleTap = (/* @__PURE__ */ new Date()).getTime() < this.threshold && target.id.indexOf(this.element.id + "_Zooming_") === -1 && (this.mouseDownX - offset >= this.mouseX || this.mouseDownX + offset >= this.mouseX) && (this.mouseDownY - offset >= this.mouseY || this.mouseDownY + offset >= this.mouseY) && (this.mouseX - offset >= this.mouseDownX || this.mouseX + offset >= this.mouseDownX) && (this.mouseY - offset >= this.mouseDownY || this.mouseY + offset >= this.mouseDownY);
      }
      if (this.dataEditingModule) {
        this.dataEditingModule.pointMouseDown();
      }
      this.notify(Browser.touchStartEvent, e);
      return false;
    };
    Chart2.prototype.mouseEnd = function(e) {
      var pageY;
      var pageX;
      var touchArg;
      if (e.type === "touchend") {
        touchArg = e;
        pageX = touchArg.changedTouches[0].clientX;
        this.isTouch = true;
        pageY = touchArg.changedTouches[0].clientY;
      } else {
        pageY = e.clientY;
        pageX = e.clientX;
        this.isTouch = e.pointerType === "touch" || e.pointerType === "2";
      }
      this.setMouseXY(pageX, pageY);
      this.chartOnMouseUp(e);
      return false;
    };
    Chart2.prototype.chartOnMouseUp = function(e) {
      var element = e.target;
      var XYvalues = this.FindXYPointValue(this.mouseX, this.mouseY);
      this.trigger(chartMouseUp, {
        target: element.id,
        x: this.mouseX,
        y: this.mouseY,
        axisData: XYvalues
      });
      this.isChartDrag = false;
      this.allowPan = false;
      if (this.isTouch) {
        this.titleTooltip(e, this.mouseX, this.mouseY, this.isTouch);
        this.axisTooltip(e, this.mouseX, this.mouseY, this.isTouch);
        this.threshold = (/* @__PURE__ */ new Date()).getTime() + 300;
      }
      if (this.dataEditingModule) {
        this.dataEditingModule.pointMouseUp();
      }
      if (!this.enableCanvas && this.seriesElements) {
        this.seriesElements.removeAttribute("clip-path");
      }
      this.notify(Browser.touchEndEvent, e);
      return false;
    };
    Chart2.prototype.setCulture = function() {
      this.intl = new Internationalization();
      this.setLocaleConstants();
      this.localeObject = new L10n(this.getModuleName(), this.defaultLocalConstants, this.locale);
    };
    Chart2.prototype.setAnnotationValue = function(annotationIndex, content) {
      var parentNode = getElement2(this.element.id + "_Annotation_Collections");
      var annotation = this.annotations[annotationIndex];
      var element;
      if (content !== null) {
        annotation.content = content;
        if (parentNode) {
          removeElement2(this.element.id + "_Annotation_" + annotationIndex);
          element = this.createElement("div");
          this.annotationModule.processAnnotation(annotation, annotationIndex, element);
          parentNode.appendChild(element.children[0]);
        } else {
          this.annotationModule.renderAnnotations(getElement2(this.element.id + "_Secondary_Element"));
        }
      }
    };
    Chart2.prototype.setLocaleConstants = function() {
      this.defaultLocalConstants = {
        ZoomIn: "Zoom in",
        Zoom: "Zoom",
        ZoomOut: "Zoom out",
        Pan: "Pan",
        Reset: "Reset",
        ResetZoom: "Reset Zoom"
      };
    };
    Chart2.prototype.setTheme = function() {
      this.themeStyle = getThemeColor(this.theme, this.enableCanvas, this);
    };
    Chart2.prototype.requiredModules = function() {
      var _this = this;
      var modules = [];
      var series = this.series;
      var enableAnnotation = false;
      var moduleName;
      var errorBarVisible = false;
      var isPointDrag = false;
      var dataLabelEnable = false;
      var zooming = this.zoomSettings;
      this.chartAreaType = series.length > 0 && (series[0].type === "Polar" || series[0].type === "Radar") ? "PolarRadar" : "Cartesian";
      if (this.tooltip.enable) {
        modules.push({
          member: "Tooltip",
          args: [this]
        });
      }
      series.map(function(value) {
        _this.isLegend = _this.legendSettings.visible && (value.name !== "" || !!_this.isLegend);
        moduleName = value.type.indexOf("100") !== -1 ? value.type.replace("100", "") + "Series" : value.type + "Series";
        errorBarVisible = value.errorBar.visible || errorBarVisible;
        dataLabelEnable = value.marker.dataLabel.visible || dataLabelEnable || value.type === "Pareto" && value.paretoOptions.marker.dataLabel.visible;
        isPointDrag = value.dragSettings.enable || isPointDrag;
        if (!modules.some(function(currentModule) {
          return currentModule.member === moduleName;
        })) {
          modules.push({
            member: moduleName,
            args: [_this, series]
          });
        }
        if (_this.chartAreaType === "PolarRadar") {
          modules.push({
            member: value.drawType + "Series",
            args: [_this, series]
          });
        }
        if (value.type === "Pareto") {
          modules.push({
            member: "ColumnSeries",
            args: [_this, series]
          });
          modules.push({
            member: "LineSeries",
            args: [_this, series]
          });
        }
      });
      this.findIndicatorModules(modules);
      this.findTrendLineModules(modules);
      modules = this.findAxisModule(modules);
      enableAnnotation = this.annotations.some(function(value) {
        return value.content !== null;
      });
      if (errorBarVisible) {
        modules.push({
          member: "ErrorBar",
          args: [this, series]
        });
      }
      if (this.isLegend) {
        modules.push({
          member: "Legend",
          args: [this]
        });
      }
      if (this.enableExport || this.allowExport) {
        modules.push({
          member: "Export",
          args: [this]
        });
      }
      if (this.chartAreaType !== "PolarRadar" && this.crosshair.enable) {
        modules.push({
          member: "Crosshair",
          args: [this]
        });
      }
      if (this.chartAreaType !== "PolarRadar" && !this.scrollSettingEnabled && (zooming.enableSelectionZooming || zooming.enableMouseWheelZooming || zooming.enablePinchZooming || zooming.enablePan || zooming.enableScrollbar || zooming.showToolbar)) {
        modules.push({
          member: "Zoom",
          args: [this, this.zoomSettings]
        });
        if (zooming.enableScrollbar) {
          modules.push({
            member: "ScrollBar",
            args: [this]
          });
        }
      }
      if (this.selectionMode !== "None" && !(this.chartAreaType === "PolarRadar" && this.selectionMode.indexOf("Drag") > -1)) {
        modules.push({
          member: "Selection",
          args: [this]
        });
      }
      if (this.highlightMode !== "None" || this.legendSettings.enableHighlight) {
        modules.push({
          member: "Highlight",
          args: [this]
        });
      }
      if (dataLabelEnable || this.stackLabels.visible) {
        modules.push({
          member: "DataLabel",
          args: [this, series]
        });
      }
      if (isPointDrag) {
        modules.push({
          member: "DataEditing",
          args: [this]
        });
      }
      if (enableAnnotation) {
        modules.push({
          member: "Annotation",
          args: [this]
        });
      }
      return modules;
    };
    Chart2.prototype.findAxisModule = function(modules) {
      var axisCollections = [];
      axisCollections.push(this.primaryXAxis);
      axisCollections.push(this.primaryYAxis);
      axisCollections = axisCollections.concat(this.axes);
      var datetimeEnabled = false;
      var categoryEnabled = false;
      var logarithmicEnabled = false;
      var striplineEnabled = false;
      var dateTimeCategoryEnabled = false;
      var multiLevelEnabled = false;
      for (var _i = 0, axisCollections_1 = axisCollections; _i < axisCollections_1.length; _i++) {
        var axis = axisCollections_1[_i];
        datetimeEnabled = axis.valueType === "DateTime" || datetimeEnabled;
        categoryEnabled = axis.valueType === "Category" || categoryEnabled;
        logarithmicEnabled = axis.valueType === "Logarithmic" || logarithmicEnabled;
        dateTimeCategoryEnabled = axis.valueType === "DateTimeCategory" || dateTimeCategoryEnabled;
        striplineEnabled = this.findStriplineVisibility(axis.stripLines) || striplineEnabled;
        multiLevelEnabled = axis.multiLevelLabels.length > 0 || multiLevelEnabled;
        this.scrollSettingEnabled = axis.scrollbarSettings.enable ? true : this.scrollSettingEnabled;
      }
      if (datetimeEnabled) {
        modules.push({
          member: "DateTime",
          args: [this]
        });
      }
      if (categoryEnabled) {
        modules.push({
          member: "Category",
          args: [this]
        });
      }
      if (logarithmicEnabled) {
        modules.push({
          member: "Logarithmic",
          args: [this]
        });
      }
      if (striplineEnabled) {
        modules.push({
          member: "StripLine",
          args: [this]
        });
      }
      if (multiLevelEnabled) {
        modules.push({
          member: "MultiLevelLabel",
          args: [this]
        });
      }
      if (dateTimeCategoryEnabled) {
        modules.push({
          member: "DateTimeCategory",
          args: [this]
        });
      }
      if (this.scrollSettingEnabled) {
        modules.push({
          member: "ScrollBar",
          args: [this]
        });
      }
      return modules;
    };
    Chart2.prototype.findIndicatorModules = function(modules) {
      var macdEnable;
      var bandEnable;
      var indicators = this.indicators;
      if (this.indicators.length) {
        modules.push({
          member: "LineSeries",
          args: [this]
        });
        indicators.map(function(indicator2) {
          macdEnable = macdEnable || indicator2.type === "Macd";
          bandEnable = bandEnable || indicator2.type === "BollingerBands";
        });
        if (macdEnable) {
          modules.push({
            member: "ColumnSeries",
            args: [this]
          });
        }
        if (bandEnable) {
          modules.push({
            member: "RangeAreaSeries",
            args: [this]
          });
        }
        if (bandEnable) {
          modules.push({
            member: "SplineRangeAreaSeries",
            args: [this]
          });
        }
        for (var _i = 0, _a = this.indicators; _i < _a.length; _i++) {
          var indicator = _a[_i];
          modules.push({
            member: indicator.type + "Indicator",
            args: [this]
          });
        }
      }
    };
    Chart2.prototype.findTrendLineModules = function(modules) {
      var isLine;
      var isSpline;
      var _loop_1 = function(series2) {
        var markerEnable;
        series2.trendlines.map(function(trendline) {
          markerEnable = markerEnable || trendline.marker.visible;
          isLine = isLine || trendline.type === "Linear" || trendline.type === "MovingAverage" ? true : false;
          isSpline = isSpline || !isLine || trendline.type === "Exponential" || trendline.type === "Logarithmic" || trendline.type === "Power" || trendline.type === "Polynomial" ? true : false;
        });
        if (markerEnable) {
          modules.push({
            member: "Marker",
            args: [this_1, series2]
          });
        }
      };
      var this_1 = this;
      for (var _i = 0, _a = this.series; _i < _a.length; _i++) {
        var series = _a[_i];
        _loop_1(series);
      }
      if (isLine || isSpline) {
        modules.push({
          member: "TrendLine",
          args: [this]
        });
      }
      if (isLine) {
        modules.push({
          member: "LineSeries",
          args: [this]
        });
      }
      if (isSpline) {
        modules.push({
          member: "SplineSeries",
          args: [this]
        });
      }
    };
    Chart2.prototype.findStriplineVisibility = function(striplines) {
      var visible = false;
      for (var _i = 0, striplines_1 = striplines; _i < striplines_1.length; _i++) {
        var stripline = striplines_1[_i];
        if (stripline.visible) {
          visible = true;
          break;
        }
      }
      return visible;
    };
    Chart2.prototype.removeSvg = function() {
      if (this.redraw) {
        return null;
      }
      blazorTemplatesReset(this);
      if (this.enableCanvas && this.svgObject && this.svgObject.tagName === "CANVAS") {
        this.renderer.clearRect(new Rect(0, 0, this.availableSize.width, this.availableSize.height));
        if (this.svgObject.parentNode) {
          remove(this.svgObject);
        }
        return null;
      }
      removeElement2(this.element.id + "_Secondary_Element");
      if (this.isReact) {
        this.clearTemplate();
      }
      var removeLength = 0;
      if (this.zoomModule && this.zoomModule.pinchTarget) {
        this.zoomModule.pinchTarget.id = "";
        this.zoomModule.pinchTarget.setAttribute("opacity", "0");
        this.svgObject.appendChild(this.zoomModule.pinchTarget);
        removeLength = 1;
      }
      if (!isNullOrUndefined(this.resizeTo)) {
        if (this.resizeTo !== this.checkResize && this.isBlazor && this.element.childElementCount) {
          var containerCollection = document.querySelectorAll(".e-chart");
          for (var index = 0; index < containerCollection.length; index++) {
            var container = containerCollection[index];
            while (container.firstChild) {
              remove(container.firstChild);
            }
          }
        }
        this.checkResize = this.resizeTo;
      }
      if (this.svgObject) {
        while (this.svgObject.childNodes.length > removeLength) {
          this.svgObject.removeChild(this.svgObject.firstChild);
        }
        if (!this.svgObject.hasChildNodes() && this.svgObject.parentNode && !this.stockChart) {
          remove(this.svgObject);
        }
      }
    };
    Chart2.prototype.refreshDefinition = function(definitions) {
      for (var _i = 0, definitions_1 = definitions; _i < definitions_1.length; _i++) {
        var item = definitions_1[_i];
        item.axes = [];
      }
    };
    Chart2.prototype.refreshAxis = function() {
      var axis = this.primaryXAxis;
      axis.rect = new Rect(void 0, void 0, 0, 0);
      axis = this.primaryYAxis;
      axis.isStack100 = false;
      axis.rect = new Rect(void 0, void 0, 0, 0);
      for (var _i = 0, _a = this.axes; _i < _a.length; _i++) {
        var item = _a[_i];
        axis = item;
        axis.rect = new Rect(void 0, void 0, 0, 0);
        axis.isStack100 = false;
      }
      if (this.paretoSeriesModule && this.series[0].type === "Pareto") {
        for (var _b = 0, _c = this.paretoSeriesModule.paretoAxes; _b < _c.length; _b++) {
          var item = _c[_b];
          axis = item;
          axis.rect = new Rect(void 0, void 0, 0, 0);
          axis.isStack100 = false;
        }
      }
    };
    Chart2.prototype.axisChange = function(axis) {
      if (!axis.name && !axis.valueType) {
        return false;
      }
      this.refreshDefinition(this.columns);
      this.refreshDefinition(this.rows);
      this.calculateVisibleAxis();
      this.processData();
      return true;
    };
    Chart2.prototype.getVisibleSeries = function(visibleSeries, index) {
      for (var _i = 0, visibleSeries_1 = visibleSeries; _i < visibleSeries_1.length; _i++) {
        var series = visibleSeries_1[_i];
        if (index === series.index) {
          return series;
        }
      }
      return null;
    };
    Chart2.prototype.refreshLiveData = function() {
      this.calculateVisibleSeries();
      this.initTechnicalIndicators();
      this.initTrendLines();
      this.refreshDefinition(this.columns);
      this.refreshDefinition(this.rows);
      this.calculateVisibleAxis();
      this.processData(false);
      if (!this.isBlazor) {
        if (this.enableCanvas) {
          this.createChartSvg();
        } else {
          this.removeSvg();
        }
        this.refreshAxis();
        this.refreshBound();
        this.trigger("loaded", {
          chart: this.isBlazor ? {} : this
        });
      }
    };
    Chart2.prototype.removeStyles = function() {
      removeElement2(this.element.id + "_ej2_chart_selection");
      removeElement2(this.element.id + "_ej2_chart_highlight");
    };
    Chart2.prototype.mouseMoveEvent = function() {
      if (this.tooltip.enable && this.previousPageX !== null && this.previousPageY !== null) {
        var mousemove = document.createEvent("MouseEvent");
        mousemove.initMouseEvent("mousemove", true, false, window, 1, 100, 100, this.previousPageX, this.previousPageY, false, false, false, false, 0, null);
        this.element.dispatchEvent(mousemove);
      }
    };
    Chart2.prototype.showTooltip = function(x, y, isPoint) {
      if (isPoint === void 0) {
        isPoint = false;
      }
      if (isPoint) {
        for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
          var series = _a[_i];
          for (var _b = 0, _c = series.points; _b < _c.length; _b++) {
            var point = _c[_b];
            var pointX = series.xAxis.valueType === "DateTime" ? point.xValue : point.x;
            var xValue = x;
            if (series.xAxis.valueType === "DateTime") {
              xValue = new Date(xValue).getTime();
            }
            if (x === pointX && y === point.yValue) {
              this.mouseX = point.regions[0].x + this.chartAxisLayoutPanel.seriesClipRect.x;
              this.mouseY = point.regions[0].y + this.chartAxisLayoutPanel.seriesClipRect.y;
              this.tooltipModule.tooltip();
              this.markerRender.mouseMoveHandler();
              break;
            }
          }
        }
      } else {
        if (this.isTouch) {
          this.startMove = true;
        }
        this.mouseX = x;
        this.mouseY = y;
        this.tooltipModule.mouseMoveHandler();
        this.markerRender.mouseMoveHandler();
      }
    };
    Chart2.prototype.hideTooltip = function() {
      this.tooltipModule.removeTooltip(Browser.isDevice ? 2e3 : 1e3);
    };
    Chart2.prototype.showCrosshair = function(x, y) {
      this.mouseX = x;
      this.mouseY = y;
      this.isCrosshair = false;
      if (withInBounds(this.mouseX, this.mouseY, this.chartAxisLayoutPanel.seriesClipRect)) {
        this.crosshairModule.crosshair();
      } else {
        this.hideCrosshair();
      }
      this.isCrosshair = true;
    };
    Chart2.prototype.hideCrosshair = function() {
      this.crosshairModule.removeCrosshair(Browser.isDevice ? 2e3 : 1e3);
    };
    Chart2.prototype.sanitize = function(value) {
      if (this.enableHtmlSanitizer) {
        return SanitizeHtmlHelper.sanitize(value);
      }
      return value;
    };
    Chart2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var renderer = false;
      var refreshBounds = false;
      this.animateSeries = false;
      var axis;
      var axisChange = false;
      var isZooming = false;
      if (!this.delayRedraw && !this.zoomRedraw) {
        for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
          var prop = _a[_i];
          axisChange = axisChange || prop !== "primaryXAxis" && prop !== "primaryYAxis" && prop !== "axes";
          if (isZooming && axisChange) {
            this.redraw = false;
          }
          switch (prop) {
            case "primaryXAxis":
              axis = newProp.primaryXAxis;
              refreshBounds = this.axisChange(axis);
              if (newProp.primaryXAxis.edgeLabelPlacement) {
                renderer = true;
              }
              if (!newProp.primaryXAxis.crosshairTooltip) {
                refreshBounds = true;
              }
              if (newProp.primaryXAxis.scrollbarSettings) {
                refreshBounds = true;
              }
              if (!isNullOrUndefined(axis.isInversed) || !isNullOrUndefined(axis.opposedPosition)) {
                this.primaryXAxis.setIsInversedAndOpposedPosition();
              }
              if ((!this.primaryXAxis.zoomingScrollBar || !this.primaryXAxis.zoomingScrollBar.isScrollUI) && this.zoomModule && (!isNullOrUndefined(axis.zoomFactor) || !isNullOrUndefined(axis.zoomPosition))) {
                this.redraw = this.zoomSettings.enableAnimation && !axisChange;
                isZooming = this.zoomSettings.enableAnimation && !axisChange;
              }
              if (newProp.primaryXAxis.crosshairTooltip) {
                if (!newProp.primaryXAxis.crosshairTooltip.enable) {
                  removeElement2(this.element.id + "_axis_tooltip_0");
                  removeElement2(this.element.id + "_axis_tooltip_text_0");
                }
              }
              break;
            case "primaryYAxis":
              axis = newProp.primaryYAxis;
              refreshBounds = this.axisChange(axis);
              if (newProp.primaryYAxis.edgeLabelPlacement) {
                renderer = true;
              }
              if (!newProp.primaryYAxis.crosshairTooltip) {
                refreshBounds = true;
              }
              if (newProp.primaryYAxis.scrollbarSettings) {
                refreshBounds = true;
              }
              if (!isNullOrUndefined(axis.isInversed) || !isNullOrUndefined(axis.opposedPosition)) {
                this.primaryYAxis.setIsInversedAndOpposedPosition();
              }
              if ((!this.primaryYAxis.zoomingScrollBar || !this.primaryYAxis.zoomingScrollBar.isScrollUI) && this.zoomModule && (!isNullOrUndefined(axis.zoomFactor) || !isNullOrUndefined(axis.zoomPosition))) {
                this.redraw = this.zoomSettings.enableAnimation && !axisChange;
                isZooming = this.zoomSettings.enableAnimation && !axisChange;
              }
              if (newProp.primaryYAxis.crosshairTooltip) {
                if (!newProp.primaryYAxis.crosshairTooltip.enable) {
                  removeElement2(this.element.id + "_axis_tooltip_1");
                  removeElement2(this.element.id + "_axis_tooltip_text_1");
                }
              }
              break;
            case "axes":
              for (var _b = 0, _c = Object.keys(newProp.axes); _b < _c.length; _b++) {
                var index = _c[_b];
                axis = newProp.axes[index];
                refreshBounds = refreshBounds || this.axisChange(axis);
                if (!axis.crosshairTooltip) {
                  refreshBounds = true;
                }
                if (axis.scrollbarSettings) {
                  refreshBounds = true;
                }
                if (!isNullOrUndefined(axis.isInversed) || !isNullOrUndefined(axis.opposedPosition)) {
                  this.axes[index].setIsInversedAndOpposedPosition();
                }
                if ((!this.axes[index].zoomingScrollBar || !this.axes[index].zoomingScrollBar.isScrollUI) && this.zoomModule && (!isNullOrUndefined(axis.zoomFactor) || !isNullOrUndefined(axis.zoomPosition))) {
                  this.redraw = this.zoomSettings.enableAnimation && !axisChange;
                  isZooming = this.zoomSettings.enableAnimation && !axisChange;
                }
                if (axis.crosshairTooltip) {
                  if (!axis.crosshairTooltip.enable) {
                    removeElement2(this.element.id + "_axis_tooltip_" + this.axes[index].index);
                    removeElement2(this.element.id + "_axis_tooltip_text_" + this.axes[index].index);
                  }
                }
              }
              break;
            case "height":
            case "width":
              this.createChartSvg();
              refreshBounds = true;
              break;
            case "subTitle":
            case "title":
              refreshBounds = true;
              break;
            case "titleStyle":
              if (newProp.titleStyle && (newProp.titleStyle.size || newProp.titleStyle.textOverflow || newProp.titleStyle.position)) {
                refreshBounds = true;
              } else {
                renderer = true;
              }
              break;
            case "subTitleStyle":
              if (newProp.subTitleStyle && (newProp.subTitleStyle.size || newProp.subTitleStyle.textOverflow)) {
                refreshBounds = true;
              } else {
                renderer = true;
              }
              break;
            case "border":
              renderer = true;
              break;
            case "dataSource":
              this.processData(false);
              refreshBounds = true;
              break;
            case "enableCanvas":
              this.refresh();
              break;
            case "series": {
              var len = this.series.length;
              var seriesRefresh = false;
              var series = void 0;
              var blazorProp = void 0;
              for (var i = 0; i < len; i++) {
                series = newProp.series[i];
                if (this.isBlazor && series && (series.visible !== oldProp.series[i].visible || series.isClosed || series.marker || series.emptyPointSettings || series.type || series.boxPlotMode || series.showMean)) {
                  blazorProp = true;
                }
                if (!isNullOrUndefined(series) && (series.dataSource || series.query || series.errorBar || series.xName || series.yName || series.size || series.high || series.low || series.open || series.close || series.trendlines || series.fill || series.name || series.marker || series.width || series.binInterval || series.type || series.visible !== oldProp.series[i].visible || series.legendShape || series.emptyPointSettings || series.opacity || series.columnWidth || series.columnSpacing || series.opacity || series.dashArray || series.bearFillColor || series.bullFillColor || blazorProp)) {
                  extend(this.getVisibleSeries(this.visibleSeries, i), series, null, true);
                  seriesRefresh = true;
                }
              }
              if (seriesRefresh) {
                this.calculateAreaType();
                this.calculateVisibleSeries();
                this.initTechnicalIndicators();
                this.initTrendLines();
                this.refreshDefinition(this.columns);
                this.refreshDefinition(this.rows);
                this.calculateVisibleAxis();
                this.processData(false);
                refreshBounds = true;
              }
              break;
            }
            case "indicators":
              refreshBounds = true;
              break;
            case "zoomSettings":
              if (newProp.zoomSettings.enableScrollbar || oldProp.zoomSettings.enableScrollbar) {
                refreshBounds = true;
              }
              renderer = true;
              break;
            case "background":
              renderer = true;
              break;
            case "chartArea":
              if (newProp.chartArea.border && newProp.chartArea.border.width) {
                refreshBounds = true;
              }
              renderer = true;
              break;
            case "legendSettings":
              if (!newProp.legendSettings.background || !newProp.legendSettings.opacity) {
                refreshBounds = true;
              }
              renderer = true;
              break;
            case "palettes":
              this.calculateVisibleSeries();
              renderer = true;
              break;
            case "selectedDataIndexes":
              if (this.selectionModule) {
                this.selectionModule.currentMode = this.selectionMode;
                this.selectionModule.selectedDataIndexes = this.selectedDataIndexes;
                this.selectionModule.styleId = this.element.id + "_ej2_chart_selection";
                this.selectionModule.redrawSelection(this, oldProp.selectionMode, true);
              } else if (this.highlightModule) {
                this.highlightModule.currentMode = this.highlightMode;
                this.highlightModule.highlightDataIndexes = this.selectedDataIndexes;
                this.highlightModule.styleId = this.element.id + "_ej2_chart_highlight";
                this.highlightModule.redrawSelection(this, oldProp.selectionMode, true);
              }
              break;
            case "selectionMode":
              if (this.selectionModule && newProp.selectionMode && newProp.selectionMode.indexOf("Drag") === -1) {
                this.selectionModule.currentMode = this.selectionMode;
                if (oldProp.selectionMode === "None") {
                  this.selectionModule.invokeSelection(this);
                }
                this.selectionModule.styleId = this.element.id + "_ej2_chart_selection";
                this.selectionModule.redrawSelection(this, oldProp.selectionMode, true);
              }
              break;
            case "isMultiSelect":
              if (this.selectionModule && !newProp.isMultiSelect && this.selectionModule.selectedDataIndexes.length > 1) {
                this.selectionModule.currentMode = this.selectionMode;
                this.selectionModule.styleId = this.element.id + "_ej2_chart_selection";
                this.selectionModule.redrawSelection(this, oldProp.selectionMode);
              }
              break;
            case "highlightMode":
            case "selectionPattern":
            case "highlightPattern":
              this.removeStyles();
              renderer = true;
              break;
            case "theme":
              this.animateSeries = true;
              break;
            case "enableRtl":
            case "locale":
            case "currencyCode":
              if (this.isBlazor) {
                this.setCulture();
                renderer = true;
              } else {
                this.refresh();
              }
              break;
            case "tooltip":
              if (this.tooltipModule) {
                this.tooltipModule.previousPoints = [];
                if (this.tooltip.template) {
                  this.tooltipModule.template = this.tooltip.template;
                }
              }
              break;
          }
        }
        if (!refreshBounds && renderer) {
          this.rotatedDataLabelCollections = [];
          this.removeSvg();
          this.renderElements();
          this.trigger("loaded", {
            chart: this.isBlazor ? {} : this
          });
        }
        if (refreshBounds) {
          if (this.enableCanvas) {
            this.createChartSvg();
          } else {
            this.removeSvg();
          }
          if (this.isReact) {
            this.clearTemplate();
          }
          this.dragY = null;
          this.refreshAxis();
          this.refreshBound();
          this.trigger("loaded", {
            chart: this.isBlazor ? {} : this
          });
          this.redraw = false;
          this.animated = false;
        }
      }
      this.zoomRedraw = false;
    };
    __decorate7([Property(null)], Chart2.prototype, "width", void 0);
    __decorate7([Property(null)], Chart2.prototype, "height", void 0);
    __decorate7([Property("")], Chart2.prototype, "title", void 0);
    __decorate7([Property("")], Chart2.prototype, "dataSource", void 0);
    __decorate7([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, titleSettings)], Chart2.prototype, "titleStyle", void 0);
    __decorate7([Property("")], Chart2.prototype, "subTitle", void 0);
    __decorate7([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null,
      accessibility: {
        focusable: false
      }
    }, titleSettings)], Chart2.prototype, "subTitleStyle", void 0);
    __decorate7([Complex({}, Margin)], Chart2.prototype, "margin", void 0);
    __decorate7([Complex({
      color: "#DDDDDD",
      width: 0
    }, Border)], Chart2.prototype, "border", void 0);
    __decorate7([Property(null)], Chart2.prototype, "background", void 0);
    __decorate7([Complex({
      border: {
        color: null,
        width: 0.5
      },
      background: "transparent"
    }, ChartArea)], Chart2.prototype, "chartArea", void 0);
    __decorate7([Property(false)], Chart2.prototype, "enableHtmlSanitizer", void 0);
    __decorate7([Complex({
      name: "primaryXAxis"
    }, Axis)], Chart2.prototype, "primaryXAxis", void 0);
    __decorate7([Complex({
      name: "primaryYAxis"
    }, Axis)], Chart2.prototype, "primaryYAxis", void 0);
    __decorate7([Collection([{}], Row)], Chart2.prototype, "rows", void 0);
    __decorate7([Collection([{}], Column)], Chart2.prototype, "columns", void 0);
    __decorate7([Collection([{}], Axis)], Chart2.prototype, "axes", void 0);
    __decorate7([Collection([{}], Series)], Chart2.prototype, "series", void 0);
    __decorate7([Collection([{
      accessibility: {
        focusable: false
      }
    }], ChartAnnotationSettings)], Chart2.prototype, "annotations", void 0);
    __decorate7([Property([])], Chart2.prototype, "palettes", void 0);
    __decorate7([Property("Material")], Chart2.prototype, "theme", void 0);
    __decorate7([Complex({}, TooltipSettings)], Chart2.prototype, "tooltip", void 0);
    __decorate7([Complex({}, CrosshairSettings)], Chart2.prototype, "crosshair", void 0);
    __decorate7([Complex({}, LegendSettings)], Chart2.prototype, "legendSettings", void 0);
    __decorate7([Collection([{}], RangeColorSetting)], Chart2.prototype, "rangeColorSettings", void 0);
    __decorate7([Complex({}, ZoomSettings)], Chart2.prototype, "zoomSettings", void 0);
    __decorate7([Property("")], Chart2.prototype, "highlightColor", void 0);
    __decorate7([Property("None")], Chart2.prototype, "selectionMode", void 0);
    __decorate7([Property("None")], Chart2.prototype, "highlightMode", void 0);
    __decorate7([Property("None")], Chart2.prototype, "selectionPattern", void 0);
    __decorate7([Property("None")], Chart2.prototype, "highlightPattern", void 0);
    __decorate7([Property(false)], Chart2.prototype, "isMultiSelect", void 0);
    __decorate7([Property(false)], Chart2.prototype, "allowMultiSelection", void 0);
    __decorate7([Property(true)], Chart2.prototype, "enableExport", void 0);
    __decorate7([Property(false)], Chart2.prototype, "allowExport", void 0);
    __decorate7([Collection([], Indexes)], Chart2.prototype, "selectedDataIndexes", void 0);
    __decorate7([Property(false)], Chart2.prototype, "useGroupingSeparator", void 0);
    __decorate7([Property(false)], Chart2.prototype, "enableAutoIntervalOnBothAxis", void 0);
    __decorate7([Property(false)], Chart2.prototype, "isTransposed", void 0);
    __decorate7([Property(false)], Chart2.prototype, "enableCanvas", void 0);
    __decorate7([Property(null)], Chart2.prototype, "backgroundImage", void 0);
    __decorate7([Collection([], TechnicalIndicator)], Chart2.prototype, "indicators", void 0);
    __decorate7([Property(true)], Chart2.prototype, "enableAnimation", void 0);
    __decorate7([Property(null)], Chart2.prototype, "description", void 0);
    __decorate7([Property(1)], Chart2.prototype, "tabIndex", void 0);
    __decorate7([Property(true)], Chart2.prototype, "enableSideBySidePlacement", void 0);
    __decorate7([Complex({}, Accessibility)], Chart2.prototype, "accessibility", void 0);
    __decorate7([Property(null)], Chart2.prototype, "focusBorderColor", void 0);
    __decorate7([Property(1.5)], Chart2.prototype, "focusBorderWidth", void 0);
    __decorate7([Property(0)], Chart2.prototype, "focusBorderMargin", void 0);
    __decorate7([Complex({}, StackLabelSettings)], Chart2.prototype, "stackLabels", void 0);
    __decorate7([Event()], Chart2.prototype, "resized", void 0);
    __decorate7([Event()], Chart2.prototype, "beforeResize", void 0);
    __decorate7([Event()], Chart2.prototype, "annotationRender", void 0);
    __decorate7([Event()], Chart2.prototype, "beforePrint", void 0);
    __decorate7([Event()], Chart2.prototype, "loaded", void 0);
    __decorate7([Event()], Chart2.prototype, "beforeExport", void 0);
    __decorate7([Event()], Chart2.prototype, "afterExport", void 0);
    __decorate7([Event()], Chart2.prototype, "load", void 0);
    __decorate7([Event()], Chart2.prototype, "animationComplete", void 0);
    __decorate7([Event()], Chart2.prototype, "legendRender", void 0);
    __decorate7([Event()], Chart2.prototype, "textRender", void 0);
    __decorate7([Event()], Chart2.prototype, "pointRender", void 0);
    __decorate7([Event()], Chart2.prototype, "seriesRender", void 0);
    __decorate7([Event()], Chart2.prototype, "axisLabelRender", void 0);
    __decorate7([Event()], Chart2.prototype, "axisLabelClick", void 0);
    __decorate7([Event()], Chart2.prototype, "axisRangeCalculated", void 0);
    __decorate7([Event()], Chart2.prototype, "axisMultiLabelRender", void 0);
    __decorate7([Event()], Chart2.prototype, "legendClick", void 0);
    __decorate7([Event()], Chart2.prototype, "multiLevelLabelClick", void 0);
    __decorate7([Event()], Chart2.prototype, "tooltipRender", void 0);
    __decorate7([Event()], Chart2.prototype, "sharedTooltipRender", void 0);
    __decorate7([Event()], Chart2.prototype, "chartMouseMove", void 0);
    __decorate7([Event()], Chart2.prototype, "chartMouseClick", void 0);
    __decorate7([Event()], Chart2.prototype, "chartDoubleClick", void 0);
    __decorate7([Event()], Chart2.prototype, "pointClick", void 0);
    __decorate7([Event()], Chart2.prototype, "pointDoubleClick", void 0);
    __decorate7([Event()], Chart2.prototype, "pointMove", void 0);
    __decorate7([Event()], Chart2.prototype, "chartMouseLeave", void 0);
    __decorate7([Event()], Chart2.prototype, "chartMouseDown", void 0);
    __decorate7([Event()], Chart2.prototype, "chartMouseUp", void 0);
    __decorate7([Event()], Chart2.prototype, "dragComplete", void 0);
    __decorate7([Event()], Chart2.prototype, "selectionComplete", void 0);
    __decorate7([Event()], Chart2.prototype, "zoomComplete", void 0);
    __decorate7([Event()], Chart2.prototype, "onZooming", void 0);
    __decorate7([Event()], Chart2.prototype, "scrollStart", void 0);
    __decorate7([Event()], Chart2.prototype, "scrollEnd", void 0);
    __decorate7([Event()], Chart2.prototype, "scrollChanged", void 0);
    __decorate7([Event()], Chart2.prototype, "dragStart", void 0);
    __decorate7([Event()], Chart2.prototype, "drag", void 0);
    __decorate7([Event()], Chart2.prototype, "dragEnd", void 0);
    __decorate7([Property("USD")], Chart2.prototype, "currencyCode", void 0);
    Chart2 = __decorate7([NotifyPropertyChanges], Chart2);
    return Chart2;
  }(Component)
);

// node_modules/@syncfusion/ej2-charts/src/chart/axis/axis-helper.js
var __extends11 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var NiceInterval = (
  /** @class */
  function(_super) {
    __extends11(NiceInterval2, _super);
    function NiceInterval2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    NiceInterval2.prototype.calculateDateTimeNiceInterval = function(axis, size, start, end, isChart) {
      if (isChart === void 0) {
        isChart = true;
      }
      var oneDay = 24 * 60 * 60 * 1e3;
      var startDate = new Date(start);
      var endDate = new Date(end);
      var totalDays = Math.abs((startDate.getTime() - endDate.getTime()) / oneDay);
      var interval;
      axis.actualIntervalType = axis.intervalType;
      var type = axis.intervalType;
      switch (type) {
        case "Years":
          interval = this.calculateNumericNiceInterval(axis, totalDays / 365, size);
          break;
        case "Quarter":
          interval = this.calculateNumericNiceInterval(axis, totalDays / 365 * 4, size);
          break;
        case "Months":
          interval = this.calculateNumericNiceInterval(axis, totalDays / 30, size);
          break;
        case "Weeks":
          interval = this.calculateNumericNiceInterval(axis, totalDays / 7, size);
          break;
        case "Days":
          interval = this.calculateNumericNiceInterval(axis, totalDays, size);
          break;
        case "Hours":
          interval = this.calculateNumericNiceInterval(axis, totalDays * 24, size);
          break;
        case "Minutes":
          interval = this.calculateNumericNiceInterval(axis, totalDays * 24 * 60, size);
          break;
        case "Seconds":
          interval = this.calculateNumericNiceInterval(axis, totalDays * 24 * 60 * 60, size);
          break;
        case "Auto":
          interval = this.calculateNumericNiceInterval(axis, totalDays / 365, size);
          if (interval >= 1) {
            axis.actualIntervalType = "Years";
            return interval;
          }
          interval = this.calculateNumericNiceInterval(axis, totalDays / 30, size);
          if (interval >= 1) {
            axis.actualIntervalType = "Months";
            return interval;
          }
          interval = this.calculateNumericNiceInterval(axis, totalDays / 7, size);
          if (interval >= 1 && !isChart) {
            axis.actualIntervalType = "Weeks";
            return interval;
          }
          interval = this.calculateNumericNiceInterval(axis, totalDays, size);
          if (interval >= 1) {
            axis.actualIntervalType = "Days";
            return interval;
          }
          interval = this.calculateNumericNiceInterval(axis, totalDays * 24, size);
          if (interval >= 1) {
            axis.actualIntervalType = "Hours";
            return interval;
          }
          interval = this.calculateNumericNiceInterval(axis, totalDays * 24 * 60, size);
          if (interval >= 1) {
            axis.actualIntervalType = "Minutes";
            return interval;
          }
          interval = this.calculateNumericNiceInterval(axis, totalDays * 24 * 60 * 60, size);
          axis.actualIntervalType = "Seconds";
          return interval;
      }
      return interval;
    };
    NiceInterval2.prototype.getSkeleton = function(axis, currentValue, previousValue, isBlazor) {
      var skeleton;
      var intervalType = axis.actualIntervalType;
      if (axis.skeleton) {
        return axis.skeleton;
      }
      if (intervalType === "Years") {
        if (isBlazor) {
          skeleton = axis.isChart ? axis.valueType === "DateTime" ? "y" : "y" : "y";
        } else {
          skeleton = axis.isChart ? axis.valueType === "DateTime" && axis.isIntervalInDecimal ? "y" : "yMMM" : "y";
        }
      } else if (intervalType === "Quarter") {
        skeleton = isBlazor ? "y" : "yMMM";
      } else if (intervalType === "Months") {
        if (isBlazor) {
          skeleton = axis.isChart ? "m" : "m";
        } else {
          skeleton = axis.isChart ? "MMMd" : "MMM";
        }
      } else if (intervalType === "Weeks") {
        skeleton = isBlazor ? "m" : "MEd";
      } else if (intervalType === "Days") {
        if (isBlazor) {
          skeleton = "d";
        } else {
          skeleton = axis.isChart ? axis.valueType === "DateTime" ? "MMMd" : "yMd" : "MMMd";
        }
      } else if (intervalType === "Hours") {
        if (isBlazor) {
          skeleton = "t";
        } else {
          skeleton = axis.isChart ? axis.valueType === "DateTime" ? "Hm" : "EHm" : "h";
        }
      } else if (intervalType === "Minutes") {
        if (isBlazor) {
          skeleton = "T";
        } else {
          skeleton = axis.isChart ? "Hms" : "hm";
        }
      } else {
        if (isBlazor) {
          skeleton = "T";
        } else {
          skeleton = axis.isChart ? "Hms" : "hms";
        }
      }
      return skeleton;
    };
    NiceInterval2.prototype.findCustomFormats = function(axis) {
      var labelFormat = axis.labelFormat ? axis.labelFormat : "";
      if (axis.isChart && !axis.skeleton && axis.actualIntervalType === "Months" && !labelFormat) {
        labelFormat = axis.valueType === "DateTime" ? "MMM yyyy" : "yMMM";
      }
      return labelFormat;
    };
    return NiceInterval2;
  }(Double)
);

// node_modules/@syncfusion/ej2-charts/src/chart/axis/date-time-axis.js
var __extends12 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DateTime = (
  /** @class */
  function(_super) {
    __extends12(DateTime2, _super);
    function DateTime2(chart) {
      return _super.call(this, chart) || this;
    }
    DateTime2.prototype.calculateRangeAndInterval = function(size, axis) {
      this.calculateRange(axis);
      this.getActualRange(axis, size);
      this.applyRangePadding(axis, size);
      this.calculateVisibleLabels(axis, this.chart);
    };
    DateTime2.prototype.getActualRange = function(axis, size) {
      var option = {
        skeleton: "full",
        type: "dateTime"
      };
      var dateParser = this.chart.intl.getDateParser(option);
      var dateFormatter = this.chart.intl.getDateFormat(option);
      if (axis.minimum !== null) {
        this.min = this.chart.isBlazor ? Date.parse(axis.minimum.toString()) : Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({
          val: axis.minimum
        }).val))));
      } else if (this.min === null || this.min === Number.POSITIVE_INFINITY) {
        this.min = Date.parse(dateParser(dateFormatter(new Date(1970, 1, 1))));
      }
      if (axis.maximum !== null) {
        this.max = this.chart.isBlazor ? Date.parse(axis.maximum.toString()) : Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({
          val: axis.maximum
        }).val))));
      } else if (this.max === null || this.max === Number.NEGATIVE_INFINITY) {
        this.max = Date.parse(dateParser(dateFormatter(new Date(1970, 5, 1))));
      }
      if (this.min === this.max) {
        this.max = this.max + 2592e6;
        this.min = this.min - 2592e6;
      }
      axis.actualRange = {};
      axis.doubleRange = new DoubleRange(this.min, this.max);
      var datetimeInterval = this.calculateDateTimeNiceInterval(axis, size, axis.doubleRange.start, axis.doubleRange.end);
      if (!axis.interval) {
        axis.actualRange.interval = datetimeInterval;
      } else {
        axis.actualRange.interval = axis.interval;
      }
      axis.actualRange.min = axis.doubleRange.start;
      axis.actualRange.max = axis.doubleRange.end;
    };
    DateTime2.prototype.applyRangePadding = function(axis, size) {
      this.min = axis.actualRange.min;
      this.max = axis.actualRange.max;
      var minimum;
      var maximum;
      var interval = axis.actualRange.interval;
      if (!setRange(axis)) {
        var rangePadding = axis.getRangePadding(this.chart);
        minimum = new Date(this.min);
        maximum = new Date(this.max);
        var intervalType = axis.actualIntervalType;
        if (rangePadding === "None") {
          this.min = minimum.getTime();
          this.max = maximum.getTime();
        } else if (rangePadding === "Additional" || rangePadding === "Round") {
          switch (intervalType) {
            case "Years":
              this.getYear(minimum, maximum, rangePadding, interval);
              break;
            case "Months":
              this.getMonth(minimum, maximum, rangePadding, interval);
              break;
            case "Days":
              this.getDay(minimum, maximum, rangePadding, interval);
              break;
            case "Hours":
              this.getHour(minimum, maximum, rangePadding, interval);
              break;
            case "Minutes": {
              var minute = minimum.getMinutes() / interval * interval;
              var endMinute = maximum.getMinutes() + (minimum.getMinutes() - minute);
              if (rangePadding === "Round") {
                this.min = new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minute, 0).getTime();
                this.max = new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), endMinute, 59).getTime();
              } else {
                this.min = new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minute + -interval, 0).getTime();
                this.max = new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), endMinute + interval, 0).getTime();
              }
              break;
            }
            case "Seconds": {
              var second = minimum.getSeconds() / interval * interval;
              var endSecond = maximum.getSeconds() + (minimum.getSeconds() - second);
              if (rangePadding === "Round") {
                this.min = new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minimum.getMinutes(), second, 0).getTime();
                this.max = new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), maximum.getMinutes(), endSecond, 0).getTime();
              } else {
                this.min = new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minimum.getMinutes(), second + -interval, 0).getTime();
                this.max = new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), maximum.getMinutes(), endSecond + interval, 0).getTime();
              }
              break;
            }
          }
        }
      }
      axis.actualRange.min = axis.minimum != null ? this.min : this.min;
      axis.actualRange.max = axis.maximum != null ? this.max : this.max;
      axis.actualRange.delta = axis.actualRange.max - axis.actualRange.min;
      axis.doubleRange = new DoubleRange(axis.actualRange.min, axis.actualRange.max);
      this.calculateVisibleRange(size, axis);
    };
    DateTime2.prototype.getYear = function(minimum, maximum, rangePadding, interval) {
      var startYear = minimum.getFullYear();
      var endYear = maximum.getFullYear();
      if (rangePadding === "Additional") {
        this.min = new Date(startYear - interval, 1, 1, 0, 0, 0).getTime();
        this.max = new Date(endYear + interval, 1, 1, 0, 0, 0).getTime();
      } else {
        this.min = new Date(startYear, 0, 0, 0, 0, 0).getTime();
        this.max = new Date(endYear, 11, 30, 23, 59, 59).getTime();
      }
    };
    DateTime2.prototype.getMonth = function(minimum, maximum, rangePadding, interval) {
      var month = minimum.getMonth();
      var endMonth = maximum.getMonth();
      if (rangePadding === "Round") {
        this.min = new Date(minimum.getFullYear(), month, 0, 0, 0, 0).getTime();
        this.max = new Date(maximum.getFullYear(), endMonth, new Date(maximum.getFullYear(), maximum.getMonth(), 0).getDate(), 23, 59, 59).getTime();
      } else {
        this.min = new Date(minimum.getFullYear(), month + -interval, 1, 0, 0, 0).getTime();
        this.max = new Date(maximum.getFullYear(), endMonth + interval, endMonth === 2 ? 28 : 30, 0, 0, 0).getTime();
      }
    };
    DateTime2.prototype.getDay = function(minimum, maximum, rangePadding, interval) {
      var day = minimum.getDate();
      var endDay = maximum.getDate();
      if (rangePadding === "Round") {
        this.min = new Date(minimum.getFullYear(), minimum.getMonth(), day, 0, 0, 0).getTime();
        this.max = new Date(maximum.getFullYear(), maximum.getMonth(), endDay, 23, 59, 59).getTime();
      } else {
        this.min = new Date(minimum.getFullYear(), minimum.getMonth(), day + -interval, 0, 0, 0).getTime();
        this.max = new Date(maximum.getFullYear(), maximum.getMonth(), endDay + interval, 0, 0, 0).getTime();
      }
    };
    DateTime2.prototype.getHour = function(minimum, maximum, rangePadding, interval) {
      var hour = minimum.getHours() / interval * interval;
      var endHour = maximum.getHours() + (minimum.getHours() - hour);
      if (rangePadding === "Round") {
        this.min = new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), hour, 0, 0).getTime();
        this.max = new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), endHour, 59, 59).getTime();
      } else {
        this.min = new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), hour + -interval, 0, 0).getTime();
        this.max = new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), endHour + interval, 0, 0).getTime();
      }
    };
    DateTime2.prototype.calculateVisibleRange = function(size, axis) {
      axis.visibleRange = {
        min: axis.actualRange.min,
        max: axis.actualRange.max,
        interval: axis.actualRange.interval,
        delta: axis.actualRange.delta
      };
      var isLazyLoad = isNullOrUndefined(axis.zoomingScrollBar) ? false : axis.zoomingScrollBar.isLazyLoad;
      if (isZoomSet(axis) && !isLazyLoad) {
        axis.calculateVisibleRangeOnZooming();
        axis.visibleRange.interval = axis.enableAutoIntervalOnZooming ? this.calculateDateTimeNiceInterval(axis, size, axis.visibleRange.min, axis.visibleRange.max) : axis.visibleRange.interval;
      }
      axis.dateTimeInterval = this.increaseDateTimeInterval(axis, axis.visibleRange.min, axis.visibleRange.interval).getTime() - axis.visibleRange.min;
      axis.triggerRangeRender(this.chart, axis.visibleRange.min, axis.visibleRange.max, axis.visibleRange.interval);
    };
    DateTime2.prototype.calculateVisibleLabels = function(axis, chart) {
      axis.visibleLabels = [];
      var tempInterval = axis.visibleRange.min;
      var labelStyle;
      var previousValue;
      var isBlazor = chart.getModuleName() === "chart" ? chart.isBlazor : false;
      var axisLabels = axis.visibleLabels;
      if (axis.minimum === null) {
        tempInterval = this.alignRangeStart(axis, tempInterval, axis.visibleRange.interval).getTime();
      }
      if (this.startValue && this.startValue < tempInterval && chart.zoomModule && chart.zoomModule.isPanning) {
        tempInterval = this.startValue;
      } else {
        this.startValue = tempInterval;
      }
      while (tempInterval <= axis.visibleRange.max) {
        labelStyle = extend({}, getValue("properties", axis.labelStyle), null, true);
        previousValue = axisLabels.length ? axis.visibleLabels[axisLabels.length - 1].value : tempInterval;
        axis.format = chart.intl.getDateFormat({
          format: this.findCustomFormats(axis) || this.blazorCustomFormat(axis),
          type: firstToLowerCase(axis.skeletonType),
          skeleton: this.getSkeleton(axis, tempInterval, previousValue, isBlazor)
        });
        axis.startLabel = axis.format(new Date(axis.visibleRange.min));
        axis.endLabel = axis.format(new Date(axis.visibleRange.max));
        if (withIn(tempInterval, axis.visibleRange)) {
          var interval = this.increaseDateTimeInterval(axis, tempInterval, axis.visibleRange.interval).getTime();
          if (interval > axis.visibleRange.max) {
            axis.endLabel = axis.format(new Date(tempInterval));
          }
          triggerLabelRender(chart, tempInterval, axis.format(new Date(tempInterval)), labelStyle, axis);
        }
        var actualInterval = tempInterval;
        tempInterval = this.increaseDateTimeInterval(axis, tempInterval, axis.visibleRange.interval).getTime();
        if (actualInterval === tempInterval) {
          break;
        }
      }
      if ((axis.actualIntervalType === "Months" || axis.actualIntervalType === "Days") && axis.isChart) {
        axis.format = chart.intl.getDateFormat({
          format: axis.labelFormat || (axis.actualIntervalType === "Months" && !axis.skeleton ? "y MMM" : ""),
          type: firstToLowerCase(axis.skeletonType),
          skeleton: axis.skeleton || (axis.actualIntervalType === "Days" ? "MMMd" : "")
        });
      }
      if (axis.getMaxLabelWidth) {
        axis.getMaxLabelWidth(this.chart);
      }
    };
    DateTime2.prototype.blazorCustomFormat = function(axis) {
      if (this.chart.isBlazor) {
        return axis.actualIntervalType === "Years" ? axis.isIntervalInDecimal ? "yyyy" : "MMM y" : axis.actualIntervalType === "Days" && !axis.isIntervalInDecimal ? "ddd HH tt" : "";
      } else {
        return "";
      }
    };
    DateTime2.prototype.increaseDateTimeInterval = function(axis, value, interval) {
      var result = new Date(value);
      if (axis.interval) {
        axis.isIntervalInDecimal = interval % 1 === 0;
        axis.visibleRange.interval = interval;
      } else {
        interval = Math.ceil(interval);
        axis.visibleRange.interval = interval;
      }
      var intervalType = axis.actualIntervalType;
      if (axis.isIntervalInDecimal) {
        switch (intervalType) {
          case "Years":
            result.setFullYear(result.getFullYear() + interval);
            return result;
          case "Quarter":
            result.setMonth(result.getMonth() + 3 * interval);
            return result;
          case "Months":
            result.setMonth(result.getMonth() + interval);
            return result;
          case "Weeks":
            result.setDate(result.getDate() + interval * 7);
            return result;
          case "Days":
            result.setDate(result.getDate() + interval);
            return result;
          case "Hours":
            result.setHours(result.getHours() + interval);
            return result;
          case "Minutes":
            result.setMinutes(result.getMinutes() + interval);
            return result;
          case "Seconds":
            result.setSeconds(result.getSeconds() + interval);
            return result;
        }
      } else {
        result = this.getDecimalInterval(result, interval, intervalType);
      }
      return result;
    };
    DateTime2.prototype.alignRangeStart = function(axis, sDate, intervalSize) {
      var sResult = new Date(sDate);
      switch (axis.actualIntervalType) {
        case "Years": {
          var year = Math.floor(Math.floor(sResult.getFullYear() / intervalSize) * intervalSize);
          sResult = new Date(year, sResult.getMonth(), sResult.getDate(), 0, 0, 0);
          return sResult;
        }
        case "Months": {
          var month = Math.floor(Math.floor(sResult.getMonth() / intervalSize) * intervalSize);
          sResult = new Date(sResult.getFullYear(), month, sResult.getDate(), 0, 0, 0);
          return sResult;
        }
        case "Days": {
          var day = Math.floor(Math.floor(sResult.getDate() / intervalSize) * intervalSize);
          sResult = new Date(sResult.getFullYear(), sResult.getMonth(), day, 0, 0, 0);
          return sResult;
        }
        case "Hours": {
          var hour = Math.floor(Math.floor(sResult.getHours() / intervalSize) * intervalSize);
          sResult = new Date(sResult.getFullYear(), sResult.getMonth(), sResult.getDate(), hour, 0, 0);
          return sResult;
        }
        case "Minutes": {
          var minutes = Math.floor(Math.floor(sResult.getMinutes() / intervalSize) * intervalSize);
          sResult = new Date(sResult.getFullYear(), sResult.getMonth(), sResult.getDate(), sResult.getHours(), minutes, 0, 0);
          return sResult;
        }
        case "Seconds": {
          var seconds = Math.floor(Math.floor(sResult.getSeconds() / intervalSize) * intervalSize);
          sResult = new Date(sResult.getFullYear(), sResult.getMonth(), sResult.getDate(), sResult.getHours(), sResult.getMinutes(), seconds, 0);
          return sResult;
        }
      }
      return sResult;
    };
    DateTime2.prototype.getDecimalInterval = function(result, interval, intervalType) {
      var roundValue = Math.floor(interval);
      var decimalValue = interval - roundValue;
      switch (intervalType) {
        case "Years": {
          var month = Math.round(12 * decimalValue);
          result.setFullYear(result.getFullYear() + roundValue);
          result.setMonth(result.getMonth() + month);
          return result;
        }
        case "Quarter":
          result.setMonth(result.getMonth() + 3 * interval);
          return result;
        case "Months": {
          var days = Math.round(30 * decimalValue);
          result.setMonth(result.getMonth() + roundValue);
          result.setDate(result.getDate() + days);
          return result;
        }
        case "Weeks":
          result.setDate(result.getDate() + interval * 7);
          return result;
        case "Days": {
          var hour = Math.round(24 * decimalValue);
          result.setDate(result.getDate() + roundValue);
          result.setHours(result.getHours() + hour);
          return result;
        }
        case "Hours": {
          var min = Math.round(60 * decimalValue);
          result.setHours(result.getHours() + roundValue);
          result.setMinutes(result.getMinutes() + min);
          return result;
        }
        case "Minutes": {
          var sec = Math.round(60 * decimalValue);
          result.setMinutes(result.getMinutes() + roundValue);
          result.setSeconds(result.getSeconds() + sec);
          return result;
        }
        case "Seconds": {
          var milliSec = Math.round(1e3 * decimalValue);
          result.setSeconds(result.getSeconds() + roundValue);
          result.setMilliseconds(result.getMilliseconds() + milliSec);
          return result;
        }
      }
      return result;
    };
    DateTime2.prototype.getModuleName = function() {
      return "DateTime";
    };
    DateTime2.prototype.destroy = function() {
    };
    return DateTime2;
  }(NiceInterval)
);

// node_modules/@syncfusion/ej2-charts/src/chart/axis/category-axis.js
var __extends13 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Category = (
  /** @class */
  function(_super) {
    __extends13(Category2, _super);
    function Category2(chart) {
      return _super.call(this, chart) || this;
    }
    Category2.prototype.calculateRangeAndInterval = function(size, axis) {
      this.calculateRange(axis);
      this.getActualRange(axis, size);
      this.applyRangePadding(axis, size);
      this.calculateVisibleLabels(axis);
    };
    Category2.prototype.getActualRange = function(axis, size) {
      this.initializeDoubleRange(axis);
      axis.actualRange = {};
      if (!axis.interval) {
        axis.actualRange.interval = Math.max(1, Math.floor(axis.doubleRange.delta / getActualDesiredIntervalsCount(size, axis)));
      } else {
        axis.actualRange.interval = Math.ceil(axis.interval);
      }
      axis.actualRange.min = axis.doubleRange.start;
      axis.actualRange.max = axis.doubleRange.end;
      axis.actualRange.delta = axis.doubleRange.delta;
    };
    Category2.prototype.applyRangePadding = function(axis, size) {
      var isColumn;
      axis.series.forEach(function(element) {
        if (!isColumn) {
          isColumn = (element.type.indexOf("Column") > -1 || element.type.indexOf("Bar") > -1) && !(axis.zoomFactor < 1 || axis.zoomPosition > 0) && isNullOrUndefined(axis.minimum) && isNullOrUndefined(axis.maximum);
        }
      });
      var ticks = (axis.labelPlacement === "BetweenTicks" || isColumn) && !this.chart.stockChart && this.chart.chartAreaType !== "PolarRadar" ? 0.5 : 0;
      if (ticks > 0) {
        axis.actualRange.min -= ticks;
        axis.actualRange.max += ticks;
      } else {
        axis.actualRange.max += axis.actualRange.max ? 0 : 0.5;
      }
      axis.doubleRange = new DoubleRange(axis.actualRange.min, axis.actualRange.max);
      axis.actualRange.delta = axis.doubleRange.delta;
      this.calculateVisibleRange(size, axis);
    };
    Category2.prototype.calculateVisibleLabels = function(axis) {
      axis.visibleLabels = [];
      axis.visibleRange.interval = axis.visibleRange.interval < 1 ? 1 : axis.visibleRange.interval;
      var tempInterval = axis.intervalOffset ? axis.intervalOffset : Math.ceil(axis.visibleRange.min);
      var labelStyle;
      if (axis.zoomFactor < 1 || axis.zoomPosition > 0) {
        tempInterval = axis.visibleRange.min - axis.visibleRange.min % axis.visibleRange.interval;
      }
      var position;
      axis.startLabel = axis.labels[Math.round(axis.visibleRange.min)];
      axis.endLabel = axis.labels[Math.floor(axis.visibleRange.max)];
      for (; tempInterval <= axis.visibleRange.max; tempInterval += axis.visibleRange.interval) {
        labelStyle = extend({}, getValue("properties", axis.labelStyle), null, true);
        if (withIn(tempInterval, axis.visibleRange) && axis.labels.length > 0) {
          position = Math.round(tempInterval);
          triggerLabelRender(this.chart, position, axis.labels[position] ? axis.labels[position].toString() : "", labelStyle, axis);
        }
      }
      if (axis.getMaxLabelWidth) {
        axis.getMaxLabelWidth(this.chart);
      }
    };
    Category2.prototype.getModuleName = function() {
      return "Category";
    };
    Category2.prototype.destroy = function() {
    };
    return Category2;
  }(NiceInterval)
);

// node_modules/@syncfusion/ej2-charts/src/chart/axis/logarithmic-axis.js
var __extends14 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Logarithmic = (
  /** @class */
  function(_super) {
    __extends14(Logarithmic2, _super);
    function Logarithmic2(chart) {
      return _super.call(this, chart) || this;
    }
    Logarithmic2.prototype.calculateRangeAndInterval = function(size, axis) {
      this.calculateRange(axis);
      this.getActualRange(axis, size);
      this.calculateVisibleRange(size, axis);
      this.calculateVisibleLabels(axis, this.chart);
    };
    Logarithmic2.prototype.getActualRange = function(axis, size) {
      this.initializeDoubleRange(axis);
      this.min = this.min < 0 ? 0 : this.min;
      var logStart = logBase(this.min, axis.logBase);
      logStart = isFinite(logStart) ? logStart : this.min;
      var logEnd = this.max === 1 ? 1 : logBase(this.max, axis.logBase);
      logEnd = isFinite(logStart) ? logEnd : this.max;
      this.min = Math.floor(logStart / 1);
      var isRectSeries = axis.series && axis.series.some(function(item) {
        return (item.type.indexOf("Column") !== -1 || item.type.indexOf("Bar") !== -1) && item.type.indexOf("Range") === -1;
      });
      if (isRectSeries) {
        this.min = this.min <= 0 ? +this.min - 1 : this.min;
      }
      this.max = Math.ceil(logEnd / 1);
      this.max = this.max === this.min ? this.max + 1 : this.max;
      axis.actualRange.interval = axis.interval || this.calculateLogNiceInterval(this.max - this.min, size, axis);
      axis.actualRange.min = this.min;
      axis.actualRange.max = this.max;
      axis.actualRange.delta = this.max - this.min;
    };
    Logarithmic2.prototype.calculateVisibleRange = function(size, axis) {
      axis.visibleRange = {
        interval: axis.actualRange.interval,
        max: axis.actualRange.max,
        min: axis.actualRange.min,
        delta: axis.actualRange.delta
      };
      var isLazyLoad = isNullOrUndefined(axis.zoomingScrollBar) ? false : axis.zoomingScrollBar.isLazyLoad;
      if ((axis.zoomFactor < 1 || axis.zoomPosition > 0) && !isLazyLoad) {
        axis.calculateVisibleRangeOnZooming();
        axis.visibleRange.interval = axis.enableAutoIntervalOnZooming ? this.calculateLogNiceInterval(axis.doubleRange.delta, size, axis) : axis.visibleRange.interval;
        axis.visibleRange.interval = Math.floor(axis.visibleRange.interval) === 0 ? 1 : Math.floor(axis.visibleRange.interval);
        axis.triggerRangeRender(this.chart, axis.visibleRange.min, axis.visibleRange.max, axis.visibleRange.interval);
      }
    };
    Logarithmic2.prototype.calculateLogNiceInterval = function(delta, size, axis) {
      var actualDesiredIntervalsCount = getActualDesiredIntervalsCount(size, axis);
      var niceInterval = delta;
      var minInterval = Math.pow(axis.logBase, Math.floor(logBase(niceInterval, 10)));
      for (var j = 0, len = axis.intervalDivs.length; j < len; j++) {
        var currentInterval = minInterval * axis.intervalDivs[j];
        if (actualDesiredIntervalsCount < delta / currentInterval) {
          break;
        }
        niceInterval = currentInterval;
      }
      return niceInterval;
    };
    Logarithmic2.prototype.calculateVisibleLabels = function(axis, chart) {
      var tempInterval = axis.visibleRange.min;
      axis.visibleLabels = [];
      var labelStyle;
      var value;
      if (axis.zoomFactor < 1 || axis.zoomPosition > 0) {
        tempInterval = axis.visibleRange.min - axis.visibleRange.min % axis.visibleRange.interval;
      }
      var axisFormat = this.getFormat(axis);
      var isCustomFormat = axisFormat.match("{value}") !== null;
      var startValue = Math.pow(axis.logBase, axis.visibleRange.min);
      axis.format = chart.intl.getNumberFormat({
        format: isCustomFormat ? "" : axisFormat,
        useGrouping: chart.useGroupingSeparator,
        maximumFractionDigits: startValue < 1 ? 20 : 3
      });
      axis.startLabel = axis.format(startValue < 1 ? +startValue.toPrecision(1) : startValue);
      axis.endLabel = axis.format(Math.pow(axis.logBase, axis.visibleRange.max));
      for (; tempInterval <= axis.visibleRange.max; tempInterval += axis.visibleRange.interval) {
        labelStyle = extend({}, getValue("properties", axis.labelStyle), null, true);
        if (withIn(tempInterval, axis.visibleRange)) {
          value = Math.pow(axis.logBase, tempInterval);
          triggerLabelRender(this.chart, tempInterval, this.formatValue(axis, isCustomFormat, axisFormat, value < 1 ? +value.toPrecision(1) : value), labelStyle, axis);
        }
      }
      if (axis.getMaxLabelWidth) {
        axis.getMaxLabelWidth(this.chart);
      }
    };
    Logarithmic2.prototype.getModuleName = function() {
      return "Logarithmic";
    };
    Logarithmic2.prototype.destroy = function() {
    };
    return Logarithmic2;
  }(Double)
);

// node_modules/@syncfusion/ej2-charts/src/chart/axis/date-time-category-axis.js
var __extends15 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DateTimeCategory = (
  /** @class */
  function(_super) {
    __extends15(DateTimeCategory2, _super);
    function DateTimeCategory2(chart) {
      return _super.call(this, chart) || this;
    }
    DateTimeCategory2.prototype.calculateRangeAndInterval = function(size, axis) {
      this.axisSize = size;
      this.calculateRange(axis);
      this.getActualRange(axis, size);
      this.applyRangePadding(axis, size);
      this.calculateVisibleLabels(axis);
    };
    DateTimeCategory2.prototype.calculateVisibleLabels = function(axis) {
      axis.visibleLabels = [];
      var labelStyle;
      var padding = axis.labelPlacement === "BetweenTicks" ? 0.5 : 0;
      var previousIndex = 0;
      var isRangeNavigator = this.chart.getModuleName() === "rangeNavigator";
      this.axisSize = isRangeNavigator ? this.chart.availableSize : this.axisSize;
      if (isRangeNavigator || this.chart.stockChart) {
        axis.labels.sort(function(a, b) {
          return Number(a) - Number(b);
        });
      }
      if (axis.intervalType === "Auto") {
        this.calculateDateTimeNiceInterval(axis, this.axisSize, parseInt(axis.labels[0], 10), parseInt(axis.labels[axis.labels.length - 1], 10));
      } else {
        axis.actualIntervalType = axis.intervalType;
      }
      axis.format = this.chart.intl.getDateFormat({
        format: axis.labelFormat || this.blazorCustomFormat(axis),
        type: firstToLowerCase(axis.skeletonType),
        skeleton: this.getSkeleton(axis, null, null, this.chart.isBlazor)
      });
      var i = !isRangeNavigator && this.chart.stockChart ? 1 : 0;
      var interval = axis.interval ? axis.interval : 1;
      for (; i < axis.labels.length; i += interval) {
        labelStyle = extend({}, getValue("properties", axis.labelStyle), null, true);
        if (this.chart.stockChart || isRangeNavigator) {
          if (axis.intervalType === "Auto") {
            if ((!isRangeNavigator && i === 1 || this.StartOfWeek(axis.labels.map(Number)[i], axis.labels.map(Number)[i - 1], axis, i, previousIndex) || axis.isIndexed) && withIn(i, axis.visibleRange)) {
              triggerLabelRender(this.chart, i, axis.isIndexed ? this.getIndexedAxisLabel(axis.labels[i], axis.format) : axis.format(new Date(axis.labels.map(Number)[i])), labelStyle, axis);
              previousIndex = i;
            }
          } else if ((!isRangeNavigator && i === 1 || !this.sameInterval(axis.labels.map(Number)[i], axis.labels.map(Number)[i - 1], axis.actualIntervalType, i) || axis.isIndexed) && withIn(i, axis.visibleRange)) {
            if (!isRangeNavigator && i === 1 || this.isMaximum(i, previousIndex, axis)) {
              triggerLabelRender(this.chart, i, axis.isIndexed ? this.getIndexedAxisLabel(axis.labels[i], axis.format) : axis.format(new Date(axis.labels.map(Number)[i])), labelStyle, axis);
              previousIndex = i;
            }
          }
        } else {
          if (!this.sameInterval(axis.labels.map(Number)[i], axis.labels.map(Number)[i - 1], axis.actualIntervalType, i) || axis.isIndexed) {
            if (withIn(i - padding, axis.visibleRange)) {
              triggerLabelRender(this.chart, i, axis.isIndexed ? this.getIndexedAxisLabel(axis.labels[i], axis.format) : axis.format(new Date(axis.labels.map(Number)[i])), labelStyle, axis);
            }
          }
        }
      }
      axis.startLabel = axis.visibleLabels[0] ? axis.visibleLabels[0].text : "";
      axis.endLabel = axis.visibleLabels[axis.visibleLabels.length - 1] ? axis.visibleLabels[axis.visibleLabels.length - 1].text : "";
      if (axis.getMaxLabelWidth) {
        axis.getMaxLabelWidth(this.chart);
      }
    };
    DateTimeCategory2.prototype.blazorCustomFormat = function(axis) {
      if (this.chart.isBlazor && axis.actualIntervalType === "Years") {
        return "yyyy";
      } else {
        return "";
      }
    };
    DateTimeCategory2.prototype.getIndexedAxisLabel = function(value, format) {
      var texts = value.split(",");
      for (var i = 0; i < texts.length; i++) {
        texts[i] = format(new Date(parseInt(texts[i], 10)));
      }
      return texts.join(", ");
    };
    DateTimeCategory2.prototype.sameInterval = function(currentDate, previousDate, type, index) {
      var sameValue;
      if (index === 0) {
        sameValue = false;
      } else {
        switch (type) {
          case "Years":
            sameValue = new Date(currentDate).getFullYear() === new Date(previousDate).getFullYear();
            break;
          case "Quarter":
            sameValue = new Date(currentDate).getFullYear() === new Date(previousDate).getFullYear() && Math.floor(new Date(currentDate).getMonth() / 3) === Math.floor(new Date(previousDate).getMonth() / 3);
            break;
          case "Months":
            sameValue = new Date(currentDate).getFullYear() === new Date(previousDate).getFullYear() && new Date(currentDate).getMonth() === new Date(previousDate).getMonth();
            break;
          case "Weeks":
            sameValue = new Date(currentDate).getFullYear() === new Date(previousDate).getFullYear() && new Date(currentDate).getMonth() === new Date(previousDate).getMonth() && Math.floor((new Date(currentDate).getDate() - 1) / 7) === Math.floor((new Date(previousDate).getDate() - 1) / 7);
            break;
          case "Days":
            sameValue = Math.abs(currentDate - previousDate) < 24 * 60 * 60 * 1e3 && new Date(currentDate).getDay() === new Date(previousDate).getDay();
            break;
          case "Hours":
            sameValue = Math.abs(currentDate - previousDate) < 60 * 60 * 1e3 && new Date(currentDate).getDay() === new Date(previousDate).getDay();
            break;
          case "Minutes":
            sameValue = Math.abs(currentDate - previousDate) < 60 * 1e3 && new Date(currentDate).getMinutes() === new Date(previousDate).getMinutes();
            break;
          case "Seconds":
            sameValue = Math.abs(currentDate - previousDate) < 1e3 && new Date(currentDate).getDay() === new Date(previousDate).getDay();
            break;
        }
      }
      return sameValue;
    };
    DateTimeCategory2.prototype.StartOfWeek = function(currentDate, previousDate, axis, index, previousIndex) {
      if (index === 0) {
        return true;
      }
      var isMonday = false;
      var labelsCount = 30;
      if (axis.labels.length >= labelsCount) {
        var previousDay = new Date(previousDate);
        var currentday = new Date(currentDate);
        previousDay.setDate(previousDay.getDate() - previousDay.getDay());
        currentday.setDate(currentday.getDate() - currentday.getDay());
        isMonday = !(previousDay.getTime() === currentday.getTime()) && this.isMaximum(index, previousIndex, axis);
      } else {
        isMonday = this.isMaximum(index, previousIndex, axis);
      }
      return isMonday;
    };
    DateTimeCategory2.prototype.isMaximum = function(index, previousIndex, axis) {
      if (index === 0) {
        return true;
      }
      var axisLabelMaximumLength = 100;
      var pointX = valueToCoefficient(index, axis) * axis.rect.width;
      var previousPointX = valueToCoefficient(previousIndex, axis) * axis.rect.width;
      return pointX - previousPointX >= (axis.labels.length >= 15 ? axisLabelMaximumLength : axisLabelMaximumLength / 2);
    };
    DateTimeCategory2.prototype.getModuleName = function() {
      return "DateTimeCategory";
    };
    DateTimeCategory2.prototype.destroy = function() {
    };
    return DateTimeCategory2;
  }(Category)
);

// node_modules/@syncfusion/ej2-charts/src/chart/axis/strip-line.js
var StripLine = (
  /** @class */
  function() {
    function StripLine2() {
    }
    StripLine2.prototype.measureStripLine = function(axis, stripline, seriesClipRect, startValue, segmentAxis, chart) {
      var actualStart;
      var actualEnd;
      var orientation = axis.orientation;
      var isDateTimeAxis = axis.valueType === "DateTime";
      if (stripline.isRepeat && stripline.size !== null) {
        actualStart = startValue;
        actualEnd = null;
      } else {
        if (axis.valueType === "DateTimeCategory") {
          var start = stripline.start;
          var end = stripline.end;
          actualStart = start != null && typeof start !== "number" ? axis.labels.indexOf(this.dateToMilliSeconds(start, chart).toString()) : start;
          actualEnd = end != null && typeof end !== "number" ? axis.labels.indexOf(this.dateToMilliSeconds(end, chart).toString()) : end;
        } else {
          actualStart = stripline.start === null ? null : isDateTimeAxis && this.isCoreDate(stripline.start) ? this.dateToMilliSeconds(stripline.start, chart) : +(axis.valueType === "Logarithmic" ? logBase(stripline.start, axis.logBase) : stripline.start);
          actualEnd = stripline.end === null ? null : isDateTimeAxis && this.isCoreDate(stripline.start) ? this.dateToMilliSeconds(stripline.end, chart) : +(axis.valueType === "Logarithmic" ? logBase(stripline.end, axis.logBase) : stripline.end);
        }
      }
      var rect = this.getFromTovalue(actualStart, actualEnd, stripline.size, stripline.startFromAxis, axis, stripline);
      var height = orientation === "Vertical" ? (rect.to - rect.from) * axis.rect.height : seriesClipRect.height;
      var width = orientation === "Horizontal" ? (rect.to - rect.from) * axis.rect.width : seriesClipRect.width;
      var x = orientation === "Vertical" ? seriesClipRect.x : rect.from * axis.rect.width + axis.rect.x;
      var y = orientation === "Horizontal" ? seriesClipRect.y : axis.rect.y + axis.rect.height - (stripline.sizeType === "Pixel" ? rect.from : rect.to) * axis.rect.height;
      if (stripline.isSegmented && stripline.segmentStart != null && stripline.segmentEnd != null && stripline.sizeType !== "Pixel") {
        var start = isDateTimeAxis && this.isCoreDate(stripline.segmentStart) ? this.dateToMilliSeconds(stripline.segmentStart, chart) : +stripline.segmentStart;
        var end = isDateTimeAxis && this.isCoreDate(stripline.segmentEnd) ? this.dateToMilliSeconds(stripline.segmentEnd, chart) : +stripline.segmentEnd;
        var segRect = this.getFromTovalue(start, end, null, null, segmentAxis, stripline);
        if (segmentAxis.orientation === "Vertical") {
          y = segmentAxis.rect.y + segmentAxis.rect.height - segRect.to * segmentAxis.rect.height;
          height = (segRect.to - segRect.from) * segmentAxis.rect.height;
        } else {
          x = segRect.from * segmentAxis.rect.width + segmentAxis.rect.x;
          width = (segRect.to - segRect.from) * segmentAxis.rect.width;
        }
      }
      if (height !== 0 && width !== 0 || stripline.sizeType === "Pixel" && (stripline.start !== null || stripline.startFromAxis)) {
        return new Rect(x, y, width, height);
      }
      return new Rect(0, 0, 0, 0);
    };
    StripLine2.prototype.getFromTovalue = function(start, end, size, startFromAxis, axis, stripline) {
      var from = !stripline.isRepeat && startFromAxis ? axis.visibleRange.min : start;
      if (axis.valueType === "Double" && size !== null && !startFromAxis && stripline.start == null) {
        from += size;
      }
      var to = this.getToValue(Math.max(start, isNullOrUndefined(end) ? start : end), from, size, axis, end, stripline);
      from = this.findValue(from, axis);
      to = this.findValue(to, axis);
      return {
        from: valueToCoefficient(axis.isAxisInverse ? to : from, axis),
        to: valueToCoefficient(axis.isAxisInverse ? from : to, axis)
      };
    };
    StripLine2.prototype.getToValue = function(to, from, size, axis, end, stripline) {
      var sizeType = stripline.sizeType;
      var isEnd = end === null;
      if (axis.valueType === "DateTime") {
        var fromValue = new Date(from);
        if (sizeType === "Auto") {
          sizeType = axis.actualIntervalType;
          size *= axis.visibleRange.interval;
        }
        switch (sizeType) {
          case "Years":
            return isEnd ? new Date(fromValue.setFullYear(fromValue.getFullYear() + size)) : to;
          case "Months":
            return isEnd ? new Date(fromValue.setMonth(fromValue.getMonth() + size)) : to;
          case "Days":
            return isEnd ? new Date(fromValue.setDate(fromValue.getDate() + size)) : to;
          case "Hours":
            return isEnd ? new Date(fromValue.setHours(fromValue.getHours() + size)) : to;
          case "Minutes":
            return isEnd ? new Date(fromValue.setMinutes(fromValue.getMinutes() + size)) : to;
          case "Seconds":
            return isEnd ? new Date(fromValue.setSeconds(fromValue.getSeconds() + size)) : to;
          default:
            return from;
        }
      } else {
        return stripline.sizeType === "Pixel" ? from : isEnd ? from + size : to;
      }
    };
    StripLine2.prototype.findValue = function(value, axis) {
      if (value < axis.visibleRange.min) {
        value = axis.visibleRange.min;
      } else if (value > axis.visibleRange.max) {
        value = axis.visibleRange.max;
      }
      return value;
    };
    StripLine2.prototype.dateParse = function(value, chart) {
      var dateParser = chart.intl.getDateParser({
        skeleton: "full",
        type: "dateTime"
      });
      var dateFormatter = chart.intl.getDateFormat({
        skeleton: "full",
        type: "dateTime"
      });
      return new Date(Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({
        val: value
      }).val)))));
    };
    StripLine2.prototype.renderStripLine = function(chart, position, axes) {
      var id = chart.element.id + "_stripline_" + position + "_";
      var seriesClipRect = chart.chartAxisLayoutPanel.seriesClipRect;
      var end = 0;
      var limit = 0;
      var startValue = 0;
      var segmentAxis = null;
      var range;
      var options = new RectOption(id + "ClipRect", "transparent", {
        width: 1,
        color: "Gray"
      }, 1, {
        x: seriesClipRect.x,
        y: seriesClipRect.y,
        width: seriesClipRect.width,
        height: seriesClipRect.height
      });
      var striplineGroup = chart.renderer.createGroup({
        id: id + "collections",
        "clip-path": "url(#" + id + "ClipRect)"
      });
      if (!chart.enableCanvas) {
        striplineGroup.appendChild(appendClipElement(chart.redraw, options, chart.renderer));
      }
      for (var _i = 0, axes_1 = axes; _i < axes_1.length; _i++) {
        var axis = axes_1[_i];
        var count = 0;
        for (var _a = 0, _b = axis.stripLines; _a < _b.length; _a++) {
          var stripline = _b[_a];
          if (stripline.visible && stripline.zIndex === position) {
            if (stripline.isSegmented && stripline.segmentStart != null && stripline.segmentEnd != null && stripline.sizeType !== "Pixel") {
              segmentAxis = this.getSegmentAxis(axes, axis, stripline);
            }
            if (stripline.isRepeat && stripline.repeatEvery != null && stripline.size !== null && stripline.sizeType !== "Pixel") {
              limit = stripline.repeatUntil != null ? axis.valueType === "DateTime" ? this.dateToMilliSeconds(stripline.repeatUntil, chart) : +stripline.repeatUntil : axis.actualRange.max;
              startValue = axis.valueType === "DateTime" && this.isCoreDate(stripline.start) ? this.dateToMilliSeconds(stripline.start, chart) : stripline.start;
              if (stripline.startFromAxis && axis.valueType === "DateTime" && stripline.sizeType === "Auto" || stripline.start < axis.visibleRange.min) {
                startValue = axis.visibleLabels[0] && axis.visibleLabels[0].value === axis.visibleRange.min ? axis.visibleRange.min : axis.visibleLabels[0] && axis.visibleLabels[0].value - (axis.valueType === "DateTime" ? axis.dateTimeInterval : axis.visibleRange.interval);
              }
              startValue = stripline.startFromAxis && axis.valueType !== "DateTime" ? axis.visibleRange.min : startValue;
              while (startValue < limit) {
                end = startValue + (axis.valueType === "DateTime" ? axis.dateTimeInterval * +stripline.size : stripline.size);
                range = withIn(end, axis.visibleRange);
                if (startValue >= axis.visibleRange.min && startValue < axis.visibleRange.max || range) {
                  this.renderStripLineElement(axis, stripline, seriesClipRect, id, striplineGroup, chart, startValue, segmentAxis, count);
                }
                count++;
                startValue = this.getStartValue(axis, stripline, startValue);
              }
            } else {
              this.renderStripLineElement(axis, stripline, seriesClipRect, id, striplineGroup, chart, null, segmentAxis, count);
              count++;
            }
          }
        }
      }
      appendChildElement(chart.enableCanvas, chart.svgObject, striplineGroup, chart.redraw);
    };
    StripLine2.prototype.isCoreDate = function(value) {
      return typeof value === "string" ? true : false;
    };
    StripLine2.prototype.dateToMilliSeconds = function(value, chart) {
      return this.dateParse(value, chart).getTime();
    };
    StripLine2.prototype.renderPath = function(stripline, rect, id, parent, chart, axis) {
      var element = getElement2(id);
      var direction = element ? element.getAttribute("d") : "";
      var strokeWidth = stripline.size;
      var d = axis.orientation === "Vertical" ? "M " + rect.x + " " + rect.y + " L " + (rect.x + rect.width) + " " + rect.y : "M " + rect.x + " " + rect.y + " L " + rect.x + " " + (rect.y + rect.height);
      if (stripline.sizeType !== "Pixel") {
        d = axis.orientation === "Vertical" ? "M " + rect.x + " " + (rect.y + rect.height / 2) + " L " + (rect.x + rect.width) + " " + (rect.y + rect.height / 2) : "M " + (rect.x + rect.width / 2) + " " + rect.y + " L " + (rect.x + rect.width / 2) + " " + (rect.y + rect.height);
        strokeWidth = axis.orientation === "Vertical" ? rect.height : rect.width;
      }
      appendChildElement(chart.enableCanvas, parent, chart.renderer.drawPath(new PathOption(id, "none", strokeWidth, stripline.color, stripline.opacity, stripline.dashArray, d)), chart.redraw, true, "x", "y", null, direction, true, null, null, chart.duration);
    };
    StripLine2.prototype.renderRectangle = function(stripline, rect, id, parent, chart) {
      var element = getElement2(id);
      var previousRect = element ? new Rect(+element.getAttribute("x"), +element.getAttribute("y"), +element.getAttribute("width"), +element.getAttribute("height")) : null;
      appendChildElement(chart.enableCanvas, parent, chart.renderer.drawRectangle(new RectOption(id, "none", stripline.border, stripline.opacity, rect, 0, 0, "", stripline.border.dashArray)), chart.redraw, true, "x", "y", null, null, true, true, previousRect, chart.duration);
    };
    StripLine2.prototype.drawImage = function(stripline, rect, id, parent, chart) {
      if (stripline.sizeType === "Pixel") {
        rect.width = rect.width ? rect.width : stripline.size;
        rect.height = rect.height ? rect.height : stripline.size;
      }
      var image = new ImageOption(rect.height, rect.width, stripline.imageUrl, rect.x, rect.y, id, "visible", "none");
      var htmlObject = chart.renderer.drawImage(image);
      appendChildElement(chart.enableCanvas, parent, htmlObject, chart.redraw, true, "x", "y", null, null, true, true);
    };
    StripLine2.prototype.renderText = function(stripline, rect, id, parent, chart, axis) {
      var textSize = measureText(stripline.text, stripline.textStyle, chart.themeStyle.stripLineLabelFont);
      var isRotationNull = stripline.rotation === null;
      var textMid = isRotationNull ? 3 * (textSize.height / 8) : 0;
      var ty = rect.y + rect.height / 2 + textMid;
      var rotation = isRotationNull ? axis.orientation === "Vertical" ? 0 : -90 : stripline.rotation;
      var tx = rect.x + rect.width / 2;
      var anchor;
      var padding = 5;
      if (axis.orientation === "Horizontal") {
        tx = this.getTextStart(tx + textMid * this.factor(stripline.horizontalAlignment), rect.width, stripline.horizontalAlignment);
        ty = this.getTextStart(ty - textMid, rect.height, stripline.verticalAlignment) + (stripline.verticalAlignment === "Start" && !isRotationNull ? textSize.height / 4 : 0);
        anchor = isRotationNull ? this.invertAlignment(stripline.verticalAlignment) : stripline.horizontalAlignment;
        var isVertical = Math.abs(stripline.rotation) === 90 || Math.abs(stripline.rotation) === 270;
        var halfSize = isVertical ? textSize.height / 2 : textSize.width / 2;
        anchor = tx - halfSize < axis.rect.x ? "Start" : tx + halfSize > axis.rect.x + axis.rect.width ? "End" : anchor;
      } else {
        tx = this.getTextStart(tx, rect.width, stripline.horizontalAlignment);
        ty = this.getTextStart(ty + textMid * this.factor(stripline.verticalAlignment) - padding, rect.height, stripline.verticalAlignment);
        anchor = stripline.horizontalAlignment;
        anchor = chart.enableRtl ? anchor === "End" ? "Start" : anchor === "Start" ? "End" : anchor : anchor;
      }
      textElement2(chart.renderer, new TextOption(id, tx, ty, anchor, stripline.text, "rotate(" + rotation + " " + tx + "," + ty + ")", "middle"), stripline.textStyle, stripline.textStyle.color || chart.themeStyle.stripLineLabelFont.color, parent, null, null, null, null, null, null, null, null, chart.enableCanvas, null, chart.themeStyle.stripLineLabelFont);
    };
    StripLine2.prototype.invertAlignment = function(anchor) {
      switch (anchor) {
        case "Start":
          anchor = "End";
          break;
        case "End":
          anchor = "Start";
          break;
      }
      return anchor;
    };
    StripLine2.prototype.getStartValue = function(axis, stripline, startValue) {
      if (axis.valueType === "DateTime") {
        return this.getToValue(null, startValue, +stripline.repeatEvery, axis, null, stripline);
      } else {
        return startValue + +stripline.repeatEvery;
      }
    };
    StripLine2.prototype.getSegmentAxis = function(axes, axis, stripline) {
      var segment;
      if (stripline.segmentAxisName == null) {
        return axis.orientation === "Horizontal" ? axes[1] : axes[0];
      } else {
        for (var i = 0; i < axes.length; i++) {
          if (stripline.segmentAxisName === axes[i].name) {
            segment = axes[i];
          }
        }
        return segment;
      }
    };
    StripLine2.prototype.renderStripLineElement = function(axis, stripline, seriesClipRect, id, striplineGroup, chart, startValue, segmentAxis, count) {
      var rect = this.measureStripLine(axis, stripline, seriesClipRect, startValue, segmentAxis, chart);
      if (stripline.imageUrl) {
        this.drawImage(stripline, rect, id + "rect_" + axis.name + "_" + count, striplineGroup, chart);
      } else {
        this.renderPath(stripline, rect, id + (stripline.sizeType === "Pixel" ? "path_" : "rect_") + axis.name + "_" + count, striplineGroup, chart, axis);
        var pixelRect = new Rect(axis.orientation === "Horizontal" ? rect.x - stripline.size / 2 : rect.x, axis.orientation === "Vertical" ? rect.y - stripline.size / 2 : rect.y, rect.width ? rect.width : stripline.size, rect.height ? rect.height : stripline.size);
        this.renderRectangle(stripline, stripline.sizeType === "Pixel" ? pixelRect : rect, id + "border_" + axis.name + "_" + count, striplineGroup, chart);
      }
      if (stripline.text !== "") {
        this.renderText(stripline, rect, id + "text_" + axis.name + "_" + count, striplineGroup, chart, axis);
      }
    };
    StripLine2.prototype.factor = function(anchor) {
      var factor = 0;
      switch (anchor) {
        case "Start":
          factor = 1;
          break;
        case "End":
          factor = -1;
          break;
      }
      return factor;
    };
    StripLine2.prototype.getTextStart = function(xy, size, textAlignment) {
      var padding = 5;
      switch (textAlignment) {
        case "Start":
          xy = xy - size / 2 + padding;
          break;
        case "End":
          xy = xy + size / 2 - padding;
          break;
      }
      return xy;
    };
    StripLine2.prototype.getModuleName = function() {
      return "StripLine";
    };
    StripLine2.prototype.destroy = function() {
    };
    return StripLine2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/line-base.js
var LineBase = (
  /** @class */
  function() {
    function LineBase2(chartModule) {
      this.chart = chartModule;
    }
    LineBase2.prototype.enableComplexProperty = function(series) {
      var tempPoints = [];
      var tempPoints2 = [];
      var xVisibleRange = series.xAxis.visibleRange;
      var yVisibleRange = series.yAxis.visibleRange;
      var seriesPoints = series.points;
      var areaBounds = series.clipRect;
      var xTolerance = this.chart && this.chart.zoomRedraw && this.chart.redraw ? this.previousX : Math.abs(xVisibleRange.delta / areaBounds.width);
      var yTolerance = this.chart && this.chart.zoomRedraw && this.chart.redraw ? this.previousY : Math.abs(yVisibleRange.delta / areaBounds.height);
      var prevXValue = seriesPoints[0] && seriesPoints[0].xValue > xTolerance ? 0 : xTolerance;
      var prevYValue = seriesPoints[0] && seriesPoints[0].y > yTolerance ? 0 : yTolerance;
      this.previousX = xTolerance;
      this.previousY = yTolerance;
      var xVal = 0;
      var yVal = 0;
      for (var _i = 0, seriesPoints_1 = seriesPoints; _i < seriesPoints_1.length; _i++) {
        var currentPoint = seriesPoints_1[_i];
        currentPoint.symbolLocations = [];
        xVal = !isNullOrUndefined(currentPoint.xValue) ? currentPoint.xValue : xVisibleRange.min;
        yVal = !isNullOrUndefined(currentPoint.yValue) ? currentPoint.yValue : yVisibleRange.min;
        if (Math.abs(prevXValue - xVal) >= xTolerance || Math.abs(prevYValue - yVal) >= yTolerance) {
          tempPoints.push(currentPoint);
          prevXValue = xVal;
          prevYValue = yVal;
        }
      }
      var tempPoint;
      for (var i = 0; i < tempPoints.length; i++) {
        tempPoint = tempPoints[i];
        if (isNullOrUndefined(tempPoint.x) || series.category === "Indicator" && (isNaN(tempPoint.xValue) || isNaN(tempPoint.yValue))) {
          continue;
        } else {
          tempPoints2.push(tempPoint);
        }
      }
      return tempPoints2;
    };
    LineBase2.prototype.getLineDirection = function(firstPoint, secondPoint, series, isInverted, getPointLocation, startPoint) {
      var direction = "";
      if (firstPoint != null) {
        var point1 = getPointLocation(firstPoint.xValue, firstPoint.yValue, series.xAxis, series.yAxis, isInverted, series);
        var point2 = getPointLocation(secondPoint.xValue, secondPoint.yValue, series.xAxis, series.yAxis, isInverted, series);
        direction = startPoint + " " + point1.x + " " + point1.y + " L " + point2.x + " " + point2.y + " ";
      }
      return direction;
    };
    LineBase2.prototype.appendLinePath = function(options, series, clipRect) {
      var points = this.appendPathElement(options, series, clipRect);
      pathAnimation(points.element, options.d, series.chart.redraw, points.previousDirection, points.chart.duration);
    };
    LineBase2.prototype.appendPathElement = function(options, series, clipRect) {
      var element = getElement2(options.id);
      var chart = series.chart;
      var previousDirection = element ? element.getAttribute("d") : null;
      var htmlObject = series.chart.renderer.drawPath(options, new Int32Array([series.clipRect.x, series.clipRect.y]));
      if (htmlObject) {
        htmlObject.setAttribute("clip-path", clipRect);
      }
      if (series.category === "TrendLine" && htmlObject) {
        var trendline = chart.series[series.sourceIndex].trendlines[series.index];
        if (!trendline.marker.visible) {
          htmlObject.setAttribute("tabindex", trendline.accessibility.focusable ? String(trendline.accessibility.tabIndex) : "-1");
        }
        htmlObject.setAttribute("role", trendline.accessibility.accessibilityRole ? trendline.accessibility.accessibilityRole : "");
        htmlObject.setAttribute("aria-label", trendline.accessibility.accessibilityDescription ? trendline.accessibility.accessibilityDescription : "");
      }
      series.pathElement = htmlObject;
      if (!series.chart.enableCanvas) {
        series.seriesElement.appendChild(htmlObject);
      }
      series.isRectSeries = false;
      return {
        element,
        previousDirection,
        chart
      };
    };
    LineBase2.prototype.addPath = function(options, series, clipRect) {
      var points = this.appendPathElement(options, series, clipRect);
      if (points.previousDirection !== "" && options.d !== "") {
        var startPathCommands = points.previousDirection.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);
        var endPathCommands = options.d.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);
        var maxLength = Math.max(startPathCommands.length, endPathCommands.length);
        var minLength = Math.min(startPathCommands.length, endPathCommands.length);
        if (startPathCommands.length < endPathCommands.length) {
          for (var i = minLength; i < maxLength; i++) {
            if (endPathCommands.length !== startPathCommands.length) {
              startPathCommands.push(startPathCommands[startPathCommands.length - 1].replace("M", "L"));
            }
          }
          animateAddPoints(points.element, options.d, series.chart.redraw, startPathCommands.join(" "), this.chart.duration);
        } else if (startPathCommands.length > endPathCommands.length) {
          for (var i = minLength; i < maxLength; i++) {
            if (endPathCommands.length !== startPathCommands.length) {
              if (series.removedPointIndex === series.points.length) {
                endPathCommands.push(endPathCommands[endPathCommands.length - 1].replace("M", "L"));
              } else {
                endPathCommands.splice(1, 0, endPathCommands[0].replace("M", "L"));
              }
            }
          }
          animateAddPoints(points.element, endPathCommands.join(""), series.chart.redraw, points.previousDirection, this.chart.duration, options.d);
        } else {
          animateAddPoints(points.element, options.d, series.chart.redraw, points.previousDirection, this.chart.duration);
        }
      }
    };
    LineBase2.prototype.addAreaPath = function(options, series, clipRect) {
      var points = this.appendPathElement(options, series, clipRect);
      if (points.previousDirection !== "" && options.d !== "") {
        var startPathCommands = points.previousDirection.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);
        var endPathCommands = options.d.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);
        var maxLength = Math.max(startPathCommands.length, endPathCommands.length);
        var minLength = Math.min(startPathCommands.length, endPathCommands.length);
        if (minLength < endPathCommands.length) {
          for (var i = minLength; i < maxLength; i++) {
            if (endPathCommands.length !== startPathCommands.length) {
              if (endPathCommands.length !== startPathCommands.length) {
                if (startPathCommands.length === 1) {
                  startPathCommands.push(startPathCommands[startPathCommands.length - (options.id.indexOf("border") !== -1 ? 1 : 2)].replace("M", "L"));
                } else {
                  startPathCommands.splice(startPathCommands.length - 1, 0, startPathCommands[startPathCommands.length - (options.id.indexOf("border") !== -1 ? 1 : 2)]);
                }
              }
            }
          }
          animateAddPoints(points.element, options.d, series.chart.redraw, startPathCommands.join(" "), this.chart.duration);
        } else if (startPathCommands.length > endPathCommands.length) {
          for (var i = minLength; i < maxLength; i++) {
            if (endPathCommands.length !== startPathCommands.length) {
              if (series.removedPointIndex === series.points.length) {
                if (endPathCommands.length === 1) {
                  endPathCommands.push(endPathCommands[endPathCommands.length - (options.id.indexOf("border") !== -1 ? 1 : 2)].replace("M", "L"));
                } else {
                  endPathCommands.splice(endPathCommands.length - 1, 0, endPathCommands[endPathCommands.length - (options.id.indexOf("border") !== -1 ? 1 : 2)]);
                }
              } else {
                endPathCommands.splice(1, 0, endPathCommands[1] ? endPathCommands[1] : endPathCommands[0]);
              }
            }
          }
          animateAddPoints(points.element, endPathCommands.join(""), series.chart.redraw, points.previousDirection, this.chart.duration, options.d);
        } else {
          animateAddPoints(points.element, options.d, series.chart.redraw, points.previousDirection, this.chart.duration);
        }
      }
    };
    LineBase2.prototype.renderMarker = function(series) {
      if (series.marker && series.marker.visible) {
        series.chart.markerRender.render(series);
      }
    };
    LineBase2.prototype.doProgressiveAnimation = function(series, option) {
      var animation = new Animation({});
      var path = series.pathElement;
      var strokeDashArray = path.getAttribute("stroke-dasharray");
      var pathLength = series.pathElement.getTotalLength();
      var currentTime;
      path.style.visibility = "hidden";
      animation.animate(path, {
        duration: option.duration === 0 && animationMode === "Enable" ? 1e3 : option.duration,
        delay: option.delay,
        progress: function(args) {
          path.style.visibility = "visible";
          currentTime = Math.abs(Math.round(args.timeStamp * pathLength / args.duration));
          path.setAttribute("stroke-dasharray", currentTime + "," + pathLength);
        },
        end: function() {
          var annotations = getElement2(series.chart.element.id + "_Annotation_Collections");
          if (annotations) {
            annotations.style.visibility = "visible";
          }
          path.setAttribute("stroke-dasharray", strokeDashArray);
          path.style.visibility = "";
          series.chart.trigger("animationComplete", {
            series: series.chart.isBlazor ? {} : series
          });
        }
      });
    };
    LineBase2.prototype.storePointLocation = function(point, series, isInverted, getLocation) {
      var markerWidth = series.marker && series.marker.width ? series.marker.width : 0;
      var markerHeight = series.marker && series.marker.height ? series.marker.height : 0;
      point.symbolLocations.push(getLocation(point.xValue, point.yValue, series.xAxis, series.yAxis, isInverted, series));
      point.regions.push(new Rect(point.symbolLocations[0].x - markerWidth, point.symbolLocations[0].y - markerHeight, 2 * markerWidth, 2 * markerHeight));
    };
    LineBase2.prototype.withinYRange = function(point, yAxis) {
      return point.yValue >= yAxis.visibleRange.min && point.yValue <= yAxis.visibleRange.max;
    };
    LineBase2.prototype.GetStepLineDirection = function(currentPoint, previousPoint, stepLineType, command, series, isBorder) {
      if (command === void 0) {
        command = "L";
      }
      var X = series.noRisers && isBorder ? " M " : " L ";
      if (stepLineType === "Right") {
        command = series.noRisers && isBorder ? "M" : "L";
        return command + " " + previousPoint.x + " " + currentPoint.y + " L " + currentPoint.x + " " + currentPoint.y + " ";
      } else if (stepLineType === "Center") {
        var centerX = previousPoint.x + (currentPoint.x - previousPoint.x) / 2;
        return command + " " + centerX + " " + previousPoint.y + X + centerX + " " + currentPoint.y + " L " + currentPoint.x + " " + currentPoint.y + " ";
      } else {
        return command + " " + currentPoint.x + " " + previousPoint.y + X + currentPoint.x + " " + currentPoint.y + " ";
      }
    };
    LineBase2.prototype.getFirstLastVisiblePoint = function(points) {
      var first = null;
      var last = null;
      for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
        var point = points_1[_i];
        if (first === null && point.visible) {
          first = last = point;
        }
        last = point.visible ? point : last;
      }
      return {
        first: first ? first : points[0],
        last: last ? last : points[points.length - 1]
      };
    };
    LineBase2.prototype.getBorderDirection = function(direction) {
      var coordinates = direction.split(" ");
      if (coordinates.length > 3 && !this.chart.stackingAreaSeriesModule && !this.chart.stackingStepAreaSeriesModule) {
        coordinates.splice(coordinates.length - 4, 3);
      } else if (this.chart.stackingAreaSeriesModule || this.chart.stackingStepAreaSeriesModule) {
        coordinates.splice(coordinates.length / 2 + 1, coordinates.length / 2 + 1);
        if (coordinates[coordinates.length - 1] === "L" || coordinates[coordinates.length - 1] === "M") {
          coordinates.splice(coordinates.length - 1, 1);
        }
      }
      return coordinates.join(" ");
    };
    LineBase2.prototype.removeEmptyPointsBorder = function(borderDirection) {
      var startIndex = 0;
      var coordinates = borderDirection.split(" ");
      var point;
      if (coordinates.length === 4) {
        return coordinates.join(" ");
      }
      do {
        point = coordinates.indexOf("M", startIndex);
        if (point > -1) {
          coordinates.splice(point + 1, 3);
          startIndex = point + 1;
          if (point - 6 > 0) {
            coordinates.splice(point - 6, 6);
            startIndex -= 6;
          }
        }
      } while (point !== -1);
      return coordinates.join(" ");
    };
    LineBase2.prototype.doLinearAnimation = function(series, animation) {
      var clipRect = series.clipRectElement.childNodes[0].childNodes[0];
      var duration = series.chart.animated ? series.chart.duration : animation.duration;
      var effect = getAnimationFunction("Linear");
      var elementHeight = +clipRect.getAttribute("height");
      var elementWidth = +clipRect.getAttribute("width");
      var xCenter = +clipRect.getAttribute("x");
      var yCenter = series.chart.requireInvertedAxis ? +clipRect.getAttribute("height") + +clipRect.getAttribute("y") : +clipRect.getAttribute("y");
      var value;
      clipRect.style.visibility = "hidden";
      this.animateRect(series, animation, clipRect, duration, effect, elementHeight, elementWidth, xCenter, yCenter, value);
      if (series.marker && series.marker.visible && series.symbolElement) {
        var markerClipRect = series.symbolElement.childNodes[0].childNodes[0];
        markerClipRect.style.visibility = "hidden";
        this.animateRect(series, animation, markerClipRect, duration, effect, elementHeight, elementWidth, xCenter, yCenter, value);
      }
    };
    LineBase2.prototype.animateRect = function(series, animation, clipRect, duration, effect, elementHeight, elementWidth, xCenter, yCenter, value) {
      new Animation({}).animate(clipRect, {
        duration: duration === 0 && animationMode === "Enable" ? 1e3 : duration,
        delay: animation.delay,
        progress: function(args) {
          clipRect.style.visibility = "visible";
          if (series.chart.requireInvertedAxis) {
            value = effect(args.timeStamp, 0, elementHeight, args.duration);
            clipRect.setAttribute("transform", "translate(" + xCenter + " " + yCenter + ") scale(1," + value / elementHeight + ") translate(" + -xCenter + " " + -yCenter + ")");
          } else {
            value = effect(args.timeStamp, 0, elementWidth, args.duration);
            clipRect.setAttribute("transform", "translate(" + xCenter + " " + yCenter + ") scale(" + value / elementWidth + ", 1) translate(" + -xCenter + " " + -yCenter + ")");
          }
        },
        end: function() {
          var annotations = getElement2(series.chart.element.id + "_Annotation_Collections");
          if (annotations) {
            annotations.style.visibility = "visible";
          }
          var stackLabelGroup = document.getElementById(series.chart.element.id + "_StackLabelGroup");
          if (stackLabelGroup) {
            stackLabelGroup.setAttribute("visibility", "visible");
          }
          clipRect.setAttribute("transform", "translate(0,0)");
          series.chart.trigger("animationComplete", {
            series: series.chart.isBlazor ? {} : series
          });
        }
      });
    };
    return LineBase2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/line-series.js
var __extends16 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var LineSeries = (
  /** @class */
  function(_super) {
    __extends16(LineSeries2, _super);
    function LineSeries2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    LineSeries2.prototype.render = function(series, xAxis, yAxis, isInverted, pointAnimate, pointUpdate) {
      var point1;
      var point2;
      var direction = "";
      var prevPoint = null;
      var startPoint = "M";
      var isPolar = series.chart && series.chart.chartAreaType === "PolarRadar";
      var isDrop = series.emptyPointSettings && series.emptyPointSettings.mode === "Drop";
      var getCoordinate = isPolar ? TransformToVisible : getPoint;
      var visiblePoints = series.category === "TrendLine" ? series.points : this.enableComplexProperty(series);
      for (var _i = 0, visiblePoints_1 = visiblePoints; _i < visiblePoints_1.length; _i++) {
        var point = visiblePoints_1[_i];
        point.regions = [];
        point.symbolLocations = [];
        if (point.visible && withInRange(visiblePoints[point.index - 1], point, visiblePoints[point.index + 1], series)) {
          direction += this.getLineDirection(prevPoint, point, series, isInverted, getCoordinate, startPoint);
          startPoint = prevPoint ? "L" : startPoint;
          prevPoint = point;
          this.storePointLocation(point, series, isInverted, getCoordinate);
          if (direction === "" && visiblePoints.length === 1) {
            direction = "M " + point.symbolLocations[0].x + " " + point.symbolLocations[0].y;
          }
        } else {
          prevPoint = isDrop ? prevPoint : null;
          startPoint = isDrop ? startPoint : "M";
        }
      }
      if (isPolar) {
        if (series.isClosed) {
          var points = this.getFirstLastVisiblePoint(visiblePoints);
          point2 = getCoordinate(points.last.xValue, points.last.yValue, xAxis, yAxis, isInverted, series);
          point1 = getCoordinate(points.first.xValue, points.first.yValue, xAxis, yAxis, isInverted, series);
          direction = direction.concat(startPoint + " " + point2.x + " " + point2.y + " L " + point1.x + " " + point1.y);
        }
      }
      var name = series.category === "Indicator" ? series.chart.element.id + "_Indicator_" + series.index + "_" + series.name : series.category === "TrendLine" ? series.chart.element.id + "_Series_" + series.sourceIndex + "_TrendLine_" + series.index : series.chart.element.id + "_Series_" + (series.index === void 0 ? series.category : series.index);
      var options = new PathOption(name, "none", series.width, series.interior, series.opacity, series.dashArray, direction);
      this[pointAnimate ? "addPath" : "appendLinePath"](options, series, "");
      if (!pointUpdate) {
        this.renderMarker(series);
      }
    };
    LineSeries2.prototype.updateDirection = function(series, point) {
      this.render(series, series.xAxis, series.yAxis, series.chart.requireInvertedAxis, false, true);
      for (var i = 0; i < point.length; i++) {
        if (series.marker && series.marker.visible) {
          series.chart.markerRender.renderMarker(series, series.points[point[i]], series.points[point[i]].symbolLocations[0], null, true);
        }
        if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {
          series.chart.dataLabelModule.commonId = series.chart.element.id + "_Series_" + series.index + "_Point_";
          series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);
        }
      }
    };
    LineSeries2.prototype.doAnimation = function(series) {
      var option = series.animation;
      this.doProgressiveAnimation(series, option);
    };
    LineSeries2.prototype.getModuleName = function() {
      return "LineSeries";
    };
    LineSeries2.prototype.destroy = function() {
    };
    return LineSeries2;
  }(LineBase)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/column-base.js
var ColumnBase = (
  /** @class */
  function() {
    function ColumnBase2() {
    }
    ColumnBase2.prototype.getSideBySideInfo = function(series) {
      series.isRectSeries = true;
      if (series.chart.enableSideBySidePlacement && !series.position || !isNullOrUndefined(series.columnWidthInPixel)) {
        this.getSideBySidePositions(series);
      }
      if (series.columnWidthInPixel) {
        return new DoubleRange(0, 0);
      }
      var position = series.type === "Histogram" || !series.chart.enableSideBySidePlacement ? 0 : series.position;
      var rectCount = series.type === "Histogram" || !series.chart.enableSideBySidePlacement ? 1 : series.rectCount;
      var visibleSeries = series.chart.visibleSeries;
      var seriesSpacing = series.chart.enableSideBySidePlacement ? series.columnSpacing : 0;
      var pointSpacing = series.columnWidth === null || isNaN(+series.columnWidth) ? series.type === "Histogram" ? 1 : 0.7 : Math.min(series.columnWidth, 1);
      var minimumPointDelta = getMinPointsDelta(series.xAxis, visibleSeries);
      var width = minimumPointDelta * pointSpacing;
      var radius;
      var location = position / rectCount - 0.5;
      var doubleRange = new DoubleRange(location, location + 1 / rectCount);
      if (!(isNaN(doubleRange.start) || isNaN(doubleRange.end))) {
        if (series.groupName && series.type.indexOf("Stacking") === -1) {
          var mainColumnWidth_1 = 0.7;
          series.chart.series.filter(function(series2) {
            if (series2.columnWidth > mainColumnWidth_1) {
              mainColumnWidth_1 = series2.columnWidth;
            }
          });
          var mainWidth = minimumPointDelta * mainColumnWidth_1;
          var mainDoubleRange = new DoubleRange(doubleRange.start * mainWidth, doubleRange.end * mainWidth);
          var difference = (mainDoubleRange.delta - (doubleRange.end * width - doubleRange.start * width)) / 2;
          doubleRange = new DoubleRange(mainDoubleRange.start + difference, mainDoubleRange.end - difference);
        } else {
          doubleRange = new DoubleRange(doubleRange.start * width, doubleRange.end * width);
        }
        radius = seriesSpacing * doubleRange.delta;
        doubleRange = new DoubleRange(doubleRange.start + radius / 2, doubleRange.end - radius / 2);
      }
      return doubleRange;
    };
    ColumnBase2.prototype.getRectangle = function(x1, y1, x2, y2, series) {
      var point1 = getPoint(x1, y1, series.xAxis, series.yAxis, series.chart.requireInvertedAxis);
      var point2 = getPoint(x2, y2, series.xAxis, series.yAxis, series.chart.requireInvertedAxis);
      return new Rect(Math.min(point1.x, point2.x), Math.min(point1.y, point2.y), Math.abs(point2.x - point1.x), Math.abs(point2.y - point1.y));
    };
    ColumnBase2.prototype.drawCylinder = function(options, element, cylinderSeriesOption, rect, series) {
      var width = rect.width;
      var height = rect.height;
      if (series.chart.enableCanvas) {
        var ctx = series.chart.canvasRender.ctx;
        var canvasCtx = ctx;
        ctx.save();
        var gradientColor = colorNameToHex(options.fill);
        var x = rect.x + series.clipRect.x;
        var y = rect.y + series.clipRect.y;
        var arc = 2 * Math.PI + 0.1;
        var rx = void 0;
        var ry = void 0;
        var cx1 = void 0;
        var cx2 = void 0;
        var cy1 = void 0;
        var cy2 = void 0;
        var x1 = void 0;
        var x2 = void 0;
        var y1 = void 0;
        var y2 = void 0;
        var cx = void 0;
        var cy = void 0;
        var xl = void 0;
        var yl = void 0;
        var xPos = void 0;
        var yPos = void 0;
        var step = void 0;
        var rxt = void 0;
        var ryt = void 0;
        var gx1 = 0;
        var gx2 = 0;
        var gy1 = 0;
        var gy2 = 0;
        var ini = 0;
        ctx.fillStyle = applyZLight(gradientColor, 0.9);
        ctx.lineWidth = 0;
        ctx.strokeStyle = applyZLight(gradientColor, 0.9);
        ctx.globalAlpha = options.opacity;
        if (cylinderSeriesOption.isColumn) {
          gx1 = x;
          gx2 = width + x;
          rx = width / 2;
          ry = rx / 4;
          cx2 = cx1 = x + rx;
          y2 = cy1 = y - ry;
          x2 = x;
          x1 = x + width;
          cy2 = y1 = y + height - ry;
          step = Math.PI;
          rxt = -rx;
          ryt = ry;
          if (cylinderSeriesOption.stacking) {
            if (!cylinderSeriesOption.isLastSeries) {
              y2 = cy1 = y + ry;
            }
          }
        } else {
          gy2 = height + y;
          gy1 = y;
          ry = height / 2;
          rx = ry / 4;
          x2 = cx1 = x + rx;
          x1 = cx2 = x + width + rx;
          y1 = y + height;
          y2 = y;
          cy2 = cy1 = y + ry;
          ini = Math.PI / 2;
          step = Math.PI * 1.5;
          if (cylinderSeriesOption.stacking) {
            if (!cylinderSeriesOption.isLastSeries) {
              x1 = cx2 = x + width - rx;
            }
          }
          ry = -ry;
          rx = -rx;
          rxt = rx;
          ryt = -ry;
        }
        var color = applyZLight(gradientColor, 0.7);
        var gradient = ctx.createLinearGradient(gx1, gy1, gx2, gy2);
        gradient.addColorStop(0, gradientColor);
        gradient.addColorStop(0.3, color);
        gradient.addColorStop(0.7, color);
        gradient.addColorStop(1, gradientColor);
        for (var j = 1; j <= 4; j++) {
          var i = 0;
          if (j < 4) {
            ctx.beginPath();
          }
          if (j % 2 === 0) {
            cx = cx2;
            cy = cy2;
            xl = x2;
            yl = y2;
          } else {
            cx = cx1;
            cy = cy1;
            xl = x1;
            yl = y1;
          }
          if (j === 4) {
            rx = rxt;
            ry = ryt;
            ctx.fillStyle = gradient;
          }
          if (j > 2) {
            i = ini;
            arc = step;
          }
          for (; i <= arc; i += 0.1) {
            xPos = cx - rx * Math.cos(i);
            yPos = cy + ry * Math.sin(i);
            if (i === 0) {
              ctx.moveTo(xPos, yPos);
            } else {
              ctx.lineTo(xPos, yPos);
            }
          }
          if (j > 2) {
            ctx.lineTo(xl, yl);
          }
          if (j !== 3) {
            ctx.stroke();
            ctx.fill();
          }
        }
        if (options.id.indexOf("Series") >= 0) {
          ctx.clip();
          ctx.restore();
          ctx = canvasCtx;
        }
      } else {
        var chart = series.chart;
        var x = rect.x;
        var y = rect.y;
        var id = options.id;
        var gradientColor = options.fill;
        var fillColor = gradientColor;
        var format = checkColorFormat(gradientColor);
        if (!format) {
          gradientColor = colorNameToHex(gradientColor);
        }
        var AEx = 0;
        var AEy = 0;
        var LX = 0;
        var LY = 0;
        var GX = 0;
        var GY = 0;
        var X = void 0;
        var Y = void 0;
        var X1 = void 0;
        var Y1 = void 0;
        var X2 = void 0;
        var Y2 = void 0;
        var rx = void 0;
        var ry = void 0;
        var i = 2;
        if (cylinderSeriesOption.isColumn) {
          rx = width / 2;
          ry = rx / 4;
          X = X1 = x;
          Y = ry < y ? y - ry : cylinderSeriesOption.stacking ? y + ry : y - ry;
          Y1 = Y;
          AEx = 2 * rx;
          LY = ry < y ? height : height < 2 * ry ? height : cylinderSeriesOption.stacking ? height - 2 * ry : height;
          X2 = X;
          Y2 = ry < y ? Y + height : height < Y ? height + Y : cylinderSeriesOption.stacking ? height + (y - ry) : height + Y;
          GX = 100;
          if (cylinderSeriesOption.stacking) {
            if (!cylinderSeriesOption.isLastSeries) {
              Y = Y1 = y + ry;
              LY = height < rx / 2 ? height : height - rx / 2;
            }
          }
        } else {
          ry = height / 2;
          rx = ry / 4;
          Y = Y1 = y;
          X = X1 = Math.abs(x - rx);
          AEy = 2 * ry;
          LX = width;
          X2 = X + width;
          Y2 = Y;
          GY = 100;
          if (cylinderSeriesOption.stacking) {
            if (!cylinderSeriesOption.isLastSeries) {
              X2 = X + width - rx * 2;
              LX = width - rx * 2;
            }
          }
        }
        remove(this.element);
        while (i--) {
          options.d = "M" + X.toString() + "," + Y.toString() + "a" + rx.toString() + "," + ry.toString() + " 0 1,0 " + AEx.toString() + "," + AEy.toString() + "a" + rx.toString() + "," + ry.toString() + " 0 1,0 " + (-1 * AEx).toString() + "," + (-1 * AEy).toString();
          options.id = id + "_Region_" + i;
          options.fill = applyZLight(gradientColor, 0.9);
          if (i % 2 === 0 && series.type !== "StackingBar100" && series.type !== "StackingBar" && series.type !== "Bar") {
            options.fill = options.fill + "10";
          }
          this.element = chart.renderer.drawPath(this.options, new Int32Array([series.clipRect.x, series.clipRect.y]));
          appendChildElement(series.chart.enableCanvas, series.seriesElement, this.element, chart.redraw);
          X = X2;
          Y = Y2;
        }
        options.d = "M" + X1.toString() + "," + Y1.toString() + "a" + rx.toString() + "," + ry.toString() + " 0 1,0 " + AEx.toString() + "," + AEy.toString() + "l" + LX.toString() + " " + LY.toString() + "a" + rx.toString() + "," + ry.toString() + " 0 1,1 " + (-1 * AEx).toString() + "," + (-1 * AEy).toString() + " z";
        options.id = id + "_Region_2";
        options.fill = applyZLight(gradientColor, 0.7);
        var optiong = void 0;
        if (fillColor.indexOf("url") === -1) {
          if (!document.getElementById(id)) {
            optiong = {
              "id": id,
              x1: "0%",
              y1: "0%",
              x2: GX.toString() + "%",
              y2: GY.toString() + "%"
            };
            var gradientElement = [{
              colorStop: "0%",
              color: gradientColor
            }, {
              colorStop: "30%",
              color: applyZLight(gradientColor, 0.7)
            }, {
              colorStop: "70%",
              color: applyZLight(gradientColor, 0.7)
            }, {
              colorStop: "100%",
              color: gradientColor
            }];
            this.drawGradient(optiong, gradientElement, series);
          }
          options.fill = "url(#" + optiong.id + ")";
        }
        this.element = chart.renderer.drawPath(this.options, new Int32Array([series.clipRect.x, series.clipRect.y]));
        appendChildElement(series.chart.enableCanvas, series.seriesElement, this.element, chart.redraw);
      }
    };
    ColumnBase2.prototype.drawGradient = function(optiong, gradientElement, series) {
      var chart = series.chart;
      var defElement = chart.renderer.createDefs();
      var xmlns = "http://www.w3.org/2000/svg";
      var linearGradientElement = document.createElementNS(xmlns, "linearGradient");
      linearGradientElement.setAttribute("id", optiong.id);
      linearGradientElement.setAttribute("x1", optiong.x1);
      linearGradientElement.setAttribute("y1", optiong.y1);
      linearGradientElement.setAttribute("x2", optiong.x2);
      linearGradientElement.setAttribute("y2", optiong.y2);
      for (var i = 0; i < gradientElement.length; i++) {
        var stopElement = document.createElementNS(xmlns, "stop");
        stopElement.setAttribute("offset", gradientElement[i].colorStop);
        stopElement.setAttribute("stop-color", gradientElement[i].color);
        stopElement.setAttribute("stop-opacity", "1");
        linearGradientElement.appendChild(stopElement);
      }
      series.seriesElement.appendChild(defElement);
      defElement.appendChild(linearGradientElement);
    };
    ColumnBase2.prototype.getSideBySidePositions = function(series) {
      var chart = series.chart;
      for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {
        var columnItem = _a[_i];
        for (var _b = 0, _c = chart.rows; _b < _c.length; _b++) {
          var item = _c[_b];
          this.findRectPosition(series.findSeriesCollection(columnItem, item, false));
        }
      }
    };
    ColumnBase2.prototype.findRectPosition = function(seriesCollection) {
      var groupingValues = [];
      var vSeries = {
        rectCount: 0,
        position: null
      };
      for (var i = 0; i < seriesCollection.length; i++) {
        var value = seriesCollection[i];
        if (value.type.indexOf("Stacking") !== -1 || value.groupName !== "") {
          var groupName = value.type.indexOf("Stacking") !== -1 ? value.stackingGroup : value.type + value.groupName;
          if (groupName) {
            if (groupingValues[groupName] === void 0) {
              value.position = vSeries.rectCount;
              groupingValues[groupName] = vSeries.rectCount++;
            } else {
              value.position = groupingValues[groupName];
            }
          } else {
            if (vSeries.position === null) {
              value.position = vSeries.rectCount;
              vSeries.position = vSeries.rectCount++;
            } else {
              value.position = vSeries.position;
            }
          }
        } else {
          value.position = vSeries.rectCount++;
        }
      }
      for (var i = 0; i < seriesCollection.length; i++) {
        var value = seriesCollection[i];
        value.rectCount = vSeries.rectCount;
      }
    };
    ColumnBase2.prototype.updateSymbolLocation = function(point, rect, series) {
      if (!series.chart.requireInvertedAxis) {
        this.updateXRegion(point, rect, series);
      } else {
        this.updateYRegion(point, rect, series);
      }
      if (series.type === "Histogram") {
        point.minimum = +point.x - series.histogramValues.binWidth / 2;
        point.maximum = +point.x + series.histogramValues.binWidth / 2;
      }
    };
    ColumnBase2.prototype.updateXRegion = function(point, rect, series) {
      point.symbolLocations.push({
        x: rect.x + rect.width / 2,
        y: series.seriesType === "BoxPlot" || series.seriesType.indexOf("HighLow") !== -1 || point.yValue >= 0 === !series.yAxis.isAxisInverse ? rect.y : rect.y + rect.height
      });
      this.getRegion(point, rect, series);
      if (series.type === "RangeColumn") {
        point.symbolLocations.push({
          x: rect.x + rect.width / 2,
          y: rect.y + rect.height
        });
      }
    };
    ColumnBase2.prototype.updateYRegion = function(point, rect, series) {
      point.symbolLocations.push({
        x: series.seriesType === "BoxPlot" || series.seriesType.indexOf("HighLow") !== -1 || point.yValue >= 0 === !series.yAxis.isAxisInverse ? rect.x + rect.width : rect.x,
        y: rect.y + rect.height / 2
      });
      this.getRegion(point, rect, series);
      if (series.type === "RangeColumn") {
        point.symbolLocations.push({
          x: rect.x,
          y: rect.y + rect.height / 2
        });
      }
    };
    ColumnBase2.prototype.renderMarker = function(series) {
      if (series.marker && series.marker.visible) {
        series.chart.markerRender.render(series);
      }
    };
    ColumnBase2.prototype.getRegion = function(point, rect, series) {
      if (point.y === 0) {
        var markerWidth = series.marker && series.marker.width ? series.marker.width : 0;
        var markerHeight = series.marker && series.marker.height ? series.marker.height : 0;
        point.regions.push(new Rect(point.symbolLocations[0].x - markerWidth, point.symbolLocations[0].y - markerHeight, 2 * markerWidth, 2 * markerHeight));
      } else {
        point.regions.push(rect);
      }
    };
    ColumnBase2.prototype.triggerEvent = function(series, point, fill, border) {
      var argsData = {
        cancel: false,
        name: pointRender,
        series,
        point,
        fill: series.setPointColor(point, fill),
        border: series.setBorderColor(point, border),
        cornerRadius: series.cornerRadius
      };
      series.chart.trigger(pointRender, argsData);
      point.color = argsData.fill;
      return argsData;
    };
    ColumnBase2.prototype.drawRectangle = function(series, point, rect, argsData) {
      var chart = series.chart;
      var check = chart.requireInvertedAxis ? rect.height : rect.width;
      if (check <= 0) {
        return null;
      }
      var direction;
      if (point.y === 0) {
        direction = this.calculateRoundedRectPath(rect, 0, 0, 0, 0);
      } else {
        var topLeft = void 0;
        var topRight = void 0;
        var bottomLeft = void 0;
        var bottomRight = void 0;
        var isNegative = point.y < 0;
        if (chart.requireInvertedAxis) {
          topLeft = isNegative ? argsData.cornerRadius.topRight : argsData.cornerRadius.topLeft;
          topRight = isNegative ? argsData.cornerRadius.topLeft : argsData.cornerRadius.topRight;
          bottomLeft = isNegative ? argsData.cornerRadius.bottomRight : argsData.cornerRadius.bottomLeft;
          bottomRight = isNegative ? argsData.cornerRadius.bottomLeft : argsData.cornerRadius.bottomRight;
        } else {
          topLeft = isNegative ? argsData.cornerRadius.bottomLeft : argsData.cornerRadius.topLeft;
          topRight = isNegative ? argsData.cornerRadius.bottomRight : argsData.cornerRadius.topRight;
          bottomLeft = isNegative ? argsData.cornerRadius.topLeft : argsData.cornerRadius.bottomLeft;
          bottomRight = isNegative ? argsData.cornerRadius.topRight : argsData.cornerRadius.bottomRight;
        }
        direction = this.calculateRoundedRectPath(rect, topLeft, topRight, bottomLeft, bottomRight, chart.requireInvertedAxis);
      }
      var name = series.category === "Indicator" ? chart.element.id + "_Indicator_" + series.index + "_" + series.name + "_Point_" + point.index : chart.element.id + "_Series_" + series.index + "_Point_" + (series.removedPointIndex !== null && series.removedPointIndex <= point.index ? point.index + 1 : point.index);
      var previousElement = redrawElement(chart.redraw, name);
      var previousDirection = previousElement ? previousElement.getAttribute("d") : "";
      this.options = new PathOption(name, argsData.fill, argsData.border.width, argsData.border.color, series.opacity, series.border.dashArray, series.columnFacet === "Cylinder" ? "" : direction);
      this.element = chart.renderer.drawPath(this.options, new Int32Array([series.clipRect.x, series.clipRect.y]));
      if (series.removedPointIndex !== null && series.removedPointIndex <= point.index) {
        this.element.id = chart.element.id + "_Series_" + series.index + "_Point_" + point.index;
      }
      switch (series.seriesType) {
        case "XY":
          this.element.setAttribute("role", "img");
          this.element.setAttribute("aria-label", series.accessibility.accessibilityDescriptionFormat ? series.formatAccessibilityDescription(point, series) : point.x + ":" + point.yValue + ", " + series.name);
          break;
        case "HighLow":
          this.element.setAttribute("role", "img");
          this.element.setAttribute("aria-label", series.accessibility.accessibilityDescriptionFormat ? series.formatAccessibilityDescription(point, series) : point.x + ":" + point.high + ", " + point.low + ", " + series.name);
          break;
      }
      if (!(series.columnFacet === "Cylinder" && (chart.redraw || !chart.enableAnimation) && series.seriesElement.querySelector("#" + this.element.id))) {
        appendChildElement(series.chart.enableCanvas, series.seriesElement, this.element, chart.redraw);
      }
      if (!series.chart.enableCanvas) {
        pathAnimation(this.element, series.columnFacet === "Cylinder" ? "" : direction, chart.redraw, previousDirection, chart.duration);
      }
    };
    ColumnBase2.prototype.animate = function(series) {
      var rectElements = series.seriesElement.childNodes;
      var count = series.category === "Indicator" ? 0 : 1;
      var visiblePoints = getVisiblePoints(series);
      for (var _i = 0, visiblePoints_1 = visiblePoints; _i < visiblePoints_1.length; _i++) {
        var point = visiblePoints_1[_i];
        if (!point.symbolLocations.length && !(series.type === "BoxAndWhisker" && point.regions.length)) {
          continue;
        }
        if ((series.type === "Column" || series.type === "Bar" || series.type === "StackingColumn" || series.type === "StackingColumn100" || series.type === "StackingBar" || series.type === "StackingBar100") && series.columnFacet === "Cylinder") {
          for (var j = 0; j < rectElements.length; j++) {
            this.animateRect(rectElements[j], series, point);
          }
        } else {
          this.animateRect(rectElements[count], series, point);
          count++;
        }
      }
    };
    ColumnBase2.prototype.animateRect = function(element, series, point) {
      var option = series.animation;
      var duration = series.chart.animated ? series.chart.duration : option.duration;
      var effect = getAnimationFunction("Linear");
      var isPlot = point.yValue < 0;
      var x;
      var y;
      var elementHeight = +point.regions[0].height;
      var elementWidth = +point.regions[0].width;
      var centerX;
      var centerY;
      if (!series.chart.requireInvertedAxis) {
        x = +point.regions[0].x;
        if (series.type.indexOf("Stacking") > -1) {
          y = (1 - valueToCoefficient(0, series.yAxis)) * series.yAxis.rect.height;
          centerX = x;
          centerY = y;
        } else {
          y = +point.regions[0].y;
          centerY = series.seriesType.indexOf("HighLow") !== -1 || series.type.indexOf("Waterfall") !== -1 ? y + elementHeight / 2 : isPlot !== series.yAxis.isAxisInverse ? y : y + elementHeight;
          centerX = isPlot ? x : x + elementWidth;
        }
      } else {
        y = +point.regions[0].y;
        if (series.type.indexOf("Stacking") > -1) {
          x = valueToCoefficient(0, series.yAxis) * series.yAxis.rect.width;
          centerX = x;
          centerY = y;
        } else {
          x = +point.regions[0].x;
          centerY = isPlot ? y : y + elementHeight;
          centerX = series.seriesType.indexOf("HighLow") !== -1 || series.type.indexOf("Waterfall") !== -1 ? x + elementWidth / 2 : isPlot !== series.yAxis.isAxisInverse ? x + elementWidth : x;
        }
      }
      var value;
      if (!isNullOrUndefined(element)) {
        element.style.visibility = "hidden";
        new Animation({}).animate(element, {
          duration: duration === 0 && animationMode === "Enable" ? 1e3 : duration,
          delay: option.delay,
          progress: function(args) {
            if (args.timeStamp >= args.delay) {
              element.style.visibility = "visible";
              if (!series.chart.requireInvertedAxis) {
                elementHeight = elementHeight ? elementHeight : 1;
                value = effect(args.timeStamp - args.delay, 0, elementHeight, args.duration);
                element.setAttribute("transform", "translate(" + centerX + " " + centerY + ") scale(1," + value / elementHeight + ") translate(" + -centerX + " " + -centerY + ")");
              } else {
                elementWidth = elementWidth ? elementWidth : 1;
                value = effect(args.timeStamp - args.delay, 0, elementWidth, args.duration);
                element.setAttribute("transform", "translate(" + centerX + " " + centerY + ") scale(" + value / elementWidth + ", 1) translate(" + -centerX + " " + -centerY + ")");
              }
            }
          },
          end: function() {
            var annotations = document.getElementById(series.chart.element.id + "_Annotation_Collections");
            if (annotations) {
              annotations.style.visibility = "visible";
            }
            var stackLabelGroup = document.getElementById(series.chart.element.id + "_StackLabelGroup");
            if (stackLabelGroup) {
              stackLabelGroup.setAttribute("visibility", "visible");
            }
            element.setAttribute("transform", "translate(0,0)");
            var seriesElement = series.seriesElement;
            if (element === seriesElement.lastElementChild || point.index === series.points.length - 1 || series.type === "Waterfall" && element === seriesElement.children[seriesElement.childElementCount - 2]) {
              series.chart.trigger("animationComplete", {
                series: series.chart.isBlazor ? {} : series
              });
              if (series.type === "Waterfall") {
                var rectElements = seriesElement.childNodes;
                for (var i = 0; i < rectElements.length; i++) {
                  if (rectElements[i].id.indexOf("Connector") !== -1) {
                    rectElements[i].style.visibility = "visible";
                    rectElements[i].setAttribute("transform", "translate(0,0)");
                  }
                }
              }
            }
          }
        });
      }
    };
    ColumnBase2.prototype.calculateRoundedRectPath = function(rect, topLeft, topRight, bottomLeft, bottomRight, inverted) {
      if (inverted === void 0) {
        inverted = false;
      }
      var halfValue = inverted ? rect.width / 2 : rect.height / 2;
      topLeft = Math.min(topLeft, halfValue);
      topRight = Math.min(topRight, halfValue);
      bottomLeft = Math.min(bottomLeft, halfValue);
      bottomRight = Math.min(bottomRight, halfValue);
      return "M " + rect.x + " " + (topLeft + rect.y) + " Q " + rect.x + " " + rect.y + " " + (rect.x + topLeft) + " " + rect.y + " L " + (rect.x + rect.width - topRight) + " " + rect.y + " Q " + (rect.x + rect.width) + " " + rect.y + " " + (rect.x + rect.width) + " " + (rect.y + topRight) + " L " + (rect.x + rect.width) + " " + (rect.y + rect.height - bottomRight) + " Q " + (rect.x + rect.width) + " " + (rect.y + rect.height) + " " + (rect.x + rect.width - bottomRight) + " " + (rect.y + rect.height) + " L " + (rect.x + bottomLeft) + " " + (rect.y + rect.height) + " Q " + rect.x + " " + (rect.y + rect.height) + " " + rect.x + " " + (rect.y + rect.height - bottomLeft) + " L " + rect.x + " " + (topLeft + rect.y) + " Z";
    };
    return ColumnBase2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/column-series.js
var __extends17 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ColumnSeries = (
  /** @class */
  function(_super) {
    __extends17(ColumnSeries2, _super);
    function ColumnSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.sideBySideInfo = [];
      return _this;
    }
    ColumnSeries2.prototype.render = function(series) {
      this.sideBySideInfo[series.index] = this.getSideBySideInfo(series);
      var origin = Math.max(series.yAxis.visibleRange.min, 0);
      for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
        var pointColumn = _a[_i];
        this.renderPoint(series, pointColumn, this.sideBySideInfo[series.index], origin);
      }
      this.renderMarker(series);
    };
    ColumnSeries2.prototype.renderPoint = function(series, pointColumn, sideBySideInfo, origin) {
      pointColumn.symbolLocations = [];
      pointColumn.regions = [];
      if (pointColumn.visible && withInRange(series.points[pointColumn.index - 1], pointColumn, series.points[pointColumn.index + 1], series)) {
        this.rect = this.getRectangle(pointColumn.xValue + sideBySideInfo.start, pointColumn.yValue, pointColumn.xValue + sideBySideInfo.end, origin, series);
        this.rect.width = series.columnWidthInPixel ? series.columnWidthInPixel - (series.chart.enableSideBySidePlacement ? series.columnWidthInPixel * series.columnSpacing : 0) : this.rect.width;
        this.rect.x = series.columnWidthInPixel ? this.rect.x - (series.columnWidthInPixel / 2 * series.rectCount - series.columnWidthInPixel * series.index) : this.rect.x;
        var color = series.category === "Indicator" ? pointColumn.color : series.interior;
        var argsData = this.triggerEvent(series, pointColumn, color, {
          width: series.border.width,
          color: series.border.color
        });
        if (!argsData.cancel) {
          var adjustedYPosition = this.rect.y;
          if (pointColumn.yValue < origin && pointColumn.yValue >= 0 && series.chart.zoomModule && series.chart.zoomModule.isAxisZoomed(series.chart.axisCollections)) {
            adjustedYPosition = getPoint(pointColumn.xValue + sideBySideInfo.start, pointColumn.yValue, series.xAxis, series.yAxis, series.chart.requireInvertedAxis).y;
          }
          this.updateSymbolLocation(pointColumn, new Rect(this.rect.x, adjustedYPosition, this.rect.width, this.rect.height), series);
          this.drawRectangle(series, pointColumn, this.rect, argsData);
          if (series.columnFacet === "Cylinder") {
            var cylinderSeriesOption = {
              "isColumn": true,
              "stacking": false,
              "isLastSeries": true
            };
            this.drawCylinder(this.options, this.element, cylinderSeriesOption, this.rect, series);
          }
        }
      }
    };
    ColumnSeries2.prototype.updateDirection = function(series, point) {
      var origin = Math.max(series.yAxis.visibleRange.min, 0);
      for (var i = 0; i < point.length; i++) {
        this.renderPoint(series, series.points[point[i]], this.sideBySideInfo[series.index], origin);
        if (series.marker && series.marker.visible) {
          series.chart.markerRender.renderMarker(series, series.points[point[i]], series.points[point[i]].symbolLocations[0], null, true);
        }
        if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {
          series.chart.dataLabelModule.commonId = series.chart.element.id + "_Series_" + series.index + "_Point_";
          series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);
        }
      }
    };
    ColumnSeries2.prototype.doAnimation = function(series) {
      this.animate(series);
    };
    ColumnSeries2.prototype.getModuleName = function() {
      return "ColumnSeries";
    };
    ColumnSeries2.prototype.destroy = function() {
    };
    return ColumnSeries2;
  }(ColumnBase)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/multi-colored-base.js
var __extends18 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var MultiColoredSeries = (
  /** @class */
  function(_super) {
    __extends18(MultiColoredSeries2, _super);
    function MultiColoredSeries2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MultiColoredSeries2.prototype.getAreaPathDirection = function(xValue, yValue, series, isInverted, getPointLocation, startPoint, startPath) {
      var direction = "";
      var firstPoint;
      if (startPoint === null) {
        firstPoint = getPointLocation(xValue, yValue, series.xAxis, series.yAxis, isInverted, series);
        direction += startPath + " " + firstPoint.x + " " + firstPoint.y + " ";
      }
      return direction;
    };
    MultiColoredSeries2.prototype.getAreaEmptyDirection = function(firstPoint, secondPoint, series, isInverted, getPointLocation) {
      var direction = "";
      direction += this.getAreaPathDirection(firstPoint.x, firstPoint.y, series, isInverted, getPointLocation, null, "L");
      direction += this.getAreaPathDirection(secondPoint.x, secondPoint.y, series, isInverted, getPointLocation, null, "L");
      return direction;
    };
    MultiColoredSeries2.prototype.setPointColor = function(currentPoint, previous, series, isXSegment, segments) {
      if (series.pointColorMapping === "") {
        var segment = void 0;
        var value = void 0;
        for (var i = 0; i < segments.length; i++) {
          segment = segments[i];
          value = isXSegment ? currentPoint.xValue : currentPoint.yValue;
          if (value <= this.getAxisValue(segment.value, isXSegment ? series.xAxis : series.yAxis, series.chart) || !segment.value && segment.value !== 0) {
            currentPoint.interior = segment.color;
            break;
          }
        }
        if (currentPoint.interior == null) {
          currentPoint.interior = series.interior;
        }
        return false;
      } else {
        if (previous) {
          return series.setPointColor(currentPoint, series.interior) !== series.setPointColor(previous, series.interior);
        } else {
          return false;
        }
      }
    };
    MultiColoredSeries2.prototype.sortSegments = function(series, chartSegments) {
      var _this = this;
      var axis = series.segmentAxis === "X" ? series.xAxis : series.yAxis;
      var segments = [].concat(chartSegments);
      return segments.sort(function(a, b) {
        return _this.getAxisValue(a.value, axis, series.chart) - _this.getAxisValue(b.value, axis, series.chart);
      });
    };
    MultiColoredSeries2.prototype.applySegmentAxis = function(series, options, segments, pointAnimate) {
      var _this = this;
      if (series.pointColorMapping !== "") {
        options.map(function(option) {
          _this[pointAnimate ? "addMulticolorPath" : "appendLinePath"](option, series, "");
        });
        return null;
      }
      var isXSegment = series.segmentAxis === "X";
      var axis = isXSegment ? series.xAxis : series.yAxis;
      var chart = series.chart;
      var segment;
      this.includeSegment(segments, axis, series, segments.length);
      var length = segments.length;
      var value;
      var clipPath;
      var attributeOptions;
      var areaBorderCount = 0;
      var _loop_1 = function(index2) {
        segment = segments[index2];
        value = this_1.getAxisValue(segment.value, axis, series.chart);
        clipPath = this_1.createClipRect(index2 ? this_1.getAxisValue(segments[index2 - 1].value, axis, series.chart) : axis.visibleRange.min, value, series, index2, isXSegment);
        if (clipPath) {
          options.map(function(option) {
            areaBorderCount += 1;
            attributeOptions = {
              "clip-path": clipPath,
              "stroke-dasharray": segment.dashArray,
              "opacity": option.opacity,
              "stroke": series.type.indexOf("Line") > -1 ? segment.color || series.interior : option["stroke"],
              "stroke-width": option["stroke-width"],
              "fill": series.type.indexOf("Line") > -1 ? "none" : segment.color || series.interior,
              "id": option.id + "_Segment_" + index2,
              "d": option.d
            };
            if (areaBorderCount % 2 === 0 && _this.chart.multiColoredAreaSeriesModule && series.border.color !== "transparent" && attributeOptions["stroke-width"] !== 0) {
              attributeOptions.fill = "transparent";
            }
            if (pointAnimate) {
              _this.addMulticolorPath(attributeOptions, series, "", true);
            } else {
              pathAnimation(getElement2(attributeOptions.id), attributeOptions.d, chart.redraw);
            }
            series.pathElement = chart.renderer.drawPath(attributeOptions);
            if (!series.chart.enableCanvas && !pointAnimate) {
              series.seriesElement.appendChild(chart.renderer.drawPath(attributeOptions));
            }
          });
        }
      };
      var this_1 = this;
      for (var index = 0; index < length; index++) {
        _loop_1(index);
      }
    };
    MultiColoredSeries2.prototype.includeSegment = function(segments, axis, series, length) {
      if (length <= 0) {
        segments.push({
          value: axis.visibleRange.max,
          color: series.interior
        });
        return null;
      }
      if (this.getAxisValue(segments[length - 1].value, axis, series.chart) < axis.visibleRange.max) {
        segments.push({
          value: axis.visibleRange.max,
          color: series.interior
        });
      }
    };
    MultiColoredSeries2.prototype.addMulticolorPath = function(options, series, clipRect, isSegnment) {
      var points = this.appendPathElement(options, series, clipRect);
      if (points.previousDirection === null || points.previousDirection === "") {
        points.previousDirection = "M " + options.d.split(" ").slice(-3)[0] + " " + options.d.split(" ").slice(-5)[0] + " L " + options.d.split(" ").slice(-3)[0] + " " + options.d.split(" ").slice(-5)[0] + " L " + options.d.split(" ").slice(-3)[0] + " " + options.d.split(" ").slice(-5)[0];
      }
      if (options.d === null || options.d === "") {
        options.d = "M " + points.previousDirection.split(" ").slice(-3)[0] + " " + points.previousDirection.split(" ").slice(-5)[0] + " L " + points.previousDirection.split(" ").slice(-3)[0] + " " + points.previousDirection.split(" ").slice(-5)[0];
      }
      if (isSegnment) {
        var startPathCommands = points.previousDirection.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);
        var endPathCommands = options.d.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);
        var maxLength = Math.max(startPathCommands.length, endPathCommands.length);
        var minLength = Math.min(startPathCommands.length, endPathCommands.length);
        if (startPathCommands.length === endPathCommands.length) {
          animateAddPoints(getElement2(options.id), options.d, series.chart.redraw, points.previousDirection, this.chart.duration);
        }
        if (startPathCommands.length < endPathCommands.length) {
          for (var i = minLength; i < maxLength; i++) {
            if (endPathCommands.length !== startPathCommands.length) {
              startPathCommands.splice(startPathCommands.length - (series.type.indexOf("Line") !== -1 ? 1 : 2), 0, startPathCommands[startPathCommands.length - (series.type.indexOf("Line") !== -1 ? 1 : 2)]);
            }
          }
          animateAddPoints(getElement2(options.id), options.d, series.chart.redraw, startPathCommands.join(" "), this.chart.duration);
        }
        if (startPathCommands.length > endPathCommands.length) {
          for (var i = minLength; i < maxLength; i++) {
            if (endPathCommands.length !== startPathCommands.length) {
              endPathCommands.splice(1, 0, endPathCommands[1].replace("M", "L"));
            }
          }
          animateAddPoints(points.element, endPathCommands.join(""), series.chart.redraw, startPathCommands.join(""), this.chart.duration, options.d);
        }
      }
    };
    MultiColoredSeries2.prototype.createClipRect = function(startValue, endValue, series, index, isX) {
      var isRequired = series.chart.requireInvertedAxis;
      var startPointLocation = getPoint(isX ? startValue : series.xAxis.visibleRange.min, isX ? series.yAxis.visibleRange.max : endValue, series.xAxis, series.yAxis, isRequired);
      var endPointLocation = getPoint(isX ? endValue : series.xAxis.visibleRange.max, isX ? series.yAxis.visibleRange.min : startValue, series.xAxis, series.yAxis, isRequired);
      endPointLocation = isRequired ? [startPointLocation, startPointLocation = endPointLocation][0] : endPointLocation;
      var options;
      if ((series.xAxis.isInversed || series.xAxis.isAxisInverse ? startPointLocation.x - endPointLocation.x > 0 : endPointLocation.x - startPointLocation.x > 0) && (series.yAxis.isInversed ? startPointLocation.y - endPointLocation.y > 0 : endPointLocation.y - startPointLocation.y > 0)) {
        options = new RectOption(series.chart.element.id + "_ChartSegment" + series.index + "ClipRect_" + index, "transparent", {
          width: 1,
          color: "Gray"
        }, 1, {
          x: series.xAxis.isInversed || series.xAxis.isAxisInverse ? endPointLocation.x : startPointLocation.x,
          y: series.yAxis.isInversed ? endPointLocation.y : startPointLocation.y,
          width: series.xAxis.isInversed || series.xAxis.isAxisInverse ? startPointLocation.x - endPointLocation.x : endPointLocation.x - startPointLocation.x,
          height: series.yAxis.isInversed ? startPointLocation.y - endPointLocation.y : endPointLocation.y - startPointLocation.y
        });
        if (!series.chart.enableCanvas) {
          series.seriesElement.appendChild(appendClipElement(series.chart.redraw, options, series.chart.renderer));
        }
        return "url(#" + series.chart.element.id + "_ChartSegment" + series.index + "ClipRect_" + index + ")";
      }
      return null;
    };
    MultiColoredSeries2.prototype.getAxisValue = function(segmentValue, axis, chart) {
      if (segmentValue === null) {
        segmentValue = axis.visibleRange.max;
      }
      if (axis.valueType === "DateTime") {
        var option = {
          skeleton: "full",
          type: "dateTime"
        };
        return Date.parse(chart.intl.getDateParser(option)(chart.intl.getDateFormat(option)(new Date(DataUtil.parse.parseJson({
          val: segmentValue
        }).val))));
      } else if (axis.valueType.indexOf("Category") > -1) {
        var xValue = axis.valueType === "DateTimeCategory" ? segmentValue.getTime().toString() : segmentValue;
        return axis.labels.indexOf(xValue) < 0 ? +segmentValue : axis.labels.indexOf(xValue);
      } else {
        return +segmentValue;
      }
    };
    return MultiColoredSeries2;
  }(LineBase)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/area-series.js
var __extends19 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var AreaSeries = (
  /** @class */
  function(_super) {
    __extends19(AreaSeries2, _super);
    function AreaSeries2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AreaSeries2.prototype.render = function(series, xAxis, yAxis, isInverted, pointAnimate, pointUpdate) {
      var startPoint = null;
      var direction = "";
      var isPolar = series.chart && series.chart.chartAreaType === "PolarRadar";
      var origin = Math.max(series.yAxis.visibleRange.min, 0);
      if (isPolar) {
        var connectPoints = this.getFirstLastVisiblePoint(series.points);
        origin = connectPoints.first.yValue;
      }
      var currentXValue;
      var isDropMode = series.emptyPointSettings && series.emptyPointSettings.mode === "Drop";
      var borderWidth = series.border.width ? series.border.width : 0;
      var borderColor = series.border.color ? series.border.color : series.interior;
      var getCoordinate = series.chart.chartAreaType === "PolarRadar" ? TransformToVisible : getPoint;
      var visiblePoints = this.enableComplexProperty(series);
      var point;
      var emptyPointDirection = "";
      for (var i = 0; i < visiblePoints.length; i++) {
        point = visiblePoints[i];
        currentXValue = point.xValue;
        point.symbolLocations = [];
        point.regions = [];
        if (point.visible && withInRange(visiblePoints[i - 1], point, visiblePoints[i + 1], series)) {
          direction += this.getAreaPathDirection(currentXValue, origin, series, isInverted, getCoordinate, startPoint, "M");
          startPoint = startPoint || new ChartLocation(currentXValue, origin);
          direction += this.getAreaPathDirection(currentXValue, point.yValue, series, isInverted, getCoordinate, null, "L");
          if (visiblePoints[i + 1] && !visiblePoints[i + 1].visible && (!isPolar || isPolar && this.withinYRange(visiblePoints[i + 1], yAxis)) && !isDropMode) {
            direction += this.getAreaEmptyDirection({
              "x": currentXValue,
              "y": origin
            }, startPoint, series, isInverted, getCoordinate);
            startPoint = null;
          }
          this.storePointLocation(point, series, isInverted, getCoordinate);
        }
      }
      if (isPolar && direction !== "") {
        var endPoint = "";
        var chart = this.chart;
        endPoint += this.getAreaPathDirection(0, origin, series, isInverted, getCoordinate, null, "L");
        if (xAxis.isAxisInverse || yAxis.isAxisInverse) {
          direction += series.type === "Polar" ? chart.polarSeriesModule.getPolarIsInversedPath(xAxis, endPoint) : chart.radarSeriesModule.getRadarIsInversedPath(xAxis, endPoint);
        }
        direction = direction.concat(direction + " Z");
      }
      this[pointAnimate ? "addAreaPath" : "appendLinePath"](new PathOption(series.chart.element.id + "_Series_" + series.index, series.interior, 0, "transparent", series.opacity, series.dashArray, direction !== "" ? direction + this.getAreaPathDirection(series.points[series.points.length - 1].xValue, series.chart.chartAreaType === "PolarRadar" ? series.points[series.points.length - 1].yValue : origin, series, isInverted, getCoordinate, null, "L") : ""), series, "");
      if (series.border.width !== 0) {
        emptyPointDirection = this.removeEmptyPointsBorder(direction);
        this[pointAnimate ? "addAreaPath" : "appendLinePath"](new PathOption(series.chart.element.id + "_Series_border_" + series.index, "transparent", borderWidth, borderColor, 1, series.border.dashArray, emptyPointDirection), series, "");
      }
      if (!pointUpdate) {
        this.renderMarker(series);
      }
    };
    AreaSeries2.prototype.updateDirection = function(series, point) {
      this.render(series, series.xAxis, series.yAxis, series.chart.requireInvertedAxis, false, true);
      for (var i = 0; i < point.length; i++) {
        if (series.marker && series.marker.visible) {
          series.chart.markerRender.renderMarker(series, series.points[point[i]], series.points[point[i]].symbolLocations[0], null, true);
        }
        if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {
          series.chart.dataLabelModule.commonId = series.chart.element.id + "_Series_" + series.index + "_Point_";
          series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);
        }
      }
    };
    AreaSeries2.prototype.destroy = function() {
    };
    AreaSeries2.prototype.getModuleName = function() {
      return "AreaSeries";
    };
    AreaSeries2.prototype.doAnimation = function(series) {
      var option = series.animation;
      this.doLinearAnimation(series, option);
    };
    return AreaSeries2;
  }(MultiColoredSeries)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/bar-series.js
var __extends20 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var BarSeries = (
  /** @class */
  function(_super) {
    __extends20(BarSeries2, _super);
    function BarSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.sideBySideInfo = [];
      return _this;
    }
    BarSeries2.prototype.render = function(series) {
      var origin = Math.max(series.yAxis.visibleRange.min, 0);
      this.sideBySideInfo[series.index] = this.getSideBySideInfo(series);
      for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
        var pointBar = _a[_i];
        this.renderPoint(series, pointBar, this.sideBySideInfo[series.index], origin);
      }
      this.renderMarker(series);
    };
    BarSeries2.prototype.renderPoint = function(series, pointBar, sideBySideInfo, origin) {
      pointBar.symbolLocations = [];
      pointBar.regions = [];
      if (pointBar.visible && withInRange(series.points[pointBar.index - 1], pointBar, series.points[pointBar.index + 1], series)) {
        this.rect = this.getRectangle(pointBar.xValue + sideBySideInfo.start, pointBar.yValue, pointBar.xValue + sideBySideInfo.end, origin, series);
        this.rect.height = series.columnWidthInPixel ? series.columnWidthInPixel : this.rect.height;
        this.rect.y = series.columnWidthInPixel ? this.rect.y - (series.columnWidthInPixel / 2 * series.rectCount - series.columnWidthInPixel * series.index) : this.rect.y;
        var argsData = this.triggerEvent(series, pointBar, series.interior, {
          width: series.border.width,
          color: series.border.color
        });
        if (!argsData.cancel) {
          this.updateSymbolLocation(pointBar, this.rect, series);
          this.drawRectangle(series, pointBar, this.rect, argsData);
          if (series.columnFacet === "Cylinder") {
            var cylinderSeriesOption = {
              "isColumn": false,
              "stacking": false,
              "isLastSeries": true
            };
            this.drawCylinder(this.options, this.element, cylinderSeriesOption, this.rect, series);
          }
        }
      }
    };
    BarSeries2.prototype.updateDirection = function(series, point) {
      var origin = Math.max(series.yAxis.visibleRange.min, 0);
      for (var i = 0; i < point.length; i++) {
        this.renderPoint(series, series.points[point[i]], this.sideBySideInfo[series.index], origin);
        if (series.marker && series.marker.visible) {
          series.chart.markerRender.renderMarker(series, series.points[point[i]], series.points[point[i]].symbolLocations[0], null, true);
        }
        if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {
          series.chart.dataLabelModule.commonId = series.chart.element.id + "_Series_" + series.index + "_Point_";
          series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);
        }
      }
    };
    BarSeries2.prototype.doAnimation = function(series) {
      this.animate(series);
    };
    BarSeries2.prototype.destroy = function() {
    };
    BarSeries2.prototype.getModuleName = function() {
      return "BarSeries";
    };
    return BarSeries2;
  }(ColumnBase)
);

// node_modules/@syncfusion/ej2-charts/src/chart/axis/polar-radar-panel.js
var __extends21 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PolarRadarPanel = (
  /** @class */
  function(_super) {
    __extends21(PolarRadarPanel2, _super);
    function PolarRadarPanel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.visibleAxisLabelRect = [];
      return _this;
    }
    PolarRadarPanel2.prototype.measureAxis = function(rect) {
      var chart = this.chart;
      this.initialClipRect = rect;
      this.seriesClipRect = new Rect(rect.x, rect.y, rect.width, rect.height);
      this.measureRowAxis(chart, this.initialClipRect);
      this.measureColumnAxis(chart, this.initialClipRect);
      this.calculateAxisSize();
    };
    PolarRadarPanel2.prototype.measureRowAxis = function(chart, rect) {
      this.calculateRowSize(rect);
      var row = chart.rows[0];
      this.measureDefinition(row, chart, new Size(chart.availableSize.width, row.computedHeight));
    };
    PolarRadarPanel2.prototype.measureColumnAxis = function(chart, rect) {
      this.calculateColumnSize(rect);
      var column = chart.columns[0];
      this.measureDefinition(column, chart, new Size(column.computedWidth, chart.availableSize.height));
    };
    PolarRadarPanel2.prototype.measureDefinition = function(definition, chart, size) {
      for (var _i = 0, _a = definition.axes; _i < _a.length; _i++) {
        var axis = _a[_i];
        axis.getModule(chart);
        axis.baseModule.calculateRangeAndInterval(size, axis);
      }
    };
    PolarRadarPanel2.prototype.calculateAxisSize = function() {
      var chart = this.chart;
      var axis;
      var padding = 5;
      this.centerX = this.initialClipRect.width * 0.5 + this.initialClipRect.x;
      this.centerY = this.initialClipRect.height * 0.5 + this.initialClipRect.y;
      chart.radius = Math.min(this.initialClipRect.width, this.initialClipRect.height) / 2 - padding - chart.primaryXAxis.majorTickLines.height - chart.primaryXAxis.maxLabelSize.height;
      chart.radius = chart.primaryXAxis.coefficient * chart.radius / 100;
      this.seriesClipRect.y = this.centerY - chart.radius;
      this.seriesClipRect.x = this.centerX - chart.radius;
      this.seriesClipRect.height = 2 * chart.radius;
      this.seriesClipRect.width = 2 * chart.radius;
      this.calculateRowSize(this.seriesClipRect);
      axis = chart.primaryYAxis;
      axis.rect = this.seriesClipRect;
      this.calculateColumnSize(this.seriesClipRect);
      axis = chart.primaryXAxis;
      axis.rect = this.seriesClipRect;
    };
    PolarRadarPanel2.prototype.measure = function() {
      var chart = this.chart;
      var yAxis = chart.primaryYAxis;
      yAxis.isRTLEnabled = chart.enableRtl;
      yAxis.setIsInversedAndOpposedPosition(true);
      chart.verticalAxes.push(yAxis);
      var row = chart.rows[0];
      row.axes[0] = yAxis;
      chart.rows[0] = row;
      var xAxis = chart.primaryXAxis;
      xAxis.isRTLEnabled = chart.enableRtl;
      xAxis.setIsInversedAndOpposedPosition(true);
      chart.horizontalAxes.push(xAxis);
      var column = chart.columns[0];
      column.axes[0] = xAxis;
      chart.columns[0] = column;
    };
    PolarRadarPanel2.prototype.calculateRowSize = function(rect) {
      var chart = this.chart;
      var row = chart.rows[0];
      row.computedHeight = rect.height / 2;
      row.computedTop = rect.y;
      chart.rows[0] = row;
    };
    PolarRadarPanel2.prototype.calculateColumnSize = function(rect) {
      var chart = this.chart;
      var column = chart.columns[0];
      column.computedLeft = rect.x;
      column.computedWidth = rect.width;
      chart.columns[0] = column;
    };
    PolarRadarPanel2.prototype.renderAxes = function() {
      var axis;
      var chart = this.chart;
      this.startAngle = chart.primaryXAxis.startAngle;
      var axisElement = chart.renderer.createGroup({
        id: chart.element.id + "AxisCollection"
      });
      var axisLineElement = chart.renderer.createGroup({
        id: chart.element.id + "AxisOutsideCollection"
      });
      for (var i = 0, len = chart.axisCollections.length; i < len; i++) {
        this.element = chart.renderer.createGroup({
          id: chart.element.id + "AxisGroup" + i
        });
        axis = chart.axisCollections[i];
        if (axis.orientation === "Horizontal") {
          if (axis.majorGridLines.width > 0 || axis.majorTickLines.width > 0) {
            this.drawXAxisGridLine(axis, i);
          }
          if (axis.visible && axis.internalVisibility) {
            this.drawXAxisLabels(axis, i);
          }
        } else {
          this.drawYAxisGridLine(axis, i);
          if (axis.lineStyle.width > 0) {
            this.drawYAxisLine(axis, i);
          }
          if (axis.visible && axis.internalVisibility) {
            this.drawYAxisLabels(axis, i);
          }
        }
        if (!this.chart.enableCanvas) {
          axisElement.appendChild(this.element);
        }
      }
      if (!this.chart.enableCanvas) {
        axisElement.appendChild(this.element);
      }
      appendChildElement(chart.enableCanvas, chart.svgObject, axisElement, chart.redraw);
      return axisLineElement;
    };
    PolarRadarPanel2.prototype.drawYAxisLine = function(axis, index) {
      var chart = this.chart;
      var optionsLine = {};
      var vector3 = CoefficientToVector(valueToPolarCoefficient(axis.visibleLabels[0].value, axis), this.startAngle);
      var axisLine = "M " + this.centerX + " " + this.centerY + "L " + (this.centerX + chart.radius * vector3.x) + " " + (this.centerY + chart.radius * vector3.y);
      optionsLine = {
        "id": chart.element.id + "AxisLine_" + index,
        "d": axisLine,
        "stroke-dasharray": axis.lineStyle.dashArray,
        "stroke-width": axis.lineStyle.width,
        "stroke": axis.lineStyle.color || chart.themeStyle.axisLine
      };
      var element = chart.renderer.drawPath(optionsLine);
      this.setPointerEventNone(element);
      if (!this.chart.enableCanvas) {
        chart.yAxisElements.appendChild(element);
      }
    };
    PolarRadarPanel2.prototype.drawYAxisLabels = function(axis, index) {
      var chart = this.chart;
      var elementSize;
      var options;
      var pointX = 0;
      var pointY = 0;
      var angle = this.startAngle < 0 ? this.startAngle + 360 : this.startAngle;
      var anchor = "middle";
      var radius;
      var padding = 5;
      var isIntersect;
      var labelRegions = [];
      var isLabelVisible = [];
      isLabelVisible[0] = true;
      var intersectType = axis.labelIntersectAction;
      var labelElement = chart.renderer.createGroup({
        id: chart.element.id + "AxisLabels" + index
      });
      var vector3 = CoefficientToVector(valueToPolarCoefficient(axis.visibleLabels[0].value, axis), this.startAngle);
      for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {
        isIntersect = false;
        radius = chart.radius * valueToCoefficient(axis.visibleLabels[i].value, axis);
        elementSize = axis.visibleLabels[i].size;
        radius = chart.radius * valueToCoefficient(axis.visibleLabels[i].value, axis);
        pointX = this.centerX + radius * vector3.x + (axis.majorTickLines.height + elementSize.width / 2 + padding / 2) * Math.cos(angle * Math.PI / 180) * (axis.labelPosition === "Inside" && chart.enableRtl ? -1 : axis.labelPosition === "Inside" ? 1 : axis.labelPosition === "Outside" && chart.enableRtl ? 1 : -1);
        pointY = this.centerY + radius * vector3.y + (axis.majorTickLines.height + elementSize.height / 2) * Math.sin(angle * Math.PI / 180) * (axis.labelPosition === "Inside" && chart.enableRtl ? -1 : axis.labelPosition === "Inside" ? 1 : axis.labelPosition === "Outside" && chart.enableRtl ? 1 : -1);
        pointY += elementSize.height / 4;
        labelRegions[i] = this.getLabelRegion(pointX, pointY, axis.visibleLabels[i], anchor);
        if (i !== 0 && intersectType === "Hide") {
          for (var j = i; j >= 0; j--) {
            j = j === 0 ? 0 : j === i ? j - 1 : j;
            if (isLabelVisible[j] && isOverlap(labelRegions[i], labelRegions[j])) {
              isIntersect = true;
              isLabelVisible[i] = false;
              break;
            } else {
              isLabelVisible[i] = true;
            }
          }
          if (isIntersect) {
            continue;
          }
          for (var _i = 0, _a = this.visibleAxisLabelRect; _i < _a.length; _i++) {
            var rect = _a[_i];
            if (isOverlap(labelRegions[i], rect)) {
              isIntersect = true;
              break;
            }
          }
        }
        if (isIntersect) {
          continue;
        }
        this.visibleAxisLabelRect.push(labelRegions[i]);
        options = new TextOption(chart.element.id + index + "_AxisLabel_" + i, pointX, pointY, anchor, axis.visibleLabels[i].text);
        textElement2(chart.renderer, options, axis.labelStyle, axis.labelStyle.color || chart.themeStyle.axisLabelFont.color, labelElement, false, chart.redraw, true, true, null, null, null, null, chart.enableCanvas, null, chart.themeStyle.axisLabelFont);
      }
      if (!this.chart.enableCanvas) {
        chart.yAxisElements.appendChild(labelElement);
      }
    };
    PolarRadarPanel2.prototype.drawYAxisGridLine = function(axis, index) {
      var chart = this.chart;
      var options;
      var radius;
      var majorTick = "";
      var majorGrid = "";
      var vector3;
      var angle = this.startAngle < 0 ? this.startAngle + 360 : this.startAngle;
      var x1;
      var y1;
      var x2;
      var y2;
      var border = {
        color: axis.majorGridLines.color || chart.themeStyle.majorGridLine,
        width: axis.majorGridLines.width
      };
      var previousValue;
      var element;
      var inversedRadius;
      if (axis.majorGridLines.width > 0) {
        if (chart.visibleSeries[0].type === "Polar") {
          for (var j = 0; j < axis.visibleLabels.length; j++) {
            element = getElement2(chart.element.id + "_MajorGridLine_" + index + "_" + j);
            previousValue = element ? element.getAttribute("r") : null;
            radius = chart.radius * valueToCoefficient(axis.visibleLabels[j].value, axis);
            if (axis.isInversed && !inversedRadius) {
              inversedRadius = radius;
            }
            options = new CircleOption(chart.element.id + "_MajorGridLine_" + index + "_" + j, "transparent", border, axis.majorGridLines.width, this.centerX, this.centerY, radius);
            appendChildElement(chart.enableCanvas, this.element, chart.renderer.drawCircle(options), chart.redraw, true, "r", "r", new ChartLocation(+previousValue, +previousValue), null, true);
          }
          if (radius !== chart.radius && (!axis.isInversed || inversedRadius !== chart.radius)) {
            options = new CircleOption(chart.element.id + "_MajorGridLine_" + index + "_" + axis.visibleLabels.length + 1, "transparent", border, axis.majorGridLines.width, this.centerX, this.centerY, chart.radius);
            appendChildElement(chart.enableCanvas, this.element, chart.renderer.drawCircle(options), chart.redraw, true, "r", "r", new ChartLocation(+previousValue, +previousValue), null, true);
          }
        } else {
          for (var j = 0; j < axis.visibleLabels.length; j++) {
            radius = chart.radius * valueToCoefficient(axis.visibleLabels[j].value, axis);
            majorGrid = this.renderRadarGrid(radius, "", chart);
            element = getElement2(chart.element.id + "_MajorGridLine_" + index + "_" + j);
            previousValue = element ? element.getAttribute("d") : null;
            options = new PathOption(chart.element.id + "_MajorGridLine_" + index + "_" + j, "transparent", axis.majorGridLines.width, axis.majorGridLines.color || chart.themeStyle.majorGridLine, null, null, majorGrid);
            appendChildElement(chart.enableCanvas, this.element, chart.renderer.drawPath(options), chart.redraw, true, "x", "y", null, previousValue, true);
          }
          if (radius !== chart.radius) {
            majorGrid = this.renderRadarGrid(chart.radius, "", chart);
            element = getElement2(chart.element.id + "_MajorGridLine_" + index + "_" + axis.visibleLabels.length);
            previousValue = element ? element.getAttribute("d") : null;
            options = new PathOption(chart.element.id + "_MajorGridLine_" + index + "_" + axis.visibleLabels.length, "transparent", axis.majorGridLines.width, axis.majorGridLines.color || chart.themeStyle.majorGridLine, null, null, majorGrid);
            appendChildElement(chart.enableCanvas, this.element, chart.renderer.drawPath(options), chart.redraw, true, "x", "y", null, previousValue, true);
          }
        }
      }
      if (axis.majorTickLines.width > 0) {
        vector3 = CoefficientToVector(valueToPolarCoefficient(axis.visibleLabels[0].value, axis), this.startAngle);
        for (var i = 0; i < axis.visibleLabels.length; i++) {
          radius = chart.radius * valueToCoefficient(axis.visibleLabels[i].value, axis);
          x1 = this.centerX + radius * vector3.x;
          y1 = this.centerY + radius * vector3.y;
          x2 = x1 + axis.majorTickLines.height * Math.cos(angle * Math.PI / 180) * (axis.tickPosition === "Inside" && chart.enableRtl ? -1 : axis.tickPosition === "Inside" ? 1 : axis.tickPosition === "Outside" && chart.enableRtl ? 1 : -1);
          y2 = y1 + axis.majorTickLines.height * Math.sin(angle * Math.PI / 180) * (axis.tickPosition === "Inside" && chart.enableRtl ? -1 : axis.tickPosition === "Inside" ? 1 : axis.tickPosition === "Outside" && chart.enableRtl ? 1 : -1);
          majorTick = "M " + x1 + " " + y1 + " L " + x2 + " " + y2;
          this.renderTickLine(axis, index, majorTick, "", i);
        }
      }
    };
    PolarRadarPanel2.prototype.renderRadarGrid = function(radius, majorGrid, chart) {
      var vector3;
      var vector22;
      var x1;
      var y1;
      var x2;
      var y2;
      for (var i = 0, len = chart.primaryXAxis.visibleLabels.length; i < len; i++) {
        vector3 = CoefficientToVector(valueToPolarCoefficient(chart.primaryXAxis.visibleLabels[i].value, chart.primaryXAxis), this.startAngle);
        if (i + 1 < len) {
          vector22 = CoefficientToVector(valueToPolarCoefficient(chart.primaryXAxis.visibleLabels[i + 1].value, chart.primaryXAxis), this.startAngle);
        } else {
          vector22 = CoefficientToVector(valueToPolarCoefficient(chart.primaryXAxis.visibleLabels[0].value, chart.primaryXAxis), this.startAngle);
        }
        x1 = this.centerX + radius * vector3.x;
        y1 = this.centerY + radius * vector3.y;
        x2 = this.centerX + radius * vector22.x;
        y2 = this.centerY + radius * vector22.y;
        majorGrid = majorGrid.concat((i ? "L " : "M ") + x1 + " " + y1 + " L " + x2 + " " + y2 + " ");
      }
      return majorGrid;
    };
    PolarRadarPanel2.prototype.drawXAxisGridLine = function(axis, index) {
      var chart = this.chart;
      var tempInterval;
      var vector3;
      var majorGrid = "";
      var majorTick = "";
      var minorGirdLine = "";
      var minorTickLine = "";
      var x1 = this.centerX;
      var x2;
      var y1 = this.centerY;
      var y2;
      var minorDirection;
      var length = axis.visibleLabels.length;
      for (var i = 0; i < length; i++) {
        tempInterval = axis.visibleLabels[i].value;
        vector3 = CoefficientToVector(valueToPolarCoefficient(axis.visibleLabels[i].value, axis), this.startAngle);
        x2 = this.centerX + chart.radius * vector3.x;
        y2 = this.centerY + chart.radius * vector3.y;
        var xLoc = x2 + axis.majorTickLines.height * vector3.x * (axis.tickPosition === "Inside" ? -1 : 1);
        var yLoc = y2 + axis.majorTickLines.height * vector3.y * (axis.tickPosition === "Inside" ? -1 : 1);
        majorGrid = "M " + x1 + " " + y1 + " L " + x2 + " " + y2;
        majorTick = "M " + x2 + " " + y2 + " L " + xLoc + " " + yLoc;
        if (axis.minorTicksPerInterval > 0 && (axis.minorGridLines.width > 0 || axis.minorTickLines.width > 0) && axis.valueType !== "Category" && chart.visibleSeries[0].type !== "Radar") {
          minorDirection = this.drawAxisMinorLine(axis, tempInterval, minorGirdLine, minorTickLine);
          minorGirdLine = minorDirection[0];
          minorTickLine = minorDirection[1];
        }
        this.renderTickLine(axis, index, majorTick, minorTickLine, i);
        this.renderGridLine(axis, index, majorGrid, minorGirdLine, i);
      }
    };
    PolarRadarPanel2.prototype.drawAxisMinorLine = function(axis, tempInterval, minorGird, minorTick) {
      var value = tempInterval;
      var x;
      var y;
      var vector3;
      var range = axis.visibleRange;
      var direction = [];
      for (var j = 0; j < axis.minorTicksPerInterval; j++) {
        value += (axis.valueType === "DateTime" ? axis.dateTimeInterval : axis.visibleRange.interval) / (axis.minorTicksPerInterval + 1);
        if (inside(value, range)) {
          vector3 = CoefficientToVector(valueToPolarCoefficient(value, axis), this.startAngle);
          x = this.centerX + this.chart.radius * vector3.x;
          y = this.centerY + this.chart.radius * vector3.y;
          var tickXSize = x + axis.minorTickLines.height * vector3.x * (axis.tickPosition === "Inside" ? -1 : 1);
          var tickYSize = y + axis.minorTickLines.height * vector3.y * (axis.tickPosition === "Inside" ? -1 : 1);
          minorGird = minorGird.concat("M " + this.centerX + " " + this.centerY + "L " + x + " " + y);
          minorTick = minorTick.concat("M " + x + " " + y + "L " + tickXSize + " " + tickYSize);
        }
      }
      direction.push(minorGird);
      direction.push(minorTick);
      return direction;
    };
    PolarRadarPanel2.prototype.drawXAxisLabels = function(axis, index) {
      this.visibleAxisLabelRect = [];
      var legendRect;
      if (this.chart.legendModule) {
        legendRect = this.chart.legendModule.legendBounds;
      }
      var chart = this.chart;
      var pointX = 0;
      var pointY = 0;
      var labelElement = chart.renderer.createGroup({
        id: chart.element.id + "AxisLabels" + index
      });
      var options;
      var vector3;
      var labelText;
      var firstLabelX;
      var islabelInside = axis.labelPosition === "Inside";
      var padding = 5;
      var lastLabelX;
      var label;
      var textAnchor = "";
      var isIntersect;
      var labelRegions = [];
      var isLabelVisible = [];
      isLabelVisible[0] = true;
      var intersectType = axis.labelIntersectAction;
      var ticksbwtLabel = axis.valueType === "Category" && axis.labelPlacement === "BetweenTicks" ? 0.5 : 0;
      var radius = chart.radius + axis.majorTickLines.height;
      radius = islabelInside ? -radius : radius;
      for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {
        isIntersect = false;
        vector3 = CoefficientToVector(valueToPolarCoefficient(axis.visibleLabels[i].value + ticksbwtLabel, axis), this.startAngle);
        if (!isNaN(vector3.x) && !isNaN(vector3.y)) {
          pointX = this.centerX + (radius + axis.majorTickLines.height + padding) * vector3.x;
          pointY = this.centerY + (radius + axis.majorTickLines.height + padding) * vector3.y;
          textAnchor = parseFloat(pointX.toFixed(1)) === parseFloat(this.centerX.toFixed(1)) ? "middle" : pointX < this.centerX && !islabelInside || pointX > this.centerX && islabelInside ? "end" : "start";
        }
        label = axis.visibleLabels[i];
        labelText = label.text;
        if ((axis.enableTrim || intersectType === "Trim") && !axis.enableWrap) {
          var originalText = axis.visibleLabels[i].originalText;
          var trimText = void 0;
          var size = void 0;
          var labelPosition = axis.labelPosition;
          var chartWidth = chart.availableSize.width;
          var textLength = originalText.length;
          for (var i_1 = textLength - 1; i_1 >= 0; --i_1) {
            trimText = originalText.substring(0, i_1) + "...";
            size = measureText(trimText, axis.labelStyle, this.chart.themeStyle.axisLabelFont).width;
            if (pointX === chartWidth / 2 ? pointX - size / 2 >= 0 && pointX + size / 2 <= chartWidth : labelPosition === "Outside" && (pointX >= chartWidth / 2 && pointX + size <= chartWidth || pointX <= chartWidth / 2 && pointX - size >= 0) || labelPosition === "Inside" && (pointX + size <= chartWidth / 2 || pointX - size >= chartWidth / 2)) {
              labelText = i_1 === textLength - 1 ? originalText : trimText;
              label.size.width = measureText(labelText, axis.labelStyle, this.chart.themeStyle.axisLabelFont).width;
              label.text = labelText;
              break;
            }
          }
        }
        labelRegions[i] = this.getLabelRegion(pointX, pointY, label, textAnchor);
        if (i === 0) {
          firstLabelX = pointX;
        } else if (i === axis.visibleLabels.length - 1 && axis.valueType !== "Category") {
          lastLabelX = measureText(labelText, axis.labelStyle, this.chart.themeStyle.axisLabelFont).height;
          lastLabelX += pointX;
          labelText = lastLabelX > firstLabelX ? "" : labelText;
        }
        if (i !== 0 && intersectType === "Hide") {
          for (var j = i; j >= 0; j--) {
            j = j === 0 ? 0 : j === i ? j - 1 : j;
            if (isLabelVisible[j] && isOverlap(labelRegions[i], labelRegions[j])) {
              isIntersect = true;
              isLabelVisible[i] = false;
              break;
            } else {
              isLabelVisible[i] = true;
            }
          }
        }
        if (!isIntersect && legendRect) {
          isIntersect = isOverlap(labelRegions[i], legendRect);
          if (isIntersect) {
            var width = this.getAvailableSpaceToTrim(legendRect, labelRegions[i]);
            if (width > 0) {
              labelText = textTrim(width, axis.visibleLabels[i].originalText, axis.labelStyle, this.chart.enableRtl, this.chart.themeStyle.axisLabelFont);
              isIntersect = false;
            }
          }
        }
        options = new TextOption(chart.element.id + index + "_AxisLabel_" + i, pointX, pointY, !chart.enableRtl ? textAnchor : textAnchor === "end" ? "start" : textAnchor === "start" ? "end" : textAnchor, labelText, "", "central");
        if (isIntersect) {
          continue;
        }
        this.visibleAxisLabelRect.push(labelRegions[i]);
        textElement2(chart.renderer, options, label.labelStyle, label.labelStyle.color || chart.themeStyle.axisLabelFont.color, labelElement, false, chart.redraw, true, true, null, null, null, null, chart.enableCanvas, null, chart.themeStyle.axisLabelFont);
      }
      if (!this.chart.enableCanvas) {
        this.element.appendChild(labelElement);
      }
    };
    PolarRadarPanel2.prototype.getAvailableSpaceToTrim = function(legendRect, labelRect) {
      var legendX1 = legendRect.x;
      var legendX2 = legendX1 + legendRect.width;
      var labelX1 = labelRect.x;
      var labelX2 = labelX1 + labelRect.width;
      var width = 0;
      if (labelX1 > legendX1 && labelX1 < legendX2 && labelX2 > legendX2) {
        width = labelX2 - legendX2;
      } else if (labelX1 > legendX1 && labelX1 < legendX2 && labelX2 < legendX2) {
        width = 0;
      } else if (labelX2 > legendX1 && labelX2 < legendX2 && labelX1 < legendX1) {
        width = legendX1 - labelX1;
      } else if (labelX2 > legendX1 && labelX2 > legendX2 && labelX1 < legendX1) {
        width = legendX1 - labelX1;
      }
      return width;
    };
    PolarRadarPanel2.prototype.getLabelRegion = function(pointX, pointY, label, anchor) {
      if (anchor === "middle") {
        pointX -= label.size.width / 2;
      } else if (anchor === "end") {
        pointX -= label.size.width;
      }
      pointY -= label.size.height / 2;
      return new Rect(pointX, pointY, label.size.width, label.size.height);
    };
    PolarRadarPanel2.prototype.renderTickLine = function(axis, index, majorTickLine, minorTickLine, gridIndex) {
      var tickOptions;
      var chart = this.chart;
      var direction;
      var element;
      if (axis.majorTickLines.width > 0) {
        element = getElement2(chart.element.id + "_MajorTickLine_" + index + "_" + gridIndex);
        direction = element ? element.getAttribute("d") : null;
        tickOptions = new PathOption(chart.element.id + "_MajorTickLine_" + index + "_" + gridIndex, "transparent", axis.majorTickLines.width, axis.majorTickLines.color || chart.themeStyle.majorTickLine, null, null, majorTickLine);
        element = chart.renderer.drawPath(tickOptions);
        this.setPointerEventNone(element);
        appendChildElement(chart.enableCanvas, chart.yAxisElements, element, chart.redraw, true, "x", "y", null, direction);
      }
      if (axis.minorTickLines.width > 0) {
        element = getElement2(chart.element.id + "_MinorTickLine_" + index + "_" + gridIndex);
        direction = element ? element.getAttribute("d") : null;
        tickOptions = new PathOption(chart.element.id + "_MinorTickLine_" + index + "_" + gridIndex, "transparent", axis.minorTickLines.width, axis.minorTickLines.color || chart.themeStyle.minorTickLine, null, null, minorTickLine);
        element = chart.renderer.drawPath(tickOptions);
        this.setPointerEventNone(element);
        appendChildElement(chart.enableCanvas, chart.yAxisElements, element, chart.redraw, true, "x", "y", null, direction);
      }
    };
    PolarRadarPanel2.prototype.renderGridLine = function(axis, index, majorGrid, minorGird, gridIndex) {
      var chart = this.chart;
      var gridOptions;
      var direction;
      var element;
      if (axis.majorGridLines.width > 0) {
        element = getElement2(chart.element.id + "_MajorGridLine_" + index + "_" + gridIndex);
        direction = element ? element.getAttribute("d") : null;
        gridOptions = new PathOption(chart.element.id + "_MajorGridLine_" + index + "_" + gridIndex, "transparent", axis.majorGridLines.width, axis.majorGridLines.color || chart.themeStyle.majorGridLine, null, axis.majorGridLines.dashArray, majorGrid);
        appendChildElement(chart.enableCanvas, this.element, chart.renderer.drawPath(gridOptions), chart.redraw, true, "x", "y", null, direction);
      }
      if (axis.minorGridLines.width > 0) {
        element = getElement2(chart.element.id + "_MinorGridLine_" + index + "_" + gridIndex);
        direction = element ? element.getAttribute("d") : null;
        gridOptions = new PathOption(chart.element.id + "_MinorGridLine_" + index + "_" + gridIndex, "transparent", axis.minorGridLines.width, axis.minorGridLines.color || chart.themeStyle.minorGridLine, null, axis.minorGridLines.dashArray, minorGird);
        appendChildElement(chart.enableCanvas, this.element, chart.renderer.drawPath(gridOptions), chart.redraw, true, "x", "y", null, direction);
      }
    };
    PolarRadarPanel2.prototype.setPointerEventNone = function(element) {
      if (element) {
        element.style.pointerEvents = "none";
      }
    };
    return PolarRadarPanel2;
  }(LineBase)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/polar-series.js
var __extends22 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PolarSeries = (
  /** @class */
  function(_super) {
    __extends22(PolarSeries2, _super);
    function PolarSeries2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PolarSeries2.prototype.render = function(series, xAxis, yAxis, inverted) {
      var seriesType = firstToLowerCase(series.drawType);
      var yAxisMin = yAxis.minimum;
      var yAxisMax = yAxis.maximum;
      for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
        var visiblePoint = _a[_i];
        visiblePoint.visible = visiblePoint.visible && !(!isNullOrUndefined(yAxisMin) && visiblePoint.yValue < yAxisMin || !isNullOrUndefined(yAxisMax) && visiblePoint.yValue > yAxisMax);
      }
      if (series.points.length) {
        if (series.drawType.indexOf("Column") > -1) {
          this.columnDrawTypeRender(series, xAxis, yAxis);
        } else {
          series.chart[seriesType + "SeriesModule"].render(series, xAxis, yAxis, inverted);
        }
      }
    };
    PolarSeries2.prototype.columnDrawTypeRender = function(series, xAxis, yAxis) {
      var options;
      var argsData;
      var startAngle;
      var endAngle;
      var itemCurrentXPos;
      var radius;
      var inversedValue;
      var pointStartAngle;
      var pointEndAngle;
      var x1;
      var x2;
      var y1;
      var y2;
      var startValue;
      var endValue;
      var innerRadius;
      var min = xAxis.actualRange.min;
      var centerX = series.clipRect.width / 2 + series.clipRect.x;
      var dStartX;
      var dStartY;
      var centerY = series.clipRect.height / 2 + series.clipRect.y;
      var dEndX;
      var dEndY;
      var isRangeColumn = series.drawType === "RangeColumn";
      var isPolar = series.type === "Polar";
      var isLogAxis = yAxis.valueType === "Logarithmic";
      var isStacking = series.drawType === "StackingColumn";
      var direction = "";
      var sumofYValues = 0;
      var arcValue;
      var interval = (series.points[1] ? series.points[1].xValue : 2 * series.points[0].xValue) - series.points[0].xValue;
      var isInverse = xAxis.isAxisInverse;
      var ticks = xAxis.valueType === "Category" && xAxis.labelPlacement === "BetweenTicks" ? 0 : isInverse ? -interval / 2 : interval / 2;
      var rangeInterval = xAxis.valueType === "DateTime" ? xAxis.dateTimeInterval : 1;
      this.getSeriesPosition(series);
      var position = isInverse ? series.rectCount - 1 - series.position : series.position;
      do {
        sumofYValues += rangeInterval;
        min += rangeInterval;
      } while (min <= xAxis.actualRange.max - (xAxis.valueType === "Category" ? 0 : 1));
      for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
        var point = _a[_i];
        point.symbolLocations = [];
        point.regions = [];
        if (point.visible && withInRange(series.points[point.index - 1], point, series.points[point.index + 1], series)) {
          inversedValue = isInverse ? xAxis.visibleRange.max - point.xValue : point.xValue - xAxis.visibleRange.min;
          itemCurrentXPos = inversedValue + (interval / series.rectCount * position - ticks) + sumofYValues / 360 * xAxis.startAngle;
          itemCurrentXPos = itemCurrentXPos / sumofYValues;
          startAngle = 2 * Math.PI * (itemCurrentXPos + xAxis.startAngle);
          endAngle = 2 * Math.PI * (itemCurrentXPos + xAxis.startAngle + interval / series.rectCount / sumofYValues);
          if (startAngle === 0 && endAngle === 0) {
            endAngle = 2 * Math.PI;
            arcValue = "1";
          } else {
            arcValue = "0";
          }
          pointStartAngle = startAngle;
          pointEndAngle = endAngle;
          startAngle = startAngle - 0.5 * Math.PI + series.columnSpacing / 2;
          endAngle = endAngle - 0.5 * Math.PI - 1e-6 - series.columnSpacing / 2;
          if (isStacking || isRangeColumn) {
            startValue = isRangeColumn ? point.low : series.stackedValues.startValues[point.index];
            endValue = isRangeColumn ? point.high : series.stackedValues.endValues[point.index];
            endValue = isLogAxis ? logBase(endValue === 0 ? 1 : endValue, yAxis.logBase) : endValue;
            endValue = endValue > yAxis.actualRange.max ? yAxis.actualRange.max : endValue;
          } else {
            startValue = yAxis.visibleRange.min;
            endValue = point.yValue > yAxis.actualRange.max ? yAxis.actualRange.max : point.yValue;
          }
          radius = startValue === endValue ? 0 : series.chart.radius * valueToCoefficient(endValue, yAxis);
          x1 = centerX + radius * Math.cos(startAngle);
          x2 = centerX + radius * Math.cos(endAngle);
          y1 = centerY + radius * Math.sin(startAngle);
          y2 = centerY + radius * Math.sin(endAngle);
          innerRadius = series.chart.radius * valueToCoefficient(startValue === 0 && yAxis.visibleRange.min !== 0 ? yAxis.visibleRange.min : startValue, yAxis);
          dStartX = centerX + innerRadius * Math.cos(startAngle);
          dStartY = centerY + innerRadius * Math.sin(startAngle);
          dEndX = centerX + innerRadius * Math.cos(endAngle);
          dEndY = centerY + innerRadius * Math.sin(endAngle);
          if (isPolar) {
            direction = "M " + x1 + " " + y1 + " A " + radius + " " + radius + " 0 " + arcValue + " 1 " + x2 + " " + y2 + " L " + dEndX + " " + dEndY + " A " + innerRadius + " " + innerRadius + " 1 0 0 " + dStartX + " " + dStartY + " Z";
          } else {
            direction = "M " + x1 + " " + y1 + " L " + x2 + " " + y2 + " L " + dEndX + " " + dEndY + " L " + dStartX + " " + dStartY + " Z";
          }
          point.regionData = new PolarArc(pointStartAngle, pointEndAngle, innerRadius, radius, itemCurrentXPos);
          argsData = this.triggerEvent(series.chart, series, point);
          options = new PathOption(series.chart.element.id + "_Series_" + series.index + "_Point_" + point.index, argsData.fill, argsData.border.width, argsData.border.color, series.opacity, series.dashArray, direction);
          if (!argsData.cancel) {
            this.appendLinePath(options, series, "");
            if (isPolar) {
              point.symbolLocations.push({
                x: centerX + radius * Math.cos(startAngle + (endAngle - startAngle) / 2),
                y: centerY + radius * Math.sin(startAngle + (endAngle - startAngle) / 2)
              });
              if (isRangeColumn) {
                point.symbolLocations.push({
                  x: centerX + innerRadius * Math.cos(startAngle + (endAngle - startAngle) / 2),
                  y: centerY + innerRadius * Math.sin(startAngle + (endAngle - startAngle) / 2)
                });
              }
            } else {
              point.symbolLocations.push({
                x: (x1 + x2) / 2,
                y: (y1 + y2) / 2
              });
              if (isRangeColumn) {
                point.symbolLocations.push({
                  x: (dEndX + dStartX) / 2,
                  y: (dEndY + dStartY) / 2
                });
              }
            }
          }
        }
      }
      this.renderMarker(series);
      series.isRectSeries = true;
    };
    PolarSeries2.prototype.triggerEvent = function(chart, series, point) {
      var argsData = {
        cancel: false,
        name: pointRender,
        series,
        point,
        fill: series.setPointColor(point, series.interior),
        border: series.setBorderColor(point, {
          width: series.border.width,
          color: series.border.color
        })
      };
      chart.trigger(pointRender, argsData);
      point.color = argsData.fill;
      return argsData;
    };
    PolarSeries2.prototype.getSeriesPosition = function(series) {
      var chart = series.chart;
      var seriesCollection = [];
      var stackingGroup = [];
      var vSeries = {
        rectCount: 0,
        position: null
      };
      for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
        var series_1 = _a[_i];
        if (series_1.visible && (series_1.type === "Polar" || series_1.type === "Radar") && series_1.drawType.indexOf("Column") !== -1) {
          seriesCollection.push(series_1);
        }
      }
      for (var i = 0; i < seriesCollection.length; i++) {
        var series_2 = seriesCollection[i];
        if (series_2.drawType.indexOf("Stacking") !== -1) {
          if (series_2.stackingGroup) {
            if (stackingGroup[series_2.stackingGroup] === void 0) {
              series_2.position = vSeries.rectCount;
              stackingGroup[series_2.stackingGroup] = vSeries.rectCount++;
            } else {
              series_2.position = stackingGroup[series_2.stackingGroup];
            }
          } else {
            if (vSeries.position === null) {
              series_2.position = vSeries.rectCount;
              vSeries.position = vSeries.rectCount++;
            } else {
              series_2.position = vSeries.position;
            }
          }
        } else {
          series_2.position = vSeries.rectCount++;
        }
      }
      for (var i = 0; i < seriesCollection.length; i++) {
        var value = seriesCollection[i];
        value.rectCount = vSeries.rectCount;
      }
    };
    PolarSeries2.prototype.doAnimation = function(series) {
      var duration = series.animation.duration;
      var delay = series.animation.delay;
      var rectElements = series.seriesElement.childNodes;
      var count = 1;
      if (series.drawType === "Scatter") {
        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
          var point = _a[_i];
          if (!point.symbolLocations.length || !rectElements[count]) {
            continue;
          }
          markerAnimate(rectElements[count], delay, duration, series, point.index, point.symbolLocations[0], false);
          count++;
        }
      } else {
        for (count = 1; count < rectElements.length; count++) {
          this.doPolarRadarAnimation(rectElements[count], delay, duration, series);
        }
      }
    };
    PolarSeries2.prototype.doPolarRadarAnimation = function(animateElement, delay, duration, series) {
      var chartcenterX = series.clipRect.width / 2 + series.clipRect.x;
      var chartcenterY = series.clipRect.height / 2 + series.clipRect.y;
      var elementHeight = 0;
      animateElement.style.visibility = "hidden";
      new Animation({}).animate(animateElement, {
        duration,
        delay,
        progress: function(args) {
          if (args.timeStamp > args.delay) {
            args.element.style.visibility = "visible";
            elementHeight = (args.timeStamp - args.delay) / args.duration;
            animateElement.setAttribute("transform", "translate(" + chartcenterX + " " + chartcenterY + ") scale(" + elementHeight + ") translate(" + -chartcenterX + " " + -chartcenterY + ")");
          }
        },
        end: function() {
          var annotations = document.getElementById(series.chart.element.id + "_Annotation_Collections");
          if (annotations) {
            annotations.style.visibility = "visible";
          }
          animateElement.style.visibility = "visible";
          animateElement.removeAttribute("transform");
          series.chart.trigger("animationComplete", {
            series: series.chart.isBlazor ? {} : series
          });
        }
      });
    };
    PolarSeries2.prototype.getPolarIsInversedPath = function(xAxis, endPoint) {
      var chart = this.chart;
      var radius = chart.radius;
      var direction = endPoint;
      var circleRotate = xAxis.isAxisInverse ? "1 1 " : "1 0 ";
      var vector3 = CoefficientToVector(valueToPolarCoefficient(xAxis.visibleLabels[0].value, xAxis), this.startAngle);
      var x1 = this.centerX + radius * vector3.x;
      var y1 = this.centerY + radius * vector3.y;
      return direction += "L " + x1 + " " + y1 + " A " + radius + " " + radius + " 0 " + circleRotate + x1 + " " + (this.centerY + radius) + " A " + radius + " " + radius + " 0 " + circleRotate + x1 + " " + y1 + " ";
    };
    PolarSeries2.prototype.getModuleName = function() {
      return "PolarSeries";
    };
    PolarSeries2.prototype.destroy = function() {
    };
    return PolarSeries2;
  }(PolarRadarPanel)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/radar-series.js
var __extends23 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var RadarSeries = (
  /** @class */
  function(_super) {
    __extends23(RadarSeries2, _super);
    function RadarSeries2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    RadarSeries2.prototype.render = function(series, xAxis, yAxis, inverted) {
      var seriesType = firstToLowerCase(series.drawType);
      var yAxisMin = yAxis.minimum;
      var yAxisMax = yAxis.maximum;
      for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
        var point = _a[_i];
        point.visible = point.visible && !(!isNullOrUndefined(yAxisMin) && point.yValue < yAxisMin || !isNullOrUndefined(yAxisMax) && point.yValue > yAxisMax);
      }
      if (series.points.length) {
        if (series.drawType.indexOf("Column") === -1) {
          series.chart[seriesType + "SeriesModule"].render(series, xAxis, yAxis, inverted);
        } else {
          this.columnDrawTypeRender(series, xAxis, yAxis);
        }
      }
    };
    RadarSeries2.prototype.getRadarIsInversedPath = function(xAxis, endPoint) {
      var chart = this.chart;
      var x1;
      var y1;
      var vector3;
      var radius = chart.radius;
      var length = xAxis.visibleLabels.length;
      var direction = endPoint;
      vector3 = CoefficientToVector(valueToPolarCoefficient(xAxis.visibleLabels[0].value, xAxis), this.startAngle);
      y1 = this.centerY + radius * vector3.y;
      x1 = this.centerX + radius * vector3.x;
      if (isNaN(x1) || isNaN(y1)) {
        return direction;
      }
      direction += " L " + x1 + " " + y1 + " ";
      for (var i = length - 1; i >= 0; i--) {
        vector3 = CoefficientToVector(valueToPolarCoefficient(xAxis.visibleLabels[i].value, xAxis), this.startAngle);
        y1 = this.centerY + radius * vector3.y;
        x1 = this.centerX + radius * vector3.x;
        direction += "L " + x1 + " " + y1 + " ";
      }
      return direction;
    };
    RadarSeries2.prototype.getModuleName = function() {
      return "RadarSeries";
    };
    RadarSeries2.prototype.destroy = function() {
    };
    return RadarSeries2;
  }(PolarSeries)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/stacking-bar-series.js
var __extends24 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var StackingBarSeries = (
  /** @class */
  function(_super) {
    __extends24(StackingBarSeries2, _super);
    function StackingBarSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.sideBySideInfo = [];
      return _this;
    }
    StackingBarSeries2.prototype.render = function(series) {
      this.sideBySideInfo[series.index] = this.getSideBySideInfo(series);
      var stackedValue = series.stackedValues;
      for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
        var pointStack = _a[_i];
        this.renderPoint(series, pointStack, this.sideBySideInfo[series.index], stackedValue);
      }
      if (series.visible) {
        this.renderMarker(series);
      }
    };
    StackingBarSeries2.prototype.renderPoint = function(series, pointStack, sideBySideInfo, stackedValue) {
      pointStack.symbolLocations = [];
      pointStack.regions = [];
      if (pointStack.visible && withInRange(series.points[pointStack.index - 1], pointStack, series.points[pointStack.index + 1], series)) {
        var index = void 0;
        var startvalue = void 0;
        if (!series.visible && series.isLegendClicked) {
          for (var i = series.index; i >= 0; i--) {
            if (series.chart.visibleSeries[i].visible) {
              index = series.chart.visibleSeries[i].index;
              break;
            }
          }
          startvalue = series.index > 0 && index !== void 0 ? series.chart.visibleSeries[index].stackedValues.endValues[pointStack.index] : series.stackedValues.startValues[pointStack.index];
        }
        this.rect = this.getRectangle(pointStack.xValue + sideBySideInfo.start, !series.visible && series.isLegendClicked ? startvalue : stackedValue.endValues[pointStack.index], pointStack.xValue + sideBySideInfo.end, !series.visible && series.isLegendClicked ? startvalue : stackedValue.startValues[pointStack.index], series);
        if (series.chart.isTransposed && series.columnWidthInPixel) {
          this.rect.width = series.columnWidthInPixel ? series.columnWidthInPixel : this.rect.height;
          this.rect.x -= series.columnWidthInPixel / 2;
        } else {
          this.rect.height = series.columnWidthInPixel ? series.columnWidthInPixel : this.rect.height;
        }
        this.rect.y = series.columnWidthInPixel ? series.chart.isTransposed ? this.rect.y : this.rect.y - series.columnWidthInPixel / 2 : this.rect.y;
        var argsData = this.triggerEvent(series, pointStack, series.interior, {
          width: series.visible ? series.border.width : 0,
          color: series.visible ? series.border.color : ""
        });
        if (!argsData.cancel) {
          this.drawRectangle(series, pointStack, this.rect, argsData);
          this.updateSymbolLocation(pointStack, this.rect, series);
          if (series.columnFacet === "Cylinder") {
            var cylinderSeriesOption = {
              "isColumn": false,
              "stacking": series.type === "StackingBar100",
              "isLastSeries": true
            };
            this.drawCylinder(this.options, this.element, cylinderSeriesOption, this.rect, series);
          }
        }
      }
    };
    StackingBarSeries2.prototype.updateDirection = function(series, point) {
      var seriesCollection = [];
      for (var i = 0; i < series.yAxis.series.length; i++) {
        var stackSeries = series.yAxis.series[i];
        if (stackSeries.stackingGroup === series.stackingGroup) {
          seriesCollection.push(stackSeries);
        }
      }
      for (var j = 0; j < seriesCollection.length; j++) {
        for (var i = 0; i < point.length; i++) {
          this.renderPoint(seriesCollection[j], seriesCollection[j].points[point[i]], this.sideBySideInfo[series.index], seriesCollection[j].stackedValues);
          if (series.marker && series.marker.visible) {
            seriesCollection[j].chart.markerRender.renderMarker(seriesCollection[j], seriesCollection[j].points[point[i]], seriesCollection[j].points[point[i]].symbolLocations[0], null, true);
          }
          if (seriesCollection[j].marker.dataLabel.visible && seriesCollection[j].chart.dataLabelModule) {
            seriesCollection[j].chart.dataLabelModule.commonId = seriesCollection[j].chart.element.id + "_Series_" + seriesCollection[j].index + "_Point_";
            seriesCollection[j].chart.dataLabelModule.renderDataLabel(seriesCollection[j], seriesCollection[j].points[point[i]], null, seriesCollection[j].marker.dataLabel);
          }
        }
      }
    };
    StackingBarSeries2.prototype.destroy = function() {
    };
    StackingBarSeries2.prototype.getModuleName = function() {
      return "StackingBarSeries";
    };
    StackingBarSeries2.prototype.doAnimation = function(series) {
      this.animate(series);
    };
    return StackingBarSeries2;
  }(ColumnBase)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/candle-series.js
var __extends25 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var CandleSeries = (
  /** @class */
  function(_super) {
    __extends25(CandleSeries2, _super);
    function CandleSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.sideBySideInfo = [];
      return _this;
    }
    CandleSeries2.prototype.render = function(series) {
      this.sideBySideInfo[series.index] = this.getSideBySideInfo(series);
      var borderWidth = Math.max(series.border.width, 1);
      for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
        var point = _a[_i];
        this.renderPoint(series, point, this.sideBySideInfo[series.index], borderWidth);
      }
    };
    CandleSeries2.prototype.renderPoint = function(series, point, sideBySideInfo, borderWidth) {
      var direction = "";
      var centerRegion;
      var tickRegion;
      point.regions = [];
      point.symbolLocations = [];
      if (point.visible && withInRange(series.points[point.index - 1], point, series.points[point.index + 1], series)) {
        tickRegion = this.getRectangle(point.xValue + sideBySideInfo.median, Math.max(point.high, point.low), point.xValue + sideBySideInfo.median, Math.min(point.high, point.low), series);
        if (!series.chart.requireInvertedAxis) {
          tickRegion.x -= borderWidth / 2;
          tickRegion.width = borderWidth;
        } else {
          tickRegion.y -= borderWidth / 2;
          tickRegion.height = borderWidth;
        }
        centerRegion = this.getRectangle(point.xValue + sideBySideInfo.start, Math.max(point.open, point.close), point.xValue + sideBySideInfo.end, Math.min(point.open, point.close), series);
        direction = this.getPathString(tickRegion, centerRegion, series);
        var argsData = this.triggerPointRenderEvent(series, point);
        if (!argsData.cancel) {
          this.drawCandle(series, point, centerRegion, argsData, direction);
          this.updateSymbolLocation(point, tickRegion, series);
          this.updateSymbolLocation(point, centerRegion, series);
        }
      }
    };
    CandleSeries2.prototype.updateDirection = function(series, point) {
      var borderWidth = Math.max(series.border.width, 1);
      for (var i = 0; i < point.length; i++) {
        this.renderPoint(series, series.points[point[i]], this.sideBySideInfo[series.index], borderWidth);
        if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {
          series.chart.dataLabelModule.commonId = series.chart.element.id + "_Series_" + series.index + "_Point_";
          series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);
        }
      }
    };
    CandleSeries2.prototype.triggerPointRenderEvent = function(series, point) {
      var fill = this.getCandleColor(point, series);
      var border = {
        color: series.border.color,
        width: Math.max(series.border.width, 1)
      };
      return this.triggerEvent(series, point, fill, border);
    };
    CandleSeries2.prototype.getCandleColor = function(point, series) {
      var previousPoint = series.points[point.index - 1];
      if (series.enableSolidCandles === false) {
        if (!previousPoint) {
          return series.bearFillColor || series.chart.themeStyle.bearFillColor;
        } else {
          return previousPoint.close > point.close ? series.bullFillColor || series.chart.themeStyle.bullFillColor : series.bearFillColor || series.chart.themeStyle.bearFillColor;
        }
      } else {
        return point.open > point.close ? series.bullFillColor || series.chart.themeStyle.bullFillColor : series.bearFillColor || series.chart.themeStyle.bearFillColor;
      }
    };
    CandleSeries2.prototype.getPathString = function(topRect, midRect, series) {
      var direction = "";
      var center = series.chart.requireInvertedAxis ? topRect.y + topRect.height / 2 : topRect.x + topRect.width / 2;
      direction += !series.chart.requireInvertedAxis ? "M " + center + " " + topRect.y + " L " + center + " " + midRect.y : "M " + topRect.x + " " + center + " L " + midRect.x + " " + center;
      direction = direction.concat(" M " + midRect.x + " " + midRect.y + " L " + (midRect.x + midRect.width) + " " + midRect.y + " L " + (midRect.x + midRect.width) + " " + (midRect.y + midRect.height) + " L " + midRect.x + " " + (midRect.y + midRect.height) + " Z");
      direction += !series.chart.requireInvertedAxis ? " M " + center + " " + (midRect.y + midRect.height) + " L " + center + " " + (topRect.y + topRect.height) : " M " + (midRect.x + midRect.width) + " " + center + " L " + (topRect.x + topRect.width) + " " + center;
      return direction;
    };
    CandleSeries2.prototype.drawCandle = function(series, point, rect, argsData, direction) {
      var check = series.chart.requireInvertedAxis ? rect.height : rect.width;
      if (check <= 0) {
        return null;
      }
      var fill = !series.enableSolidCandles ? point.open > point.close ? argsData.fill : "transparent" : argsData.fill;
      argsData.border.color = argsData.fill;
      var options = new PathOption(series.chart.element.id + "_Series_" + series.index + "_Point_" + (series.removedPointIndex !== null && series.removedPointIndex <= point.index ? point.index + 1 : point.index), fill, argsData.border.width, argsData.border.color, series.opacity, series.dashArray, direction);
      var element = getElement2(options.id);
      var previousDirection = element ? element.getAttribute("d") : null;
      var candleElement = series.chart.renderer.drawPath(options, new Int32Array([series.clipRect.x, series.clipRect.y]));
      if (series.removedPointIndex !== null && series.removedPointIndex <= point.index) {
        candleElement.id = series.chart.element.id + "_Series_" + series.index + "_Point_" + point.index;
      }
      candleElement.setAttribute("role", "img");
      candleElement.setAttribute("aria-label", series.accessibility.accessibilityDescriptionFormat ? series.formatAccessibilityDescription(point, series) : point.x.toString() + ":" + point.high.toString() + ":" + point.low.toString() + ":" + point.close.toString() + ":" + point.open.toString());
      if (!series.chart.enableCanvas) {
        series.seriesElement.appendChild(candleElement);
      }
      pathAnimation(element, direction, series.chart.redraw, previousDirection, series.chart.duration);
    };
    CandleSeries2.prototype.doAnimation = function(series) {
      this.animate(series);
    };
    CandleSeries2.prototype.getModuleName = function() {
      return "CandleSeries";
    };
    CandleSeries2.prototype.destroy = function() {
    };
    return CandleSeries2;
  }(ColumnBase)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/stacking-column-series.js
var __extends26 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var StackingColumnSeries = (
  /** @class */
  function(_super) {
    __extends26(StackingColumnSeries2, _super);
    function StackingColumnSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.sideBySideInfo = [];
      return _this;
    }
    StackingColumnSeries2.prototype.render = function(series) {
      series.isRectSeries = true;
      this.sideBySideInfo[series.index] = this.getSideBySideInfo(series);
      var stackedValue = series.stackedValues;
      var visiblePoints = getVisiblePoints(series);
      for (var _i = 0, visiblePoints_1 = visiblePoints; _i < visiblePoints_1.length; _i++) {
        var point = visiblePoints_1[_i];
        this.renderPoint(series, point, this.sideBySideInfo[series.index], stackedValue, visiblePoints);
      }
      if (series.visible) {
        this.renderMarker(series);
      }
    };
    StackingColumnSeries2.prototype.renderPoint = function(series, point, sideBySideInfo, stackedValue, visiblePoints) {
      point.symbolLocations = [];
      point.regions = [];
      if (point.visible && withInRange(visiblePoints[point.index - 1], point, visiblePoints[point.index + 1], series)) {
        var index = void 0;
        var startvalue = void 0;
        if (!series.visible && series.isLegendClicked) {
          for (var i = series.index; i >= 0; i--) {
            if (series.chart.visibleSeries[i].visible) {
              index = series.chart.visibleSeries[i].index;
              break;
            }
          }
          startvalue = series.index > 0 && index !== void 0 ? series.chart.visibleSeries[index].stackedValues.endValues[point.index] : series.stackedValues.startValues[point.index];
        }
        this.rect = this.getRectangle(point.xValue + sideBySideInfo.start, !series.visible && series.isLegendClicked ? startvalue : stackedValue.endValues[point.index], point.xValue + sideBySideInfo.end, !series.visible && series.isLegendClicked ? startvalue : stackedValue.startValues[point.index], series);
        if (series.chart.isTransposed && series.columnWidthInPixel) {
          this.rect.height = series.columnWidthInPixel ? series.columnWidthInPixel : this.rect.width;
          this.rect.y -= series.columnWidthInPixel / 2;
        } else {
          this.rect.width = series.columnWidthInPixel ? series.columnWidthInPixel : this.rect.width;
        }
        this.rect.x = series.columnWidthInPixel ? series.chart.isTransposed ? this.rect.x : this.rect.x - (series.columnWidthInPixel / 2 * series.rectCount - series.columnWidthInPixel * series.position) : this.rect.x;
        var argsData = this.triggerEvent(series, point, series.interior, {
          width: series.visible ? series.border.width : 0,
          color: series.visible ? series.border.color : ""
        });
        if (!argsData.cancel) {
          this.drawRectangle(series, point, this.rect, argsData);
          this.updateSymbolLocation(point, this.rect, series);
          if (series.columnFacet === "Cylinder") {
            var cylinderSeriesOption = {
              "isColumn": true,
              "stacking": series.type === "StackingColumn100",
              "isLastSeries": true
            };
            this.drawCylinder(this.options, this.element, cylinderSeriesOption, this.rect, series);
          }
        }
      }
    };
    StackingColumnSeries2.prototype.updateDirection = function(series, point) {
      var seriesCollection = [];
      for (var i = 0; i < series.xAxis.series.length; i++) {
        var stackSeries = series.xAxis.series[i];
        if (stackSeries.stackingGroup === series.stackingGroup) {
          seriesCollection.push(stackSeries);
        }
      }
      for (var j = 0; j < seriesCollection.length; j++) {
        var visiblePoints = getVisiblePoints(seriesCollection[j]);
        for (var i = 0; i < point.length; i++) {
          this.renderPoint(seriesCollection[j], seriesCollection[j].points[point[i]], this.sideBySideInfo[series.index], seriesCollection[j].stackedValues, visiblePoints);
          if (series.marker && series.marker.visible) {
            seriesCollection[j].chart.markerRender.renderMarker(seriesCollection[j], seriesCollection[j].points[point[i]], seriesCollection[j].points[point[i]].symbolLocations[0], null, true);
          }
          if (seriesCollection[j].marker.dataLabel.visible && seriesCollection[j].chart.dataLabelModule) {
            seriesCollection[j].chart.dataLabelModule.commonId = seriesCollection[j].chart.element.id + "_Series_" + seriesCollection[j].index + "_Point_";
            seriesCollection[j].chart.dataLabelModule.renderDataLabel(seriesCollection[j], seriesCollection[j].points[point[i]], null, seriesCollection[j].marker.dataLabel);
          }
        }
      }
    };
    StackingColumnSeries2.prototype.doAnimation = function(series) {
      this.animate(series);
    };
    StackingColumnSeries2.prototype.destroy = function() {
    };
    StackingColumnSeries2.prototype.getModuleName = function() {
      return "StackingColumnSeries";
    };
    return StackingColumnSeries2;
  }(ColumnBase)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/step-line-series.js
var __extends27 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var StepLineSeries = (
  /** @class */
  function(_super) {
    __extends27(StepLineSeries2, _super);
    function StepLineSeries2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    StepLineSeries2.prototype.render = function(series, xAxis, yAxis, isInverted, pointAnimate, pointUpdate) {
      var direction = "";
      var startPoint = "M";
      var prevPoint = null;
      var lineLength;
      var point1;
      var point2;
      var visiblePoints = this.enableComplexProperty(series);
      if (xAxis.valueType === "Category" && xAxis.labelPlacement === "BetweenTicks") {
        lineLength = 0.5;
      } else {
        lineLength = 0;
      }
      for (var _i = 0, visiblePoints_1 = visiblePoints; _i < visiblePoints_1.length; _i++) {
        var point = visiblePoints_1[_i];
        point.symbolLocations = [];
        point.regions = [];
        if (point.visible && withInRange(visiblePoints[point.index - 1], point, visiblePoints[point.index + 1], series)) {
          if (startPoint === "M" && (!visiblePoints[point.index + 1] || !visiblePoints[point.index + 1].visible)) {
            direction = "";
          }
          if (prevPoint != null) {
            point2 = getPoint(point.xValue, point.yValue, xAxis, yAxis, isInverted);
            point1 = getPoint(prevPoint.xValue, prevPoint.yValue, xAxis, yAxis, isInverted);
            direction = direction.concat(startPoint + " " + point1.x + " " + point1.y + this.GetStepLineDirection(point2, point1, series.step, "L", series, true));
            startPoint = "L";
          } else {
            point1 = getPoint(point.xValue - lineLength, point.yValue, xAxis, yAxis, isInverted);
            direction = direction.concat(startPoint + " " + point1.x + " " + point1.y + " ");
            startPoint = "L";
          }
          this.storePointLocation(point, series, isInverted, getPoint);
          if (direction === "") {
            direction = "M " + point.symbolLocations[0].x + " " + point.symbolLocations[0].y;
          }
          prevPoint = point;
        } else {
          prevPoint = series.emptyPointSettings.mode === "Drop" ? prevPoint : null;
          startPoint = series.emptyPointSettings.mode === "Drop" ? startPoint : "M";
        }
      }
      if (visiblePoints.length > 0) {
        point1 = getPoint(visiblePoints[visiblePoints.length - 1].xValue + lineLength, visiblePoints[visiblePoints.length - 1].yValue, xAxis, yAxis, isInverted);
        direction = direction.concat(startPoint + " " + point1.x + " " + point1.y + " ");
      }
      var pathOptions = new PathOption(series.chart.element.id + "_Series_" + series.index, "transparent", series.width, series.interior, series.opacity, series.dashArray, direction);
      this[pointAnimate ? "addPath" : "appendLinePath"](pathOptions, series, "");
      if (!pointUpdate) {
        this.renderMarker(series);
      }
    };
    StepLineSeries2.prototype.updateDirection = function(series, point) {
      this.render(series, series.xAxis, series.yAxis, series.chart.requireInvertedAxis, false, true);
      for (var i = 0; i < point.length; i++) {
        if (series.marker && series.marker.visible) {
          series.chart.markerRender.renderMarker(series, series.points[point[i]], series.points[point[i]].symbolLocations[0], null, true);
        }
        if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {
          series.chart.dataLabelModule.commonId = series.chart.element.id + "_Series_" + series.index + "_Point_";
          series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);
        }
      }
    };
    StepLineSeries2.prototype.doAnimation = function(series) {
      var option = series.animation;
      this.doLinearAnimation(series, option);
    };
    StepLineSeries2.prototype.destroy = function() {
    };
    StepLineSeries2.prototype.getModuleName = function() {
      return "StepLineSeries";
    };
    return StepLineSeries2;
  }(LineBase)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/step-area-series.js
var __extends28 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var StepAreaSeries = (
  /** @class */
  function(_super) {
    __extends28(StepAreaSeries2, _super);
    function StepAreaSeries2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    StepAreaSeries2.prototype.render = function(series, xAxis, yAxis, isInverted, pointAnimate, pointUpdate) {
      var currentPoint;
      var secondPoint;
      var start = null;
      var direction = "";
      var visiblePoints = this.enableComplexProperty(series);
      var pointsLength = visiblePoints.length;
      var origin = Math.max(series.yAxis.visibleRange.min, 0);
      var point;
      var xValue;
      var lineLength;
      var prevPoint = null;
      var borderDirection = "";
      if (xAxis.valueType === "Category" && xAxis.labelPlacement === "BetweenTicks") {
        lineLength = 0.5;
      } else {
        lineLength = 0;
      }
      for (var i = 0; i < pointsLength; i++) {
        point = visiblePoints[i];
        xValue = point.xValue;
        point.symbolLocations = [];
        point.regions = [];
        if (point.visible && withInRange(visiblePoints[i - 1], point, visiblePoints[i + 1], series)) {
          if (start === null) {
            start = new ChartLocation(xValue, 0);
            currentPoint = getPoint(xValue - lineLength, origin, xAxis, yAxis, isInverted);
            direction += "M " + currentPoint.x + " " + currentPoint.y + " ";
            currentPoint = getPoint(xValue - lineLength, point.yValue, xAxis, yAxis, isInverted);
            direction += "L " + currentPoint.x + " " + currentPoint.y + " ";
            borderDirection += "M " + currentPoint.x + " " + currentPoint.y + " ";
          }
          if (prevPoint != null) {
            currentPoint = getPoint(point.xValue, point.yValue, xAxis, yAxis, isInverted);
            secondPoint = getPoint(prevPoint.xValue, prevPoint.yValue, xAxis, yAxis, isInverted);
            direction = direction.concat(this.GetStepLineDirection(currentPoint, secondPoint, series.step, "L", series));
            borderDirection += this.GetStepLineDirection(currentPoint, secondPoint, series.step, "L", series, true);
          } else if (series.emptyPointSettings.mode === "Gap") {
            currentPoint = getPoint(point.xValue, point.yValue, xAxis, yAxis, isInverted);
            direction += "L " + currentPoint.x + " " + currentPoint.y + " ";
            borderDirection += "L " + currentPoint.x + " " + currentPoint.y + " ";
          }
          this.storePointLocation(point, series, isInverted, getPoint);
          prevPoint = point;
        }
        if (visiblePoints[i + 1] && !visiblePoints[i + 1].visible && series.emptyPointSettings.mode !== "Drop") {
          currentPoint = getPoint(xValue + lineLength, origin, xAxis, yAxis, isInverted);
          direction += "L " + currentPoint.x + " " + currentPoint.y;
          start = null;
          prevPoint = null;
        }
      }
      if (pointsLength > 1 && direction !== "") {
        start = {
          "x": visiblePoints[pointsLength - 1].xValue + lineLength,
          "y": visiblePoints[pointsLength - 1].yValue
        };
        secondPoint = getPoint(start.x, start.y, xAxis, yAxis, isInverted);
        direction += "L " + secondPoint.x + " " + secondPoint.y + " ";
        borderDirection += "L " + secondPoint.x + " " + secondPoint.y + " ";
        start = {
          "x": visiblePoints[pointsLength - 1].xValue + lineLength,
          "y": origin
        };
        secondPoint = getPoint(start.x, start.y, xAxis, yAxis, isInverted);
        direction += "L " + secondPoint.x + " " + secondPoint.y + " ";
      } else {
        direction = "";
      }
      var options = new PathOption(series.chart.element.id + "_Series_" + series.index, series.interior, 0, "transparent", series.opacity, series.dashArray, direction);
      this[pointAnimate ? "addAreaPath" : "appendLinePath"](options, series, "");
      if (series.border.width !== 0) {
        var options_1 = new PathOption(series.chart.element.id + "_Series_border_" + series.index, "transparent", series.border.width, series.border.color ? series.border.color : series.interior, 1, series.border.dashArray, borderDirection);
        this[pointAnimate ? "addAreaPath" : "appendLinePath"](options_1, series, "");
      }
      if (!pointUpdate) {
        this.renderMarker(series);
      }
    };
    StepAreaSeries2.prototype.updateDirection = function(series, point) {
      this.render(series, series.xAxis, series.yAxis, series.chart.requireInvertedAxis, false, true);
      for (var i = 0; i < point.length; i++) {
        if (series.marker && series.marker.visible) {
          series.chart.markerRender.renderMarker(series, series.points[point[i]], series.points[point[i]].symbolLocations[0], null, true);
        }
        if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {
          series.chart.dataLabelModule.commonId = series.chart.element.id + "_Series_" + series.index + "_Point_";
          series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);
        }
      }
    };
    StepAreaSeries2.prototype.doAnimation = function(series) {
      var option = series.animation;
      this.doLinearAnimation(series, option);
    };
    StepAreaSeries2.prototype.destroy = function() {
    };
    StepAreaSeries2.prototype.getModuleName = function() {
      return "StepAreaSeries";
    };
    return StepAreaSeries2;
  }(LineBase)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/stacking-area-series.js
var __extends29 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var StackingAreaSeries = (
  /** @class */
  function(_super) {
    __extends29(StackingAreaSeries2, _super);
    function StackingAreaSeries2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    StackingAreaSeries2.prototype.render = function(series, xAxis, yAxis, isInverted, pointAnimate, pointUpdate) {
      var polarAreaType = series.chart.chartAreaType === "PolarRadar";
      var getCoordinate = polarAreaType ? TransformToVisible : getPoint;
      var lineDirection = "";
      var visiblePoints = this.enableComplexProperty(series);
      var pointsLength = visiblePoints.length;
      var stackedvalue = series.stackedValues;
      var pointIndex;
      var nextPointIndex;
      var origin = polarAreaType ? Math.max(series.yAxis.visibleRange.min, stackedvalue.endValues[0]) : Math.max(series.yAxis.visibleRange.min, stackedvalue.startValues[0]);
      var startPoint = 0;
      var point1;
      var point2;
      var emptyPointDirection = "";
      if (pointsLength > 0) {
        point1 = getCoordinate(visiblePoints[0].xValue, origin, xAxis, yAxis, isInverted, series);
        lineDirection = lineDirection.concat("M " + point1.x + " " + point1.y + " ");
      }
      var isPolar = series.chart && series.chart.chartAreaType === "PolarRadar";
      var index;
      for (var i = series.index; i >= 0; i--) {
        if (series.chart.visibleSeries[i].visible) {
          index = series.chart.visibleSeries[i].index;
          break;
        }
      }
      for (var i = 0; i < pointsLength; i++) {
        pointIndex = visiblePoints[i].index;
        visiblePoints[i].symbolLocations = [];
        visiblePoints[i].regions = [];
        if (visiblePoints[i].visible && withInRange(visiblePoints[i - 1], visiblePoints[i], visiblePoints[i + 1], series)) {
          var startvalue = series.index > 0 && index !== void 0 ? this.chart.visibleSeries[series.index].stackedValues.endValues[pointIndex] : stackedvalue.startValues[pointIndex];
          point1 = getCoordinate(visiblePoints[i].xValue, !series.visible && series.isLegendClicked ? startvalue : stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted, series);
          lineDirection = lineDirection.concat("L " + point1.x + " " + point1.y + " ");
          visiblePoints[i].symbolLocations.push(getCoordinate(visiblePoints[i].xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted, series));
          visiblePoints[i].regions.push(new Rect(visiblePoints[i].symbolLocations[0].x - series.marker.width, visiblePoints[i].symbolLocations[0].y - series.marker.height, 2 * series.marker.width, 2 * series.marker.height));
        } else {
          if (!isPolar && series.emptyPointSettings.mode !== "Drop") {
            for (var j = i - 1; j >= startPoint; j--) {
              pointIndex = visiblePoints[j].index;
              point2 = getCoordinate(visiblePoints[j].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted, series);
              lineDirection = lineDirection.concat("L " + point2.x + " " + point2.y + " ");
            }
            if (visiblePoints[i + 1] && visiblePoints[i + 1].visible && (!isPolar || isPolar && this.withinYRange(visiblePoints[i + 1], yAxis))) {
              nextPointIndex = visiblePoints[i + 1].index;
              point1 = getCoordinate(visiblePoints[i + 1].xValue, stackedvalue.startValues[nextPointIndex], xAxis, yAxis, isInverted, series);
              lineDirection = lineDirection.concat("M " + point1.x + " " + point1.y + " ");
            }
            startPoint = i + 1;
          }
        }
      }
      if (series.chart.chartAreaType === "PolarRadar" && visiblePoints.length > 1) {
        var connectPoints = this.getFirstLastVisiblePoint(series.points);
        var chart = this.chart;
        point1 = {
          "x": connectPoints.first.xValue,
          "y": stackedvalue.endValues[connectPoints.first.index]
        };
        point2 = getCoordinate(point1.x, point1.y, xAxis, yAxis, isInverted, series);
        lineDirection += "L " + point2.x + " " + point2.y + " ";
        if (this.chart.visible === 1 && (xAxis.isAxisInverse || yAxis.isAxisInverse)) {
          this.chart.enableAnimation = false;
          lineDirection = series.type === "Polar" ? chart.polarSeriesModule.getPolarIsInversedPath(xAxis, lineDirection) : chart.radarSeriesModule.getRadarIsInversedPath(xAxis, lineDirection);
        }
      }
      if (!isPolar || isPolar && series.index !== this.getFirstSeriesIndex(series.chart.visibleSeries)) {
        for (var j = pointsLength - 1; j >= startPoint; j--) {
          pointIndex = visiblePoints[j].index;
          if (isPolar && !visiblePoints[j].visible) {
            continue;
          }
          var previousSeries = this.getPreviousSeries(series);
          if (previousSeries.emptyPointSettings.mode !== "Drop" || !previousSeries.points[j].isEmpty) {
            point2 = getCoordinate(visiblePoints[j].xValue, !series.visible && series.isLegendClicked && series.index > 0 && index !== void 0 ? this.chart.visibleSeries[series.index].stackedValues.endValues[pointIndex] : stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted, series);
            if (stackedvalue.startValues[pointIndex] === stackedvalue.endValues[pointIndex]) {
              point2.y = Math.floor(point2.y);
            }
            lineDirection = lineDirection.concat((j === pointsLength - 1 && polarAreaType ? "M" : "L") + " " + point2.x + " " + point2.y + " ");
          }
        }
      }
      var options = new PathOption(series.chart.element.id + "_Series_" + series.index, series.interior, 0, "transparent", series.opacity, series.dashArray, lineDirection);
      this[pointAnimate ? "addAreaPath" : "appendLinePath"](options, series, "");
      if (series.border.width !== 0 && series.visible) {
        emptyPointDirection = this.removeEmptyPointsBorder(this.getBorderDirection(lineDirection));
        var options_1 = new PathOption(series.chart.element.id + "_Series_border_" + series.index, "transparent", series.visible ? series.border.width : 0, series.border.color ? series.border.color : series.interior, 1, series.border.dashArray, emptyPointDirection);
        this[pointAnimate ? "addAreaPath" : "appendLinePath"](options_1, series, "");
      }
      if (!pointUpdate && series.visible) {
        this.renderMarker(series);
      }
    };
    StackingAreaSeries2.prototype.updateDirection = function(series, point) {
      for (var i = 0; i < series.xAxis.series.length; i++) {
        var stackSeries = series.xAxis.series[i];
        this.render(stackSeries, stackSeries.xAxis, stackSeries.yAxis, stackSeries.chart.requireInvertedAxis, false, true);
        for (var j = 0; j < point.length; j++) {
          if (stackSeries.marker && stackSeries.marker.visible) {
            stackSeries.chart.markerRender.renderMarker(stackSeries, stackSeries.points[point[j]], stackSeries.points[point[j]].symbolLocations[0], null, true);
          }
          if (stackSeries.marker.dataLabel.visible && stackSeries.chart.dataLabelModule) {
            stackSeries.chart.dataLabelModule.commonId = stackSeries.chart.element.id + "_Series_" + stackSeries.index + "_Point_";
            stackSeries.chart.dataLabelModule.renderDataLabel(stackSeries, stackSeries.points[point[j]], null, stackSeries.marker.dataLabel);
          }
        }
      }
    };
    StackingAreaSeries2.prototype.addAreaPath = function(options, series, clipRect) {
      var points = this.appendPathElement(options, series, clipRect);
      if (points.previousDirection !== "" && options.d !== "") {
        var startPathCommands = points.previousDirection.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);
        var endPathCommands = options.d.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);
        var maxLength = Math.max(startPathCommands.length, endPathCommands.length);
        var minLength = Math.min(startPathCommands.length, endPathCommands.length);
        if (startPathCommands.length < endPathCommands.length) {
          for (var i = startPathCommands.length; i < endPathCommands.length; i++) {
            if (endPathCommands.length !== startPathCommands.length) {
              startPathCommands.splice((startPathCommands.length + 1) / 2, 0, startPathCommands.slice((startPathCommands.length - 1) / 2)[0], startPathCommands.slice((startPathCommands.length - 1) / 2)[1]);
            }
          }
          animateAddPoints(points.element, options.d, series.chart.redraw, startPathCommands.join(" "), this.chart.duration);
        } else if (startPathCommands.length > endPathCommands.length) {
          for (var i = minLength; i < maxLength; i++) {
            if (endPathCommands.length !== startPathCommands.length) {
              endPathCommands.splice(1, 0, endPathCommands[1]);
              endPathCommands.splice(endPathCommands.length - 1, 0, endPathCommands[endPathCommands.length - 1]);
            }
          }
          animateAddPoints(points.element, endPathCommands.join(""), series.chart.redraw, points.previousDirection, this.chart.duration, options.d);
        } else {
          animateAddPoints(points.element, options.d, series.chart.redraw, points.previousDirection, this.chart.duration);
        }
      }
    };
    StackingAreaSeries2.prototype.doAnimation = function(series) {
      var option = series.animation;
      this.doLinearAnimation(series, option);
    };
    StackingAreaSeries2.prototype.destroy = function() {
    };
    StackingAreaSeries2.prototype.getModuleName = function() {
      return "StackingAreaSeries";
    };
    StackingAreaSeries2.prototype.getPreviousSeries = function(series) {
      var seriesCollection = series.chart.visibleSeries;
      for (var i = 0, length_1 = seriesCollection.length; i < length_1; i++) {
        if (series.index === seriesCollection[i].index && i !== 0) {
          return seriesCollection[i - 1];
        }
      }
      return seriesCollection[0];
    };
    StackingAreaSeries2.prototype.getFirstSeriesIndex = function(seriesCollection) {
      for (var _i = 0, seriesCollection_1 = seriesCollection; _i < seriesCollection_1.length; _i++) {
        var series = seriesCollection_1[_i];
        if (series.visible) {
          return series.index;
        }
      }
      return 0;
    };
    return StackingAreaSeries2;
  }(LineBase)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/stacking-step-area-series.js
var __extends30 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var StackingStepAreaSeries = (
  /** @class */
  function(_super) {
    __extends30(StackingStepAreaSeries2, _super);
    function StackingStepAreaSeries2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    StackingStepAreaSeries2.prototype.render = function(stackSeries, xAxis, yAxis, isInverted, pointAnimate, pointUpdate) {
      var currentPointLocation;
      var secondPoint;
      var start = null;
      var direction = "";
      var borderDirection = "";
      var stackedvalue = stackSeries.stackedValues;
      var visiblePoint = this.enableComplexProperty(stackSeries);
      var origin = Math.max(stackSeries.yAxis.visibleRange.min, stackedvalue.startValues[0]);
      var pointsLength = visiblePoint.length;
      var options;
      var point;
      var point2;
      var point3;
      var xValue;
      var lineLength;
      var prevPoint = null;
      var validIndex;
      var startPoint = 0;
      var pointIndex;
      if (xAxis.valueType === "Category" && xAxis.labelPlacement === "BetweenTicks") {
        lineLength = 0.5;
      } else {
        lineLength = 0;
      }
      for (var i = 0; i < pointsLength; i++) {
        point = visiblePoint[i];
        xValue = point.xValue;
        point.symbolLocations = [];
        point.regions = [];
        pointIndex = point.index;
        if (point.visible && withInRange(visiblePoint[i - 1], point, visiblePoint[i + 1], stackSeries)) {
          if (start === null) {
            start = new ChartLocation(xValue, 0);
            currentPointLocation = getPoint(xValue - lineLength, origin, xAxis, yAxis, isInverted);
            direction += "M " + currentPointLocation.x + " " + currentPointLocation.y + " ";
            currentPointLocation = getPoint(xValue - lineLength, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted);
            direction += "L " + currentPointLocation.x + " " + currentPointLocation.y + " ";
            borderDirection += "M " + currentPointLocation.x + " " + currentPointLocation.y + " ";
          }
          if (prevPoint != null) {
            currentPointLocation = getPoint(point.xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted);
            secondPoint = getPoint(prevPoint.xValue, stackedvalue.endValues[prevPoint.index], xAxis, yAxis, isInverted);
            direction += this.GetStepLineDirection(currentPointLocation, secondPoint, stackSeries.step, "L", stackSeries, false);
            borderDirection += this.GetStepLineDirection(currentPointLocation, secondPoint, stackSeries.step, "L", stackSeries, true);
          } else if (stackSeries.emptyPointSettings.mode === "Gap") {
            currentPointLocation = getPoint(point.xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted);
            direction += "L " + currentPointLocation.x + " " + currentPointLocation.y + " ";
            borderDirection += "L " + currentPointLocation.x + " " + currentPointLocation.y + " ";
          }
          visiblePoint[i].symbolLocations.push(getPoint(visiblePoint[i].xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted));
          visiblePoint[i].regions.push(new Rect(visiblePoint[i].symbolLocations[0].x - stackSeries.marker.width, visiblePoint[i].symbolLocations[0].y - stackSeries.marker.height, 2 * stackSeries.marker.width, 2 * stackSeries.marker.height));
          prevPoint = point;
        }
        if (visiblePoint[i + 1] && !visiblePoint[i + 1].visible && start !== null && stackSeries.emptyPointSettings.mode !== "Drop") {
          var previousPointIndex = void 0;
          for (var j = i; j >= startPoint; j--) {
            pointIndex = visiblePoint[j].index;
            previousPointIndex = j === 0 ? 0 : visiblePoint[j - 1].index;
            currentPointLocation = getPoint(visiblePoint[pointIndex].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted);
            if (j !== 0 && (stackedvalue.startValues[pointIndex] < stackedvalue.startValues[previousPointIndex] || stackedvalue.startValues[pointIndex] > stackedvalue.startValues[previousPointIndex])) {
              direction = direction.concat("L " + currentPointLocation.x + " " + currentPointLocation.y + " ");
              secondPoint = getPoint(visiblePoint[previousPointIndex].xValue, stackedvalue.startValues[previousPointIndex], xAxis, yAxis, isInverted);
            } else {
              secondPoint = getPoint(visiblePoint[pointIndex].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted);
            }
            if (visiblePoint[previousPointIndex].visible) {
              direction = direction.concat(this.GetStepLineDirection(secondPoint, currentPointLocation, this.prevStep, "L", stackSeries));
            }
          }
          startPoint = i + 2;
          start = null;
          prevPoint = null;
        }
      }
      if (direction !== "") {
        if (pointsLength > 1) {
          pointIndex = visiblePoint[pointsLength - 1].index;
          start = {
            "x": visiblePoint[pointsLength - 1].xValue + lineLength,
            "y": stackedvalue.endValues[pointIndex]
          };
          secondPoint = getPoint(start.x, start.y, xAxis, yAxis, isInverted);
          direction += "L " + secondPoint.x + " " + secondPoint.y + " ";
          borderDirection += "L " + secondPoint.x + " " + secondPoint.y + " ";
          start = {
            "x": visiblePoint[pointsLength - 1].xValue + lineLength,
            "y": stackedvalue.startValues[pointIndex]
          };
          secondPoint = getPoint(start.x, start.y, xAxis, yAxis, isInverted);
          direction += "L " + secondPoint.x + " " + secondPoint.y + " ";
        }
        for (var j = pointsLength - 1; j >= startPoint; j--) {
          var index = void 0;
          if (visiblePoint[j].visible) {
            pointIndex = visiblePoint[j].index;
            point2 = getPoint(visiblePoint[j].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted);
            direction = direction.concat("L " + point2.x + " " + point2.y + " ");
          }
          if (j !== 0 && !visiblePoint[j - 1].visible) {
            index = this.getNextVisiblePointIndex(visiblePoint, j);
          }
          if (j !== 0) {
            validIndex = index ? index : j - 1;
            pointIndex = index ? visiblePoint[index].index : visiblePoint[j - 1].index;
            point3 = getPoint(visiblePoint[validIndex].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted);
            if (!(j !== 0 && !visiblePoint[j - 1].visible)) {
              direction = direction.concat(this.GetStepLineDirection(point3, point2, this.prevStep, "L", stackSeries));
            }
          }
        }
        this.prevStep = stackSeries.step === "Right" ? "Left" : stackSeries.step === "Left" ? "Right" : stackSeries.step;
        options = new PathOption(stackSeries.chart.element.id + "_Series_" + stackSeries.index, stackSeries.interior, 0, "transparent", stackSeries.opacity, stackSeries.dashArray, direction);
        this[pointAnimate ? "addPath" : "appendLinePath"](options, stackSeries, "");
        if (stackSeries.border.width !== 0) {
          options = new PathOption(stackSeries.chart.element.id + "_Series_border_" + stackSeries.index, "transparent", stackSeries.border.width, stackSeries.border.color ? stackSeries.border.color : stackSeries.interior, 1, stackSeries.border.dashArray, borderDirection);
          this[pointAnimate ? "addPath" : "appendLinePath"](options, stackSeries, "");
        }
        if (!pointUpdate) {
          this.renderMarker(stackSeries);
        }
      }
    };
    StackingStepAreaSeries2.prototype.updateDirection = function(series, point) {
      for (var i = 0; i < series.xAxis.series.length; i++) {
        var stackSeries = series.xAxis.series[i];
        this.render(stackSeries, stackSeries.xAxis, stackSeries.yAxis, stackSeries.chart.requireInvertedAxis, false, true);
        for (var j = 0; j < point.length; j++) {
          if (stackSeries.marker && stackSeries.marker.visible) {
            stackSeries.chart.markerRender.renderMarker(stackSeries, stackSeries.points[point[j]], stackSeries.points[point[j]].symbolLocations[0], null, true);
          }
          if (stackSeries.marker.dataLabel.visible && stackSeries.chart.dataLabelModule) {
            stackSeries.chart.dataLabelModule.commonId = stackSeries.chart.element.id + "_Series_" + stackSeries.index + "_Point_";
            stackSeries.chart.dataLabelModule.renderDataLabel(stackSeries, stackSeries.points[point[j]], null, stackSeries.marker.dataLabel);
          }
        }
      }
    };
    StackingStepAreaSeries2.prototype.addPath = function(options, series, clipRect) {
      var points = this.appendPathElement(options, series, clipRect);
      if (points.previousDirection !== "" && options.d !== "") {
        var startPathCommands = points.previousDirection.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);
        var endPathCommands = options.d.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);
        var maxLength = Math.max(startPathCommands.length, endPathCommands.length);
        var minLength = Math.min(startPathCommands.length, endPathCommands.length);
        if (startPathCommands.length < endPathCommands.length) {
          for (var i = startPathCommands.length; i < endPathCommands.length; i++) {
            if (endPathCommands.length !== startPathCommands.length) {
              startPathCommands.splice(Math.floor(startPathCommands.length / 2) - 1, 0, startPathCommands[Math.floor(startPathCommands.length / 2) - 1], startPathCommands[Math.floor(startPathCommands.length / 2) - 1]);
              startPathCommands.splice(Math.floor(startPathCommands.length / 2) + 2, 0, startPathCommands[Math.floor(startPathCommands.length / 2) + 2], startPathCommands[Math.floor(startPathCommands.length / 2) + 2], startPathCommands[Math.floor(startPathCommands.length / 2) + 2]);
            }
          }
          animateAddPoints(points.element, options.d, series.chart.redraw, startPathCommands.join(" "), this.chart.duration);
        } else if (startPathCommands.length > endPathCommands.length) {
          for (var i = minLength; i < maxLength; i++) {
            if (endPathCommands.length !== startPathCommands.length) {
              endPathCommands.splice(2, 0, endPathCommands[2]);
              endPathCommands.splice(endPathCommands.length - 3, 0, endPathCommands[endPathCommands.length - 3]);
            }
          }
          animateAddPoints(points.element, endPathCommands.join(""), series.chart.redraw, points.previousDirection, this.chart.duration, options.d);
        } else {
          animateAddPoints(points.element, options.d, series.chart.redraw, points.previousDirection, this.chart.duration);
        }
      }
    };
    StackingStepAreaSeries2.prototype.doAnimation = function(series) {
      var option = series.animation;
      this.doLinearAnimation(series, option);
    };
    StackingStepAreaSeries2.prototype.destroy = function() {
    };
    StackingStepAreaSeries2.prototype.getModuleName = function() {
      return "StackingStepAreaSeries";
    };
    StackingStepAreaSeries2.prototype.getNextVisiblePointIndex = function(points, j) {
      var index;
      for (index = j - 1; index >= 0; index--) {
        if (!points[index].visible) {
          continue;
        } else {
          return index;
        }
      }
      return 0;
    };
    return StackingStepAreaSeries2;
  }(LineBase)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/stacking-line-series.js
var __extends31 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var StackingLineSeries = (
  /** @class */
  function(_super) {
    __extends31(StackingLineSeries2, _super);
    function StackingLineSeries2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    StackingLineSeries2.prototype.render = function(series, xAxis, yAxis, isInverted, pointAnimate, pointUpdate) {
      var polarType = series.chart.chartAreaType === "PolarRadar";
      var getCoordinate = polarType ? TransformToVisible : getPoint;
      var direction = "";
      var visiblePts = this.enableComplexProperty(series);
      var pointsLength = visiblePts.length;
      var stackedvalue = series.stackedValues;
      var pointIndex;
      var nextPointIndex;
      var point1;
      var point2;
      for (var i = 0; i < pointsLength; i++) {
        visiblePts[i].regions = [];
        visiblePts[i].symbolLocations = [];
        pointIndex = visiblePts[i].index;
        if (visiblePts[i].visible && withInRange(visiblePts[i - 1], visiblePts[i], visiblePts[i + 1], series)) {
          point1 = getCoordinate(visiblePts[i].xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted, series);
          direction = direction.concat((i ? "L" : "M") + " " + point1.x + " " + point1.y + " ");
          visiblePts[i].symbolLocations.push(getCoordinate(visiblePts[i].xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted, series));
          visiblePts[i].regions.push(new Rect(visiblePts[i].symbolLocations[0].x - series.marker.width, visiblePts[i].symbolLocations[0].y - series.marker.height, 2 * series.marker.width, 2 * series.marker.height));
        } else {
          if (series.emptyPointSettings.mode !== "Drop") {
            if (visiblePts[i + 1] && visiblePts[i + 1].visible) {
              nextPointIndex = visiblePts[i + 1].index;
              point1 = getCoordinate(visiblePts[i + 1].xValue, stackedvalue.endValues[nextPointIndex], xAxis, yAxis, isInverted, series);
              direction = direction.concat("M " + point1.x + " " + point1.y + " ");
            }
          }
        }
      }
      if (series.chart.chartAreaType === "PolarRadar" && visiblePts.length > 1) {
        point1 = {
          "y": stackedvalue.endValues[0],
          "x": series.points[0].xValue
        };
        point2 = getCoordinate(point1.x, point1.y, xAxis, yAxis, isInverted, series);
        direction += "L " + point2.x + " " + point2.y + " ";
      }
      var options = new PathOption(series.chart.element.id + "_Series_" + series.index, "none", series.width, series.interior, series.opacity, series.dashArray, direction);
      this[pointAnimate ? "addPath" : "appendLinePath"](options, series, "");
      if (!pointUpdate) {
        this.renderMarker(series);
      }
    };
    StackingLineSeries2.prototype.updateDirection = function(series, point) {
      this.render(series, series.xAxis, series.yAxis, series.chart.requireInvertedAxis, false, true);
      for (var i = 0; i < point.length; i++) {
        if (series.marker && series.marker.visible) {
          series.chart.markerRender.renderMarker(series, series.points[point[i]], series.points[point[i]].symbolLocations[0], null, true);
        }
        if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {
          series.chart.dataLabelModule.commonId = series.chart.element.id + "_Series_" + series.index + "_Point_";
          series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);
        }
      }
    };
    StackingLineSeries2.prototype.doAnimation = function(series) {
      var option = series.animation;
      this.doLinearAnimation(series, option);
    };
    StackingLineSeries2.prototype.destroy = function() {
    };
    StackingLineSeries2.prototype.getModuleName = function() {
      return "StackingLineSeries";
    };
    return StackingLineSeries2;
  }(LineBase)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/scatter-series.js
var ScatterSeries = (
  /** @class */
  function() {
    function ScatterSeries2() {
    }
    ScatterSeries2.prototype.render = function(series, xAxis, yAxis, isInverted) {
      series.isRectSeries = false;
      var marker = series.marker;
      var visiblePoints = this.enableComplexProperty(series);
      var getCoordinate = series.chart.chartAreaType === "PolarRadar" ? TransformToVisible : getPoint;
      var scatterBorder = {
        width: this.isLineShapeMarker(marker.shape) ? series.width : series.border.width,
        color: this.isLineShapeMarker(marker.shape) ? series.interior : series.border.color
      };
      for (var _i = 0, visiblePoints_1 = visiblePoints; _i < visiblePoints_1.length; _i++) {
        var point = visiblePoints_1[_i];
        this.renderPoint(series, point, isInverted, getCoordinate, scatterBorder, visiblePoints);
      }
    };
    ScatterSeries2.prototype.renderPoint = function(series, point, isInverted, getCoordinate, scatterBorder, visiblePoints) {
      var redraw = series.chart.redraw;
      var argsData;
      var startLocation = redraw && point.symbolLocations ? point.symbolLocations[0] : null;
      point.symbolLocations = [];
      point.regions = [];
      if (point.visible && withInRange(visiblePoints[point.index - 1], point, visiblePoints[point.index + 1], series)) {
        argsData = {
          cancel: false,
          name: pointRender,
          series,
          point,
          fill: series.setPointColor(point, series.interior),
          border: series.setBorderColor(point, {
            width: scatterBorder.width,
            color: scatterBorder.color
          }),
          height: series.marker.height,
          width: series.marker.width,
          shape: series.marker.shape
        };
        series.chart.trigger(pointRender, argsData);
        if (!argsData.cancel) {
          point.symbolLocations.push(getCoordinate(point.xValue, point.yValue, series.xAxis, series.yAxis, isInverted, series));
          point.color = argsData.fill;
          this.refresh(series, point, argsData, startLocation);
        } else {
          point.marker = {
            visible: true
          };
        }
      }
    };
    ScatterSeries2.prototype.updateDirection = function(series, point, isInverted) {
      var marker = series.marker;
      var visiblePoints = this.enableComplexProperty(series);
      var getCoordinate = series.chart.chartAreaType === "PolarRadar" ? TransformToVisible : getPoint;
      var scatterBorder = {
        width: this.isLineShapeMarker(marker.shape) ? series.width : series.border.width,
        color: this.isLineShapeMarker(marker.shape) ? series.interior : series.border.color
      };
      for (var i = 0; i < point.length; i++) {
        this.renderPoint(series, series.points[point[i]], isInverted, getCoordinate, scatterBorder, visiblePoints);
        if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {
          series.chart.dataLabelModule.commonId = series.chart.element.id + "_Series_" + series.index + "_Point_";
          series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);
        }
      }
    };
    ScatterSeries2.prototype.isLineShapeMarker = function(shape) {
      return shape === "HorizontalLine" || shape === "VerticalLine" || shape === "Cross";
    };
    ScatterSeries2.prototype.enableComplexProperty = function(series) {
      var tempPoints2 = [];
      var tempPoints = [];
      var yVisibleRange = series.yAxis.visibleRange;
      var xVisibleRange = series.xAxis.visibleRange;
      var areaBounds = series.clipRect;
      var seriesPoints = series.points;
      var yTolerance = Math.abs(yVisibleRange.delta / areaBounds.height);
      var xTolerance = Math.abs(xVisibleRange.delta / areaBounds.width);
      var prevYValue = seriesPoints[0] && seriesPoints[0].y > yTolerance ? 0 : yTolerance;
      var prevXValue = seriesPoints[0] && seriesPoints[0].x > xTolerance ? 0 : xTolerance;
      var yVal = 0;
      var xVal = 0;
      for (var _i = 0, seriesPoints_1 = seriesPoints; _i < seriesPoints_1.length; _i++) {
        var currentPoint = seriesPoints_1[_i];
        if (!currentPoint.symbolLocations) {
          currentPoint.symbolLocations = [];
        }
        yVal = currentPoint.yValue ? currentPoint.yValue : yVisibleRange.min;
        xVal = currentPoint.xValue ? currentPoint.xValue : xVisibleRange.min;
        if (Math.abs(prevYValue - yVal) >= yTolerance || Math.abs(prevXValue - xVal) >= xTolerance) {
          tempPoints.push(currentPoint);
          prevYValue = yVal;
          prevXValue = xVal;
        }
      }
      var currentTempPoint;
      for (var i = 0; i < tempPoints.length; i++) {
        currentTempPoint = tempPoints[i];
        if (isNullOrUndefined(currentTempPoint.x) || currentTempPoint.x === "") {
          continue;
        } else {
          tempPoints2.push(currentTempPoint);
        }
      }
      return tempPoints2;
    };
    ScatterSeries2.prototype.refresh = function(series, point, argsData, startLocation) {
      var chart = series.chart;
      var circlePath;
      var previousPath;
      var marker = series.marker;
      var imageURL = argsData.point.marker.imageUrl || marker.imageUrl;
      var shapeOption = new PathOption(chart.element.id + "_Series_" + series.index + "_Point_" + point.index, argsData.fill, argsData.border.width, series.chart.enableCanvas && !argsData.border.color ? argsData.fill : argsData.border.color, series.opacity, series.border.dashArray);
      if (chart.redraw && getElement2(shapeOption.id)) {
        circlePath = argsData.shape === "Circle" ? "c" : "";
        previousPath = getElement2(shapeOption.id).getAttribute("d");
        var scatterElement = getElement2(shapeOption.id);
        startLocation = {
          x: +scatterElement.getAttribute(circlePath + "x"),
          y: +scatterElement.getAttribute(circlePath + "y")
        };
      }
      var element = drawSymbol(point.symbolLocations[0], argsData.shape, new Size(argsData.width, argsData.height), imageURL, shapeOption, point.x.toString() + ":" + point.yValue.toString(), series.chart.renderer, series.clipRect);
      appendChildElement(series.chart.enableCanvas, series.seriesElement, element, chart.redraw, true, circlePath + "x", circlePath + "y", startLocation, previousPath, false, false, null, chart.duration, true);
      point.regions.push(new Rect(point.symbolLocations[0].x - marker.width, point.symbolLocations[0].y - marker.height, 2 * marker.width, 2 * marker.height));
      point.marker = {
        border: argsData.border,
        fill: argsData.fill,
        height: argsData.height,
        visible: true,
        width: argsData.width,
        shape: argsData.shape,
        imageUrl: imageURL
      };
    };
    ScatterSeries2.prototype.doAnimation = function(series) {
      var duration = series.animation.duration;
      var delay = series.animation.delay;
      var rectElements = series.seriesElement.childNodes;
      var count = 1;
      for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
        var point = _a[_i];
        if (!point.symbolLocations.length || !rectElements[count]) {
          continue;
        }
        markerAnimate(rectElements[count], delay, duration, series, point.index, point.symbolLocations[0], false);
        count++;
      }
    };
    ScatterSeries2.prototype.getModuleName = function() {
      return "ScatterSeries";
    };
    ScatterSeries2.prototype.destroy = function() {
    };
    return ScatterSeries2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/range-column-series.js
var __extends32 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var RangeColumnSeries = (
  /** @class */
  function(_super) {
    __extends32(RangeColumnSeries2, _super);
    function RangeColumnSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.sideBySideInfo = [];
      return _this;
    }
    RangeColumnSeries2.prototype.render = function(series) {
      this.sideBySideInfo[series.index] = this.getSideBySideInfo(series);
      for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
        var rangePoint = _a[_i];
        this.renderPoint(series, rangePoint, this.sideBySideInfo[series.index]);
      }
      this.renderMarker(series);
    };
    RangeColumnSeries2.prototype.renderPoint = function(series, rangePoint, sideBySideInfo) {
      var rect;
      rangePoint.symbolLocations = [];
      rangePoint.regions = [];
      if (rangePoint.visible && withInRange(series.points[rangePoint.index - 1], rangePoint, series.points[rangePoint.index + 1], series)) {
        rect = this.getRectangle(rangePoint.xValue + sideBySideInfo.start, rangePoint.high, rangePoint.xValue + sideBySideInfo.end, rangePoint.low, series);
        rect.width = series.columnWidthInPixel ? series.columnWidthInPixel : rect.width;
        rect.x = series.columnWidthInPixel ? rect.x - (series.columnWidthInPixel / 2 * series.rectCount - series.columnWidthInPixel * series.index) : rect.x;
        var argsData = this.triggerEvent(series, rangePoint, series.interior, {
          width: series.border.width,
          color: series.border.color
        });
        if (!argsData.cancel) {
          this.updateSymbolLocation(rangePoint, rect, series);
          this.drawRectangle(series, rangePoint, rect, argsData);
        }
      }
    };
    RangeColumnSeries2.prototype.updateDirection = function(series, point) {
      var _loop_1 = function(i2) {
        this_1.renderPoint(series, series.points[point[i2]], this_1.sideBySideInfo[series.index]);
        if (series.marker && series.marker.visible) {
          series.points[point[i2]].symbolLocations.map(function(location, index) {
            series.chart.markerRender.renderMarker(series, series.points[point[i2]], location, index, true);
          });
        }
        if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {
          series.chart.dataLabelModule.commonId = series.chart.element.id + "_Series_" + series.index + "_Point_";
          series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i2]], null, series.marker.dataLabel);
        }
      };
      var this_1 = this;
      for (var i = 0; i < point.length; i++) {
        _loop_1(i);
      }
    };
    RangeColumnSeries2.prototype.getModuleName = function() {
      return "RangeColumnSeries";
    };
    RangeColumnSeries2.prototype.doAnimation = function(series) {
      this.animate(series);
    };
    RangeColumnSeries2.prototype.destroy = function() {
    };
    return RangeColumnSeries2;
  }(ColumnBase)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/range-step-area-series.js
var __extends33 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var RangeStepAreaSeries = (
  /** @class */
  function(_super) {
    __extends33(RangeStepAreaSeries2, _super);
    function RangeStepAreaSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.borderDirection = "";
      _this.prevPoint = null;
      return _this;
    }
    RangeStepAreaSeries2.prototype.render = function(series, xAxis, yAxis, isInverted, pointAnimate, pointUpdate) {
      this.prevPoint = null;
      var point;
      var currentPoint;
      var secondPoint;
      var start = null;
      var direction = "";
      var lineLength = 0;
      var command = "M";
      var closed = void 0;
      var low;
      var high;
      var borderWidth = series.border.width ? series.border.width : 0;
      var borderColor = series.border.color ? series.border.color : series.interior;
      var origin = Math.max(series.yAxis.visibleRange.min, 0);
      var visiblePoints = this.enableComplexProperty(series);
      if (xAxis.valueType === "Category" && xAxis.labelPlacement === "BetweenTicks") {
        lineLength = 0.5;
      }
      for (var i = 0, length_1 = visiblePoints.length; i < length_1; i++) {
        point = visiblePoints[i];
        point.symbolLocations = [];
        point.regions = [];
        low = Math.min(point.low, point.high);
        high = Math.max(point.low, point.high);
        if (yAxis.isAxisInverse) {
          var temp = low;
          low = high;
          high = temp;
        }
        var lowPoint = getPoint(point.xValue, low, xAxis, yAxis, isInverted);
        var highPoint = getPoint(point.xValue, high, xAxis, yAxis, isInverted);
        point.symbolLocations.push(highPoint);
        point.symbolLocations.push(lowPoint);
        var rect = new Rect(Math.min(lowPoint.x, highPoint.x), Math.min(lowPoint.y, highPoint.y), Math.max(Math.abs(highPoint.x - lowPoint.x), series.marker.width), Math.max(Math.abs(highPoint.y - lowPoint.y), series.marker.width));
        point.regions.push(rect);
        if (point.visible && withInRange(visiblePoints[point.index - 1], point, visiblePoints[point.index + 1], series)) {
          if (start === null) {
            start = new ChartLocation(point.xValue, 0);
            currentPoint = getPoint(point.xValue - lineLength, origin, xAxis, yAxis, isInverted);
            direction += command + " " + currentPoint.x + " " + currentPoint.y + " ";
            currentPoint = getPoint(point.xValue - lineLength, point.high > point.low ? point.high : point.low, xAxis, yAxis, isInverted);
            direction += "L " + currentPoint.x + " " + currentPoint.y + " ";
            this.borderDirection += command + " " + currentPoint.x + " " + currentPoint.y + " ";
          }
          if (this.prevPoint != null) {
            currentPoint = getPoint(point.xValue, point.high > point.low ? point.high : point.low, xAxis, yAxis, isInverted);
            secondPoint = getPoint(this.prevPoint.xValue, this.prevPoint.high > this.prevPoint.low ? this.prevPoint.high : this.prevPoint.low, xAxis, yAxis, isInverted);
            direction += this.GetStepLineDirection(currentPoint, secondPoint, series.step, command, series, false);
            this.borderDirection += this.GetStepLineDirection(currentPoint, secondPoint, series.step, command, series, true);
          } else if (series.emptyPointSettings.mode === "Gap") {
            currentPoint = getPoint(point.xValue, point.high > point.low ? point.high : point.low, xAxis, yAxis, isInverted);
            direction += command + " " + currentPoint.x + " " + currentPoint.y + " ";
            this.borderDirection += command + " " + currentPoint.x + " " + currentPoint.y + " ";
          }
          closed = false;
          command = " L";
          this.prevPoint = point;
          if (i + 1 < visiblePoints.length && !visiblePoints[i + 1].visible || i === visiblePoints.length - 1) {
            direction = this.closeRangeStepAreaPath(visiblePoints, point, series, direction, i, xAxis, yAxis, isInverted);
            command = "M";
            direction = direction.concat(" Z ");
            closed = true;
            this.prevPoint = null;
            start = null;
          }
        } else {
          if (closed === false && i !== 0) {
            direction = this.closeRangeStepAreaPath(visiblePoints, point, series, direction, i, xAxis, yAxis, isInverted);
            closed = true;
          }
          command = "M";
          point.symbolLocations = [];
        }
      }
      var options = new PathOption(series.chart.element.id + "_Series_" + series.index, series.interior, 0, "transparent", series.opacity, series.dashArray, direction);
      this[pointAnimate ? "addPath" : "appendLinePath"](options, series, "");
      if (series.border.width !== 0) {
        this[pointAnimate ? "addPath" : "appendLinePath"](new PathOption(series.chart.element.id + "_Series_border_" + series.index, "transparent", borderWidth, borderColor, 1, series.border.dashArray, this.borderDirection), series, "");
        this.borderDirection = "";
      }
      if (!pointUpdate) {
        this.renderMarker(series);
      }
    };
    RangeStepAreaSeries2.prototype.closeRangeStepAreaPath = function(visiblePoints, point, series, direction, i, xAxis, yAxis, isInverted) {
      var currentPoint;
      var secondPoint;
      var low;
      var high;
      for (var j = i; j >= 0; j--) {
        if (visiblePoints[j].visible) {
          point = visiblePoints[j];
          low = Math.min(point.low, point.high);
          high = Math.max(point.low, point.high);
          if (yAxis.isAxisInverse) {
            var temp = low;
            low = high;
            high = temp;
          }
          if (this.prevPoint != null) {
            currentPoint = getPoint(point.xValue, point.low < point.high ? point.low : point.high, xAxis, yAxis, isInverted);
            secondPoint = getPoint(this.prevPoint.xValue, this.prevPoint.low < this.prevPoint.high ? this.prevPoint.low : this.prevPoint.high, xAxis, yAxis, isInverted);
            direction += this.GetStepLineDirection(currentPoint, secondPoint, series.step === "Right" ? "Left" : series.step === "Left" ? "Right" : series.step, "L", series, false);
            if (j === i) {
              this.borderDirection += this.GetStepLineDirection(currentPoint, secondPoint, series.step === "Right" ? "Left" : series.step === "Left" ? "Right" : series.step, "M", series, true);
            } else {
              this.borderDirection += this.GetStepLineDirection(currentPoint, secondPoint, series.step === "Right" ? "Left" : series.step === "Left" ? "Right" : series.step, "L", series, true);
            }
          }
        } else {
          break;
        }
        this.prevPoint = point;
      }
      return direction;
    };
    RangeStepAreaSeries2.prototype.updateDirection = function(series, point) {
      this.render(series, series.xAxis, series.yAxis, series.chart.requireInvertedAxis, false, true);
      var _loop_1 = function(i2) {
        if (series.marker && series.marker.visible) {
          series.points[point[i2]].symbolLocations.map(function(location, index) {
            series.chart.markerRender.renderMarker(series, series.points[point[i2]], location, index, true);
          });
        }
        if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {
          series.chart.dataLabelModule.commonId = series.chart.element.id + "_Series_" + series.index + "_Point_";
          series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i2]], null, series.marker.dataLabel);
        }
      };
      for (var i = 0; i < point.length; i++) {
        _loop_1(i);
      }
    };
    RangeStepAreaSeries2.prototype.addPath = function(options, series, clipRect) {
      var points = this.appendPathElement(options, series, clipRect);
      if (points.previousDirection !== "" && options.d !== "") {
        var startPathCommands = points.previousDirection.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);
        var endPathCommands = options.d.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);
        var maxLength = Math.max(startPathCommands.length, endPathCommands.length);
        var minLength = Math.min(startPathCommands.length, endPathCommands.length);
        if (startPathCommands.length < endPathCommands.length) {
          for (var i = startPathCommands.length; i < endPathCommands.length; i++) {
            if (endPathCommands.length !== startPathCommands.length) {
              startPathCommands.splice(Math.floor(startPathCommands.length / 2) - 1, 0, startPathCommands[Math.floor(startPathCommands.length / 2) - 1], startPathCommands[Math.floor(startPathCommands.length / 2) - 1]);
              startPathCommands.splice(Math.floor(startPathCommands.length / 2) + 2, 0, startPathCommands[Math.floor(startPathCommands.length / 2) + 2], startPathCommands[Math.floor(startPathCommands.length / 2) + 2]);
            }
          }
          animateAddPoints(points.element, options.d, series.chart.redraw, startPathCommands.join(" "), this.chart.duration);
        } else if (startPathCommands.length > endPathCommands.length) {
          for (var i = minLength; i < maxLength; i++) {
            if (endPathCommands.length !== startPathCommands.length) {
              endPathCommands.splice(2, 0, endPathCommands[2]);
              endPathCommands.splice(endPathCommands.length - 3, 0, endPathCommands[endPathCommands.length - 3]);
            }
          }
          animateAddPoints(points.element, endPathCommands.join(""), series.chart.redraw, points.previousDirection, this.chart.duration, options.d);
        } else {
          animateAddPoints(points.element, options.d, series.chart.redraw, points.previousDirection, this.chart.duration);
        }
      }
    };
    RangeStepAreaSeries2.prototype.doAnimation = function(series) {
      var option = series.animation;
      this.doLinearAnimation(series, option);
    };
    RangeStepAreaSeries2.prototype.getModuleName = function() {
      return "RangeStepAreaSeries";
    };
    RangeStepAreaSeries2.prototype.destroy = function() {
    };
    return RangeStepAreaSeries2;
  }(LineBase)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/waterfall-series.js
var __extends34 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var WaterfallSeries = (
  /** @class */
  function(_super) {
    __extends34(WaterfallSeries2, _super);
    function WaterfallSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.cumulativeSums = [];
      return _this;
    }
    WaterfallSeries2.prototype.render = function(series) {
      var rect;
      var sideBySideInfo = this.getSideBySideInfo(series);
      var origin = Math.max(series.yAxis.visibleRange.min, 0);
      var argsData;
      var prevEndValue = 0;
      var direction = "";
      var currentEndValue = 0;
      var originValue;
      var prevRegion = null;
      var y;
      var isInversed = series.chart.requireInvertedAxis;
      var intermediateOrigin = 0;
      var redraw = series.chart.redraw;
      for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
        var point = _a[_i];
        point.symbolLocations = [];
        point.regions = [];
        if (point.visible && withInRange(series.points[point.index - 1], point, series.points[point.index + 1], series)) {
          var isSum = this.isIntermediateSum(series, point.index);
          var totalSum = this.isSumIndex(series, point.index);
          currentEndValue += isSum || totalSum === true ? 0 : point.yValue;
          originValue = isSum === true ? intermediateOrigin : prevEndValue !== null && !totalSum ? prevEndValue : origin;
          rect = this.getRectangle(point.xValue + sideBySideInfo.start, currentEndValue, point.xValue + sideBySideInfo.end, originValue, series);
          argsData = this.triggerPointRenderEvent(series, point);
          if (isSum) {
            intermediateOrigin = currentEndValue;
          }
          prevEndValue = currentEndValue;
          if (!argsData.cancel) {
            this.updateSymbolLocation(point, rect, series);
            this.drawRectangle(series, point, rect, argsData);
          }
          var currentRegion = point.regions[0];
          if (prevRegion !== null) {
            var prevLeft = isInversed ? prevRegion.x : prevRegion.y;
            var currentLeft = isInversed ? currentRegion.x : currentRegion.y;
            var prevBottom = void 0;
            var currentBottom = void 0;
            var currentYValue = currentRegion.y;
            var currentXValue = currentRegion.x;
            var beforePoint = series.points[point.index - 1 === -1 ? 1 : point.index - 1];
            if (point.yValue === 0) {
              prevBottom = isInversed ? prevRegion.x + prevRegion.width : prevRegion.y + prevRegion.height;
              currentBottom = isInversed ? point.symbolLocations[0].x : point.symbolLocations[0].y;
            } else {
              prevBottom = isInversed ? beforePoint.yValue === 0 ? beforePoint.symbolLocations[0].x : prevRegion.x + prevRegion.width : beforePoint.yValue === 0 ? beforePoint.symbolLocations[0].y : prevRegion.y + prevRegion.height;
              currentBottom = isInversed ? currentRegion.x + currentRegion.width : currentRegion.y + currentRegion.height;
            }
            if (Math.round(prevLeft) === Math.round(currentLeft) || Math.round(prevBottom) === Math.round(currentLeft)) {
              y = isInversed ? currentRegion.x === 0 && prevRegion.x === 0 ? currentBottom : currentRegion.x : currentRegion.y;
              y = point.yValue === 0 ? isInversed ? point.symbolLocations[0].x : point.symbolLocations[0].y : y;
            } else {
              y = currentBottom;
            }
            if (isInversed) {
              if (beforePoint.yValue === 0) {
                prevRegion.y = prevRegion.y + prevRegion.height / 2 + rect.height / 2 - prevRegion.height;
              }
              if (point.yValue === 0) {
                currentYValue = currentRegion.y + currentRegion.height / 2 - rect.height / 2;
              }
              direction = direction.concat("M " + y + " " + (series.xAxis.isInversed ? prevRegion.y + prevRegion.height : prevRegion.y) + " L " + y + " " + (series.xAxis.isInversed ? currentYValue : currentYValue + currentRegion.height) + " ");
            } else {
              var connectorX = prevRegion.x;
              if (beforePoint.yValue === 0) {
                connectorX = connectorX + prevRegion.width / 2 + rect.width / 2 - prevRegion.width;
                currentXValue = currentRegion.x + currentRegion.width / 2 + rect.width / 2 - currentRegion.width;
              }
              if (point.yValue === 0) {
                currentXValue = currentRegion.x + currentRegion.width / 2 - rect.width / 2;
              }
              direction = direction.concat("M " + (series.xAxis.isInversed ? connectorX : connectorX + prevRegion.width) + " " + y + " L " + (series.xAxis.isInversed ? currentXValue + currentRegion.width : currentXValue) + " " + y + " ");
            }
          }
          prevRegion = point.regions[0];
        }
      }
      var options = new PathOption(series.chart.element.id + "_Series_" + series.index + "_Connector_", "none", series.connector.width, series.connector.color, series.opacity, series.connector.dashArray, direction);
      if (redraw && getElement2(options.id)) {
        direction = getElement2(options.id).getAttribute("d");
      }
      var element = redrawElement(redraw, options.id, options, series.chart.renderer) || series.chart.renderer.drawPath(options, new Int32Array([series.clipRect.x, series.clipRect.y]));
      element.style.visibility = !series.chart.enableCanvas ? (series.animation.enable && animationMode !== "Disable" || animationMode === "Enable") && series.chart.animateSeries ? "hidden" : "visible" : null;
      appendChildElement(series.chart.enableCanvas, series.seriesElement, element, redraw, true, null, null, null, direction, null, null, null, series.chart.duration);
      this.renderMarker(series);
    };
    WaterfallSeries2.prototype.updateDirection = function(series, point) {
      this.render(series);
      if (series.marker.visible) {
        appendChildElement(series.chart.enableCanvas, series.chart.seriesElements, series.symbolElement, true);
      }
      if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {
        for (var i = 0; i < point.length; i++) {
          series.chart.dataLabelModule.commonId = series.chart.element.id + "_Series_" + series.index + "_Point_";
          var dataLabelElement = series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);
          for (var j = 0; j < dataLabelElement.length; j++) {
            series.chart.dataLabelModule.doDataLabelAnimation(series, dataLabelElement[j]);
          }
        }
      }
    };
    WaterfallSeries2.prototype.isIntermediateSum = function(series, index) {
      if (series.intermediateSumIndexes !== void 0 && series.intermediateSumIndexes.indexOf(index) !== -1) {
        return true;
      }
      return false;
    };
    WaterfallSeries2.prototype.isSumIndex = function(series, index) {
      if (series.sumIndexes !== void 0 && series.sumIndexes.indexOf(index) !== -1) {
        return true;
      }
      return false;
    };
    WaterfallSeries2.prototype.triggerPointRenderEvent = function(series, point) {
      var color;
      var isSum = this.isIntermediateSum(series, point.index);
      var totalSum = this.isSumIndex(series, point.index);
      if (isSum || totalSum) {
        color = series.summaryFillColor;
      } else if (point.y < 0) {
        color = series.negativeFillColor;
      } else {
        color = series.interior;
      }
      return this.triggerEvent(series, point, color, {
        color: series.border.color,
        width: series.border.width
      });
    };
    WaterfallSeries2.prototype.processInternalData = function(json, series) {
      var data = json;
      var index;
      var sumValue = 0;
      var intermediateSum = !isNullOrUndefined(series.intermediateSumIndexes) && series.intermediateSumIndexes.length > 0 ? series.intermediateSumIndexes.sort(function(a, b) {
        return a - b;
      }) : series.intermediateSumIndexes;
      var sumIndex = !isNullOrUndefined(series.sumIndexes) && series.sumIndexes.length > 0 ? series.sumIndexes.sort(function(a, b) {
        return a - b;
      }) : series.sumIndexes;
      var cumulativeSum = 0;
      for (var i = 0; i < data.length; i++) {
        cumulativeSum += data[i][series.yName] !== void 0 ? data[i][series.yName] : 0;
        this.cumulativeSums.push(cumulativeSum);
      }
      if (intermediateSum !== void 0 && intermediateSum.length > 0) {
        for (var i = 0; i < intermediateSum.length; i++) {
          for (var j = 0; j < data.length; j++) {
            if (j === intermediateSum[i]) {
              if (i === 0) {
                index = subArraySum(data, -1, intermediateSum[i], null, series);
              } else {
                index = subArraySum(data, intermediateSum[i - 1], intermediateSum[i], null, series);
              }
              data[j][series.yName] = index;
            }
          }
        }
      }
      if (sumIndex !== void 0 && sumIndex.length > 0) {
        var intermediateSumCount = 0;
        for (var k = 0; k < sumIndex.length; k++) {
          for (var j = 0; j < data.length; j++) {
            if (j === sumIndex[k]) {
              if (intermediateSum !== void 0 && intermediateSum.length > intermediateSumCount && intermediateSum[k] !== sumIndex[k] && intermediateSum[k] < sumIndex[k]) {
                index = subArraySum(data, intermediateSum.length <= 1 ? intermediateSum[0] - 1 : intermediateSum[k] - 1, sumIndex[k], sumIndex, series);
                intermediateSumCount += 1;
              } else {
                if (k === 0) {
                  index = subArraySum(data, -1, sumIndex[k], null, series);
                } else {
                  index = subArraySum(data, sumIndex[k - 1], sumIndex[k], null, series);
                }
              }
              sumValue += index;
              data[j][series.yName] = sumValue;
            }
          }
        }
      }
      return data;
    };
    WaterfallSeries2.prototype.doAnimation = function(series) {
      this.animate(series);
    };
    WaterfallSeries2.prototype.getModuleName = function() {
      return "WaterfallSeries";
    };
    WaterfallSeries2.prototype.destroy = function() {
    };
    return WaterfallSeries2;
  }(ColumnBase)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/hilo-series.js
var __extends35 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var HiloSeries = (
  /** @class */
  function(_super) {
    __extends35(HiloSeries2, _super);
    function HiloSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.sideBySideInfo = [];
      return _this;
    }
    HiloSeries2.prototype.render = function(series) {
      this.sideBySideInfo[series.index] = this.getSideBySideInfo(series);
      for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
        var point = _a[_i];
        this.renderPoint(series, point, this.sideBySideInfo[series.index]);
      }
    };
    HiloSeries2.prototype.renderPoint = function(series, point, sideBySideInfo) {
      point.symbolLocations = [];
      point.regions = [];
      var region;
      if (point.visible && withInRange(series.points[point.index - 1], point, series.points[point.index + 1], series)) {
        region = this.getRectangle(point.xValue + sideBySideInfo.median, point.high, point.xValue + sideBySideInfo.median, point.low, series);
        var argsData = this.triggerPointRenderEvent(series, point);
        if (!argsData.cancel) {
          if (!series.chart.requireInvertedAxis) {
            region.width = argsData.border.width;
            region.x = region.x - region.width / 2;
          } else {
            region.height = argsData.border.width;
            region.y = region.y - region.height / 2;
          }
          argsData.border.width = 0;
          this.updateSymbolLocation(point, region, series);
          this.drawRectangle(series, point, region, argsData);
        }
      }
    };
    HiloSeries2.prototype.updateDirection = function(series, point) {
      for (var i = 0; i < point.length; i++) {
        this.renderPoint(series, series.points[point[i]], this.sideBySideInfo[series.index]);
        if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {
          series.chart.dataLabelModule.commonId = series.chart.element.id + "_Series_" + series.index + "_Point_";
          series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);
        }
      }
    };
    HiloSeries2.prototype.triggerPointRenderEvent = function(series, point) {
      var border = {
        color: series.fill,
        width: Math.max(series.border.width, 2)
      };
      return _super.prototype.triggerEvent.call(this, series, point, series.interior, border);
    };
    HiloSeries2.prototype.getModuleName = function() {
      return "HiloSeries";
    };
    HiloSeries2.prototype.doAnimation = function(series) {
      this.animate(series);
    };
    HiloSeries2.prototype.destroy = function() {
    };
    return HiloSeries2;
  }(ColumnBase)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/hilo-open-close-series.js
var __extends36 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var HiloOpenCloseSeries = (
  /** @class */
  function(_super) {
    __extends36(HiloOpenCloseSeries2, _super);
    function HiloOpenCloseSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.sideBySideInfo = [];
      return _this;
    }
    HiloOpenCloseSeries2.prototype.render = function(series) {
      this.sideBySideInfo[series.index] = this.getSideBySideInfo(series);
      var borderWidth = Math.max(series.border.width, 2);
      for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
        var point = _a[_i];
        this.renderPoint(series, point, this.sideBySideInfo[series.index], borderWidth);
      }
    };
    HiloOpenCloseSeries2.prototype.renderPoint = function(series, point, sideBySideInfo, borderWidth) {
      point.symbolLocations = [];
      point.regions = [];
      var highLowRect;
      var index1;
      var index2;
      if (point.visible && withInRange(series.points[point.index - 1], point, series.points[point.index + 1], series)) {
        highLowRect = this.getRectangle(point.xValue + sideBySideInfo.start, Math.max(point.high, point.low), point.xValue + sideBySideInfo.end, Math.min(point.high, point.low), series);
        point.regions.push(this.getRectangle(point.xValue + sideBySideInfo.median, Math.max(point.high, point.low), point.xValue + sideBySideInfo.median, Math.min(point.high, point.low), series));
        this.updateTickRegion(!series.chart.requireInvertedAxis, point.regions[0], borderWidth);
        point.regions.push(this.getRectangle(point.xValue + sideBySideInfo.start, Math.max(point.open, point.close), point.xValue + sideBySideInfo.median, Math.max(point.open, point.close), series));
        point.regions.push(this.getRectangle(point.xValue + sideBySideInfo.median, Math.min(point.open, point.close), point.xValue + sideBySideInfo.end, Math.min(point.open, point.close), series));
        var argsData = this.triggerPointRenderEvent(series, point);
        if (!argsData.cancel) {
          this.updateSymbolLocation(point, point.regions[0], series);
          index1 = point.open > point.close ? 1 : 2;
          index2 = point.open > point.close ? 2 : 1;
          var open_1 = {
            x: point.regions[index1].x,
            y: point.regions[index1].y
          };
          var close_1 = {
            x: point.regions[index2].x,
            y: point.regions[index2].y
          };
          this.drawHiloOpenClosePath(series, point, open_1, close_1, highLowRect, argsData);
        }
        this.updateTickRegion(series.chart.requireInvertedAxis, point.regions[1], borderWidth);
        this.updateTickRegion(series.chart.requireInvertedAxis, point.regions[2], borderWidth);
      }
    };
    HiloOpenCloseSeries2.prototype.updateDirection = function(series, point) {
      var borderWidth = Math.max(series.border.width, 2);
      for (var i = 0; i < point.length; i++) {
        this.renderPoint(series, series.points[point[i]], this.sideBySideInfo[series.index], borderWidth);
        if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {
          series.chart.dataLabelModule.commonId = series.chart.element.id + "_Series_" + series.index + "_Point_";
          series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);
        }
      }
    };
    HiloOpenCloseSeries2.prototype.updateTickRegion = function(horizontal, region, borderWidth) {
      if (horizontal) {
        region.x -= borderWidth / 2;
        region.width = borderWidth;
      } else {
        region.y -= borderWidth / 2;
        region.height = borderWidth;
      }
    };
    HiloOpenCloseSeries2.prototype.triggerPointRenderEvent = function(series, point) {
      var fill = point.open <= point.close ? series.bearFillColor || series.chart.themeStyle.bearFillColor : series.bullFillColor || series.chart.themeStyle.bullFillColor;
      var border = {
        color: series.border.color,
        width: Math.max(series.border.width, 1)
      };
      return this.triggerEvent(series, point, fill, border);
    };
    HiloOpenCloseSeries2.prototype.drawHiloOpenClosePath = function(series, point, open, close, rect, argsData) {
      var direction;
      if (series.chart.requireInvertedAxis) {
        direction = "M " + rect.x + " " + (rect.y + rect.height / 2) + " L " + (rect.x + rect.width) + " " + (rect.y + rect.height / 2) + " ";
        direction += "M " + open.x + " " + (rect.y + rect.height / 2) + " L " + open.x + " " + (rect.y + rect.height) + " ";
        direction += "M " + close.x + " " + (rect.y + rect.height / 2) + " L " + close.x + " " + rect.y + " ";
      } else {
        direction = "M " + (rect.x + rect.width / 2) + " " + (rect.y + rect.height) + " L " + (rect.x + rect.width / 2) + " " + rect.y + " ";
        direction += "M " + rect.x + " " + open.y + " L " + (rect.x + rect.width / 2 + argsData.border.width / 2) + " " + open.y + " ";
        direction += "M " + (rect.x + rect.width / 2 - argsData.border.width / 2) + " " + close.y + " L " + (rect.x + rect.width) + " " + close.y + " ";
      }
      var options = new PathOption(series.chart.element.id + "_Series_" + series.index + "_Point_" + (series.removedPointIndex !== null && series.removedPointIndex <= point.index ? point.index + 1 : point.index), argsData.fill, argsData.border.width, argsData.fill, series.opacity, series.dashArray, direction);
      pathAnimation(getElement2(options.id), direction, series.chart.redraw, null, series.chart.duration);
      var element = series.chart.renderer.drawPath(options, new Int32Array([series.clipRect.x, series.clipRect.y]));
      if (series.removedPointIndex !== null && series.removedPointIndex <= point.index) {
        element.id = series.chart.element.id + "_Series_" + series.index + "_Point_" + point.index;
      }
      element.setAttribute("role", "img");
      element.setAttribute("aria-label", series.accessibility.accessibilityDescriptionFormat ? series.formatAccessibilityDescription(point, series) : point.x.toString() + ":" + point.high.toString() + ":" + point.low.toString() + ":" + point.close.toString() + ":" + point.open.toString());
      if (!series.chart.enableCanvas) {
        series.seriesElement.appendChild(element);
      }
    };
    HiloOpenCloseSeries2.prototype.getModuleName = function() {
      return "HiloOpenCloseSeries";
    };
    HiloOpenCloseSeries2.prototype.doAnimation = function(series) {
      this.animate(series);
    };
    HiloOpenCloseSeries2.prototype.destroy = function() {
    };
    return HiloOpenCloseSeries2;
  }(ColumnBase)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/range-area-series.js
var __extends37 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var RangeAreaSeries = (
  /** @class */
  function(_super) {
    __extends37(RangeAreaSeries2, _super);
    function RangeAreaSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.borderDirection = "";
      return _this;
    }
    RangeAreaSeries2.prototype.render = function(series, xAxis, yAxis, inverted, pointAnimate, pointUpdate) {
      var point;
      var direction = "";
      var command = "M";
      var closed = void 0;
      var borderWidth = series.border.width ? series.border.width : 0;
      var borderColor = series.border.color ? series.border.color : series.interior;
      var visiblePoints = this.enableComplexProperty(series);
      for (var i = 0, length_1 = visiblePoints.length; i < length_1; i++) {
        point = visiblePoints[i];
        point.symbolLocations = [];
        point.regions = [];
        var low = Math.min(point.low, point.high);
        var high = Math.max(point.low, point.high);
        if (yAxis.isAxisInverse) {
          var temp = low;
          low = high;
          high = temp;
        }
        var lowPoint = getPoint(point.xValue, low, xAxis, yAxis, inverted);
        var highPoint = getPoint(point.xValue, high, xAxis, yAxis, inverted);
        point.symbolLocations.push(highPoint);
        point.symbolLocations.push(lowPoint);
        var rect = new Rect(Math.min(lowPoint.x, highPoint.x), Math.min(lowPoint.y, highPoint.y), Math.max(Math.abs(highPoint.x - lowPoint.x), series.marker.width), Math.max(Math.abs(highPoint.y - lowPoint.y), series.marker.width));
        if (!inverted) {
          rect.x -= series.marker.width / 2;
        } else {
          rect.y -= series.marker.width / 2;
        }
        point.regions.push(rect);
        if (point.visible && withInRange(visiblePoints[point.index - 1], point, visiblePoints[point.index + 1], series)) {
          direction = direction.concat(command + " " + lowPoint.x + " " + lowPoint.y + " ");
          this.borderDirection += command + " " + lowPoint.x + " " + lowPoint.y + " ";
          closed = false;
          if (i + 1 < visiblePoints.length && !visiblePoints[i + 1].visible || i === visiblePoints.length - 1) {
            direction = this.closeRangeAreaPath(visiblePoints, point, series, direction, i);
            command = "M";
            direction = direction.concat(" Z");
            closed = true;
          }
          command = "L";
        } else {
          if (closed === false && i !== 0) {
            direction = this.closeRangeAreaPath(visiblePoints, point, series, direction, i);
            closed = true;
          }
          command = "M";
          point.symbolLocations = [];
        }
      }
      var name = series.category === "Indicator" ? series.chart.element.id + "_Indicator_" + series.index + "_" + series.name : series.chart.element.id + "_Series_" + series.index;
      var options = new PathOption(name, series.interior, 0, "transparent", series.opacity, series.dashArray, direction);
      this[pointAnimate ? "addPath" : "appendLinePath"](options, series, "");
      if (series.border.width !== 0) {
        this[pointAnimate ? "addPath" : "appendLinePath"](new PathOption(series.chart.element.id + "_Series_border_" + series.index, "transparent", borderWidth, borderColor, 1, series.border.dashArray, this.borderDirection), series, "");
        this.borderDirection = "";
      }
      if (!pointUpdate) {
        this.renderMarker(series);
      }
    };
    RangeAreaSeries2.prototype.closeRangeAreaPath = function(visiblePoints, point, series, direction, i) {
      for (var j = i; j >= 0; j--) {
        if (visiblePoints[j].visible && visiblePoints[j].symbolLocations[0]) {
          point = visiblePoints[j];
          direction += "L " + point.symbolLocations[0].x + " " + point.symbolLocations[0].y + " ";
          this.borderDirection += (j === i ? "M" : "L") + " " + point.symbolLocations[0].x + " " + point.symbolLocations[0].y + " ";
        } else {
          break;
        }
      }
      return direction;
    };
    RangeAreaSeries2.prototype.updateDirection = function(series, point) {
      this.render(series, series.xAxis, series.yAxis, series.chart.requireInvertedAxis, false, true);
      var _loop_1 = function(i2) {
        if (series.marker && series.marker.visible) {
          series.points[point[i2]].symbolLocations.map(function(location, index) {
            series.chart.markerRender.renderMarker(series, series.points[point[i2]], location, index, true);
          });
        }
        if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {
          series.chart.dataLabelModule.commonId = series.chart.element.id + "_Series_" + series.index + "_Point_";
          series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i2]], null, series.marker.dataLabel);
        }
      };
      for (var i = 0; i < point.length; i++) {
        _loop_1(i);
      }
    };
    RangeAreaSeries2.prototype.addPath = function(options, series, clipRect) {
      var points = this.appendPathElement(options, series, clipRect);
      if (points.previousDirection !== "" && options.d !== "") {
        var startPathCommands = points.previousDirection.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);
        var endPathCommands = options.d.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);
        var maxLength = Math.max(startPathCommands.length, endPathCommands.length);
        var minLength = Math.min(startPathCommands.length, endPathCommands.length);
        if (startPathCommands.length < endPathCommands.length) {
          for (var i = startPathCommands.length; i < endPathCommands.length; i++) {
            if (endPathCommands.length !== startPathCommands.length) {
              startPathCommands.splice((startPathCommands.length - 1) / 2, 0, startPathCommands.slice(0, (startPathCommands.length - 1) / 2).pop(), startPathCommands.slice(0, (startPathCommands.length - 1) / 2 + 1).pop());
            }
          }
          animateAddPoints(points.element, options.d, series.chart.redraw, startPathCommands.join(" "), this.chart.duration);
        } else if (startPathCommands.length > endPathCommands.length) {
          for (var i = minLength; i < maxLength; i++) {
            if (endPathCommands.length !== startPathCommands.length) {
              endPathCommands.splice(1, 0, endPathCommands[0]);
              endPathCommands.splice(endPathCommands.length - 2, 0, endPathCommands[endPathCommands.length - 2]);
            }
          }
          animateAddPoints(points.element, endPathCommands.join(""), series.chart.redraw, points.previousDirection, this.chart.duration, options.d);
        } else {
          animateAddPoints(points.element, options.d, series.chart.redraw, points.previousDirection, this.chart.duration);
        }
      }
    };
    RangeAreaSeries2.prototype.doAnimation = function(series) {
      var option = series.animation;
      this.doLinearAnimation(series, option);
    };
    RangeAreaSeries2.prototype.getModuleName = function() {
      return "RangeAreaSeries";
    };
    RangeAreaSeries2.prototype.destroy = function() {
    };
    return RangeAreaSeries2;
  }(LineBase)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/spline-base.js
var __extends38 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var SplineBase = (
  /** @class */
  function(_super) {
    __extends38(SplineBase2, _super);
    function SplineBase2(chartModule) {
      var _this = _super.call(this, chartModule) || this;
      _this.splinePoints = [];
      _this.lowSplinePoints = [];
      return _this;
    }
    SplineBase2.prototype.findSplinePoint = function(series) {
      var value;
      var lowPoints;
      var realPoints = [];
      var points = [];
      var point;
      var pointIndex = 0;
      var negativePoint = false;
      realPoints = this.filterEmptyPoints(series);
      for (var i = 0; i < realPoints.length; i++) {
        point = realPoints[i];
        if (point.x === null || point.x === "") {
          continue;
        } else {
          point.index = pointIndex;
          pointIndex++;
          points.push(point);
        }
      }
      var isLow = false;
      this.splinePoints = this.findSplineCoefficients(points, series, isLow);
      if (series.type === "SplineRangeArea") {
        isLow = !isLow;
        this.lowSplinePoints = this.findSplineCoefficients(points, series, isLow);
      }
      if (points.length > 1) {
        series.drawPoints = [];
        series.lowDrawPoints = [];
        for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
          var point_1 = points_1[_i];
          negativePoint = negativePoint ? negativePoint : point_1.yValue < 0;
          if (point_1.index !== 0) {
            var previous = this.getPreviousIndex(points, point_1.index - 1, series);
            if (series.type === "SplineRangeArea") {
              points[previous].yValue = points[previous].high > points[previous].low ? points[previous].high : points[previous].low;
              point_1.yValue = point_1.high > point_1.low ? point_1.high : point_1.low;
            }
            value = this.getControlPoints(points[previous], point_1, this.splinePoints[previous], this.splinePoints[point_1.index], series);
            series.drawPoints.push(value);
            if (series.type === "SplineRangeArea") {
              points[previous].yValue = points[previous].low < points[previous].high ? points[previous].low : points[previous].high;
              point_1.yValue = point_1.low < point_1.high ? point_1.low : point_1.high;
              lowPoints = this.getControlPoints(points[previous], point_1, this.lowSplinePoints[previous], this.lowSplinePoints[point_1.index], series);
              series.lowDrawPoints.push(lowPoints);
            }
            var delta = series.yMax - series.yMin;
            if (point_1.yValue && value.controlPoint1.y && value.controlPoint2.y && delta > 1) {
              series.yMin = Math.min(series.yMin, point_1.yValue, value.controlPoint1.y, value.controlPoint2.y);
              series.yMax = Math.ceil(Math.max(series.yMax, point_1.yValue, value.controlPoint1.y, value.controlPoint2.y));
              series.yMin = series.yAxis.valueType !== "Logarithmic" ? Math.floor(series.yMin) : series.yMin;
            }
          }
        }
        if (!negativePoint && series.yMin < 0) {
          series.yMin = 0;
        }
        if (series.chart.chartAreaType === "PolarRadar" && series.isClosed) {
          value = this.getControlPoints({
            xValue: points[points.length - 1].xValue,
            yValue: points[points.length - 1].yValue
          }, {
            xValue: points[points.length - 1].xValue + 1,
            yValue: points[0].yValue
          }, this.splinePoints[0], this.splinePoints[points[points.length - 1].index], series);
          series.drawPoints.push(value);
        }
      }
    };
    SplineBase2.prototype.getPreviousIndex = function(points, i, series) {
      if (series.emptyPointSettings.mode !== "Drop") {
        return i;
      }
      while (isNullOrUndefined(points[i]) && i > -1) {
        i = i - 1;
      }
      return i;
    };
    SplineBase2.prototype.getNextIndex = function(points, i, series) {
      if (series.emptyPointSettings.mode !== "Drop") {
        return i;
      }
      while (isNullOrUndefined(points[i]) && i < points.length) {
        i = i + 1;
      }
      return i;
    };
    SplineBase2.prototype.filterEmptyPoints = function(series, seriesPoints) {
      if (series.emptyPointSettings.mode !== "Drop" && this.isPointInRange(series.points)) {
        return seriesPoints ? seriesPoints : series.points;
      }
      var points = seriesPoints ? seriesPoints : extend([], series.points, null, true);
      for (var i = 0; i < points.length; i++) {
        points[i].index = i;
        if (points[i].isEmpty) {
          points[i].symbolLocations = [];
          points[i].regions = [];
          points.splice(i, 1);
          i--;
        }
      }
      return points;
    };
    SplineBase2.prototype.isPointInRange = function(points) {
      for (var _i = 0, points_2 = points; _i < points_2.length; _i++) {
        var point = points_2[_i];
        if (!point.isPointInRange) {
          return false;
        }
      }
      return true;
    };
    SplineBase2.prototype.findSplineCoefficients = function(points, series, isLow) {
      var ySpline = [];
      var ySplineDuplicate = [];
      var cardinalSplineTension = series.cardinalSplineTension ? series.cardinalSplineTension : 0.5;
      if (cardinalSplineTension < 0) {
        cardinalSplineTension = 0;
      } else if (cardinalSplineTension > 1) {
        cardinalSplineTension = 1;
      }
      switch (series.splineType) {
        case "Monotonic":
          ySpline = this.monotonicSplineCoefficients(points, series, isLow);
          break;
        case "Cardinal":
          ySpline = this.cardinalSplineCofficients(points, series);
          break;
        default:
          if (series.splineType === "Clamped") {
            ySpline = this.clampedSplineCofficients(points, series, isLow);
          } else {
            ySpline[0] = ySplineDuplicate[0] = 0;
            ySpline[points.length - 1] = 0;
          }
          ySpline = this.naturalSplineCoefficients(points, series, isLow);
          break;
      }
      return ySpline;
    };
    SplineBase2.prototype.monotonicSplineCoefficients = function(points, series, isLow) {
      var count = points.length;
      var ySpline = [];
      var dx = [];
      var dy = [];
      var slope = [];
      var interPoint;
      for (var i = 0; i < count - 1; i++) {
        if (series.type === "SplineRangeArea") {
          if (!isLow) {
            points[i + 1].yValue = points[i + 1].high > points[i + 1].low ? points[i + 1].high : points[i + 1].low;
            points[i].yValue = points[i].high > points[i].low ? points[i].high : points[i].low;
          }
          if (isLow) {
            points[i + 1].yValue = points[i + 1].low < points[i + 1].high ? points[i + 1].low : points[i + 1].high;
            points[i].yValue = points[i].low < points[i].high ? points[i].low : points[i].high;
          }
        }
        dx[i] = points[i + 1].xValue - points[i].xValue;
        dy[i] = points[i + 1].yValue - points[i].yValue;
        slope[i] = dy[i] / dx[i];
      }
      var slopeLength = slope.length;
      ySpline[0] = slope[0];
      ySpline[count - 1] = slope[slopeLength - 1];
      for (var j = 0; j < dx.length; j++) {
        if (slopeLength > j + 1) {
          if (slope[j] * slope[j + 1] <= 0) {
            ySpline[j + 1] = 0;
          } else {
            interPoint = dx[j] + dx[j + 1];
            ySpline[j + 1] = 3 * interPoint / ((interPoint + dx[j + 1]) / slope[j] + (interPoint + dx[j]) / slope[j + 1]);
          }
        }
      }
      return ySpline;
    };
    SplineBase2.prototype.cardinalSplineCofficients = function(points, series) {
      var count = points.length;
      var ySpline = [];
      var cardinalSplineTension = series.cardinalSplineTension ? series.cardinalSplineTension : 0.5;
      cardinalSplineTension = cardinalSplineTension < 0 ? 0 : cardinalSplineTension > 1 ? 1 : cardinalSplineTension;
      for (var i = 0; i < count; i++) {
        if (i === 0) {
          ySpline[i] = count > 2 ? cardinalSplineTension * (points[i + 2].xValue - points[i].xValue) : 0;
        } else if (i === count - 1) {
          ySpline[i] = count > 2 ? cardinalSplineTension * (points[count - 1].xValue - points[count - 3].xValue) : 0;
        } else {
          ySpline[i] = cardinalSplineTension * (points[i + 1].xValue - points[i - 1].xValue);
        }
      }
      return ySpline;
    };
    SplineBase2.prototype.clampedSplineCofficients = function(points, series, isLow) {
      var count = points.length;
      var ySpline = [];
      var ySplineDuplicate = [];
      for (var i = 0; i < count - 1; i++) {
        if (series.type === "SplineRangeArea") {
          if (!isLow) {
            points[1].yValue = points[1].high > points[1].low ? points[1].high : points[1].low;
            points[0].yValue = points[0].high > points[0].low ? points[0].high : points[0].low;
            points[points.length - 1].yValue = points[points.length - 1].high > points[points.length - 1].low ? points[points.length - 1].high : points[points.length - 1].low;
            points[points.length - 2].yValue = points[points.length - 2].high > points[points.length - 2].low ? points[points.length - 2].high : points[points.length - 2].low;
          }
          if (isLow) {
            points[1].yValue = points[1].low < points[1].high ? points[1].low : points[1].high;
            points[0].yValue = points[0].low < points[0].high ? points[0].low : points[0].high;
            points[points.length - 1].yValue = points[points.length - 1].low < points[points.length - 1].high ? points[points.length - 1].low : points[points.length - 1].high;
            points[points.length - 2].yValue = points[points.length - 2].low < points[points.length - 2].high ? points[points.length - 2].low : points[points.length - 2].high;
          }
        }
        ySpline[0] = 3 * (points[1].yValue - points[0].yValue) / (points[1].xValue - points[0].xValue) - 3;
        ySplineDuplicate[0] = 0.5;
        ySpline[points.length - 1] = 3 * (points[points.length - 1].yValue - points[points.length - 2].yValue) / (points[points.length - 1].xValue - points[points.length - 2].xValue);
        ySpline[0] = ySplineDuplicate[0] = Math.abs(ySpline[0]) === Infinity ? 0 : ySpline[0];
        ySpline[points.length - 1] = ySplineDuplicate[points.length - 1] = Math.abs(ySpline[points.length - 1]) === Infinity ? 0 : ySpline[points.length - 1];
      }
      return ySpline;
    };
    SplineBase2.prototype.naturalSplineCoefficients = function(points, series, isLow) {
      var count = points.length;
      var ySpline = [];
      var ySplineDuplicate = [];
      var dy1;
      var dy2;
      var coefficient1;
      var coefficient2;
      var coefficient3;
      ySpline[0] = ySplineDuplicate[0] = 0;
      ySpline[points.length - 1] = 0;
      for (var i = 1; i < count - 1; i++) {
        if (series.type === "SplineRangeArea") {
          if (!isLow) {
            points[i + 1].yValue = points[i + 1].low > points[i + 1].high ? points[i + 1].low : points[i + 1].high;
            points[i].yValue = points[i].low > points[i].high ? points[i].low : points[i].high;
            points[i - 1].yValue = points[i - 1].low > points[i - 1].high ? points[i - 1].low : points[i - 1].high;
          }
          if (isLow) {
            points[i + 1].yValue = points[i + 1].high < points[i + 1].low ? points[i + 1].high : points[i + 1].low;
            points[i].yValue = points[i].high < points[i].low ? points[i].high : points[i].low;
            points[i - 1].yValue = points[i - 1].high < points[i - 1].low ? points[i - 1].high : points[i - 1].low;
          }
        }
        coefficient1 = points[i].xValue - points[i - 1].xValue;
        coefficient2 = points[i + 1].xValue - points[i - 1].xValue;
        coefficient3 = points[i + 1].xValue - points[i].xValue;
        dy1 = points[i + 1].yValue - points[i].yValue || null;
        dy2 = points[i].yValue - points[i - 1].yValue || null;
        if (coefficient1 === 0 || coefficient2 === 0 || coefficient3 === 0) {
          ySpline[i] = 0;
          ySplineDuplicate[i] = 0;
        } else {
          var p = 1 / (coefficient1 * ySpline[i - 1] + 2 * coefficient2);
          ySpline[i] = -p * coefficient3;
          ySplineDuplicate[i] = p * (6 * (dy1 / coefficient3 - dy2 / coefficient1) - coefficient1 * ySplineDuplicate[i - 1]);
        }
      }
      for (var k = count - 2; k >= 0; k--) {
        ySpline[k] = ySpline[k] * ySpline[k + 1] + ySplineDuplicate[k];
      }
      return ySpline;
    };
    SplineBase2.prototype.getControlPoints = function(point1, point2, ySpline1, ySpline2, series) {
      var controlPoint1;
      var controlPoint2;
      var point;
      var ySplineDuplicate1 = ySpline1;
      var ySplineDuplicate2 = ySpline2;
      var xValue1 = point1.xValue;
      var yValue1 = point1.yValue;
      var xValue2 = point2.xValue;
      var yValue2 = point2.yValue;
      switch (series.splineType) {
        case "Cardinal":
          if (series.xAxis.valueType === "DateTime") {
            ySplineDuplicate1 = ySpline1 / this.dateTimeInterval(series);
            ySplineDuplicate2 = ySpline2 / this.dateTimeInterval(series);
          }
          controlPoint1 = new ChartLocation(xValue1 + ySpline1 / 3, yValue1 + ySplineDuplicate1 / 3);
          controlPoint2 = new ChartLocation(xValue2 - ySpline2 / 3, yValue2 - ySplineDuplicate2 / 3);
          point = new ControlPoints(controlPoint1, controlPoint2);
          break;
        case "Monotonic": {
          var value = (xValue2 - xValue1) / 3;
          controlPoint1 = new ChartLocation(xValue1 + value, yValue1 + ySpline1 * value);
          controlPoint2 = new ChartLocation(xValue2 - value, yValue2 - ySpline2 * value);
          point = new ControlPoints(controlPoint1, controlPoint2);
          break;
        }
        default: {
          var one3 = 1 / 3;
          var deltaX2 = xValue2 - xValue1;
          deltaX2 = deltaX2 * deltaX2;
          var y1 = one3 * (2 * yValue1 + yValue2 - one3 * deltaX2 * (ySpline1 + 0.5 * ySpline2));
          var y2 = one3 * (yValue1 + 2 * yValue2 - one3 * deltaX2 * (0.5 * ySpline1 + ySpline2));
          controlPoint1 = new ChartLocation((2 * xValue1 + xValue2) * one3, y1);
          controlPoint2 = new ChartLocation((xValue1 + 2 * xValue2) * one3, y2);
          point = new ControlPoints(controlPoint1, controlPoint2);
          break;
        }
      }
      return point;
    };
    SplineBase2.prototype.dateTimeInterval = function(series) {
      var interval = series.xAxis.actualIntervalType;
      var intervalInMilliseconds;
      if (interval === "Years") {
        intervalInMilliseconds = 365 * 24 * 60 * 60 * 1e3;
      } else if (interval === "Months") {
        intervalInMilliseconds = 30 * 24 * 60 * 60 * 1e3;
      } else if (interval === "Days") {
        intervalInMilliseconds = 24 * 60 * 60 * 1e3;
      } else if (interval === "Hours") {
        intervalInMilliseconds = 60 * 60 * 1e3;
      } else if (interval === "Minutes") {
        intervalInMilliseconds = 60 * 1e3;
      } else if (interval === "Seconds") {
        intervalInMilliseconds = 1e3;
      } else {
        intervalInMilliseconds = 30 * 24 * 60 * 60 * 1e3;
      }
      return intervalInMilliseconds;
    };
    SplineBase2.prototype.doAnimation = function(series) {
      var option = series.animation;
      this.doLinearAnimation(series, option);
    };
    return SplineBase2;
  }(LineBase)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/spline-range-area-series.js
var __extends39 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var SplineRangeAreaSeries = (
  /** @class */
  function(_super) {
    __extends39(SplineRangeAreaSeries2, _super);
    function SplineRangeAreaSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.borderDirection = "";
      return _this;
    }
    SplineRangeAreaSeries2.prototype.render = function(series, xAxis, yAxis, inverted, pointAnimate, pointUpdate) {
      var point;
      var direction = "";
      var closed = void 0;
      var firstPoint = null;
      var pt;
      var betweenPt1;
      var betweenPt2;
      var highControlPt1;
      var highControlPt2;
      var realPoint = [];
      var points = [];
      var Index2 = 0;
      var borderWidth = series.border.width ? series.border.width : 0;
      var borderColor = series.border.color ? series.border.color : series.interior;
      var lastPoint = "";
      realPoint = this.filterEmptyPoints(series);
      for (var i = 0; i < realPoint.length; i++) {
        point = realPoint[i];
        if (point.x === null || point.x === "") {
          continue;
        } else {
          point.index = Index2;
          Index2++;
          points.push(point);
        }
      }
      var previous;
      var next;
      var visiblePoint = this.enableComplexProperty(series);
      var length = visiblePoint.length;
      for (var i = 0; i < length; i++) {
        point = visiblePoint[i];
        point.regions = [];
        point.symbolLocations = [];
        next = this.getNextIndex(points, point.index - 1, series);
        previous = this.getPreviousIndex(points, point.index - 1, series);
        var lowPoint = Math.min(point.low, point.high);
        var highPoint = Math.max(point.low, point.high);
        if (yAxis.isAxisInverse) {
          var temp = lowPoint;
          lowPoint = highPoint;
          highPoint = temp;
        }
        var lowPtCoordinate = getPoint(point.xValue, lowPoint, xAxis, yAxis, inverted);
        var highPtCoordinate = getPoint(point.xValue, highPoint, xAxis, yAxis, inverted);
        point.symbolLocations.push(highPtCoordinate);
        point.symbolLocations.push(lowPtCoordinate);
        var rect1 = new Rect(Math.min(lowPtCoordinate.x, highPtCoordinate.x), Math.min(lowPtCoordinate.y, highPtCoordinate.y), Math.max(Math.abs(highPtCoordinate.x - lowPtCoordinate.x), series.marker.width), Math.max(Math.abs(highPtCoordinate.y - lowPtCoordinate.y), series.marker.width));
        if (!inverted) {
          rect1.x -= series.marker.width / 2;
        } else {
          rect1.y -= series.marker.width / 2;
        }
        point.regions.push(rect1);
        if (point.visible && withInRange(visiblePoint[previous], point, visiblePoint[next], series)) {
          if (firstPoint) {
            highControlPt1 = series.drawPoints[previous].controlPoint1;
            highControlPt2 = series.drawPoints[previous].controlPoint2;
            pt = getPoint(point.xValue, point.high > point.low ? point.high : point.low, xAxis, yAxis, inverted);
            betweenPt1 = getPoint(highControlPt1.x, highControlPt1.y, xAxis, yAxis, inverted);
            betweenPt2 = getPoint(highControlPt2.x, highControlPt2.y, xAxis, yAxis, inverted);
            direction = direction.concat("C " + betweenPt1.x + " " + betweenPt1.y + " " + betweenPt2.x + " " + betweenPt2.y + " " + pt.x + " " + pt.y + " ");
            this.borderDirection += "C " + betweenPt1.x + " " + betweenPt1.y + " " + betweenPt2.x + " " + betweenPt2.y + " " + pt.x + " " + pt.y + " ";
          } else {
            if (yAxis.isAxisInverse) {
              direction = direction.concat("M " + highPtCoordinate.x + " " + highPtCoordinate.y + " L " + lowPtCoordinate.x + " " + lowPtCoordinate.y + " ");
              this.borderDirection += "M " + highPtCoordinate.x + " " + highPtCoordinate.y + " ";
              lastPoint = "L " + lowPtCoordinate.x + " " + lowPtCoordinate.y;
            } else {
              direction = direction.concat("M " + lowPtCoordinate.x + " " + lowPtCoordinate.y + " L " + highPtCoordinate.x + " " + highPtCoordinate.y + " ");
              this.borderDirection += "M " + highPtCoordinate.x + " " + highPtCoordinate.y + " ";
              lastPoint = "L " + lowPtCoordinate.x + " " + lowPtCoordinate.y;
            }
            closed = false;
          }
          if (i + 1 < visiblePoint.length && !visiblePoint[i + 1].visible || i === visiblePoint.length - 1) {
            direction = this.closeSplineRangeAreaPath(visiblePoint, point, series, direction, i, xAxis, yAxis, inverted);
            this.borderDirection += lastPoint;
            lastPoint = "";
            direction = direction.concat(" Z");
            closed = true;
          }
          firstPoint = point;
        } else {
          if (closed === false && i !== 0) {
            direction = this.closeSplineRangeAreaPath(visiblePoint, point, series, direction, i, xAxis, yAxis, inverted);
            closed = true;
          }
          firstPoint = null;
          point.symbolLocations = [];
        }
      }
      var name1 = series.category === "Indicator" ? series.chart.element.id + "_Indicator_" + series.index + "_" + series.name : series.chart.element.id + "_Series_" + series.index;
      var options = new PathOption(name1, series.interior, 0, "transparent", series.opacity, series.dashArray, direction);
      this[pointAnimate ? "addPath" : "appendLinePath"](options, series, "");
      if (series.border.width !== 0) {
        this[pointAnimate ? "addPath" : "appendLinePath"](new PathOption(series.chart.element.id + "_Series_border_" + series.index, "transparent", borderWidth, borderColor, 1, series.border.dashArray, this.borderDirection), series, "");
        this.borderDirection = "";
      }
      if (!pointUpdate) {
        this.renderMarker(series);
      }
    };
    SplineRangeAreaSeries2.prototype.closeSplineRangeAreaPath = function(visiblePoint, point, series, direction, i, xAxis, yAxis, inverted) {
      var firstPoint = null;
      var pt;
      var betweenPt1;
      var betweenPt2;
      var lowControlPt1;
      var lowControlPt2;
      for (var j = i; j > 0; j--) {
        if (visiblePoint[j].visible) {
          point = visiblePoint[j];
          var low = Math.min(point.low, point.high);
          var high = Math.max(point.low, point.high);
          if (yAxis.isAxisInverse) {
            var temp = low;
            low = high;
            high = temp;
          }
          var lowPtCoordinate = getPoint(point.xValue, low, xAxis, yAxis, inverted);
          var highPtCoordinate = getPoint(point.xValue, high, xAxis, yAxis, inverted);
          if (firstPoint) {
            lowControlPt1 = series.lowDrawPoints[j].controlPoint1;
            lowControlPt2 = series.lowDrawPoints[j].controlPoint2;
            pt = getPoint(point.xValue, point.low < point.high ? point.low : point.high, xAxis, yAxis, inverted);
            betweenPt1 = getPoint(lowControlPt1.x, lowControlPt1.y, xAxis, yAxis, inverted);
            betweenPt2 = getPoint(lowControlPt2.x, lowControlPt2.y, xAxis, yAxis, inverted);
            if (!isNaN(betweenPt1.y) || !isNaN(betweenPt2.y)) {
              direction = direction.concat("C " + betweenPt2.x + " " + betweenPt2.y + " " + betweenPt1.x + " " + betweenPt1.y + " " + pt.x + " " + pt.y + " ");
              this.borderDirection += "C " + betweenPt2.x + " " + betweenPt2.y + " " + betweenPt1.x + " " + betweenPt1.y + " " + pt.x + " " + pt.y + " ";
            }
          } else {
            if (yAxis.isAxisInverse) {
              direction = direction.concat("L " + highPtCoordinate.x + " " + highPtCoordinate.y + " ");
              this.borderDirection += "M " + highPtCoordinate.x + " " + highPtCoordinate.y + " ";
            } else {
              direction = direction.concat("L " + lowPtCoordinate.x + " " + lowPtCoordinate.y + " ");
              this.borderDirection += "M " + lowPtCoordinate.x + " " + lowPtCoordinate.y + " ";
            }
          }
        } else {
          break;
        }
        firstPoint = point;
      }
      return direction;
    };
    SplineRangeAreaSeries2.prototype.updateDirection = function(series, point) {
      this.render(series, series.xAxis, series.yAxis, series.chart.requireInvertedAxis, false, true);
      var _loop_1 = function(i2) {
        if (series.marker && series.marker.visible) {
          series.points[i2].symbolLocations.map(function(location, index) {
            series.chart.markerRender.renderMarker(series, series.points[point[i2]], location, index, true);
          });
        }
        if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {
          series.chart.dataLabelModule.commonId = series.chart.element.id + "_Series_" + series.index + "_Point_";
          series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i2]], null, series.marker.dataLabel);
        }
      };
      for (var i = 0; i < point.length; i++) {
        _loop_1(i);
      }
    };
    SplineRangeAreaSeries2.prototype.addPath = function(options, series, clipRect) {
      var points = this.appendPathElement(options, series, clipRect);
      if (points.previousDirection !== "" && options.d !== "") {
        var startPathCommands = points.previousDirection.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);
        var endPathCommands = options.d.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);
        var maxLength = Math.max(startPathCommands.length, endPathCommands.length);
        var minLength = Math.min(startPathCommands.length, endPathCommands.length);
        if (startPathCommands.length < endPathCommands.length) {
          for (var i = startPathCommands.length; i < endPathCommands.length; i++) {
            if (endPathCommands.length !== startPathCommands.length) {
              startPathCommands.splice(startPathCommands.length / 2 + 1, 0, "C " + startPathCommands[(startPathCommands.length - 1) / 2].split(" ").slice(5, 7).join(" ") + " " + startPathCommands[(startPathCommands.length - 1) / 2].split(" ").slice(5, 7).join(" ") + " " + startPathCommands[(startPathCommands.length - 1) / 2].split(" ").slice(5, 7).join(" "));
              startPathCommands.splice(startPathCommands.length / 2 + 2, 0, "C " + startPathCommands[startPathCommands.length / 2 + 1].split(" ").slice(1, 3).join(" ") + " " + startPathCommands[startPathCommands.length / 2 + 1].split(" ").slice(1, 3).join(" ") + " " + startPathCommands[startPathCommands.length / 2 + 1].split(" ").slice(1, 3).join(" "));
            }
          }
          animateAddPoints(points.element, options.d, series.chart.redraw, startPathCommands.join(" "), this.chart.duration);
        } else if (startPathCommands.length > endPathCommands.length) {
          for (var i = minLength; i < maxLength; i++) {
            if (endPathCommands.length !== startPathCommands.length) {
              endPathCommands.splice(2, 0, "C " + endPathCommands[1].split(" ").slice(-3).join(" ") + endPathCommands[1].split(" ").slice(-3).join(" ") + endPathCommands[1].split(" ").slice(-3).join(" "));
              endPathCommands.splice(endPathCommands.length - 1, 0, "C " + endPathCommands[endPathCommands.length - 2].split(" ").slice(-4).join(" ") + endPathCommands[endPathCommands.length - 2].split(" ").slice(-4).join(" ") + endPathCommands[endPathCommands.length - 2].split(" ").slice(-4).join(" "));
            }
          }
          animateAddPoints(points.element, endPathCommands.join(""), series.chart.redraw, points.previousDirection, this.chart.duration, options.d);
        } else {
          animateAddPoints(points.element, options.d, series.chart.redraw, points.previousDirection, this.chart.duration);
        }
      }
    };
    SplineRangeAreaSeries2.prototype.doAnimation = function(series) {
      var option = series.animation;
      this.doLinearAnimation(series, option);
    };
    SplineRangeAreaSeries2.prototype.getModuleName = function() {
      return "SplineRangeAreaSeries";
    };
    SplineRangeAreaSeries2.prototype.destroy = function() {
    };
    return SplineRangeAreaSeries2;
  }(SplineBase)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/bubble-series.js
var BubbleSeries = (
  /** @class */
  function() {
    function BubbleSeries2() {
    }
    BubbleSeries2.prototype.render = function(series, xAxis, yAxis, isInverted) {
      var visiblePoints = series.points;
      var radius;
      var value = Math.max(series.chart.initialClipRect.height, series.chart.initialClipRect.width);
      var percentChange = value / 100;
      var maxRadius = series.maxRadius * percentChange;
      var minRadius = series.minRadius * percentChange;
      var maximumSize = null;
      var maxValue = null;
      if (series.maxRadius === null || series.minRadius === null) {
        for (var _i = 0, _a = series.chart.visibleSeries; _i < _a.length; _i++) {
          var value_1 = _a[_i];
          if (value_1.type === "Bubble" && value_1.visible === true && (value_1.maxRadius === null || value_1.minRadius === null)) {
            maximumSize = value_1.sizeMax > maximumSize ? value_1.sizeMax : maximumSize;
          }
        }
        maxValue = value / 5 / 2;
        minRadius = maxRadius = 1;
        radius = maxValue * maxRadius;
      } else {
        maximumSize = series.sizeMax;
        radius = maxRadius - minRadius;
      }
      for (var _b = 0, visiblePoints_1 = visiblePoints; _b < visiblePoints_1.length; _b++) {
        var bubblePoint = visiblePoints_1[_b];
        this.renderPoint(series, bubblePoint, isInverted, radius, maximumSize, minRadius, visiblePoints);
      }
    };
    BubbleSeries2.prototype.renderPoint = function(series, bubblePoint, isInverted, radius, maximumSize, minRadius, visiblePoints, pointUpdate) {
      var startLocation = series.chart.redraw && bubblePoint.symbolLocations ? bubblePoint.symbolLocations[0] : null;
      bubblePoint.symbolLocations = [];
      bubblePoint.regions = [];
      var segmentRadius;
      if (bubblePoint.visible && withInRange(visiblePoints[bubblePoint.index - 1], bubblePoint, visiblePoints[bubblePoint.index + 1], series)) {
        if (series.maxRadius === null || series.minRadius === null) {
          segmentRadius = radius * Math.abs(+bubblePoint.size / maximumSize);
        } else {
          segmentRadius = minRadius + radius * Math.abs(+bubblePoint.size / maximumSize);
        }
        segmentRadius = segmentRadius || minRadius;
        var argsData = {
          cancel: false,
          name: pointRender,
          series,
          point: bubblePoint,
          fill: series.setPointColor(bubblePoint, series.interior),
          border: series.setBorderColor(bubblePoint, {
            width: series.border.width,
            color: series.border.color
          }),
          height: 2 * segmentRadius,
          width: 2 * segmentRadius
        };
        series.chart.trigger(pointRender, argsData);
        if (!argsData.cancel) {
          bubblePoint.symbolLocations.push(getPoint(bubblePoint.xValue, bubblePoint.yValue, series.xAxis, series.yAxis, isInverted));
          bubblePoint.color = argsData.fill;
          var shapeOption = new PathOption(series.chart.element.id + "_Series_" + series.index + "_Point_" + bubblePoint.index, argsData.fill, argsData.border.width, argsData.border.color, series.opacity, series.border.dashArray);
          if (pointUpdate && getElement2(shapeOption.id)) {
            var markerElement = getElement2(shapeOption.id);
            startLocation = {
              x: +markerElement.getAttribute("cx"),
              y: +markerElement.getAttribute("cy")
            };
          }
          var element = drawSymbol(bubblePoint.symbolLocations[0], "Circle", new Size(argsData.width, argsData.height), series.marker.imageUrl, shapeOption, bubblePoint.x.toString() + ":" + bubblePoint.yValue.toString(), series.chart.svgRenderer, series.clipRect);
          appendChildElement(series.chart.enableCanvas, series.seriesElement, element, series.chart.redraw, true, "cx", "cy", startLocation, null, false, false, null, series.chart.duration, true);
          bubblePoint.regions.push(new Rect(bubblePoint.symbolLocations[0].x - segmentRadius, bubblePoint.symbolLocations[0].y - segmentRadius, 2 * segmentRadius, 2 * segmentRadius));
          bubblePoint.marker = {
            border: argsData.border,
            fill: argsData.fill,
            height: argsData.height,
            visible: true,
            shape: "Circle",
            width: argsData.width
          };
          if (series.chart.enableCanvas) {
            series.chart.markerRender.render(series);
          }
          startLocation = series.chart.redraw && !startLocation ? bubblePoint.symbolLocations[0] : startLocation;
          if (series.chart.redraw) {
            animateRedrawElement(element, series.chart.duration ? series.chart.duration : 300, startLocation, bubblePoint.symbolLocations[0], "cx", "cy");
          }
        } else {
          bubblePoint.marker = {
            visible: false
          };
        }
      }
    };
    BubbleSeries2.prototype.updateDirection = function(series, point, isInverted) {
      var visiblePoints = series.points;
      var radius;
      var value = Math.max(series.chart.initialClipRect.height, series.chart.initialClipRect.width);
      var percentChange = value / 100;
      var maxRadius = series.maxRadius * percentChange;
      var minRadius = series.minRadius * percentChange;
      var maximumSize = null;
      var maxValue = null;
      if (series.maxRadius === null || series.minRadius === null) {
        for (var _i = 0, _a = series.chart.visibleSeries; _i < _a.length; _i++) {
          var value_2 = _a[_i];
          if (value_2.type === "Bubble" && value_2.visible === true && (value_2.maxRadius === null || value_2.minRadius === null)) {
            maximumSize = value_2.sizeMax > maximumSize ? value_2.sizeMax : maximumSize;
          }
        }
        maxValue = value / 5 / 2;
        minRadius = maxRadius = 1;
        radius = maxValue * maxRadius;
      } else {
        maximumSize = series.sizeMax;
        radius = maxRadius - minRadius;
      }
      for (var i = 0; i < point.length; i++) {
        this.renderPoint(series, series.points[point[i]], isInverted, radius, maximumSize, minRadius, visiblePoints, true);
        if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {
          series.chart.dataLabelModule.commonId = series.chart.element.id + "_Series_" + series.index + "_Point_";
          series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);
        }
      }
    };
    BubbleSeries2.prototype.destroy = function() {
    };
    BubbleSeries2.prototype.getModuleName = function() {
      return "BubbleSeries";
    };
    BubbleSeries2.prototype.doAnimation = function(series) {
      var duration = series.animation.duration;
      var delay = series.animation.delay;
      var rectElements = series.seriesElement.childNodes;
      var count = 1;
      for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
        var bubblePoint = _a[_i];
        if (!bubblePoint.symbolLocations.length) {
          continue;
        }
        markerAnimate(rectElements[count], delay, duration, series, bubblePoint.index, bubblePoint.symbolLocations[0], false);
        count++;
      }
    };
    return BubbleSeries2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/spline-series.js
var __extends40 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var SplineSeries = (
  /** @class */
  function(_super) {
    __extends40(SplineSeries2, _super);
    function SplineSeries2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SplineSeries2.prototype.render = function(series, xAxis, yAxis, isInverted, pointAnimate, pointUpdate) {
      var firstPoint = null;
      var direction = "";
      var startPoint = "M";
      var points = [];
      var tempPoints = series.category === "TrendLine" ? series.points : this.enableComplexProperty(series);
      points = this.filterEmptyPoints(series, tempPoints);
      var previous;
      var getCoordinate = series.chart.chartAreaType === "PolarRadar" ? TransformToVisible : getPoint;
      for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
        var point = points_1[_i];
        if (point.index === 1) {
          direction = "";
        }
        previous = this.getPreviousIndex(points, point.index - 1, series);
        point.symbolLocations = [];
        point.regions = [];
        if (point.visible) {
          if (withInRange(points[previous], point, points[this.getNextIndex(points, point.index - 1, series)], series)) {
            if (firstPoint !== null) {
              direction = this.getSplineDirection(series.drawPoints[previous], firstPoint, point, xAxis, yAxis, isInverted, series, startPoint, getCoordinate, direction);
              startPoint = "L";
            }
            this.storePointLocation(point, series, isInverted, getCoordinate);
            if (direction === "" && points.length === 1) {
              direction = "M " + point.symbolLocations[0].x + " " + point.symbolLocations[0].y;
            }
            if (firstPoint === null && direction !== "" && (point.index === points.length - 1 || points[point.index + 1] && !points[point.index + 1].visible)) {
              direction += "M " + point.symbolLocations[0].x + " " + point.symbolLocations[0].y + " ";
            }
          }
          firstPoint = point;
        } else {
          startPoint = "M";
          firstPoint = null;
          point.symbolLocations = [];
        }
      }
      if (points.length > 0 && series.drawPoints.length > 0 && series.chart.chartAreaType === "PolarRadar" && series.isClosed) {
        var connectPoints = this.getFirstLastVisiblePoint(points);
        direction = this.getSplineDirection(series.drawPoints[series.drawPoints.length - 1], connectPoints.last, {
          xValue: connectPoints.first.xValue,
          yValue: connectPoints.first.yValue
        }, xAxis, yAxis, isInverted, series, startPoint, getCoordinate, direction);
        startPoint = "L";
      }
      var name = series.category === "TrendLine" ? series.chart.element.id + "_Series_" + series.sourceIndex + "_TrendLine_" + series.index : series.chart.element.id + "_Series_" + series.index;
      var options = new PathOption(name, "transparent", series.width, series.interior, series.opacity, series.dashArray, direction);
      this[pointAnimate ? "addPath" : "appendLinePath"](options, series, "");
      if (!pointUpdate) {
        this.renderMarker(series);
      }
    };
    SplineSeries2.prototype.getSplineDirection = function(data, firstPoint, point, xAxis, yAxis, isInverted, series, startPoint, getCoordinate, direction) {
      var controlPoint1 = data.controlPoint1;
      var controlPoint2 = data.controlPoint2;
      var pt1 = getCoordinate(firstPoint.xValue, firstPoint.yValue, xAxis, yAxis, isInverted, series);
      var pt2 = getCoordinate(point.xValue, point.yValue, xAxis, yAxis, isInverted, series);
      var bpt1 = getCoordinate(controlPoint1.x, controlPoint1.y, xAxis, yAxis, isInverted, series);
      var bpt2 = getCoordinate(controlPoint2.x, controlPoint2.y, xAxis, yAxis, isInverted, series);
      return direction.concat(startPoint + " " + pt1.x + " " + pt1.y + " C " + bpt1.x + " " + bpt1.y + " " + bpt2.x + " " + bpt2.y + " " + pt2.x + " " + pt2.y + " ");
    };
    SplineSeries2.prototype.updateDirection = function(series, point) {
      this.render(series, series.xAxis, series.yAxis, series.chart.requireInvertedAxis, false, true);
      for (var i = 0; i < point.length; i++) {
        if (series.marker && series.marker.visible) {
          series.chart.markerRender.renderMarker(series, series.points[point[i]], series.points[point[i]].symbolLocations[0], null, true);
        }
        if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {
          series.chart.dataLabelModule.commonId = series.chart.element.id + "_Series_" + series.index + "_Point_";
          series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);
        }
      }
    };
    SplineSeries2.prototype.addPath = function(options, series, clipRect) {
      var points = this.appendPathElement(options, series, clipRect);
      if (points.previousDirection !== "" && options.d !== "") {
        var startPathCommands = points.previousDirection.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);
        var endPathCommands = options.d.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);
        var maxLength = Math.max(startPathCommands.length, endPathCommands.length);
        var minLength = Math.min(startPathCommands.length, endPathCommands.length);
        if (series.removedPointIndex === 0 && startPathCommands.length > endPathCommands.length && startPathCommands[2] && startPathCommands[2].indexOf("M") === 0) {
          startPathCommands.splice(0, startPathCommands.length - endPathCommands.length);
          points.previousDirection = startPathCommands.join("");
        }
        if (startPathCommands.length < endPathCommands.length) {
          for (var i = startPathCommands.length; i < endPathCommands.length; i++) {
            if (endPathCommands.length !== startPathCommands.length) {
              if (endPathCommands.length === startPathCommands.length + 1 && endPathCommands[endPathCommands.length - 1].indexOf("M") === 0) {
                startPathCommands.push(endPathCommands[endPathCommands.length - 1]);
              } else if (startPathCommands[startPathCommands.length - 1].indexOf("C") === 0) {
                startPathCommands.push("L " + startPathCommands[startPathCommands.length - 1].split(" ").slice(-3).join(" "));
              } else if (startPathCommands[startPathCommands.length - 1].indexOf("L") === 0) {
                var points_2 = startPathCommands[startPathCommands.length - 1].split(" ").slice(-3);
                startPathCommands.push("C " + points_2.join(" ") + points_2.join(" ") + points_2.join(" "));
              } else {
                var points_3 = startPathCommands[startPathCommands.length - 1].replace("M", "");
                startPathCommands.push("C" + points_3 + points_3 + points_3);
              }
            }
          }
          animateAddPoints(points.element, options.d, series.chart.redraw, startPathCommands.join(" "), this.chart.duration);
        } else if (startPathCommands.length > endPathCommands.length) {
          for (var i = minLength; i < maxLength; i++) {
            if (series.removedPointIndex === series.points.length && endPathCommands.length !== startPathCommands.length) {
              if (endPathCommands[endPathCommands.length - 1].indexOf("C") === 0) {
                endPathCommands.push("L " + endPathCommands[endPathCommands.length - 1].split(" ").slice(-3).join(" "));
              } else if (endPathCommands[endPathCommands.length - 1].indexOf("L") === 0) {
                var points_4 = endPathCommands[endPathCommands.length - 1].split(" ").slice(-3);
                endPathCommands.push("C " + points_4.join(" ") + points_4.join(" ") + points_4.join(" "));
              } else {
                var points_5 = endPathCommands[endPathCommands.length - 1].replace("M", "");
                endPathCommands.push("C" + points_5 + points_5 + points_5);
              }
            } else {
              if (endPathCommands.length === 1) {
                var points_6 = endPathCommands[endPathCommands.length - 1].replace("M", "");
                endPathCommands.push("C" + points_6 + points_6 + points_6);
              } else if (endPathCommands.length !== startPathCommands.length) {
                endPathCommands.splice(1, 0, "C " + endPathCommands[0].split(" ").slice(-3).join(" ") + endPathCommands[0].split(" ").slice(-3).join(" ") + endPathCommands[0].split(" ").slice(-3).join(" "), endPathCommands[0].replace("M", "L"));
              }
            }
          }
          animateAddPoints(points.element, endPathCommands.join(""), series.chart.redraw, points.previousDirection, this.chart.duration, options.d);
        } else {
          animateAddPoints(points.element, options.d, series.chart.redraw, points.previousDirection, this.chart.duration);
        }
      }
    };
    SplineSeries2.prototype.getModuleName = function() {
      return "SplineSeries";
    };
    SplineSeries2.prototype.destroy = function() {
    };
    return SplineSeries2;
  }(SplineBase)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/histogram-series.js
var __extends41 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var HistogramSeries = (
  /** @class */
  function(_super) {
    __extends41(HistogramSeries2, _super);
    function HistogramSeries2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HistogramSeries2.prototype.render = function(series) {
      _super.prototype.render.call(this, series);
      if (series.showNormalDistribution) {
        this.renderNormalDistribution(series);
      }
    };
    HistogramSeries2.prototype.calculateBinInterval = function(yValues, series) {
      var mean = sum(yValues) / yValues.length;
      var sumValue = 0;
      for (var _i = 0, yValues_1 = yValues; _i < yValues_1.length; _i++) {
        var value = yValues_1[_i];
        sumValue += (value - mean) * (value - mean);
      }
      series.histogramValues.mean = mean;
      series.histogramValues.sDValue = Math.sqrt(Math.abs(sumValue / yValues.length));
      series.histogramValues.binWidth = series.binInterval || Math.round(3.5 * series.histogramValues.sDValue / Math.pow(yValues.length, 1 / 3)) || 1;
    };
    HistogramSeries2.prototype.processInternalData = function(data, series) {
      var _a;
      var updatedData = [];
      var yValues = [];
      var keys = Object.keys(data);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        yValues.push(data[key][series.yName]);
      }
      series.histogramValues = {
        yValues
      };
      var min = Math.min.apply(Math, series.histogramValues.yValues);
      var max = Math.max.apply(Math, series.histogramValues.yValues);
      this.calculateBinInterval(series.histogramValues.yValues, series);
      var binWidth = series.histogramValues.binWidth;
      var yCount;
      for (var j = 0; j < data.length; ) {
        yCount = yValues.filter(function(y) {
          return y >= min && y < min + binWidth;
        }).length;
        if (min + binWidth === max) {
          yCount += yValues.filter(function(y) {
            return y >= max;
          }).length;
        }
        updatedData.push((_a = {
          "x": min + binWidth / 2
        }, _a[series.yName] = yCount, _a));
        min = min + binWidth;
        j += yCount;
      }
      return updatedData;
    };
    HistogramSeries2.prototype.calculateBinValues = function(series) {
      var yValuesCount = series.histogramValues.yValues.length;
      var binWidth = series.histogramValues.binWidth;
      var mean = series.histogramValues.mean;
      var sDValue = series.histogramValues.sDValue;
      var pointsCount = 500;
      var min = series.xAxis.minimum ? parseInt(series.xAxis.minimum.toString(), 10) : series.xMin;
      var max = series.xAxis.maximum ? parseInt(series.xAxis.maximum.toString(), 10) : series.xMax;
      var points = series.points.length;
      var xValue;
      var yValue;
      var del = (max - min) / (pointsCount - 1);
      if (points) {
        for (var i = 0; i < pointsCount; i++) {
          xValue = min + i * del;
          yValue = Math.exp(-(xValue - mean) * (xValue - mean) / (2 * sDValue * sDValue)) / (sDValue * Math.sqrt(2 * Math.PI)) * binWidth * yValuesCount;
          series.yMin = series.yMin > yValue ? yValue : series.yMin;
          series.yMax = series.yMax < yValue ? yValue : series.yMax;
        }
      }
    };
    HistogramSeries2.prototype.renderNormalDistribution = function(series) {
      var min = series.xAxis.actualRange.min;
      var max = series.xAxis.actualRange.max;
      var xValue;
      var pointLocation;
      var yValue;
      var direction = "";
      var startPoint = "M";
      var yValuesCount = series.histogramValues.yValues.length;
      var binWidth = series.histogramValues.binWidth;
      var mean = series.histogramValues.mean;
      var sDValue = series.histogramValues.sDValue;
      var pointsCount = 500;
      var del = (max - min) / (pointsCount - 1);
      var points = series.points.length;
      if (points) {
        for (var i = 0; i < pointsCount; i++) {
          xValue = min + i * del;
          yValue = Math.exp(-(xValue - mean) * (xValue - mean) / (2 * sDValue * sDValue)) / (sDValue * Math.sqrt(2 * Math.PI));
          pointLocation = getPoint(xValue, yValue * binWidth * yValuesCount, series.xAxis, series.yAxis, series.chart.requireInvertedAxis);
          direction += startPoint + " " + pointLocation.x + " " + pointLocation.y + " ";
          startPoint = "L";
        }
      }
      var distributionLine = series.chart.renderer.drawPath(new PathOption(series.chart.element.id + "_Series_" + series.index + "_NDLine", "transparent", 2, series.chart.themeStyle.histogram || series.chart.themeStyle.errorBar, series.opacity, series.dashArray, direction), new Int32Array([series.clipRect.x, series.clipRect.y]));
      distributionLine.style.visibility = !series.chart.enableCanvas ? (series.animation.enable && animationMode !== "Disable" || animationMode === "Enable") && series.chart.animateSeries ? "hidden" : "visible" : null;
      if (!series.chart.enableCanvas) {
        series.seriesElement.appendChild(distributionLine);
      }
    };
    HistogramSeries2.prototype.doAnimation = function(series) {
      _super.prototype.doAnimation.call(this, series);
      if (series.showNormalDistribution) {
        templateAnimate(series.seriesElement.lastElementChild, series.animation.duration === 0 ? 1e3 : series.animation.duration, 500, "FadeIn");
      }
    };
    HistogramSeries2.prototype.updateDirection = function(series) {
      this.render(series);
      if (series.marker.visible) {
        appendChildElement(series.chart.enableCanvas, series.chart.seriesElements, series.symbolElement, true);
      }
      if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {
        series.chart.dataLabelCollections = [];
        series.chart.dataLabelModule.render(series, series.chart, series.marker.dataLabel);
        if (series.textElement) {
          appendChildElement(series.chart.enableCanvas, series.chart.dataLabelElements, series.shapeElement, true);
          appendChildElement(series.chart.enableCanvas, series.chart.dataLabelElements, series.textElement, true);
        }
      }
    };
    HistogramSeries2.prototype.getModuleName = function() {
      return "HistogramSeries";
    };
    HistogramSeries2.prototype.destroy = function() {
    };
    return HistogramSeries2;
  }(ColumnSeries)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/spline-area-series.js
var __extends42 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var SplineAreaSeries = (
  /** @class */
  function(_super) {
    __extends42(SplineAreaSeries2, _super);
    function SplineAreaSeries2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SplineAreaSeries2.prototype.render = function(series, xAxis, yAxis, isInverted, pointAnimate, pointUpdate) {
      var firstPoint = null;
      var direction = "";
      var startPoint = null;
      var startPoint1 = null;
      var pt2;
      var bpt1;
      var bpt2;
      var controlPt1;
      var controlPt2;
      var realPoints = [];
      var points = [];
      var point;
      var pointIndex = 0;
      realPoints = this.filterEmptyPoints(series);
      var emptyPointDirection = "";
      for (var i = 0; i < realPoints.length; i++) {
        point = realPoints[i];
        if (point.x === null || point.x === "") {
          continue;
        } else {
          point.index = pointIndex;
          pointIndex++;
          points.push(point);
        }
      }
      var pointsLength = points.length;
      var previous;
      var getCoordinate = series.chart.chartAreaType === "PolarRadar" ? TransformToVisible : getPoint;
      var origin = series.chart.chartAreaType === "PolarRadar" ? series.points[0].yValue : Math.max(series.yAxis.visibleRange.min, 0);
      for (var i = 0; i < pointsLength; i++) {
        point = points[i];
        point.symbolLocations = [];
        point.regions = [];
        previous = this.getPreviousIndex(points, point.index - 1, series);
        if (point.visible && withInRange(points[previous], point, points[this.getNextIndex(points, point.index - 1, series)], series)) {
          if (firstPoint) {
            controlPt1 = series.drawPoints[previous].controlPoint1;
            controlPt2 = series.drawPoints[previous].controlPoint2;
            pt2 = getCoordinate(point.xValue, point.yValue, xAxis, yAxis, isInverted, series);
            bpt1 = getCoordinate(controlPt1.x, controlPt1.y, xAxis, yAxis, isInverted, series);
            bpt2 = getCoordinate(controlPt2.x, controlPt2.y, xAxis, yAxis, isInverted, series);
            direction = direction.concat("C " + bpt1.x + " " + bpt1.y + " " + bpt2.x + " " + bpt2.y + " " + pt2.x + " " + pt2.y + " ");
          } else {
            startPoint = getCoordinate(point.xValue, origin, xAxis, yAxis, isInverted, series);
            direction += "M " + startPoint.x + " " + startPoint.y + " ";
            startPoint1 = getCoordinate(point.xValue, point.yValue, xAxis, yAxis, isInverted, series);
            direction += "L " + startPoint1.x + " " + startPoint1.y + " ";
          }
          this.storePointLocation(point, series, isInverted, getCoordinate);
          firstPoint = point;
        } else {
          firstPoint = null;
          point.symbolLocations = [];
        }
        if ((i + 1 < pointsLength && !points[i + 1].visible || i === pointsLength - 1) && pt2 && startPoint) {
          startPoint = getCoordinate(point.xValue, origin, xAxis, yAxis, isInverted, series);
          direction = direction.concat("L " + startPoint.x + " " + startPoint.y + " ");
        }
      }
      this[pointAnimate ? "addPath" : "appendLinePath"](new PathOption(series.chart.element.id + "_Series_" + series.index, series.interior, 0, "transparent", series.opacity, series.dashArray, direction), series, "");
      if (series.border.width !== 0) {
        emptyPointDirection = this.removeEmptyPointsBorder(this.getBorderDirection(direction));
        this[pointAnimate ? "addPath" : "appendLinePath"](new PathOption(series.chart.element.id + "_Series_border_" + series.index, "transparent", series.border.width, series.border.color ? series.border.color : series.interior, 1, series.border.dashArray, emptyPointDirection), series, "");
      }
      if (!pointUpdate) {
        this.renderMarker(series);
      }
    };
    SplineAreaSeries2.prototype.updateDirection = function(series, point) {
      this.render(series, series.xAxis, series.yAxis, series.chart.requireInvertedAxis, false, true);
      for (var i = 0; i < point.length; i++) {
        if (series.marker && series.marker.visible) {
          series.chart.markerRender.renderMarker(series, series.points[point[i]], series.points[point[i]].symbolLocations[0], null, true);
        }
        if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {
          series.chart.dataLabelModule.commonId = series.chart.element.id + "_Series_" + series.index + "_Point_";
          series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);
        }
      }
    };
    SplineAreaSeries2.prototype.addPath = function(options, series, clipRect) {
      var points = this.appendPathElement(options, series, clipRect);
      if (points.previousDirection !== "" && options.d !== "") {
        if (points.previousDirection.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g).length === 2) {
          points.previousDirection = points.previousDirection.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g)[0] + "L " + points.previousDirection.split(" ")[1] + " " + points.previousDirection.split(" ")[2] + " C " + points.previousDirection.split(" ")[1] + " " + points.previousDirection.split(" ")[2] + " " + points.previousDirection.split(" ")[1] + " " + points.previousDirection.split(" ")[2] + " " + points.previousDirection.split(" ")[1] + " " + points.previousDirection.split(" ")[2] + " L " + points.previousDirection.split(" ")[1] + " " + points.previousDirection.split(" ")[2];
        }
        if (options.d.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g).length === 2) {
          options.d = points.previousDirection.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g)[0] + "L " + points.previousDirection.split(" ")[1] + " " + points.previousDirection.split(" ")[2] + " C " + points.previousDirection.split(" ")[1] + " " + points.previousDirection.split(" ")[2] + " " + points.previousDirection.split(" ")[1] + " " + points.previousDirection.split(" ")[2] + " " + points.previousDirection.split(" ")[1] + " " + points.previousDirection.split(" ")[2] + " L " + points.previousDirection.split(" ")[1] + " " + points.previousDirection.split(" ")[2];
        }
        var startPathCommands = points.previousDirection.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);
        var endPathCommands = options.d.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);
        var maxLength = Math.max(startPathCommands.length, endPathCommands.length);
        var minLength = Math.min(startPathCommands.length, endPathCommands.length);
        if (startPathCommands.length < endPathCommands.length) {
          for (var i = startPathCommands.length; i < endPathCommands.length; i++) {
            if (endPathCommands.length !== startPathCommands.length) {
              var lastPointBeforeCurve = void 0;
              if (startPathCommands[startPathCommands.length - 1].split(" ").length === 4 && options.id.indexOf("border") !== -1) {
                lastPointBeforeCurve = startPathCommands[startPathCommands.length - (options.id.indexOf("border") !== -1 ? 1 : 2)].split(" ").slice(1).join(" ");
              } else {
                lastPointBeforeCurve = startPathCommands[startPathCommands.length - (options.id.indexOf("border") !== -1 ? 1 : 2)].split(" ").slice(5).join(" ");
              }
              var curveCommand = "C " + lastPointBeforeCurve + lastPointBeforeCurve + lastPointBeforeCurve;
              if (options.id.indexOf("border") !== -1) {
                startPathCommands.push(curveCommand);
              } else {
                startPathCommands.splice(startPathCommands.length - 1, 0, curveCommand);
              }
            }
          }
          animateAddPoints(points.element, options.d, series.chart.redraw, startPathCommands.join(" "), this.chart.duration);
        } else if (startPathCommands.length > endPathCommands.length) {
          for (var i = minLength; i < maxLength; i++) {
            if (endPathCommands.length !== startPathCommands.length) {
              var firstPointBeforeCurve = void 0;
              if (series.removedPointIndex === series.points.length) {
                if (startPathCommands[startPathCommands.length - 1].split(" ").length === 4 && options.id.indexOf("border") !== -1) {
                  firstPointBeforeCurve = endPathCommands[endPathCommands.length - (options.id.indexOf("border") !== -1 ? 1 : 2)].split(" ").slice(1).join(" ");
                } else {
                  firstPointBeforeCurve = endPathCommands[endPathCommands.length - (options.id.indexOf("border") !== -1 ? 1 : 2)].split(" ").slice(5).join(" ");
                }
                var curveCommand = "C " + firstPointBeforeCurve + firstPointBeforeCurve + firstPointBeforeCurve;
                if (options.id.indexOf("border") !== -1) {
                  endPathCommands.push(curveCommand);
                } else {
                  endPathCommands.splice(endPathCommands.length - 1, 0, curveCommand);
                }
              } else {
                if (startPathCommands[startPathCommands.length - 1].split(" ").length === 4) {
                  firstPointBeforeCurve = "C " + endPathCommands[options.id.indexOf("border") !== -1 ? 0 : 1].split(" ").slice(-3).join(" ") + endPathCommands[options.id.indexOf("border") !== -1 ? 0 : 1].split(" ").slice(1).join(" ") + endPathCommands[options.id.indexOf("border") !== -1 ? 0 : 1].split(" ").slice(1).join(" ");
                } else {
                  firstPointBeforeCurve = "C " + endPathCommands[options.id.indexOf("border") !== -1 ? 0 : 1].split(" ").slice(-3).join(" ") + endPathCommands[options.id.indexOf("border") !== -1 ? 0 : 1].split(" ").slice(-3).join(" ") + endPathCommands[options.id.indexOf("border") !== -1 ? 0 : 1].split(" ").slice(-3).join(" ");
                }
                endPathCommands.splice(options.id.indexOf("border") !== -1 ? 1 : 2, 0, firstPointBeforeCurve);
              }
            }
          }
          animateAddPoints(points.element, endPathCommands.join(""), series.chart.redraw, points.previousDirection, this.chart.duration, options.d);
        } else {
          animateAddPoints(points.element, options.d, series.chart.redraw, points.previousDirection, this.chart.duration);
        }
      }
    };
    SplineAreaSeries2.prototype.getModuleName = function() {
      return "SplineAreaSeries";
    };
    SplineAreaSeries2.prototype.destroy = function() {
    };
    return SplineAreaSeries2;
  }(SplineBase)
);

// node_modules/@syncfusion/ej2-charts/src/chart/technical-indicators/indicator-base.js
var __extends43 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TechnicalAnalysis = (
  /** @class */
  function(_super) {
    __extends43(TechnicalAnalysis2, _super);
    function TechnicalAnalysis2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    TechnicalAnalysis2.prototype.initSeriesCollection = function(indicator, chart) {
      indicator.targetSeries = [];
      var signalLine = new Series(indicator, "targetSeries", {}, true);
      this.setSeriesProperties(signalLine, indicator, indicator.type, indicator.fill, indicator.width, chart);
    };
    TechnicalAnalysis2.prototype.setSeriesProperties = function(series, indicator, name, fill, width, chart) {
      series.name = name.length <= 4 ? name.toLocaleUpperCase() : name;
      series.xName = "x";
      series.yName = "y";
      series.fill = fill || "#606eff";
      series.dashArray = indicator.dashArray;
      series.width = width;
      series.xAxisName = indicator.xAxisName;
      series.animation = indicator.animation;
      series.yAxisName = indicator.yAxisName;
      series.clipRectElement = indicator.clipRectElement;
      series.points = [];
      series.enableTooltip = true;
      series.interior = series.fill;
      series.category = "Indicator";
      series.index = indicator.index;
      series.chart = chart;
      series.xMin = Infinity;
      series.xMax = -Infinity;
      series.yMin = Infinity;
      series.yMax = -Infinity;
      series.xData = [];
      series.yData = [];
      series.marker.visible = false;
      indicator.targetSeries.push(series);
    };
    TechnicalAnalysis2.prototype.createIndicatorElements = function(chart, indicator, index) {
      if (indicator.seriesName || indicator.dataSource) {
        findClipRect(indicator.targetSeries[0]);
      }
      var clipRect = new Rect(0, 0, 0, 0);
      if (indicator.seriesName || indicator.dataSource) {
        clipRect = indicator.targetSeries[0].clipRect;
      }
      var options = new RectOption(chart.element.id + "_ChartIndicatorClipRect_" + index, "transparent", {
        width: 1,
        color: "Gray"
      }, 1, {
        x: 0,
        y: 0,
        width: clipRect.width,
        height: clipRect.height
      });
      var clipRectElement = appendClipElement(chart.redraw, options, chart.renderer);
      indicator.indicatorElement = chart.renderer.createGroup({
        "id": chart.element.id + "IndicatorGroup" + index,
        "transform": "translate(" + clipRect.x + "," + clipRect.y + ")",
        "clip-path": "url(#" + chart.element.id + "_ChartIndicatorClipRect_" + index + ")"
      });
      if (indicator.indicatorElement) {
        indicator.indicatorElement.setAttribute("role", indicator.accessibility.accessibilityRole ? indicator.accessibility.accessibilityRole : "");
        indicator.indicatorElement.setAttribute("tabindex", indicator.accessibility.focusable ? String(indicator.accessibility.tabIndex) : "-1");
        if (indicator.accessibility.focusable) {
          indicator.indicatorElement.style.outline = "none";
        }
        indicator.indicatorElement.setAttribute("aria-label", indicator.accessibility.accessibilityDescription ? indicator.accessibility.accessibilityDescription : "");
        indicator.indicatorElement.appendChild(clipRectElement);
      }
      for (var _i = 0, _a = indicator.targetSeries; _i < _a.length; _i++) {
        var series = _a[_i];
        series.clipRectElement = clipRectElement;
        var element = series.chart.renderer.createGroup({
          "id": series.chart.element.id + "_Indicator_" + indicator.index + "_" + series.name + "_Group"
        });
        if (indicator.indicatorElement) {
          indicator.indicatorElement.appendChild(element);
        }
        series.seriesElement = element;
      }
      if (chart.indicatorElements) {
        chart.indicatorElements.appendChild(indicator.indicatorElement);
      }
    };
    TechnicalAnalysis2.prototype.getDataPoint = function(x, y, sourcePoint, series, index, indicator) {
      if (indicator === void 0) {
        indicator = null;
      }
      var point = new Points();
      point.x = x;
      point.y = y;
      point.xValue = sourcePoint.xValue;
      point.color = series.fill;
      point.index = index;
      point.yValue = y;
      point.visible = true;
      series.xMin = Math.min(series.xMin, point.xValue);
      series.yMin = Math.min(series.yMin, point.yValue);
      series.xMax = Math.max(series.xMax, point.xValue);
      series.yMax = Math.max(series.yMax, point.yValue);
      series.xData.push(point.xValue);
      if (indicator && indicator.type === "Macd" && series.type === "Column") {
        if (point.y >= 0) {
          point.color = indicator.macdPositiveColor;
        } else {
          point.color = indicator.macdNegativeColor;
        }
      }
      return point;
    };
    TechnicalAnalysis2.prototype.getRangePoint = function(x, high, low, sourcePoint, series, index) {
      var point = new Points();
      point.x = x;
      point.high = high;
      point.low = low;
      point.xValue = sourcePoint.xValue;
      point.color = series.fill;
      point.index = index;
      point.visible = true;
      series.xData.push(point.xValue);
      return point;
    };
    TechnicalAnalysis2.prototype.setSeriesRange = function(points, indicator, series) {
      if (series === void 0) {
        series = null;
      }
      if (!series) {
        indicator.targetSeries[0].points = points;
      } else {
        series.points = points;
      }
    };
    return TechnicalAnalysis2;
  }(LineBase)
);

// node_modules/@syncfusion/ej2-charts/src/chart/technical-indicators/sma-indicator.js
var __extends44 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var SmaIndicator = (
  /** @class */
  function(_super) {
    __extends44(SmaIndicator2, _super);
    function SmaIndicator2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SmaIndicator2.prototype.initDataSource = function(indicator) {
      var smaPoints = [];
      var points = indicator.points;
      if (points && points.length) {
        var validData = points;
        var field = firstToLowerCase(indicator.field);
        var xField = "x";
        var signalSeries = indicator.targetSeries[0];
        if (validData && validData.length && validData.length >= indicator.period) {
          var average = 0;
          var sum2 = 0;
          for (var i = 0; i < indicator.period; i++) {
            sum2 += validData[i][field];
          }
          average = sum2 / indicator.period;
          smaPoints.push(this.getDataPoint(validData[indicator.period - 1][xField], average, validData[indicator.period - 1], signalSeries, smaPoints.length));
          var index = indicator.period;
          while (index < validData.length) {
            sum2 -= validData[index - indicator.period][field];
            sum2 += validData[index][field];
            average = sum2 / indicator.period;
            smaPoints.push(this.getDataPoint(validData[index][xField], average, validData[index], signalSeries, smaPoints.length));
            index++;
          }
        }
        this.setSeriesRange(smaPoints, indicator);
      }
    };
    SmaIndicator2.prototype.destroy = function() {
    };
    SmaIndicator2.prototype.getModuleName = function() {
      return "SmaIndicator";
    };
    return SmaIndicator2;
  }(TechnicalAnalysis)
);

// node_modules/@syncfusion/ej2-charts/src/chart/technical-indicators/ema-indicator.js
var __extends45 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var EmaIndicator = (
  /** @class */
  function(_super) {
    __extends45(EmaIndicator2, _super);
    function EmaIndicator2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    EmaIndicator2.prototype.initDataSource = function(indicator) {
      var field = firstToLowerCase(indicator.field);
      var xField = "x";
      var emaPoints = [];
      var signalSeries = indicator.targetSeries[0];
      var validData = indicator.points;
      if (validData && validData.length && validData.length >= indicator.period) {
        var sum2 = 0;
        var average = 0;
        var k = 2 / (indicator.period + 1);
        for (var i = 0; i < indicator.period; i++) {
          sum2 += validData[i][field];
        }
        average = sum2 / indicator.period;
        emaPoints.push(this.getDataPoint(validData[indicator.period - 1][xField], average, validData[indicator.period - 1], signalSeries, emaPoints.length));
        var index = indicator.period;
        while (index < validData.length) {
          var prevAverage = emaPoints[index - indicator.period][signalSeries.yName];
          var yValue = (validData[index][field] - prevAverage) * k + prevAverage;
          emaPoints.push(this.getDataPoint(validData[index][xField], yValue, validData[index], signalSeries, emaPoints.length));
          index++;
        }
      }
      this.setSeriesRange(emaPoints, indicator);
    };
    EmaIndicator2.prototype.destroy = function() {
    };
    EmaIndicator2.prototype.getModuleName = function() {
      return "EmaIndicator";
    };
    return EmaIndicator2;
  }(TechnicalAnalysis)
);

// node_modules/@syncfusion/ej2-charts/src/chart/technical-indicators/tma-indicator.js
var __extends46 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TmaIndicator = (
  /** @class */
  function(_super) {
    __extends46(TmaIndicator2, _super);
    function TmaIndicator2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    TmaIndicator2.prototype.initDataSource = function(indicator) {
      var tmaPoints = [];
      var field = firstToLowerCase(indicator.field);
      var xField = "x";
      var validData = indicator.points;
      if (validData && validData.length && validData.length >= indicator.period) {
        var signalSeries = indicator.targetSeries[0];
        var validData_1 = indicator.points;
        if (validData_1.length && validData_1.length >= indicator.period) {
          var sum2 = 0;
          var smaValues = [];
          var index = 0;
          var length_1 = validData_1.length;
          var period = indicator.period;
          while (length_1 >= period) {
            sum2 = 0;
            index = validData_1.length - length_1;
            for (var j = index; j < index + period; j++) {
              sum2 = sum2 + validData_1[j][field];
            }
            sum2 = sum2 / period;
            smaValues.push(sum2);
            length_1--;
          }
          for (var k = 0; k < period - 1; k++) {
            sum2 = 0;
            for (var j = 0; j < k + 1; j++) {
              sum2 = sum2 + validData_1[j][field];
            }
            sum2 = sum2 / (k + 1);
            smaValues.splice(k, 0, sum2);
          }
          index = indicator.period;
          while (index <= smaValues.length) {
            sum2 = 0;
            for (var j = index - indicator.period; j < index; j++) {
              sum2 = sum2 + smaValues[j];
            }
            sum2 = sum2 / indicator.period;
            tmaPoints.push(this.getDataPoint(validData_1[index - 1][xField], sum2, validData_1[index - 1], signalSeries, tmaPoints.length));
            index++;
          }
        }
      }
      this.setSeriesRange(tmaPoints, indicator);
    };
    TmaIndicator2.prototype.destroy = function() {
    };
    TmaIndicator2.prototype.getModuleName = function() {
      return "TmaIndicator";
    };
    return TmaIndicator2;
  }(TechnicalAnalysis)
);

// node_modules/@syncfusion/ej2-charts/src/chart/technical-indicators/ad-indicator.js
var __extends47 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var AccumulationDistributionIndicator = (
  /** @class */
  function(_super) {
    __extends47(AccumulationDistributionIndicator2, _super);
    function AccumulationDistributionIndicator2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AccumulationDistributionIndicator2.prototype.initDataSource = function(indicator) {
      var adPoints = [];
      var validData = indicator.points;
      if (validData.length > 0 && validData.length > indicator.period) {
        adPoints = this.calculateADPoints(indicator, validData);
      }
      this.setSeriesRange(adPoints, indicator);
    };
    AccumulationDistributionIndicator2.prototype.calculateADPoints = function(indicator, validData) {
      var temp = [];
      var sum2 = 0;
      var i = 0;
      var value = 0;
      var high = 0;
      var low = 0;
      var close = 0;
      var signalSeries = indicator.targetSeries[0];
      for (i = 0; i < validData.length; i++) {
        high = Number(validData[i].high);
        low = Number(validData[i].low);
        close = Number(validData[i].close);
        value = (close - low - (high - close)) / (high - low ? high - low : 1);
        sum2 = sum2 + value * Number(validData[i].volume);
        temp[i] = this.getDataPoint(validData[i].x, sum2, validData[i], signalSeries, temp.length);
      }
      return temp;
    };
    AccumulationDistributionIndicator2.prototype.destroy = function() {
    };
    AccumulationDistributionIndicator2.prototype.getModuleName = function() {
      return "AccumulationDistributionIndicator";
    };
    return AccumulationDistributionIndicator2;
  }(TechnicalAnalysis)
);

// node_modules/@syncfusion/ej2-charts/src/chart/technical-indicators/atr-indicator.js
var __extends48 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var AtrIndicator = (
  /** @class */
  function(_super) {
    __extends48(AtrIndicator2, _super);
    function AtrIndicator2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AtrIndicator2.prototype.initDataSource = function(indicator) {
      var validData = indicator.points;
      if (validData.length > 0 && validData.length > indicator.period) {
        this.calculateATRPoints(indicator, validData);
      }
    };
    AtrIndicator2.prototype.calculateATRPoints = function(indicator, validData) {
      var average = 0;
      var highLow = 0;
      var highClose = 0;
      var lowClose = 0;
      var trueRange = 0;
      var points = [];
      var temp = [];
      var period = indicator.period;
      var sum2 = 0;
      var y = "y";
      var signalSeries = indicator.targetSeries[0];
      for (var i = 0; i < validData.length; i++) {
        highLow = Number(validData[i].high) - Number(validData[i].low);
        if (i > 0) {
          highClose = Math.abs(Number(validData[i].high) - Number(validData[i - 1].close));
          lowClose = Math.abs(Number(validData[i].low) - Number(validData[i - 1].close));
        }
        trueRange = Math.max(highLow, highClose, lowClose);
        sum2 = sum2 + trueRange;
        if (i >= period) {
          average = (Number(temp[i - 1][y]) * (period - 1) + trueRange) / period;
          points.push(this.getDataPoint(validData[i].x, average, validData[i], signalSeries, points.length));
        } else {
          average = sum2 / period;
          if (i === period - 1) {
            points.push(this.getDataPoint(validData[i].x, average, validData[i], signalSeries, points.length));
          }
        }
        temp[i] = {
          x: validData[i].x,
          y: average
        };
      }
      this.setSeriesRange(points, indicator);
    };
    AtrIndicator2.prototype.destroy = function() {
    };
    AtrIndicator2.prototype.getModuleName = function() {
      return "AtrIndicator";
    };
    return AtrIndicator2;
  }(TechnicalAnalysis)
);

// node_modules/@syncfusion/ej2-charts/src/chart/technical-indicators/momentum-indicator.js
var __extends49 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var MomentumIndicator = (
  /** @class */
  function(_super) {
    __extends49(MomentumIndicator2, _super);
    function MomentumIndicator2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MomentumIndicator2.prototype.initSeriesCollection = function(indicator, chart) {
      _super.prototype.initSeriesCollection.call(this, indicator, chart);
      var upperLine = new Series(indicator, "targetSeries", {}, true);
      _super.prototype.setSeriesProperties.call(this, upperLine, indicator, "UpperLine", indicator.upperLine.color, indicator.upperLine.width, chart);
    };
    MomentumIndicator2.prototype.initDataSource = function(indicator) {
      var upperCollection = [];
      var signalCollection = [];
      var validData = indicator.points;
      if (validData && validData.length) {
        var upperSeries = indicator.targetSeries[1];
        var signalSeries = indicator.targetSeries[0];
        var length_1 = indicator.period;
        if (validData.length >= indicator.period) {
          for (var i = 0; i < validData.length; i++) {
            upperCollection.push(this.getDataPoint(validData[i].x, 100, validData[i], upperSeries, upperCollection.length));
            if (!(i < length_1)) {
              signalCollection.push(this.getDataPoint(validData[i].x, Number(validData[i].close) / Number(validData[i - length_1].close) * 100, validData[i], signalSeries, signalCollection.length));
            }
          }
        }
        this.setSeriesRange(signalCollection, indicator, indicator.targetSeries[0]);
        this.setSeriesRange(upperCollection, indicator, indicator.targetSeries[1]);
      }
    };
    MomentumIndicator2.prototype.destroy = function() {
    };
    MomentumIndicator2.prototype.getModuleName = function() {
      return "MomentumIndicator";
    };
    return MomentumIndicator2;
  }(TechnicalAnalysis)
);

// node_modules/@syncfusion/ej2-charts/src/chart/technical-indicators/rsi-indicator.js
var __extends50 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var RsiIndicator = (
  /** @class */
  function(_super) {
    __extends50(RsiIndicator2, _super);
    function RsiIndicator2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    RsiIndicator2.prototype.initSeriesCollection = function(indicator, chart) {
      _super.prototype.initSeriesCollection.call(this, indicator, chart);
      if (indicator.showZones) {
        var lowerLine = new Series(indicator, "targetSeries", {}, true);
        _super.prototype.setSeriesProperties.call(this, lowerLine, indicator, "LowerLine", indicator.lowerLine.color, indicator.lowerLine.width, chart);
        var upperLine = new Series(indicator, "targetSeries", {}, true);
        _super.prototype.setSeriesProperties.call(this, upperLine, indicator, "UpperLine", indicator.upperLine.color, indicator.upperLine.width, chart);
      }
    };
    RsiIndicator2.prototype.initDataSource = function(indicator) {
      var signalCollection = [];
      var lowerCollection = [];
      var upperCollection = [];
      var signalSeries = indicator.targetSeries[0];
      var validData = indicator.points;
      if (validData.length && validData.length >= indicator.period) {
        if (indicator.showZones) {
          for (var i = 0; i < validData.length; i++) {
            upperCollection.push(this.getDataPoint(validData[i].x, indicator.overBought, validData[i], indicator.targetSeries[1], upperCollection.length));
            lowerCollection.push(this.getDataPoint(validData[i].x, indicator.overSold, validData[i], indicator.targetSeries[2], lowerCollection.length));
          }
        }
        var prevClose = Number(validData[0].close);
        var gain = 0;
        var loss = 0;
        for (var i = 1; i <= indicator.period; i++) {
          var close_1 = Number(validData[i].close);
          if (close_1 > prevClose) {
            gain += close_1 - prevClose;
          } else {
            loss += prevClose - close_1;
          }
          prevClose = close_1;
        }
        gain = gain / indicator.period;
        loss = loss / indicator.period;
        signalCollection.push(this.getDataPoint(validData[indicator.period].x, 100 - 100 / (1 + gain / loss), validData[indicator.period], signalSeries, signalCollection.length));
        for (var j = indicator.period + 1; j < validData.length; j++) {
          var close_2 = Number(validData[j].close);
          if (close_2 > prevClose) {
            gain = (gain * (indicator.period - 1) + (close_2 - prevClose)) / indicator.period;
            loss = loss * (indicator.period - 1) / indicator.period;
          } else if (close_2 < prevClose) {
            loss = (loss * (indicator.period - 1) + (prevClose - close_2)) / indicator.period;
            gain = gain * (indicator.period - 1) / indicator.period;
          }
          prevClose = close_2;
          signalCollection.push(this.getDataPoint(validData[j].x, 100 - 100 / (1 + gain / loss), validData[j], signalSeries, signalCollection.length));
        }
      }
      this.setSeriesRange(signalCollection, indicator, indicator.targetSeries[0]);
      if (indicator.showZones) {
        this.setSeriesRange(upperCollection, indicator, indicator.targetSeries[1]);
        this.setSeriesRange(lowerCollection, indicator, indicator.targetSeries[2]);
      }
    };
    RsiIndicator2.prototype.destroy = function() {
    };
    RsiIndicator2.prototype.getModuleName = function() {
      return "RsiIndicator";
    };
    return RsiIndicator2;
  }(TechnicalAnalysis)
);

// node_modules/@syncfusion/ej2-charts/src/chart/technical-indicators/stochastic-indicator.js
var __extends51 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var StochasticIndicator = (
  /** @class */
  function(_super) {
    __extends51(StochasticIndicator2, _super);
    function StochasticIndicator2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    StochasticIndicator2.prototype.initSeriesCollection = function(indicator, chart) {
      _super.prototype.initSeriesCollection.call(this, indicator, chart);
      var periodLine = new Series(indicator, "targetSeries", {}, true);
      this.setSeriesProperties(periodLine, indicator, "PeriodLine", indicator.periodLine.color, indicator.periodLine.width, chart);
      if (indicator.showZones) {
        var upperSeries = new Series(indicator, "targetSeries", {}, true);
        this.setSeriesProperties(upperSeries, indicator, "UpperLine", indicator.upperLine.color, indicator.upperLine.width, chart);
        var lowerSeries = new Series(indicator, "targetSeries", {}, true);
        this.setSeriesProperties(lowerSeries, indicator, "LowerLine", indicator.lowerLine.color, indicator.lowerLine.width, chart);
      }
    };
    StochasticIndicator2.prototype.initDataSource = function(indicator) {
      var signalCollection = [];
      var upperCollection = [];
      var lowerCollection = [];
      var periodCollection = [];
      var source = [];
      var validData = indicator.points;
      if (validData.length && validData.length >= indicator.period) {
        if (indicator.showZones) {
          for (var i = 0; i < validData.length; i++) {
            upperCollection.push(this.getDataPoint(validData[i].x, indicator.overBought, validData[i], indicator.targetSeries[2], upperCollection.length));
            lowerCollection.push(this.getDataPoint(validData[i].x, indicator.overSold, validData[i], indicator.targetSeries[3], lowerCollection.length));
          }
        }
        source = this.calculatePeriod(indicator.period, indicator.kPeriod, validData, indicator.targetSeries[1]);
        periodCollection = this.smaCalculation(indicator.period, indicator.kPeriod, source, indicator.targetSeries[1]);
        signalCollection = this.smaCalculation(indicator.period + indicator.kPeriod - 1, indicator.dPeriod, source, indicator.targetSeries[0]);
      }
      this.setSeriesRange(signalCollection, indicator, indicator.targetSeries[0]);
      this.setSeriesRange(periodCollection, indicator, indicator.targetSeries[1]);
      if (indicator.showZones) {
        this.setSeriesRange(upperCollection, indicator, indicator.targetSeries[2]);
        this.setSeriesRange(lowerCollection, indicator, indicator.targetSeries[3]);
      }
    };
    StochasticIndicator2.prototype.smaCalculation = function(period, kPeriod, data, sourceSeries) {
      var pointCollection = [];
      if (data.length >= period + kPeriod) {
        var count = period + (kPeriod - 1);
        var temp = [];
        var values = [];
        for (var i = 0; i < data.length; i++) {
          var value = Number(data[i].y);
          temp.push(value);
        }
        var length_1 = temp.length;
        while (length_1 >= count) {
          var sum2 = 0;
          for (var i = period - 1; i < period + kPeriod - 1; i++) {
            sum2 = sum2 + temp[i];
          }
          sum2 = sum2 / kPeriod;
          values.push(sum2.toFixed(2));
          temp.splice(0, 1);
          length_1 = temp.length;
        }
        var len = count - 1;
        for (var i = 0; i < data.length; i++) {
          if (!(i < len)) {
            pointCollection.push(this.getDataPoint(data[i].x, Number(values[i - len]), data[i], sourceSeries, pointCollection.length));
            data[i].y = Number(values[i - len]);
          }
        }
      }
      return pointCollection;
    };
    StochasticIndicator2.prototype.calculatePeriod = function(period, kPeriod, data, series) {
      var lowValues = [];
      var highValues = [];
      var closeValues = [];
      var modifiedSource = [];
      for (var j = 0; j < data.length; j++) {
        lowValues[j] = data[j].low;
        highValues[j] = data[j].high;
        closeValues[j] = data[j].close;
      }
      if (data.length > period) {
        var mins = [];
        var maxs = [];
        for (var i = 0; i < period - 1; ++i) {
          maxs.push(0);
          mins.push(0);
          modifiedSource.push(this.getDataPoint(data[i].x, data[i].close, data[i], series, modifiedSource.length));
        }
        for (var i = period - 1; i < data.length; ++i) {
          var min = Number.MAX_VALUE;
          var max = Number.MIN_VALUE;
          for (var j = 0; j < period; ++j) {
            min = Math.min(min, lowValues[i - j]);
            max = Math.max(max, highValues[i - j]);
          }
          maxs.push(max);
          mins.push(min);
        }
        for (var i = period - 1; i < data.length; ++i) {
          var top_1 = 0;
          var bottom = 0;
          top_1 += closeValues[i] - mins[i];
          bottom += maxs[i] - mins[i];
          modifiedSource.push(this.getDataPoint(data[i].x, top_1 / bottom * 100, data[i], series, modifiedSource.length));
        }
      }
      return modifiedSource;
    };
    StochasticIndicator2.prototype.destroy = function() {
    };
    StochasticIndicator2.prototype.getModuleName = function() {
      return "StochasticIndicator";
    };
    return StochasticIndicator2;
  }(TechnicalAnalysis)
);

// node_modules/@syncfusion/ej2-charts/src/chart/technical-indicators/bollinger-bands.js
var __extends52 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var BollingerBands = (
  /** @class */
  function(_super) {
    __extends52(BollingerBands2, _super);
    function BollingerBands2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    BollingerBands2.prototype.initSeriesCollection = function(indicator, chart) {
      indicator.targetSeries = [];
      var rangeArea = new Series(indicator, "targetSeries", {}, true);
      rangeArea.type = "RangeArea";
      if (indicator.bandColor !== "transparent" && indicator.bandColor !== "none") {
        this.setSeriesProperties(rangeArea, indicator, "BollingerBand", indicator.bandColor, 0, chart);
      }
      var signalLine = new Series(indicator, "targetSeries", {}, true);
      this.setSeriesProperties(signalLine, indicator, "BollingerBand", indicator.fill, indicator.width, chart);
      var upperLine = new Series(indicator, "targetSeries", {}, true);
      this.setSeriesProperties(upperLine, indicator, "UpperLine", indicator.upperLine.color, indicator.upperLine.width, chart);
      var lowerLine = new Series(indicator, "targetSeries", {}, true);
      this.setSeriesProperties(lowerLine, indicator, "LowerLine", indicator.lowerLine.color, indicator.lowerLine.width, chart);
    };
    BollingerBands2.prototype.initDataSource = function(indicator) {
      var enableBand = indicator.bandColor !== "transparent" && indicator.bandColor !== "none";
      var start = enableBand ? 1 : 0;
      var signalCollection = [];
      var upperCollection = [];
      var lowerCollection = [];
      var bandCollection = [];
      var upperSeries = indicator.targetSeries[start + 1];
      var lowerSeries = indicator.targetSeries[start + 2];
      var signalSeries = indicator.targetSeries[start];
      var rangeAreaSeries = enableBand ? indicator.targetSeries[0] : null;
      var validData = indicator.points;
      if (validData.length && validData.length >= indicator.period) {
        var sum2 = 0;
        var deviationSum = 0;
        var multiplier = indicator.standardDeviation;
        var limit = validData.length;
        var length_1 = Math.round(indicator.period);
        var smaPoints = [];
        var deviations = [];
        var bollingerPoints = [];
        for (var i_1 = 0; i_1 < length_1; i_1++) {
          sum2 += Number(validData[i_1].close);
        }
        var sma = sum2 / indicator.period;
        for (var i_2 = 0; i_2 < limit; i_2++) {
          var y = Number(validData[i_2].close);
          if (i_2 >= length_1 - 1 && i_2 < limit) {
            if (i_2 - indicator.period >= 0) {
              var diff = y - Number(validData[i_2 - length_1].close);
              sum2 = sum2 + diff;
              sma = sum2 / indicator.period;
              smaPoints[i_2] = sma;
              deviations[i_2] = Math.pow(y - sma, 2);
              deviationSum += deviations[i_2] - deviations[i_2 - length_1];
            } else {
              smaPoints[i_2] = sma;
              deviations[i_2] = Math.pow(y - sma, 2);
              deviationSum += deviations[i_2];
            }
            var range = Math.sqrt(deviationSum / indicator.period);
            var lowerBand = smaPoints[i_2] - multiplier * range;
            var upperBand = smaPoints[i_2] + multiplier * range;
            if (i_2 + 1 === length_1) {
              for (var j_1 = 0; j_1 < length_1 - 1; j_1++) {
                bollingerPoints[j_1] = {
                  "X": validData[j_1].x,
                  "mb": smaPoints[i_2],
                  "lb": lowerBand,
                  "ub": upperBand,
                  visible: true
                };
              }
            }
            bollingerPoints[i_2] = {
              "X": validData[i_2].x,
              "mb": smaPoints[i_2],
              "lb": lowerBand,
              "ub": upperBand,
              visible: true
            };
          } else {
            if (i_2 < indicator.period - 1) {
              smaPoints[i_2] = sma;
              deviations[i_2] = Math.pow(y - sma, 2);
              deviationSum += deviations[i_2];
            }
          }
        }
        var i = -1;
        var j = -1;
        for (var k = 0; k < limit; k++) {
          if (k >= length_1 - 1) {
            var ub = "ub";
            var lb = "lb";
            var mb = "mb";
            upperCollection.push(this.getDataPoint(validData[k].x, bollingerPoints[k][ub], validData[k], upperSeries, upperCollection.length));
            lowerCollection.push(this.getDataPoint(validData[k].x, bollingerPoints[k][lb], validData[k], lowerSeries, lowerCollection.length));
            signalCollection.push(this.getDataPoint(validData[k].x, bollingerPoints[k][mb], validData[k], signalSeries, signalCollection.length));
            if (enableBand) {
              bandCollection.push(this.getRangePoint(validData[k].x, upperCollection[++i].y, lowerCollection[++j].y, validData[k], rangeAreaSeries, bandCollection.length));
            }
          }
        }
      }
      if (enableBand) {
        this.setSeriesRange(bandCollection, indicator, indicator.targetSeries[0]);
      }
      this.setSeriesRange(signalCollection, indicator, indicator.targetSeries[start]);
      this.setSeriesRange(upperCollection, indicator, indicator.targetSeries[start + 1]);
      this.setSeriesRange(lowerCollection, indicator, indicator.targetSeries[start + 2]);
    };
    BollingerBands2.prototype.destroy = function() {
    };
    BollingerBands2.prototype.getModuleName = function() {
      return "BollingerBandsIndicator";
    };
    return BollingerBands2;
  }(TechnicalAnalysis)
);

// node_modules/@syncfusion/ej2-charts/src/chart/technical-indicators/macd-indicator.js
var __extends53 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var MacdIndicator = (
  /** @class */
  function(_super) {
    __extends53(MacdIndicator2, _super);
    function MacdIndicator2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MacdIndicator2.prototype.initSeriesCollection = function(indicator, chart) {
      _super.prototype.initSeriesCollection.call(this, indicator, chart);
      if (indicator.macdType === "Line" || indicator.macdType === "Both") {
        var macdSeries = new Series(indicator, "targetSeries", {}, true);
        this.setSeriesProperties(macdSeries, indicator, "MacdLine", indicator.macdLine.color, indicator.macdLine.width, chart);
      }
      if (indicator.macdType === "Histogram" || indicator.macdType === "Both") {
        var histogramSeries = new Series(indicator, "targetSeries", {}, true);
        histogramSeries.type = "Column";
        this.setSeriesProperties(histogramSeries, indicator, "Histogram", indicator.macdPositiveColor, indicator.width, chart);
      }
    };
    MacdIndicator2.prototype.initDataSource = function(indicator) {
      var signalCollection = [];
      var fastPeriod = indicator.fastPeriod;
      var slowPeriod = indicator.slowPeriod;
      var trigger = indicator.period;
      var length = fastPeriod + trigger;
      var macdCollection = [];
      var histogramCollection = [];
      var validData = indicator.points;
      var signalSeries = indicator.targetSeries[0];
      var histogramSeries;
      var macdLineSeries;
      if (indicator.macdType === "Histogram") {
        histogramSeries = indicator.targetSeries[1];
      } else {
        macdLineSeries = indicator.targetSeries[1];
        if (indicator.macdType === "Both") {
          histogramSeries = indicator.targetSeries[2];
        }
      }
      if (validData && length < validData.length && slowPeriod <= fastPeriod && slowPeriod > 0 && length - 2 >= 0) {
        var shortEMA = this.calculateEMAValues(slowPeriod, validData, "close");
        var longEMA = this.calculateEMAValues(fastPeriod, validData, "close");
        var macdValues = this.getMACDVales(indicator, shortEMA, longEMA);
        macdCollection = this.getMACDPoints(indicator, macdValues, validData, macdLineSeries || signalSeries);
        var signalEMA = this.calculateEMAValues(trigger, macdCollection, "y");
        signalCollection = this.getSignalPoints(indicator, signalEMA, validData, signalSeries);
        if (histogramSeries) {
          histogramCollection = this.getHistogramPoints(indicator, macdValues, signalEMA, validData, histogramSeries);
        }
      }
      this.setSeriesRange(signalCollection, indicator, indicator.targetSeries[0]);
      if (histogramSeries) {
        this.setSeriesRange(histogramCollection, indicator, histogramSeries);
      }
      if (macdLineSeries) {
        this.setSeriesRange(macdCollection, indicator, macdLineSeries);
      }
    };
    MacdIndicator2.prototype.calculateEMAValues = function(period, validData, field) {
      var sum2 = 0;
      var initialEMA = 0;
      var emaValues = [];
      var emaPercent = 2 / (period + 1);
      for (var i = 0; i < period; i++) {
        sum2 += Number(validData[i][field]);
      }
      initialEMA = sum2 / period;
      emaValues.push(initialEMA);
      var emaAvg = initialEMA;
      for (var j = period; j < validData.length; j++) {
        emaAvg = (Number(validData[j][field]) - emaAvg) * emaPercent + emaAvg;
        emaValues.push(emaAvg);
      }
      return emaValues;
    };
    MacdIndicator2.prototype.getMACDPoints = function(indicator, macdPoints, validData, series) {
      var macdCollection = [];
      var dataMACDIndex = indicator.fastPeriod - 1;
      var macdIndex = 0;
      while (dataMACDIndex < validData.length) {
        macdCollection.push(this.getDataPoint(validData[dataMACDIndex].x, macdPoints[macdIndex], validData[dataMACDIndex], series, macdCollection.length));
        dataMACDIndex++;
        macdIndex++;
      }
      return macdCollection;
    };
    MacdIndicator2.prototype.getSignalPoints = function(indicator, signalEma, validData, series) {
      var dataSignalIndex = indicator.fastPeriod + indicator.period - 2;
      var signalIndex = 0;
      var signalCollection = [];
      while (dataSignalIndex < validData.length) {
        signalCollection.push(this.getDataPoint(validData[dataSignalIndex].x, signalEma[signalIndex], validData[dataSignalIndex], series, signalCollection.length));
        dataSignalIndex++;
        signalIndex++;
      }
      return signalCollection;
    };
    MacdIndicator2.prototype.getMACDVales = function(indicator, shortEma, longEma) {
      var macdPoints = [];
      var diff = indicator.fastPeriod - indicator.slowPeriod;
      for (var i = 0; i < longEma.length; i++) {
        macdPoints.push(shortEma[i + diff] - longEma[i]);
      }
      return macdPoints;
    };
    MacdIndicator2.prototype.getHistogramPoints = function(indicator, macdPoints, signalEma, validData, series) {
      var dataHistogramIndex = indicator.fastPeriod + indicator.period - 2;
      var histogramIndex = 0;
      var histogramCollection = [];
      while (dataHistogramIndex < validData.length) {
        histogramCollection.push(this.getDataPoint(validData[dataHistogramIndex].x, macdPoints[histogramIndex + (indicator.period - 1)] - signalEma[histogramIndex], validData[dataHistogramIndex], series, histogramCollection.length, indicator));
        dataHistogramIndex++;
        histogramIndex++;
      }
      return histogramCollection;
    };
    MacdIndicator2.prototype.destroy = function() {
    };
    MacdIndicator2.prototype.getModuleName = function() {
      return "MacdIndicator";
    };
    return MacdIndicator2;
  }(TechnicalAnalysis)
);

// node_modules/@syncfusion/ej2-charts/src/chart/trend-lines/trend-line.js
var Trendlines = (
  /** @class */
  function() {
    function Trendlines2() {
    }
    Trendlines2.prototype.initSeriesCollection = function(trendline, chart) {
      var trendLineSeries = new Series(trendline, "targetSeries", {}, true);
      if (trendline.type === "Linear" || trendline.type === "MovingAverage") {
        trendLineSeries.type = "Line";
      } else {
        trendLineSeries.type = "Spline";
      }
      this.setSeriesProperties(trendLineSeries, trendline, trendline.type, trendline.fill, trendline.width, chart);
    };
    Trendlines2.prototype.setSeriesProperties = function(series, trendline, name, fill, width, chart) {
      series.name = trendline.name;
      series.xName = "x";
      series.yName = "y";
      series.fill = fill || "blue";
      series.width = width;
      series.dashArray = trendline.dashArray;
      series.clipRectElement = trendline.clipRectElement;
      series.points = [];
      series.enableTooltip = trendline.enableTooltip;
      series.index = trendline.index;
      series.sourceIndex = trendline.sourceIndex;
      series.interior = series.fill;
      series.animation = trendline.animation;
      series.legendShape = "HorizontalLine";
      series.marker = trendline.marker;
      series.category = "TrendLine";
      series.chart = chart;
      series.xMin = Infinity;
      series.xMax = -Infinity;
      series.yMin = Infinity;
      series.yMax = -Infinity;
      series.xData = [];
      series.yData = [];
      trendline.targetSeries = series;
      if (chart.isBlazor) {
        trendline.targetSeries.border = {};
        trendline.targetSeries.connector = {};
      }
    };
    Trendlines2.prototype.createTrendLineElements = function(chart, trendline, index, element, clipRectElement) {
      trendline.trendLineElement = element;
      trendline.targetSeries.clipRectElement = clipRectElement;
      trendline.targetSeries.seriesElement = element;
      if (chart.trendLineElements) {
        chart.trendLineElements.appendChild(trendline.trendLineElement);
      }
    };
    Trendlines2.prototype.getDataPoint = function(x, y, series, index) {
      var trendPoint = new Points();
      trendPoint.x = series.xAxis.valueType === "DateTime" ? new Date(Number(x)) : x;
      trendPoint.y = y;
      trendPoint.xValue = Number(x);
      trendPoint.color = series.fill;
      trendPoint.index = index;
      trendPoint.yValue = Number(y);
      trendPoint.visible = true;
      series.xMin = Math.min(series.xMin, trendPoint.xValue);
      series.yMin = Math.min(series.yMin, trendPoint.yValue);
      series.xMax = Math.max(series.xMax, trendPoint.xValue);
      series.yMax = Math.max(series.yMax, trendPoint.yValue);
      series.xData.push(trendPoint.xValue);
      return trendPoint;
    };
    Trendlines2.prototype.findSlopeIntercept = function(xValues, yValues, trendline, points) {
      var xAvg = 0;
      var yAvg = 0;
      var xyAvg = 0;
      var xxAvg = 0;
      var index = 0;
      var slope = 0;
      var intercept = 0;
      while (index < points.length) {
        if (isNaN(yValues[index])) {
          yValues[index] = (yValues[index - 1] + yValues[index + 1]) / 2;
        }
        xAvg += xValues[index];
        yAvg += yValues[index];
        xyAvg += xValues[index] * yValues[index];
        xxAvg += xValues[index] * xValues[index];
        index++;
      }
      var type = trendline.type;
      if (trendline.intercept && (type === "Linear" || type === "Exponential")) {
        intercept = trendline.intercept;
        switch (type) {
          case "Linear":
            slope = (xyAvg - trendline.intercept * xAvg) / xxAvg;
            break;
          case "Exponential":
            slope = (xyAvg - Math.log(Math.abs(trendline.intercept)) * xAvg) / xxAvg;
            break;
        }
      } else {
        slope = (points.length * xyAvg - xAvg * yAvg) / (points.length * xxAvg - xAvg * xAvg);
        slope = type === "Linear" ? slope : Math.abs(slope);
        if (type === "Exponential" || type === "Power") {
          intercept = Math.exp((yAvg - slope * xAvg) / points.length);
        } else {
          intercept = (yAvg - slope * xAvg) / points.length;
        }
      }
      return {
        slope,
        intercept
      };
    };
    Trendlines2.prototype.initDataSource = function(trendline) {
      var points = trendline.points;
      if (points && points.length) {
        var trendlineSeries = trendline.targetSeries;
        switch (trendline.type) {
          case "Linear":
            this.setLinearRange(points, trendline, trendlineSeries);
            break;
          case "Exponential":
            this.setExponentialRange(points, trendline, trendlineSeries);
            break;
          case "MovingAverage":
            this.setMovingAverageRange(points, trendline, trendlineSeries);
            break;
          case "Polynomial":
            this.setPolynomialRange(points, trendline, trendlineSeries);
            break;
          case "Power":
            this.setPowerRange(points, trendline, trendlineSeries);
            break;
          case "Logarithmic":
            this.setLogarithmicRange(points, trendline, trendlineSeries);
            break;
        }
        if (trendline.type !== "Linear" && trendline.type !== "MovingAverage") {
          trendlineSeries.chart.splineSeriesModule.findSplinePoint(trendlineSeries);
        }
      }
    };
    Trendlines2.prototype.setExponentialRange = function(points, trendline, series) {
      var xValue = [];
      var yValue = [];
      var index = 0;
      while (index < points.length) {
        var point = points[index];
        var yDataValue = point.yValue ? Math.log(point.yValue) : 0;
        xValue.push(point.xValue);
        yValue.push(yDataValue);
        index++;
      }
      var slopeIntercept = this.findSlopeIntercept(xValue, yValue, trendline, points);
      series.points = this.getExponentialPoints(trendline, points, xValue, yValue, series, slopeIntercept);
    };
    Trendlines2.prototype.setLogarithmicRange = function(points, trendline, series) {
      var xLogValue = [];
      var yLogValue = [];
      var xPointsLgr = [];
      var index = 0;
      while (index < points.length) {
        var point = points[index];
        var xDataValue = point.xValue ? Math.log(point.xValue) : 0;
        xPointsLgr.push(point.xValue);
        xLogValue.push(xDataValue);
        yLogValue.push(point.yValue);
        index++;
      }
      var slopeIntercept = this.findSlopeIntercept(xLogValue, yLogValue, trendline, points);
      series.points = this.getLogarithmicPoints(trendline, points, xPointsLgr, yLogValue, series, slopeIntercept);
    };
    Trendlines2.prototype.setPolynomialRange = function(points, trendline, series) {
      var xPolyValues = [];
      var yPolyValues = [];
      var index = 0;
      while (index < points.length) {
        var point = points[index];
        xPolyValues.push(point.xValue);
        yPolyValues.push(point.yValue);
        index++;
      }
      series.points = this.getPolynomialPoints(trendline, points, xPolyValues, yPolyValues, series);
    };
    Trendlines2.prototype.setPowerRange = function(points, trendline, series) {
      var xValues = [];
      var yValues = [];
      var powerPoints = [];
      var index = 0;
      while (index < points.length) {
        var point = points[index];
        var xDataValue = point.xValue ? Math.log(point.xValue) : 0;
        var yDataValue = point.yValue ? Math.log(point.yValue) : 0;
        powerPoints.push(point.xValue);
        xValues.push(xDataValue);
        yValues.push(yDataValue);
        index++;
      }
      var slopeIntercept = this.findSlopeIntercept(xValues, yValues, trendline, points);
      series.points = this.getPowerPoints(trendline, points, powerPoints, yValues, series, slopeIntercept);
    };
    Trendlines2.prototype.setLinearRange = function(points, trendline, series) {
      var xValues = [];
      var yValues = [];
      var index = 0;
      while (index < points.length) {
        var point = points[index];
        xValues.push(point.xValue);
        yValues.push(point.yValue);
        index++;
      }
      var slopeIntercept = this.findSlopeIntercept(xValues, yValues, trendline, points);
      series.points = this.getLinearPoints(trendline, points, xValues, yValues, series, slopeIntercept);
    };
    Trendlines2.prototype.setMovingAverageRange = function(points, trendline, series) {
      var xValues = [];
      var yValues = [];
      var xAvgValues = [];
      var index = 0;
      while (index < points.length) {
        var point = points[index];
        xAvgValues.push(point.xValue);
        xValues.push(index + 1);
        yValues.push(point.yValue);
        index++;
      }
      series.points = this.getMovingAveragePoints(trendline, points, xAvgValues, yValues, series);
    };
    Trendlines2.prototype.getLogarithmicPoints = function(trendline, points, xValues, yValues, series, slopeInterceptLog) {
      var midPoint = Math.round(points.length / 2);
      var pts = [];
      var x1Log = xValues[0] - trendline.backwardForecast;
      var x1 = x1Log ? Math.log(x1Log) : 0;
      var y1Log = slopeInterceptLog.intercept + slopeInterceptLog.slope * x1;
      var x2Log = xValues[midPoint - 1];
      var x2 = x2Log ? Math.log(x2Log) : 0;
      var y2Log = slopeInterceptLog.intercept + slopeInterceptLog.slope * x2;
      var x3Log = xValues[xValues.length - 1] + trendline.forwardForecast;
      var x3 = x3Log ? Math.log(x3Log) : 0;
      var y3Log = slopeInterceptLog.intercept + slopeInterceptLog.slope * x3;
      pts.push(this.getDataPoint(x1Log, y1Log, series, pts.length));
      pts.push(this.getDataPoint(x2Log, y2Log, series, pts.length));
      pts.push(this.getDataPoint(x3Log, y3Log, series, pts.length));
      return pts;
    };
    Trendlines2.prototype.getPowerPoints = function(trendline, points, xValues, yValues, series, slopeInterceptPower) {
      var midPoint = Math.round(points.length / 2);
      var pts = [];
      var x1 = xValues[0] - trendline.backwardForecast;
      x1 = x1 > -1 ? x1 : 0;
      var y1 = slopeInterceptPower.intercept * Math.pow(x1, slopeInterceptPower.slope);
      var x2 = xValues[midPoint - 1];
      var y2 = slopeInterceptPower.intercept * Math.pow(x2, slopeInterceptPower.slope);
      var x3 = xValues[xValues.length - 1] + trendline.forwardForecast;
      var y3 = slopeInterceptPower.intercept * Math.pow(x3, slopeInterceptPower.slope);
      pts.push(this.getDataPoint(x1, y1, series, pts.length));
      pts.push(this.getDataPoint(x2, y2, series, pts.length));
      pts.push(this.getDataPoint(x3, y3, series, pts.length));
      return pts;
    };
    Trendlines2.prototype.getPolynomialPoints = function(trendline, points, xValues, yValues, series) {
      var pts = [];
      var polynomialOrder = points.length <= trendline.polynomialOrder ? points.length : trendline.polynomialOrder;
      polynomialOrder = Math.max(2, polynomialOrder);
      polynomialOrder = Math.min(6, polynomialOrder);
      trendline.polynomialOrder = polynomialOrder;
      trendline.polynomialSlopes = [];
      trendline.polynomialSlopes.length = trendline.polynomialOrder + 1;
      var index = 0;
      while (index < xValues.length) {
        var xVal = xValues[index];
        var yVal = yValues[index];
        var subIndex = 0;
        while (subIndex <= trendline.polynomialOrder) {
          if (!trendline.polynomialSlopes[subIndex]) {
            trendline.polynomialSlopes[subIndex] = 0;
          }
          trendline.polynomialSlopes[subIndex] += Math.pow(xVal, subIndex) * yVal;
          ++subIndex;
        }
        index++;
      }
      var numArray = [];
      numArray.length = 1 + 2 * trendline.polynomialOrder;
      var matrix = [];
      matrix.length = trendline.polynomialOrder + 1;
      var newIndex = 0;
      while (newIndex < trendline.polynomialOrder + 1) {
        matrix[newIndex] = [];
        matrix[newIndex].length = 3;
        newIndex++;
      }
      var nIndex = 0;
      while (nIndex < xValues.length) {
        var d = xValues[nIndex];
        var num2 = 1;
        var nIndex2 = 0;
        while (nIndex2 < numArray.length) {
          if (!numArray[nIndex2]) {
            numArray[nIndex2] = 0;
          }
          numArray[nIndex2] += num2;
          num2 *= d;
          ++nIndex2;
        }
        ++nIndex;
      }
      var nnIndex = 0;
      while (nnIndex <= trendline.polynomialOrder) {
        var nnIndex2 = 0;
        while (nnIndex2 <= trendline.polynomialOrder) {
          matrix[nnIndex][nnIndex2] = numArray[nnIndex + nnIndex2];
          ++nnIndex2;
        }
        ++nnIndex;
      }
      if (!this.gaussJordanElimination(matrix, trendline.polynomialSlopes)) {
        trendline.polynomialSlopes = null;
      }
      pts = this.getPoints(trendline, points, xValues, series);
      return pts;
    };
    Trendlines2.prototype.getMovingAveragePoints = function(trendline, points, xValues, yValues, series) {
      var pts = [];
      var period = trendline.period >= points.length ? points.length - 1 : trendline.period;
      period = period === 1 ? 1 : Math.max(2, period);
      var index = 0;
      var y;
      var x;
      var count;
      var nullCount;
      while (index < points.length) {
        y = count = nullCount = 0;
        for (var j = index; count < period; j++) {
          count++;
          y += yValues[j];
        }
        y = period - nullCount < 0 ? null : y ? y / (period - nullCount) : y;
        if (!isNullOrUndefined(y) && !isNaN(y)) {
          x = xValues[period - 1 + index];
          pts.push(this.getDataPoint(x, y, series, pts.length));
        }
        index++;
      }
      return pts;
    };
    Trendlines2.prototype.getLinearPoints = function(trendline, points, xValues, yValues, series, slopeInterceptLinear) {
      var pts = [];
      var max = xValues.indexOf(Math.max.apply(null, xValues));
      var min = xValues.indexOf(Math.min.apply(null, xValues));
      var x1Linear = xValues[min] - trendline.backwardForecast;
      var y1Linear = slopeInterceptLinear.slope * x1Linear + slopeInterceptLinear.intercept;
      var x2Linear = xValues[max] + trendline.forwardForecast;
      var y2Linear = slopeInterceptLinear.slope * x2Linear + slopeInterceptLinear.intercept;
      pts.push(this.getDataPoint(x1Linear, y1Linear, series, pts.length));
      pts.push(this.getDataPoint(x2Linear, y2Linear, series, pts.length));
      return pts;
    };
    Trendlines2.prototype.getExponentialPoints = function(trendline, points, xValues, yValues, series, slopeInterceptExp) {
      var midPoint = Math.round(points.length / 2);
      var ptsExp = [];
      var x1 = xValues[0] - trendline.backwardForecast;
      var y1 = slopeInterceptExp.intercept * Math.exp(slopeInterceptExp.slope * x1);
      var x2 = xValues[midPoint - 1];
      var y2 = slopeInterceptExp.intercept * Math.exp(slopeInterceptExp.slope * x2);
      var x3 = xValues[xValues.length - 1] + trendline.forwardForecast;
      var y3 = slopeInterceptExp.intercept * Math.exp(slopeInterceptExp.slope * x3);
      ptsExp.push(this.getDataPoint(x1, isNaN(y1) ? 0 : y1, series, ptsExp.length));
      ptsExp.push(this.getDataPoint(x2, isNaN(y2) ? 0 : y2, series, ptsExp.length));
      ptsExp.push(this.getDataPoint(x3, isNaN(y3) ? 0 : y3, series, ptsExp.length));
      return ptsExp;
    };
    Trendlines2.prototype.getPoints = function(trendline, points, xValues, series) {
      var polynomialSlopes = trendline.polynomialSlopes;
      var pts = [];
      var x1 = 1;
      var index = 1;
      var xValue;
      var yValue;
      points.sort(function(a, b) {
        return a.xValue - b.xValue;
      });
      xValues.sort(function(a, b) {
        return a - b;
      });
      while (polynomialSlopes !== null && index <= polynomialSlopes.length) {
        if (index === 1) {
          xValue = xValues[0] - trendline.backwardForecast;
          yValue = this.getPolynomialYValue(polynomialSlopes, xValue);
          pts.push(this.getDataPoint(xValue, yValue, series, pts.length));
        } else if (index === polynomialSlopes.length) {
          xValue = xValues[points.length - 1] + trendline.forwardForecast;
          yValue = this.getPolynomialYValue(polynomialSlopes, xValue);
          pts.push(this.getDataPoint(xValue, yValue, series, pts.length));
        } else {
          x1 += (points.length + (series.xAxis.valueType === "DateTime" ? index : trendline.forwardForecast)) / polynomialSlopes.length;
          xValue = xValues[parseInt(x1.toString(), 10) - 1];
          yValue = this.getPolynomialYValue(polynomialSlopes, xValue);
          pts.push(this.getDataPoint(xValue, yValue, series, pts.length));
        }
        index++;
      }
      return pts;
    };
    Trendlines2.prototype.getPolynomialYValue = function(slopes, x) {
      var sum2 = 0;
      var index = 0;
      while (index < slopes.length) {
        sum2 += slopes[index] * Math.pow(x, index);
        index++;
      }
      return sum2;
    };
    Trendlines2.prototype.gaussJordanElimination = function(matrix, polynomialSlopes) {
      var length = matrix.length;
      var numArray1 = [];
      var numArray2 = [];
      var numArray3 = [];
      numArray1.length = length;
      numArray2.length = length;
      numArray3.length = length;
      var index = 0;
      while (index < length) {
        numArray3[index] = 0;
        ++index;
      }
      var index1 = 0;
      while (index1 < length) {
        var num1 = 0;
        var index2 = 0;
        var index3 = 0;
        var index4 = 0;
        while (index4 < length) {
          if (numArray3[index4] !== 1) {
            var index5 = 0;
            while (index5 < length) {
              if (numArray3[index5] === 0 && Math.abs(matrix[index4][index5]) >= num1) {
                num1 = Math.abs(matrix[index4][index5]);
                index2 = index4;
                index3 = index5;
              }
              ++index5;
            }
          }
          ++index4;
        }
        ++numArray3[index3];
        if (index2 !== index3) {
          var index4_1 = 0;
          while (index4_1 < length) {
            var num2 = matrix[index2][index4_1];
            matrix[index2][index4_1] = matrix[index3][index4_1];
            matrix[index3][index4_1] = num2;
            ++index4_1;
          }
          var num3 = polynomialSlopes[index2];
          polynomialSlopes[index2] = polynomialSlopes[index3];
          polynomialSlopes[index3] = num3;
        }
        numArray2[index1] = index2;
        numArray1[index1] = index3;
        if (matrix[index3][index3] === 0) {
          return false;
        }
        var num4 = 1 / matrix[index3][index3];
        matrix[index3][index3] = 1;
        var iindex4 = 0;
        while (iindex4 < length) {
          matrix[index3][iindex4] *= num4;
          ++iindex4;
        }
        polynomialSlopes[index3] *= num4;
        var iandex4 = 0;
        while (iandex4 < length) {
          if (iandex4 !== index3) {
            var num2 = matrix[iandex4][index3];
            matrix[iandex4][index3] = 0;
            var index5 = 0;
            while (index5 < length) {
              matrix[iandex4][index5] -= matrix[index3][index5] * num2;
              ++index5;
            }
            polynomialSlopes[iandex4] -= polynomialSlopes[index3] * num2;
          }
          ++iandex4;
        }
        ++index1;
      }
      var iindex1 = length - 1;
      while (iindex1 >= 0) {
        if (numArray2[iindex1] !== numArray1[iindex1]) {
          var iindex2 = 0;
          while (iindex2 < length) {
            var num = matrix[iindex2][numArray2[iindex1]];
            matrix[iindex2][numArray2[iindex1]] = matrix[iindex2][numArray1[iindex1]];
            matrix[iindex2][numArray1[iindex1]] = num;
            ++iindex2;
          }
        }
        --iindex1;
      }
      return true;
    };
    Trendlines2.prototype.getTrendLineElements = function(series, chart) {
      findClipRect(series);
      var clipRect = series.clipRect;
      var clipRectElement = chart.renderer.drawClipPath(new RectOption(chart.element.id + "_ChartTrendlineClipRect_" + series.index, "transparent", {
        width: 1,
        color: "Gray"
      }, 1, {
        x: 0,
        y: 0,
        width: clipRect.width,
        height: clipRect.height
      }));
      var element = chart.renderer.createGroup({
        "id": chart.element.id + "TrendlineSeriesGroup" + series.index,
        "transform": "translate(" + clipRect.x + "," + clipRect.y + ")",
        "clip-path": "url(#" + chart.element.id + "_ChartTrendlineClipRect_" + series.index + ")"
      });
      if (element) {
        element.appendChild(clipRectElement);
      }
      for (var _i = 0, _a = series.trendlines; _i < _a.length; _i++) {
        var trendline = _a[_i];
        this.createTrendLineElements(chart, trendline, trendline.index, element, clipRectElement);
      }
    };
    Trendlines2.prototype.destroy = function() {
    };
    Trendlines2.prototype.getModuleName = function() {
      return "TrendLine";
    };
    return Trendlines2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart/user-interaction/crosshair.js
var Crosshair = (
  /** @class */
  function() {
    function Crosshair2(chart) {
      this.arrowLocation = new ChartLocation(0, 0);
      this.rx = 2;
      this.ry = 2;
      this.highlightWidth = 0;
      this.crosshairLeftOverflow = 0;
      this.crosshairRightOverflow = 0;
      this.chart = chart;
      this.elementID = this.chart.element.id;
      this.svgRenderer = new SvgRenderer(this.chart.element.id);
      if (this.chart.crosshair.snapToData || this.chart.crosshair.highlightCategory) {
        this.data = new ChartData(this.chart);
      }
      this.addEventListener();
    }
    Crosshair2.prototype.addEventListener = function() {
      if (this.chart.isDestroyed) {
        return;
      }
      var cancelEvent = Browser.isPointer ? "pointerleave" : "mouseleave";
      this.chart.on(Browser.touchMoveEvent, this.mouseMoveHandler, this);
      this.chart.on(Browser.touchEndEvent, this.mouseUpHandler, this);
      this.chart.on(cancelEvent, this.mouseLeaveHandler, this);
      this.chart.on("tapHold", this.longPress, this);
    };
    Crosshair2.prototype.mouseUpHandler = function() {
      if (this.chart.startMove) {
        this.removeCrosshair(2e3);
      }
    };
    Crosshair2.prototype.mouseLeaveHandler = function() {
      this.removeCrosshair(1e3);
    };
    Crosshair2.prototype.mouseMoveHandler = function(event2) {
      var chart = this.chart;
      if (chart.stockChart && chart.stockChart.onPanning) {
        if (chart.mouseY < chart.chartAxisLayoutPanel.seriesClipRect.y) {
          chart.mouseY = chart.chartAxisLayoutPanel.seriesClipRect.y;
        } else if (chart.mouseY > chart.chartAxisLayoutPanel.seriesClipRect.y + chart.chartAxisLayoutPanel.seriesClipRect.height) {
          chart.mouseY = chart.chartAxisLayoutPanel.seriesClipRect.y + chart.chartAxisLayoutPanel.seriesClipRect.height;
        }
      }
      if (event2.type === "touchmove" && (Browser.isIos || Browser.isIos7) && chart.startMove && event2.preventDefault) {
        event2.preventDefault();
      }
      if (!chart.disableTrackTooltip) {
        if (chart.crosshair.enable && withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect)) {
          if (chart.startMove || !chart.isTouch) {
            this.crosshair();
          }
        } else {
          this.removeCrosshair(1e3);
        }
      }
    };
    Crosshair2.prototype.longPress = function() {
      var chart = this.chart;
      if (withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect)) {
        this.crosshair();
      }
      return false;
    };
    Crosshair2.prototype.findMousePoints = function(chart) {
      var data = this.data.getData();
      var pointLocations = [];
      var axisCoordinate = chart.isTransposed ? "x" : "y";
      var nearestDataPoint = null;
      var nearestValue = null;
      var minDifference = Infinity;
      var mouseCoordinate = axisCoordinate === "x" ? chart.mouseX : chart.mouseY;
      var seriesVisibility = false;
      var commonXvalues = this.data.mergeXvalues(this.chart.visibleSeries);
      for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
        var series = _a[_i];
        seriesVisibility = seriesVisibility ? seriesVisibility : series.visible;
        if (series.visible && series.category !== "TrendLine") {
          var closestData = this.data.getClosestX(chart, series, commonXvalues) || data;
          if (closestData && closestData.point && closestData.point.symbolLocations[0]) {
            var pointLocation = closestData.point.symbolLocations[0][axisCoordinate] + closestData.series.clipRect[axisCoordinate];
            if (chart.crosshair.snapToData || chart.crosshair.highlightCategory) {
              pointLocations.push(pointLocation);
              var difference = Math.abs(pointLocation - mouseCoordinate);
              if (difference < minDifference) {
                minDifference = difference;
                nearestValue = pointLocation;
                nearestDataPoint = closestData;
              }
            }
          }
        }
      }
      if ((chart.crosshair.snapToData || chart.crosshair.highlightCategory) && nearestDataPoint) {
        data = nearestDataPoint;
        chart.crosshairModule.highlightWidth = 0;
        if (chart.crosshair.highlightCategory && data.series.xAxis.valueType === "Category") {
          var clipRectSize = chart.isTransposed || chart.requireInvertedAxis ? chart.chartAxisLayoutPanel.seriesClipRect.height : chart.chartAxisLayoutPanel.seriesClipRect.width;
          var highlightCategoryWidth = clipRectSize / data.series.xAxis.visibleRange.delta;
          var pointRelativePosition = (data.point.xValue - data.series.xAxis.visibleRange.min) / (data.series.xAxis.visibleRange.max - data.series.xAxis.visibleRange.min);
          chart.crosshairModule.crosshairLeftOverflow = Math.max(0, highlightCategoryWidth / 2 - pointRelativePosition * clipRectSize);
          chart.crosshairModule.crosshairRightOverflow = Math.max(0, pointRelativePosition * clipRectSize + highlightCategoryWidth / 2 - clipRectSize);
          chart.crosshairModule.highlightWidth = Math.max(0, highlightCategoryWidth - chart.crosshairModule.crosshairLeftOverflow - chart.crosshairModule.crosshairRightOverflow);
        }
      }
      if (data && data.point) {
        this.data.findMouseValues(data, chart, this);
      }
      return seriesVisibility;
    };
    Crosshair2.prototype.crosshair = function() {
      var visibleSeriesLength = this.chart.series.filter(function(series) {
        return series.visible;
      }).length;
      var seriesVisible = true;
      if (this.chart.crosshair.snapToData || this.chart.crosshair.highlightCategory) {
        seriesVisible = this.findMousePoints(this.chart);
      }
      var chart = this.chart;
      var horizontalCross = "";
      var verticalCross = "";
      var options;
      var axisTooltipGroup = document.getElementById(this.elementID + "_crosshair_axis");
      var crosshair = chart.crosshair;
      var tooltipdiv = document.getElementById(this.elementID + "_tooltip");
      var chartRect = chart.chartAxisLayoutPanel.seriesClipRect;
      var crossGroup = chart.enableCanvas ? document.getElementById(this.elementID + "_Secondary_Element") : document.getElementById(this.elementID + "_UserInteraction");
      var crosshairsvg;
      var cross = document.getElementById(this.elementID + "_Crosshair");
      if (chart.enableCanvas) {
        if (!cross) {
          cross = createElement("div", {
            id: this.elementID + "_Crosshair",
            styles: "position: absolute; pointer-events: none"
          });
          crossGroup.appendChild(cross);
        }
      }
      this.stopAnimation();
      if (visibleSeriesLength === 0 || chart.crosshair.snapToData && this.valueY === void 0 || chart.isCrosshair && chart.tooltip.enable && chart.tooltipModule && !withInBounds(chart.tooltipModule.valueX, chart.tooltipModule.valueY, chartRect) || chart.crosshair.snapToData && !seriesVisible) {
        return null;
      }
      this.valueX = chart.crosshair.snapToData || chart.crosshair.highlightCategory ? this.valueX : chart.tooltip.enable && chart.tooltipModule && chart.tooltipModule.valueX ? chart.tooltipModule.valueX : chart.mouseX;
      this.valueY = chart.crosshair.snapToData || chart.crosshair.highlightCategory ? this.valueY : chart.tooltip.enable && chart.tooltipModule && chart.tooltipModule.valueY ? chart.tooltipModule.valueY : chart.mouseY;
      if (!chart.enableCanvas) {
        crossGroup.setAttribute("opacity", "1");
      }
      if (crosshair.lineType === "Both" || crosshair.lineType === "Horizontal") {
        if (chart.crosshair.highlightCategory && this.highlightWidth !== 0 && (chart.isTransposed || chart.requireInvertedAxis)) {
          var crosshairHighlightWidth = this.highlightWidth;
          chart.crosshairModule.valueY = this.adjustCrosshairPositionForOverflow(this.valueY, true, chart);
          var y = this.valueY - crosshairHighlightWidth / 2;
          horizontalCross = "M " + chartRect.x + " " + y + " L " + (chartRect.x + chartRect.width) + " " + y + " L " + (chartRect.x + chartRect.width) + " " + (y + crosshairHighlightWidth) + " L " + chartRect.x + " " + (y + crosshairHighlightWidth) + " Z";
        } else {
          horizontalCross += "M " + chartRect.x + " " + this.valueY + " L " + (chartRect.x + chartRect.width) + " " + this.valueY;
        }
      }
      if (crosshair.lineType === "Both" || crosshair.lineType === "Vertical") {
        if (chart.crosshair.highlightCategory && this.highlightWidth !== 0 && !chart.requireInvertedAxis) {
          var crosshairHighlightWidth = this.highlightWidth;
          chart.crosshairModule.valueX = this.adjustCrosshairPositionForOverflow(this.valueX, false, chart);
          var x = this.valueX - crosshairHighlightWidth / 2;
          verticalCross = "M " + x + " " + chartRect.y + " L " + (x + crosshairHighlightWidth) + " " + chartRect.y + " L " + (x + crosshairHighlightWidth) + " " + (chartRect.y + chartRect.height) + " L " + x + " " + (chartRect.y + chartRect.height) + " Z";
        } else {
          verticalCross += "M " + this.valueX + " " + chartRect.y + " L " + this.valueX + " " + (chartRect.y + chartRect.height);
        }
      }
      if (chart.enableCanvas) {
        if (!axisTooltipGroup) {
          axisTooltipGroup = this.svgRenderer.createGroup({
            "id": this.elementID + "_crosshair_axis"
          });
        }
        var elementID = chart.tooltip.enable ? chart.element.id + "_tooltip_svg" : chart.element.id + "_svg";
        crosshairsvg = this.svgRenderer.createSvg({
          id: elementID,
          width: chart.availableSize.width,
          height: chart.availableSize.height
        });
        if (chart.tooltip.enable) {
          tooltipdiv = !tooltipdiv ? chart.tooltipModule.createElement() : tooltipdiv;
          tooltipdiv.appendChild(crosshairsvg);
          crossGroup.appendChild(tooltipdiv);
        }
        options = new PathOption(this.elementID + "_HorizontalLine", "none", crosshair.line.width, crosshair.horizontalLineColor || crosshair.line.color || chart.themeStyle.crosshairLine, crosshair.opacity, chart.theme.indexOf("Bootstrap5") > -1 || chart.theme === "Fluent2HighContrast" || chart.theme.indexOf("Tailwind3") > -1 ? crosshair.dashArray || "2.5" : crosshair.dashArray, horizontalCross);
        this.drawCrosshairLine(options, cross, chartRect.x, this.valueY, chartRect.width, 0, horizontalCross);
        options = new PathOption(this.elementID + "_VerticalLine", "none", crosshair.line.width, crosshair.verticalLineColor || crosshair.line.color || chart.themeStyle.crosshairLine, crosshair.opacity, chart.theme.indexOf("Bootstrap5") > -1 || chart.theme === "Fluent2HighContrast" || chart.theme.indexOf("Tailwind3") > -1 ? crosshair.dashArray || "2.5" : crosshair.dashArray, verticalCross);
        this.drawCrosshairLine(options, cross, this.valueX, chartRect.y, 0, chartRect.height, verticalCross);
        this.renderAxisTooltip(chart, chartRect, axisTooltipGroup);
        crosshairsvg.appendChild(axisTooltipGroup);
        if (!chart.tooltip.enable) {
          cross.appendChild(crosshairsvg);
        }
      } else {
        if (crossGroup.childNodes.length === 0) {
          var horizontalHighlight = chart.crosshair.highlightCategory && this.highlightWidth !== 0 && (chart.isTransposed || chart.requireInvertedAxis);
          var verticalHighlight = chart.crosshair.highlightCategory && this.highlightWidth !== 0 && !chart.requireInvertedAxis;
          axisTooltipGroup = chart.renderer.createGroup({
            "id": this.elementID + "_crosshair_axis"
          });
          options = new PathOption(this.elementID + "_HorizontalLine", horizontalHighlight ? crosshair.horizontalLineColor || crosshair.line.color ? this.crosshairLightenColor(crosshair.horizontalLineColor || crosshair.line.color) : chart.themeStyle.crosshairBackground : "none", horizontalHighlight ? 0 : crosshair.line.width, horizontalHighlight ? "none" : crosshair.horizontalLineColor || crosshair.line.color || chart.themeStyle.crosshairLine, crosshair.opacity, horizontalHighlight ? null : chart.theme.indexOf("Bootstrap5") > -1 || chart.theme === "Fluent2HighContrast" || chart.theme.indexOf("Tailwind3") > -1 ? crosshair.dashArray || "2.5" : crosshair.dashArray, horizontalCross);
          this.renderCrosshairLine(options, crossGroup);
          options = new PathOption(this.elementID + "_VerticalLine", verticalHighlight ? crosshair.verticalLineColor || crosshair.line.color ? this.crosshairLightenColor(crosshair.verticalLineColor || crosshair.line.color) : chart.themeStyle.crosshairBackground : "none", verticalHighlight ? 0 : crosshair.line.width, verticalHighlight ? "none" : crosshair.verticalLineColor || crosshair.line.color || chart.themeStyle.crosshairLine, crosshair.opacity, verticalHighlight ? null : chart.theme.indexOf("Bootstrap5") > -1 || chart.theme === "Fluent2HighContrast" || chart.theme.indexOf("Tailwind3") > -1 ? crosshair.dashArray || "2.5" : crosshair.dashArray, verticalCross);
          this.renderCrosshairLine(options, crossGroup);
          crossGroup.appendChild(axisTooltipGroup);
          this.renderAxisTooltip(chart, chartRect, crossGroup.lastChild);
        } else {
          document.getElementById(this.elementID + "_HorizontalLine").setAttribute("d", horizontalCross);
          document.getElementById(this.elementID + "_VerticalLine").setAttribute("d", verticalCross);
          this.renderAxisTooltip(chart, chartRect, crossGroup.lastChild);
        }
      }
    };
    Crosshair2.prototype.crosshairLightenColor = function(color) {
      var rgbValue = convertHexToColor(colorNameToHex(color));
      return "rgb(" + rgbValue.r + "," + rgbValue.g + "," + rgbValue.b + "," + 0.25 + ")";
    };
    Crosshair2.prototype.adjustCrosshairPositionForOverflow = function(initialPosition, isHorizontalOrientation, chart) {
      if (chart.crosshairModule.crosshairLeftOverflow > 0) {
        initialPosition += isHorizontalOrientation ? -chart.crosshairModule.crosshairLeftOverflow / 2 : chart.crosshairModule.crosshairLeftOverflow / 2;
      }
      if (chart.crosshairModule.crosshairRightOverflow > 0) {
        initialPosition += isHorizontalOrientation ? chart.crosshairModule.crosshairRightOverflow / 2 : -chart.crosshairModule.crosshairRightOverflow / 2;
      }
      return initialPosition;
    };
    Crosshair2.prototype.renderCrosshairLine = function(options, crossGroup) {
      var htmlObject = this.chart.renderer.drawPath(options);
      crossGroup.appendChild(htmlObject);
    };
    Crosshair2.prototype.drawCrosshairLine = function(options, crossGroup, left, top, width, height, direction) {
      if (!document.getElementById(options.id) && direction) {
        var line = createElement("div", {
          id: options.id
        });
        crossGroup.appendChild(line);
      }
      if (document.getElementById(options.id)) {
        var style = "top:" + top.toString() + "px;left:" + left.toString() + "px;width:" + width + "px;height:" + height + "px;fill:" + options.stroke + ";border: 0.5px solid " + options.stroke + ";opacity: " + options.opacity + " ; position: absolute";
        var crosshairline = document.getElementById(options.id);
        var crosshairtooltip = document.getElementById(this.elementID + "_crosshair_axis");
        crosshairline.style.cssText = style;
        crossGroup.style.opacity = "1";
        if (crosshairtooltip) {
          crosshairtooltip.style.opacity = "1";
        }
      }
    };
    Crosshair2.prototype.renderAxisTooltip = function(chart, chartRect, axisGroup) {
      var axis;
      var text;
      var rect;
      var pathElement;
      var textElem;
      var options;
      var padding = 5;
      var direction;
      var axisRect;
      for (var k = 0, length_1 = chart.axisCollections.length; k < length_1; k++) {
        axis = chart.axisCollections[k];
        axisRect = !axis.placeNextToAxisLine ? axis.rect : axis.updatedRect;
        if (axis.crosshairTooltip.enable) {
          if (axisRect && (this.valueX <= axisRect.x + axisRect.width && axisRect.x <= this.valueX || this.valueY <= axisRect.y + axisRect.height && axisRect.y <= this.valueY)) {
            pathElement = document.getElementById(this.elementID + "_axis_tooltip_" + k);
            textElem = document.getElementById(this.elementID + "_axis_tooltip_text_" + k);
            text = this.getAxisText(axis);
            if (text && text.indexOf("<br") > -1) {
              text = this.getAxisText(axis).split(/<br.*?>/g);
            }
            if (!text) {
              continue;
            }
            rect = this.tooltipLocation(text, axis, chartRect, axisRect);
            if (rect.y + rect.height / 2 > chart.availableSize.height || rect.y < 0) {
              continue;
            }
            if (pathElement === null) {
              if (chart.enableCanvas) {
                pathElement = this.svgRenderer.drawPath({
                  "id": this.elementID + "_axis_tooltip_" + k,
                  "fill": axis.crosshairTooltip.fill || chart.themeStyle.crosshairFill
                });
              } else {
                pathElement = chart.renderer.drawPath({
                  "id": this.elementID + "_axis_tooltip_" + k,
                  "fill": axis.crosshairTooltip.fill || chart.themeStyle.crosshairFill
                }, null);
              }
              axisGroup.appendChild(pathElement);
              options = new TextOption(this.elementID + "_axis_tooltip_text_" + k, 0, 0, chart.stockChart && chart.enableRtl ? "end" : "start", text);
              var render = chart.enableCanvas ? this.svgRenderer : chart.renderer;
              textElem = textElement2(render, options, axis.crosshairTooltip.textStyle, axis.crosshairTooltip.textStyle.color || chart.themeStyle.crosshairLabelFont.color, axisGroup, null, null, null, null, null, null, null, null, chart.enableCanvas, null, this.chart.themeStyle.crosshairLabelFont);
            }
            direction = findCrosshairDirection(this.rx, this.ry, rect, this.arrowLocation, 9, this.isTop, this.isBottom, this.isLeft, this.valueX, this.valueY);
            pathElement.setAttribute("d", direction);
            if (typeof text !== "string" && text.length > 1) {
              for (var i = 0; i < text.length; i++) {
                textElem.childNodes[i].textContent = text[i];
              }
            } else {
              textElem.textContent = text;
            }
            textElem.setAttribute("x", (rect.x + padding + (chart.enableRtl ? this.elementSize.width : 0)).toString());
            textElem.setAttribute("y", (rect.y + padding + 3 * this.elementSize.height / 4).toString());
            var shadowId = this.chart.element.id + "_shadow";
            if (typeof text !== "string" && text.length > 1) {
              var height = 0;
              textElem.setAttribute("y", (rect.y + padding + 3 * this.elementSize.height / (4 * text.length)).toString());
              for (var i = 0; i < textElem.children.length; i++) {
                height += this.elementSize.height / text.length;
                textElem.children[i].setAttribute("x", (rect.x + padding + (chart.enableRtl ? this.elementSize.width : 0) + this.elementSize.width / 2).toString());
                textElem.children[i].setAttribute("y", (parseInt(textElem.getAttribute("y"), 10) + height).toString());
                textElem.children[i].style.textAnchor = "middle";
              }
            }
            if (this.chart.theme === "Fluent" || this.chart.theme === "FluentDark" || this.chart.theme === "Fabric" || this.chart.theme === "FabricDark" || this.chart.theme === "Fluent2HighContrast") {
              var defElement = this.chart.renderer.createDefs();
              var bordercolor = this.chart.theme === "Fluent" || this.chart.theme === "Fabric" ? "#D2D0CE" : this.chart.theme === "Fluent2HighContrast" ? "#FFFFFF" : null;
              var borderwidth = this.chart.theme === "Fluent" || this.chart.theme === "Fabric" || this.chart.theme === "Fluent2HighContrast" ? 1 : null;
              defElement.setAttribute("id", this.chart.element.id + "SVG_tooltip_definition");
              axisGroup.appendChild(defElement);
              pathElement.setAttribute("stroke", bordercolor);
              pathElement.setAttribute("stroke-width", " " + borderwidth);
            } else if (this.chart.theme.indexOf("Fluent2") > -1) {
              pathElement.setAttribute("box-shadow", "0px 1.6px 3.6px 0px #00000021, 0px 0.3px 0.9px 0px #0000001A");
              pathElement.setAttribute("filter", Browser.isIE ? "" : "url(#" + shadowId + ")");
              var shadow = '<filter id="' + shadowId + '" height="130%"><feGaussianBlur in="SourceAlpha" stdDeviation="3"/>';
              shadow += '<feOffset dx="-1" dy="3.6" result="offsetblur"/><feComponentTransfer><feFuncA type="linear" slope="0.2"/>';
              shadow += '</feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge></filter>';
              var defElement = this.chart.renderer.createDefs();
              defElement.setAttribute("id", this.chart.element.id + "SVG_tooltip_definition");
              pathElement.appendChild(defElement);
              defElement.innerHTML = shadow;
            }
          } else {
            removeElement2(this.elementID + "_axis_tooltip_" + k);
            removeElement2(this.elementID + "_axis_tooltip_text_" + k);
          }
        }
      }
    };
    Crosshair2.prototype.getAxisText = function(axis) {
      var value;
      this.isBottom = false;
      this.isTop = false;
      this.isLeft = false;
      this.isRight = false;
      var labelValue = axis.valueType === "Category" && axis.labelPlacement === "BetweenTicks" ? 0.5 : 0;
      var isOpposed = axis.isAxisOpposedPosition;
      if (axis.orientation === "Horizontal") {
        value = getValueXByPoint(Math.abs(this.valueX - axis.rect.x), axis.rect.width, axis) + labelValue;
        this.isBottom = !isOpposed;
        this.isTop = isOpposed;
      } else {
        value = getValueYByPoint(Math.abs(this.valueY - axis.rect.y), axis.rect.height, axis) + labelValue;
        this.isRight = isOpposed;
        this.isLeft = !isOpposed;
      }
      if (axis.valueType === "DateTime") {
        return axis.format(new Date(value));
      } else if (axis.valueType === "Category") {
        return axis.labels[Math.floor(value)];
      } else if (axis.valueType === "DateTimeCategory") {
        return this.chart.dateTimeCategoryModule.getIndexedAxisLabel(axis.labels[Math.round(value)], axis.format);
      } else if (axis.valueType === "Logarithmic") {
        return value = axis.format(Math.pow(axis.logBase, value));
      } else {
        var customLabelFormat = axis.labelFormat && axis.labelFormat.match("{value}") !== null;
        return customLabelFormat ? axis.labelFormat.replace("{value}", axis.format(value)) : axis.format(value);
      }
    };
    Crosshair2.prototype.tooltipLocation = function(text, axis, bounds, axisRect) {
      var padding = 5;
      var arrowPadding = 9;
      var tooltipRect;
      var boundsX = bounds.x;
      var boundsY = bounds.y;
      var islabelInside = axis.labelPosition === "Inside";
      var scrollBarHeight = axis.scrollbarSettings.enable || axis.zoomingScrollBar && axis.zoomingScrollBar.svgObject ? axis.scrollBarHeight : 0;
      this.elementSize = measureText(text, axis.crosshairTooltip.textStyle, this.chart.themeStyle.crosshairLabelFont);
      if (typeof text !== "string" && text.length > 1) {
        this.elementSize.width = 0;
        this.elementSize.height = 0;
        for (var i = 0; i < text.length; i++) {
          var size = measureText(text[i], axis.crosshairTooltip.textStyle, this.chart.themeStyle.crosshairLabelFont);
          this.elementSize.height += size.height;
          if (this.elementSize.width < size.width) {
            this.elementSize.width = size.width;
          }
        }
      }
      var isOpposed = axis.isAxisOpposedPosition;
      if (axis.orientation === "Horizontal") {
        var yLocation = islabelInside ? axisRect.y - this.elementSize.height - (padding * 2 + arrowPadding) : axisRect.y + scrollBarHeight;
        var height = islabelInside ? axisRect.y - this.elementSize.height - arrowPadding : axisRect.y + arrowPadding;
        this.arrowLocation = new ChartLocation(this.valueX, yLocation);
        tooltipRect = new Rect(this.valueX - this.elementSize.width / 2 - padding, height + (!islabelInside ? scrollBarHeight : 0), this.elementSize.width + padding * 2, this.elementSize.height + padding * 2);
        if (isOpposed) {
          tooltipRect.y = islabelInside ? axisRect.y : axisRect.y - (this.elementSize.height + padding * 2 + arrowPadding) - scrollBarHeight;
        }
        if (tooltipRect.x < boundsX) {
          tooltipRect.x = boundsX;
        }
        if (tooltipRect.x + tooltipRect.width > boundsX + bounds.width) {
          tooltipRect.x -= tooltipRect.x + tooltipRect.width - (boundsX + bounds.width);
        }
        if (this.arrowLocation.x + arrowPadding / 2 > tooltipRect.x + tooltipRect.width - this.rx) {
          this.arrowLocation.x = tooltipRect.x + tooltipRect.width - this.rx - arrowPadding;
        }
        if (this.arrowLocation.x - arrowPadding < tooltipRect.x + this.rx) {
          this.arrowLocation.x = tooltipRect.x + this.rx + arrowPadding;
        }
      } else {
        scrollBarHeight = scrollBarHeight * (isOpposed ? 1 : -1);
        this.arrowLocation = new ChartLocation(axisRect.x, this.valueY);
        var width = islabelInside ? axisRect.x - scrollBarHeight : axisRect.x - this.elementSize.width - (padding * 2 + arrowPadding);
        tooltipRect = new Rect(width + scrollBarHeight, this.valueY - this.elementSize.height / 2 - padding, this.elementSize.width + padding * 2, this.elementSize.height + padding * 2);
        if (isOpposed) {
          tooltipRect.x = islabelInside ? axisRect.x - this.elementSize.width - arrowPadding : axisRect.x + arrowPadding + scrollBarHeight;
          if (tooltipRect.x + tooltipRect.width > this.chart.availableSize.width) {
            this.arrowLocation.x -= tooltipRect.x + tooltipRect.width - this.chart.availableSize.width;
            tooltipRect.x -= tooltipRect.x + tooltipRect.width - this.chart.availableSize.width;
          }
        } else {
          if (tooltipRect.x < 0) {
            this.arrowLocation.x -= tooltipRect.x;
            tooltipRect.x = 0;
          }
        }
        if (tooltipRect.y < boundsY) {
          tooltipRect.y = boundsY;
        }
        if (tooltipRect.y + tooltipRect.height >= boundsY + bounds.height) {
          tooltipRect.y -= tooltipRect.y + tooltipRect.height - (boundsY + bounds.height);
        }
        if (this.arrowLocation.y + arrowPadding / 2 > tooltipRect.y + tooltipRect.height - this.ry) {
          this.arrowLocation.y = tooltipRect.y + tooltipRect.height - this.ry - arrowPadding / 2;
        }
        if (this.arrowLocation.y - arrowPadding / 2 < tooltipRect.y + this.ry) {
          this.arrowLocation.y = tooltipRect.y + this.ry + arrowPadding / 2;
        }
      }
      return tooltipRect;
    };
    Crosshair2.prototype.stopAnimation = function() {
      stopTimer(this.crosshairInterval);
    };
    Crosshair2.prototype.progressAnimation = function() {
      stopTimer(this.crosshairInterval);
    };
    Crosshair2.prototype.removeCrosshair = function(duration) {
      var chart = this.chart;
      var crosshair = chart.enableCanvas ? document.getElementById(this.elementID + "_Crosshair") : document.getElementById(this.elementID + "_UserInteraction");
      var crosshairtooltip = chart.enableCanvas ? document.getElementById(this.elementID + "_crosshair_axis") : null;
      this.stopAnimation();
      if (crosshair && crosshair.getAttribute("opacity") !== "0") {
        this.crosshairInterval = +setTimeout(function() {
          new Animation({}).animate(crosshair, {
            duration: 200,
            progress: function(args) {
              crosshair.style.animation = "";
              if (!chart.enableCanvas) {
                crosshair.setAttribute("opacity", (1 - args.timeStamp / args.duration).toString());
              } else {
                crosshair.style.opacity = (1 - args.timeStamp / args.duration).toString();
                crosshairtooltip.style.opacity = (1 - args.timeStamp / args.duration).toString();
              }
            },
            end: function() {
              if (chart.enableCanvas) {
                crosshair.style.opacity = "0";
                crosshairtooltip.style.opacity = "0";
              } else {
                crosshair.setAttribute("opacity", "0");
              }
              chart.startMove = false;
              if (chart.tooltipModule) {
                chart.tooltipModule.valueX = null;
                chart.tooltipModule.valueY = null;
              }
            }
          });
        }, duration);
      }
    };
    Crosshair2.prototype.getModuleName = function() {
      return "Crosshair";
    };
    Crosshair2.prototype.destroy = function() {
    };
    return Crosshair2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/common/user-interaction/selection.js
var BaseSelection = (
  /** @class */
  function() {
    function BaseSelection2(control) {
      this.selectionStyle = [];
      this.control = control;
    }
    BaseSelection2.prototype.seriesStyles = function() {
      var seriesclass;
      var style = document.getElementById(this.styleId);
      var pattern = "{}";
      var fill;
      var opacity;
      var selectionPattern = this.control.selectionPattern;
      var highlightPattern = this.control.highlightPattern;
      if (this.styleId.indexOf("highlight") > 0 && this.control.highlightColor !== "" || isNullOrUndefined(style) || selectionPattern !== "None" || highlightPattern !== "None") {
        if (document.getElementById(this.styleId)) {
          document.getElementById(this.styleId).remove();
        }
        style = this.control.createElement("div");
        style.setAttribute("id", this.styleId);
        for (var _i = 0, _a = this.control.visibleSeries; _i < _a.length; _i++) {
          var series = _a[_i];
          var visibleSeries = this.control.visibleSeries[series.index] || this.control.visibleSeries[series.index];
          if (this.styleId.indexOf("highlight") > 0 && this.control.highlightColor !== "" || (!isNullOrUndefined(selectionPattern) || !isNullOrUndefined(highlightPattern)) && (selectionPattern !== "None" || highlightPattern !== "None")) {
            var patternName = this.styleId.indexOf("highlight") > 0 ? highlightPattern : selectionPattern;
            if ((visibleSeries.type === "Pie" || visibleSeries.type === "Funnel" || visibleSeries.type === "Pyramid" || this.control.getModuleName() === "circularchart3d") && this.control.highlightColor !== "transparent") {
              for (var i = 0; i < visibleSeries.points.length; i++) {
                opacity = visibleSeries.opacity;
                fill = this.pattern(this.control, this.styleId.indexOf("highlight") > 0 && this.control.highlightColor !== "" ? this.control.highlightColor : visibleSeries.points[i].color, series.points[i].index, patternName, opacity);
                pattern = "{ fill:" + fill + "}";
                seriesclass = series.selectionStyle || this.styleId + "_series_" + series.index + "_point_" + series.points[i].index + ",." + this.styleId + "_series_" + series.index + "_point_" + series.points[i].index + "> *";
                if (this.control.highlightMode === "None" && this.control.legendSettings.enableHighlight && !series.isRectSeries) {
                  style.innerText += "." + this.styleId + "_series_" + series.index + "> * { stroke-width:3;} ";
                  this.selectionStyle.push([this.styleId + "_series_" + series.index, "stroke-width", "3"]);
                }
                pattern = pattern.indexOf("None") > -1 ? "{fill:" + (this.styleId.indexOf("highlight") > 0 && this.control.highlightColor !== "" ? this.control.highlightColor : visibleSeries.points[i].color) + "!important}" : pattern;
                this.selectionStyle.push([this.styleId + "_series_" + series.index + "_point_" + series.points[i].index, "fill", fill ? fill.indexOf("None") > -1 ? this.styleId.indexOf("highlight") > -1 ? this.control.highlightColor : "" : fill : ""]);
              }
            } else if (visibleSeries.type && this.control.highlightColor !== "transparent") {
              opacity = visibleSeries.opacity;
              fill = this.pattern(this.control, this.styleId.indexOf("highlight") > 0 && this.control.highlightColor !== "" ? this.control.highlightColor : visibleSeries.pointColorMapping !== "" || this.control.rangeColorSettings && this.control.rangeColorSettings.length > 1 ? visibleSeries.points[0].color : visibleSeries.interior, series.index, patternName, opacity);
              pattern = "{ fill:" + fill + "}";
            }
          }
          seriesclass = series.selectionStyle || this.styleId + "_series_" + series.index + ",." + this.styleId + "_series_" + series.index + "> *";
          if (this.control.highlightMode === "None" && this.control.legendSettings.enableHighlight && !series.isRectSeries) {
            this.selectionStyle.push([this.styleId + "_series_" + series.index, "stroke-width", (parseFloat(series.width ? series.width.toString() : "0") + 1).toString()]);
          }
          pattern = pattern.indexOf("None") > -1 ? "{}" : pattern;
          this.selectionStyle.push([this.styleId + "_series_" + series.index, "fill", fill ? fill.indexOf("None") > -1 ? this.styleId.indexOf("highlight") > -1 ? this.control.highlightColor : "" : fill : ""]);
        }
        var unSelectOpacity = this.control.highlightColor !== "transparent" ? this.control.getModuleName() === "circularchart3d" ? 0.2 : 0.3 : opacity;
        if (isNullOrUndefined(this.control.selectionModule) && this.control.selectionMode === "None" && this.control.highlightColor !== "") {
          unSelectOpacity = 1;
        }
        this.selectionStyle.push([this.unselected, "opacity", unSelectOpacity.toString()]);
        var secondaryElement = document.getElementById(this.control.element.id + "_Secondary_Element");
        if (secondaryElement) {
          secondaryElement.appendChild(style);
        }
      }
    };
    BaseSelection2.prototype.pattern = function(chart, color, index, patternName, opacity) {
      var backgroundColor = "#ffffff";
      var svg = chart.svgObject;
      var pathOptions = [];
      var patternGroup = {
        "id": chart.element.id + "_" + patternName + "_Selection_" + index,
        "patternUnits": "userSpaceOnUse"
      };
      var heightStr = "height";
      var widthStr = "width";
      var width = 10;
      var height = 12;
      var patternNum = 6;
      var turquoiseNum = 17;
      var turstrokewidth = 1;
      var starNum = 21;
      var circleNum = 9;
      var tileNum = 18;
      var strokeWidth = 1;
      var bubNum = 20;
      switch (patternName) {
        case "Dots":
          patternGroup[heightStr] = patternGroup[widthStr] = patternNum;
          patternGroup[widthStr] = patternNum;
          pathOptions[0] = {
            "x": 0,
            "y": 0,
            "width": 7,
            "height": 7,
            "transform": "translate(0,0)",
            "fill": backgroundColor,
            "opacity": opacity,
            "name": "rect"
          };
          pathOptions[1] = {
            "cx": 3,
            "cy": 3,
            "r": 2,
            "stroke-width": 1,
            "fill": color,
            "name": "circle"
          };
          break;
        case "Pacman":
          patternGroup[heightStr] = "18.384";
          patternGroup[widthStr] = "17.917";
          pathOptions[0] = {
            "name": "rect",
            "x": 0,
            "y": 0,
            "width": 17.917,
            "height": 18.384,
            "transform": "translate(0,0)",
            "fill": backgroundColor,
            "opacity": opacity
          };
          pathOptions[1] = {
            "name": "path",
            "d": "M9.081,9.194l5.806-3.08c-0.812-1.496-2.403-3.052-4.291-3.052H8.835C6.138,3.063,3,6.151,3,8.723v1.679   c0,2.572,3.138,5.661,5.835,5.661h1.761c2.085,0,3.835-1.76,4.535-3.514L9.081,9.194z",
            "stroke-width": 1,
            "stroke": color,
            "fill": color
          };
          break;
        case "Chessboard":
          patternGroup[heightStr] = patternGroup[widthStr] = width;
          pathOptions[0] = {
            "x": 0,
            "y": 0,
            "width": width,
            "height": width,
            "fill": backgroundColor,
            "opacity": opacity,
            "name": "rect"
          };
          pathOptions[1] = {
            "x": 0,
            "y": 0,
            "width": 5,
            "height": 5,
            "fill": color,
            "opacity": opacity,
            "name": "rect"
          };
          pathOptions[2] = {
            "x": 5,
            "y": 5,
            "width": 5,
            "height": 5,
            "fill": color,
            "opacity": opacity,
            "name": "rect"
          };
          break;
        case "Crosshatch":
          patternGroup[heightStr] = patternGroup[widthStr] = "8";
          pathOptions[0] = {
            "x": 0,
            "y": 0,
            "width": 8,
            "height": 8,
            "transform": "translate(0,0)",
            "fill": backgroundColor,
            "opacity": opacity,
            "name": "rect"
          };
          pathOptions[1] = {
            "d": "M0 0L8 8ZM8 0L0 8Z",
            "stroke-width": 1,
            "stroke": color,
            "name": "path"
          };
          break;
        case "DiagonalForward":
          patternGroup[heightStr] = patternGroup[widthStr] = patternNum;
          pathOptions[0] = {
            "x": 0,
            "y": 0,
            "width": patternNum,
            "height": patternNum,
            "transform": "translate(0,0)",
            "fill": backgroundColor,
            "opacity": opacity,
            "name": "rect"
          };
          pathOptions[1] = {
            "d": "M 3 -3 L 9 3 M 6 6 L 0 0 M 3 9 L -3 3",
            "stroke-width": 2,
            "stroke": color,
            "name": "path"
          };
          break;
        case "DiagonalBackward":
          patternGroup[heightStr] = patternGroup[widthStr] = patternNum;
          pathOptions[0] = {
            "x": 0,
            "y": 0,
            "width": patternNum,
            "height": patternNum,
            "transform": "translate(0,0)",
            "fill": backgroundColor,
            "opacity": opacity,
            "name": "rect"
          };
          pathOptions[1] = {
            "d": "M 3 -3 L -3 3 M 0 6 L 6 0 M 9 3 L 3 9",
            "stroke-width": 2,
            "stroke": color,
            "name": "path"
          };
          break;
        case "Grid":
          patternGroup[heightStr] = patternGroup[widthStr] = patternNum;
          pathOptions[0] = {
            "name": "rect",
            "x": 0,
            "y": 0,
            "width": patternNum,
            "height": patternNum,
            "transform": "translate(0,0)",
            "fill": backgroundColor,
            "opacity": opacity
          };
          pathOptions[1] = {
            "name": "path",
            "d": "M1 3.5L11 3.5 M0 3.5L11 3.5 M0 7.5L11 7.5 M0 11.5L11 11.5 M5.5 0L5.5 12 M11.5 0L11.5 12Z",
            "stroke-width": 1,
            "stroke": color
          };
          break;
        case "Turquoise":
          patternGroup[heightStr] = patternGroup[widthStr] = turquoiseNum;
          pathOptions[0] = {
            "name": "rect",
            "x": 0,
            "y": 0,
            "width": turquoiseNum,
            "height": turquoiseNum,
            "transform": "translate(0,0)",
            "fill": backgroundColor,
            "opacity": opacity
          };
          pathOptions[1] = {
            "name": "path",
            "d": "M0.5739999999999998,2.643a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0",
            "stroke-width": turstrokewidth,
            "stroke-miterlimit": width,
            "stroke": color,
            "fill": color
          };
          pathOptions[2] = {
            "name": "path",
            "d": "M11.805,2.643a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0",
            "stroke-width": turstrokewidth,
            "stroke-miterlimit": width,
            "stroke": color,
            "fill": color
          };
          pathOptions[3] = {
            "name": "path",
            "d": "M6.19,2.643a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0",
            "stroke-width": turstrokewidth,
            "stroke-miterlimit": width,
            "stroke": color,
            "fill": color
          };
          pathOptions[4] = {
            "name": "path",
            "d": "M11.805,8.217a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0",
            "stroke-width": turstrokewidth,
            "stroke-miterlimit": width,
            "stroke": color,
            "fill": color
          };
          pathOptions[5] = {
            "name": "path",
            "d": "M6.19,8.217a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0",
            "stroke-width": turstrokewidth,
            "stroke-miterlimit": width,
            "stroke": color,
            "fill": color
          };
          pathOptions[6] = {
            "name": "path",
            "d": "M11.805,13.899a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0",
            "stroke-width": turstrokewidth,
            "stroke-miterlimit": width,
            "stroke": color,
            "fill": color
          };
          pathOptions[7] = {
            "name": "path",
            "d": "M6.19,13.899a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0",
            "stroke-width": turstrokewidth,
            "stroke-miterlimit": width,
            "stroke": color,
            "fill": color
          };
          break;
        case "Star":
          patternGroup[heightStr] = patternGroup[widthStr] = starNum;
          pathOptions[0] = {
            "name": "rect",
            "x": 0,
            "y": 0,
            "width": starNum,
            "height": starNum,
            "transform": "translate(0,0)",
            "fill": backgroundColor,
            "opacity": opacity
          };
          pathOptions[1] = {
            "name": "path",
            "d": "M15.913,18.59L10.762 12.842 5.613 18.75 8.291 11.422 0.325 9.91 8.154 8.33 5.337 0.91 10.488 6.658 15.637 0.75 12.959 8.078 20.925 9.59 13.096 11.17 z",
            "stroke-width": 1,
            "stroke": color,
            "fill": color
          };
          break;
        case "Triangle":
          patternGroup[heightStr] = patternGroup[widthStr] = width;
          pathOptions[0] = {
            "name": "rect",
            "x": 0,
            "y": 0,
            "width": width,
            "height": width,
            "transform": "translate(0,0)",
            "fill": backgroundColor,
            "opacity": opacity
          };
          pathOptions[1] = {
            "name": "path",
            "d": "M4.987,0L7.48 4.847 9.974 9.694 4.987 9.694 0 9.694 2.493 4.847 z",
            "stroke-width": 1,
            "stroke": color,
            "fill": color
          };
          break;
        case "Circle":
          patternGroup[heightStr] = patternGroup[widthStr] = circleNum;
          pathOptions[0] = {
            "name": "rect",
            "x": 0,
            "y": 0,
            "width": circleNum,
            "height": circleNum,
            "transform": "translate(0,0)",
            "fill": backgroundColor,
            "opacity": opacity
          };
          pathOptions[1] = {
            "name": "circle",
            "cx": 5.125,
            "cy": 3.875,
            "r": 3.625,
            "stroke-width": 1,
            "fill": color
          };
          break;
        case "Tile":
          patternGroup[heightStr] = patternGroup[widthStr] = tileNum;
          pathOptions[0] = {
            "name": "rect",
            "x": 0,
            "y": 0,
            "width": tileNum,
            "height": tileNum,
            "transform": "translate(0,0)",
            "fill": backgroundColor,
            "opacity": opacity
          };
          pathOptions[1] = {
            "name": "path",
            "d": "M0,9L0 0 9 0 z",
            "stroke-width": strokeWidth,
            "stroke": color,
            "fill": color
          };
          pathOptions[2] = {
            "name": "path",
            "d": "M9,9L9 0 18 0 z",
            "stroke-width": strokeWidth,
            "stroke": color,
            "fill": color
          };
          pathOptions[3] = {
            "name": "path",
            "d": "M0,18L0 9 9 9 z",
            "stroke-width": strokeWidth,
            "stroke": color,
            "fill": color
          };
          pathOptions[4] = {
            "name": "path",
            "d": "M9,18L9 9 18 9 z",
            "stroke-width": strokeWidth,
            "stroke": color,
            "fill": color
          };
          break;
        case "HorizontalDash":
          patternGroup[heightStr] = patternGroup[widthStr] = height;
          pathOptions[0] = {
            "name": "rect",
            "x": 0,
            "y": 0,
            "width": height,
            "height": height,
            "transform": "translate(0,0)",
            "fill": backgroundColor,
            "opacity": opacity
          };
          pathOptions[1] = {
            "name": "path",
            "d": "M0,1.5 L10 1.5 M0,5.5 L10 5.5 M0,9.5 L10 9.5 z",
            "stroke-width": 1,
            "stroke": color,
            "fill": color
          };
          break;
        case "VerticalDash":
          patternGroup[heightStr] = patternGroup[widthStr] = height;
          pathOptions[0] = {
            "name": "rect",
            "x": 0,
            "y": 0,
            "width": height,
            "height": height,
            "transform": "translate(0,0)",
            "fill": backgroundColor,
            "opacity": opacity
          };
          pathOptions[1] = {
            "name": "path",
            "d": "M1.5,0 L1.5 10 M5.5,0 L5.5 10 M9.5,0 L9.5 10 z",
            "stroke-width": 1,
            "stroke": color,
            "fill": color
          };
          break;
        case "Rectangle":
          patternGroup[heightStr] = patternGroup[widthStr] = height;
          pathOptions[0] = {
            "name": "rect",
            "width": height,
            "height": height,
            "fill": backgroundColor,
            "opacity": opacity
          };
          pathOptions[1] = {
            "name": "rect",
            "x": 1,
            "y": 2,
            "width": 4,
            "height": 9,
            "fill": color,
            "opacity": opacity
          };
          pathOptions[2] = {
            "name": "rect",
            "x": 7,
            "y": 2,
            "width": 4,
            "height": 9,
            "fill": color,
            "opacity": opacity
          };
          break;
        case "Box":
          patternGroup[heightStr] = patternGroup[widthStr] = width;
          pathOptions[0] = {
            "name": "rect",
            "width": 13,
            "height": 13,
            "fill": backgroundColor,
            "opacity": opacity
          };
          pathOptions[1] = {
            "name": "rect",
            "x": 1.5,
            "y": 1.5,
            "width": width,
            "height": 9,
            "fill": color,
            "opacity": opacity
          };
          break;
        case "HorizontalStripe":
          patternGroup[heightStr] = height;
          patternGroup[widthStr] = width;
          pathOptions[0] = {
            "name": "rect",
            "x": 0,
            "y": 0,
            "width": width,
            "height": height,
            "transform": "translate(0,0)",
            "fill": backgroundColor,
            "opacity": opacity
          };
          pathOptions[1] = {
            "name": "path",
            "d": "M0,0.5 L10 0.5 M0,4.5 L10 4.5 M0,8.5 L10 8.5 z",
            "stroke-width": 1,
            "stroke": color,
            "fill": color
          };
          break;
        case "VerticalStripe":
          patternGroup[heightStr] = width;
          patternGroup[widthStr] = height;
          pathOptions[0] = {
            "name": "rect",
            "x": 0,
            "y": 0,
            "width": height,
            "height": width,
            "transform": "translate(0,0)",
            "fill": backgroundColor,
            "opacity": opacity
          };
          pathOptions[1] = {
            "name": "path",
            "d": "M0.5,0 L0.5 10 M4.5,0 L4.5 10 M8.5,0 L8.5 10 z",
            "stroke-width": 1,
            "stroke": color,
            "fill": color
          };
          break;
        case "Bubble":
          patternGroup[heightStr] = patternGroup[widthStr] = bubNum;
          pathOptions[0] = {
            "name": "rect",
            "x": 0,
            "y": 0,
            "width": bubNum,
            "height": bubNum,
            "transform": "translate(0,0)",
            "fill": backgroundColor,
            "opacity": opacity
          };
          pathOptions[1] = {
            "name": "circle",
            "cx": 5.217,
            "cy": 11.325,
            "r": 3.429,
            "stroke-width": 1,
            "fill": "#D0A6D1"
          };
          pathOptions[2] = {
            "name": "circle",
            "cx": 13.328,
            "cy": 6.24,
            "r": 4.884,
            "stroke-width": 1,
            "fill": color
          };
          pathOptions[3] = {
            "name": "circle",
            "cx": 13.277,
            "cy": 14.66,
            "r": 3.018,
            "stroke-width": 1,
            "fill": "#D0A6D1"
          };
          break;
      }
      var svgRenderer = chart.svgRenderer || chart.renderer;
      var pattern = svgRenderer.createPattern(patternGroup, "pattern");
      this.loadPattern(chart, pathOptions, pattern, svgRenderer);
      svg.appendChild(pattern);
      return "url(#" + chart.element.id + "_" + patternName + "_Selection_" + index + ")";
    };
    BaseSelection2.prototype.loadPattern = function(chart, options, pattern, svgRenderer) {
      var i;
      for (i = 0; i < options.length; i++) {
        var path = svgRenderer.createPattern(options[i], options[i].name);
        pattern.appendChild(path);
      }
    };
    BaseSelection2.prototype.concatIndexes = function(userIndexes, localIndexes) {
      return userIndexes.concat(localIndexes);
    };
    BaseSelection2.prototype.checkVisibility = function(selectedIndexes, chart) {
      if (chart === void 0) {
        chart = null;
      }
      if (!selectedIndexes) {
        return false;
      }
      var visible = false;
      var uniqueSeries = [];
      for (var _i = 0, selectedIndexes_1 = selectedIndexes; _i < selectedIndexes_1.length; _i++) {
        var index = selectedIndexes_1[_i];
        if (uniqueSeries.indexOf(index.series) === -1) {
          uniqueSeries.push(index.series);
        }
      }
      for (var _a = 0, uniqueSeries_1 = uniqueSeries; _a < uniqueSeries_1.length; _a++) {
        var index = uniqueSeries_1[_a];
        if (chart != null && chart.rangeColorSettings && chart.rangeColorSettings.length > 0 && chart.rangeColorSettings[0].colors.length > 0) {
          if (this.control.series[0].visible) {
            visible = true;
            break;
          }
        } else {
          if (this.control.visibleSeries[index].visible) {
            visible = true;
            break;
          }
        }
      }
      return visible;
    };
    BaseSelection2.prototype.addSvgClass = function(element, className) {
      var elementClassName = element.getAttribute("class") || "";
      elementClassName += elementClassName !== "" ? " " : "";
      var isDataLabel = element.id.indexOf("datalabel") > -1 || element.id.indexOf("Text") > -1 || element.id.indexOf("TextShape") > -1;
      if (elementClassName.indexOf(className) === -1) {
        element.setAttribute("class", elementClassName + className);
        var selectionStyles_1 = this.selectionStyle;
        if (className && className.indexOf("highlight") !== -1) {
          if (this.control.getModuleName() === "chart" && this.control.highlightModule) {
            selectionStyles_1 = this.control.highlightModule.selectionStyle;
          } else if (this.control.getModuleName() === "accumulationchart" && this.control.accumulationHighlightModule) {
            selectionStyles_1 = this.control.accumulationHighlightModule.selectionStyle;
          } else if (this.control.getModuleName() === "chart3d" && this.control.highlight3DModule) {
            selectionStyles_1 = this.control.highlight3DModule.selectionStyle;
          } else if (this.control.getModuleName() === "circularchart3d" && this.control.circularChartHighlight3DModule) {
            selectionStyles_1 = this.control.circularChartHighlight3DModule.selectionStyle;
          }
        }
        if (element.tagName.toLowerCase() === "g") {
          element.querySelectorAll("*").forEach(function(child) {
            for (var i2 = 0; i2 < selectionStyles_1.length; i2++) {
              var key2 = selectionStyles_1[i2];
              var classValue2 = key2[0];
              var childClass2 = child.getAttribute("class") ? child.getAttribute("class") : "";
              if ((classValue2 === className || classValue2.indexOf(className) !== -1) && childClass2.indexOf("selection") === -1) {
                if (key2[1] === "fill" && key2[2] && !isDataLabel) {
                  child.style.fill = key2[2];
                }
                if (key2[1] === "opacity" && key2[2]) {
                  child.style.opacity = key2[2];
                  child.style.fill = "";
                }
                if (key2[1] === "stroke-width" && key2[2]) {
                  child.style.strokeWidth = key2[2];
                }
              }
            }
          });
        } else {
          for (var i = 0; i < selectionStyles_1.length; i++) {
            var key = selectionStyles_1[i];
            var classValue = key[0];
            var childClass = element.getAttribute("class") ? element.getAttribute("class") : "";
            if ((classValue === className || classValue.indexOf(className) !== -1) && (className.indexOf("highlight") === -1 || childClass.indexOf("selection") === -1)) {
              if (key[1] === "fill" && key[2] && !isDataLabel) {
                element.style.fill = key[2];
              }
              if (key[1] === "opacity" && key[2]) {
                element.style.opacity = key[2];
                element.style.fill = "";
              }
              if (key[1] === "stroke-width" && key[2] && element.id.indexOf("legend_shape") === -1) {
                element.style.strokeWidth = key[2];
              }
            }
          }
        }
      }
    };
    BaseSelection2.prototype.removeSvgClass = function(element, className) {
      var elementClassName = element.getAttribute("class") || "";
      if (elementClassName.indexOf(className) > -1) {
        element.setAttribute("class", elementClassName.replace(className, "").trim());
        var selectionStyles_2 = this.selectionStyle;
        if (className && className.indexOf("highlight") !== -1) {
          if (this.control.getModuleName() === "chart" && this.control.highlightModule) {
            selectionStyles_2 = this.control.highlightModule.selectionStyle;
          } else if (this.control.getModuleName() === "accumulationchart" && this.control.accumulationHighlightModule) {
            selectionStyles_2 = this.control.accumulationHighlightModule.selectionStyle;
          } else if (this.control.getModuleName() === "chart3d" && this.control.highlight3DModule) {
            selectionStyles_2 = this.control.highlight3DModule.selectionStyle;
          } else if (this.control.getModuleName() === "circularchart3d" && this.control.circularChartHighlight3DModule) {
            selectionStyles_2 = this.control.circularChartHighlight3DModule.selectionStyle;
          }
        }
        if (element.tagName.toLowerCase() === "g") {
          element.querySelectorAll("*").forEach(function(child) {
            for (var i2 = 0; i2 < selectionStyles_2.length; i2++) {
              var key2 = selectionStyles_2[i2];
              var classValue2 = key2[0];
              var childClass2 = child.getAttribute("class") ? child.getAttribute("class") : "";
              if ((classValue2 === className || classValue2.indexOf(className) !== -1) && childClass2.indexOf("selection") === -1) {
                if (key2[1] === "fill" && key2[2]) {
                  child.style.fill = "";
                }
                if (key2[1] === "opacity" && key2[2]) {
                  child.style.opacity = "";
                }
                if (key2[1] === "stroke-width" && key2[2]) {
                  child.style.strokeWidth = "";
                }
              }
            }
          });
        } else {
          for (var i = 0; i < selectionStyles_2.length; i++) {
            var key = selectionStyles_2[i];
            var classValue = key[0];
            var childClass = element.getAttribute("class") ? element.getAttribute("class") : "";
            if ((classValue === className || classValue.indexOf(className) !== -1) && (className.indexOf("highlight") === -1 || childClass.indexOf("selection") === -1)) {
              if (key[1] === "fill" && key[2]) {
                element.style.fill = "";
              }
              if (key[1] === "opacity" && key[2]) {
                element.style.opacity = "";
              }
              if (key[1] === "stroke-width" && key[2]) {
                element.style.strokeWidth = "";
              }
            }
          }
        }
      }
    };
    BaseSelection2.prototype.getChildren = function(parent) {
      var children = [];
      for (var i = 0; i < parent.childNodes.length; i++) {
        if (parent.childNodes[i].tagName !== "defs") {
          children.push(parent.childNodes[i]);
        }
      }
      return children;
    };
    return BaseSelection2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart/user-interaction/selection.js
var __extends54 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Selection = (
  /** @class */
  function(_super) {
    __extends54(Selection2, _super);
    function Selection2(chart) {
      var _this = _super.call(this, chart) || this;
      _this.isdrawRect = true;
      _this.multiDataIndexes = [];
      _this.pathIndex = 0;
      _this.seriesIndex = 0;
      _this.count = -1;
      _this.dragRectArray = [];
      _this.filterArray = [];
      _this.totalSelectedPoints = [];
      _this.chart = chart;
      _this.renderer = chart.renderer;
      var mode = chart.selectionMode;
      _this.isMultiDrag = chart.isMultiSelect && mode.indexOf("Drag") > -1;
      _this.addEventListener();
      return _this;
    }
    Selection2.prototype.addEventListener = function() {
      if (this.chart.isDestroyed || this.chart.stockChart && this.chart.stockChart.onPanning) {
        return;
      }
      var cancelEvent = Browser.isPointer ? "pointerleave" : "mouseleave";
      this.chart.on(Browser.touchMoveEvent, this.mouseMove, this);
      this.chart.on(cancelEvent, this.mouseLeave, this);
      this.chart.on("click", this.mouseClick, this);
      this.chart.on(Browser.touchStartEvent, this.mousedown, this);
      this.chart.on(Browser.touchEndEvent, this.mouseLeave, this);
    };
    Selection2.prototype.mousedown = function(e) {
      var chart = this.chart;
      if (chart.isPointMouseDown || chart.selectionMode === "None" || chart.isChartDrag) {
        return;
      }
      if (chart.isDoubleTap || !chart.isTouch || this.rectPoints) {
        this.dragStart(chart, chart.chartAxisLayoutPanel.seriesClipRect, chart.mouseDownX, chart.mouseDownY, e);
      }
    };
    Selection2.prototype.removeEventListener = function() {
      if (this.chart.isDestroyed) {
        return;
      }
      this.chart.off(Browser.touchMoveEvent, this.mouseMove);
      this.chart.off("pointerleave", this.mouseLeave);
      this.chart.off("click", this.mouseClick);
      this.chart.off(Browser.touchStartEvent, this.mousedown);
      this.chart.off(Browser.touchEndEvent, this.mouseLeave);
    };
    Selection2.prototype.initPrivateVariables = function(chart) {
      this.styleId = chart.element.id + "_ej2_chart_selection";
      this.unselected = chart.element.id + "_ej2_deselected";
      this.closeIconId = chart.element.id + "_ej2_drag_close";
      this.draggedRectGroup = chart.element.id + "_ej2_drag_group";
      this.multiRectGroup = chart.element.id + "_ej2_drag_multi_group";
      this.draggedRect = chart.element.id + "_ej2_drag_rect";
      this.lassoPath = chart.element.id + "_ej2_drag_path";
      this.selectedDataIndexes = [];
      this.rectPoints = null;
      this.isSeriesMode = chart.selectionMode === "Series";
    };
    Selection2.prototype.invokeSelection = function(chart) {
      this.initPrivateVariables(chart);
      this.series = extend({}, chart.visibleSeries, null, true);
      this.seriesStyles();
      this.currentMode = chart.selectionMode;
      if (!(chart.selectionMode.indexOf("Drag") > -1)) {
        this.selectDataIndex(chart, this.concatIndexes(chart.selectedDataIndexes, this.selectedDataIndexes));
      }
    };
    Selection2.prototype.generateStyle = function(series) {
      if (series) {
        if (this.styleId.indexOf("selection") > 1 && this.chart.selectionMode !== "None") {
          this.unselected = series.unSelectedStyle || this.unselected;
        }
        if (this.styleId.indexOf("highlight") > 0 && (this.chart.highlightMode !== "None" || this.chart.legendSettings.enableHighlight)) {
          this.unselected = series.nonHighlightStyle || this.unselected;
        }
        return series.selectionStyle || this.styleId + "_series_" + series.index;
      }
      return "undefined";
    };
    Selection2.prototype.selectDataIndex = function(chart, indexes) {
      for (var _i = 0, indexes_1 = indexes; _i < indexes_1.length; _i++) {
        var index = indexes_1[_i];
        this.performSelection(index, chart, this.getElementByIndex(chart, index, "", this.series[index.series].marker.visible)[0]);
      }
    };
    Selection2.prototype.getElementByIndex = function(chart, index, suffix, marker, dataLabel) {
      if (suffix === void 0) {
        suffix = "";
      }
      var elementId = chart.element.id + "_Series_" + index.series + "_Point_" + index.point;
      var series = chart.series[index.series];
      elementId = series.type !== "Scatter" && series.type !== "Bubble" && marker ? elementId + "_Symbol" + suffix : elementId;
      if (!marker && dataLabel) {
        return [getElement2(elementId + "_Text_0" + suffix), getElement2(elementId + "_TextShape_0" + suffix)];
      }
      return [getElement2(elementId), (series.type === "RangeArea" || series.type === "SplineRangeArea" || series.type === "RangeStepArea") && series.marker.visible ? getElement2(elementId + "1") : null];
    };
    Selection2.prototype.getClusterElements = function(chart, index) {
      var clusters = [];
      var seriesStyle;
      var selectedElements;
      for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
        var series = _a[_i];
        if (series.visible) {
          index = new Index(series.index, index.point);
          if (series.isRectSeries) {
            clusters.push(this.getElementByIndex(chart, index)[0]);
          }
          clusters.push(this.getElementByIndex(chart, index, "", series.marker.visible)[0]);
          var dataLabelTextElement = document.getElementById(chart.element.id + "_Series_" + series.index + "_Point_" + index.point + "_Text_0");
          var dataLabelShapeElement = document.getElementById(chart.element.id + "_Series_" + series.index + "_Point_" + index.point + "_TextShape_0");
          if (dataLabelTextElement) {
            clusters.push(dataLabelTextElement);
          }
          if (dataLabelShapeElement) {
            clusters.push(dataLabelShapeElement);
          }
          seriesStyle = this.generateStyle(chart.visibleSeries[index.series]);
          selectedElements = document.querySelectorAll("." + seriesStyle);
          this.findTrackballElements(selectedElements, seriesStyle);
          var clusterIndex = series.marker.visible && series.isRectSeries ? 2 : 1;
          clusterIndex += dataLabelTextElement && dataLabelShapeElement ? 2 : dataLabelTextElement || dataLabelShapeElement ? 1 : 0;
          if (!chart.isMultiSelect && selectedElements.length > 0 && selectedElements[0].id !== (clusters[clusters.length - clusterIndex] ? clusters[clusters.length - clusterIndex].id : "")) {
            this.removeSelection(chart, index.series, selectedElements, seriesStyle, true);
          }
        }
      }
      return clusters;
    };
    Selection2.prototype.findTrackballElements = function(selectedElements, className) {
      var trackballElements;
      var elements;
      for (var i = 0; i < selectedElements.length; i++) {
        if (!isNullOrUndefined(selectedElements[i])) {
          trackballElements = !isNullOrUndefined(selectedElements[i].parentNode) ? [].slice.call(selectedElements[0].parentNode.querySelectorAll("." + className)) : [];
          if (trackballElements.length > 0) {
            elements = [];
            for (var i_1 = 0; i_1 < trackballElements.length; i_1++) {
              if (trackballElements[i_1].id.indexOf("Trackball") > -1) {
                elements.push(trackballElements[i_1]);
              }
            }
            this.removeStyles(elements);
          }
        }
      }
    };
    Selection2.prototype.findElements = function(chart, series, index, suffix, marker, dataLabel) {
      if (suffix === void 0) {
        suffix = "";
      }
      if (this.isSeriesMode) {
        return this.getSeriesElements(series);
      } else if (this.currentMode === "Cluster") {
        return this.getClusterElements(chart, index);
      } else {
        return this.getElementByIndex(chart, index, suffix, marker, dataLabel);
      }
    };
    Selection2.prototype.isAlreadySelected = function(targetElem, eventType) {
      if (eventType === "click") {
        this.currentMode = this.chart.selectionMode;
        this.styleId = this.chart.element.id + (this.chart.selectionModule && this.chart.selectionMode !== "None" ? "_ej2_chart_selection" : "_ej2_chart_highlight");
      } else if (eventType === "mousemove" || eventType === "pointermove") {
        this.currentMode = this.chart.highlightMode;
        this.highlightDataIndexes = [];
        this.styleId = this.chart.element.id + "_ej2_chart_highlight";
      }
      if (this.chart.highlightMode !== "None" && this.chart.selectionMode === "None") {
        if (eventType === "click") {
          return false;
        }
      }
      if ((this.chart.highlightMode !== "None" || this.chart.legendSettings.enableHighlight) && this.previousSelectedEle && this.previousSelectedEle[0]) {
        var parentNodeId = targetElem.parentNode ? targetElem.parentNode.id : "";
        var isElement = void 0;
        if (targetElem.parentNode) {
          isElement = parentNodeId.indexOf("SeriesGroup") > 0 || parentNodeId.indexOf("SymbolGroup") > 0 ? true : false;
        }
        for (var i = 0; i < this.previousSelectedEle.length; i++) {
          if (this.previousSelectedEle[i] && this.previousSelectedEle[i].hasAttribute("class")) {
            if (this.previousSelectedEle[i].getAttribute("class").indexOf("highlight") > -1 && (isElement || eventType === "click")) {
              this.previousSelectedEle[i].removeAttribute("class");
              if (this.previousSelectedEle[i].id.indexOf("Group") > 0) {
                for (var j = 0; j < this.previousSelectedEle[i].children.length; j++) {
                  if (this.chart.highlightColor !== "" && !isNullOrUndefined(this.chart.highlightColor) && this.chart.highlightPattern === "None") {
                    this.previousSelectedEle[i].children[j].setAttribute("fill", this.previousSelectedEle[i].children[j].id.indexOf("Text") > -1 || this.previousSelectedEle[i].children[j].id.indexOf("TextShape") > -1 ? this.previousSelectedEle[i].children[j].getAttribute("fill") : this.control.visibleSeries[this.indexFinder(this.previousSelectedEle[i].id).series].interior);
                  }
                  this.previousSelectedEle[i].children[j].removeAttribute("style");
                }
              } else {
                if (this.chart.highlightColor !== "" && !isNullOrUndefined(this.chart.highlightColor) && this.chart.highlightPattern === "None") {
                  this.previousSelectedEle[i].setAttribute("fill", this.previousSelectedEle[i].id.indexOf("Text") > -1 || this.previousSelectedEle[i].id.indexOf("TextShape") > -1 ? this.previousSelectedEle[i].getAttribute("fill") : this.control.visibleSeries[this.indexFinder(this.previousSelectedEle[i].id).series].interior);
                }
                this.previousSelectedEle[i].removeAttribute("style");
              }
              this.addOrRemoveIndex(this.highlightDataIndexes, this.indexFinder(this.previousSelectedEle[i].id));
            } else if (!isElement && this.previousSelectedEle[i].getAttribute("class").indexOf("highlight") > -1) {
              this.performSelection(this.indexFinder(this.previousSelectedEle[i].id), this.chart, this.previousSelectedEle[i]);
            }
          }
        }
      }
      return true;
    };
    Selection2.prototype.mouseClick = function(event2) {
      this.calculateSelectedElements(event2.target, event2.type, true);
      if (this.chart.highlightModule && this.chart.highlightModule.highlightDataIndexes && this.chart.highlightModule.highlightDataIndexes.length > 0 && event2.target.id.indexOf("_chart_legend_") === -1 && event2.target.id.indexOf("_Series_") === -1 && this.chart.isTouch && Browser.isDevice) {
        this.removeLegendHighlightStyles();
      }
    };
    Selection2.prototype.calculateSelectedElements = function(targetElement, eventType, pointClick2) {
      if (isNullOrUndefined(targetElement)) {
        return;
      }
      if (this.chart.selectionMode === "None" && this.chart.highlightMode === "None" || targetElement.id && targetElement.id.indexOf(this.chart.element.id + "_") === -1) {
        return;
      }
      if (eventType === "mousemove" || eventType === "pointermove") {
        if (targetElement.hasAttribute("class") && (targetElement.getAttribute("class").indexOf("highlight") > -1 || targetElement.getAttribute("class").indexOf("selection") > -1)) {
          return;
        }
        if (!isNullOrUndefined(targetElement.parentNode) && targetElement.parentNode.hasAttribute("class") && (targetElement.parentNode.getAttribute("class").indexOf("highlight") > 0 || targetElement.parentNode.getAttribute("class").indexOf("selection") > 0)) {
          return;
        }
      }
      this.isAlreadySelected(targetElement, eventType);
      if (targetElement.id && targetElement.id.indexOf("_Series_") > -1 && targetElement.id.indexOf("_Text_") === -1) {
        var element = void 0;
        if (targetElement.id.indexOf("_Trackball_1") > -1) {
          element = getElement2(targetElement.id.split("_Trackball_")[0] + "_Symbol");
          element = isNullOrUndefined(element) ? getElement2(targetElement.id.split("_Trackball_")[0]) : element;
        } else if (targetElement.id.indexOf("_Trackball_0") > -1) {
          return null;
        }
        this.performSelection(this.indexFinder(targetElement.id), this.chart, element || targetElement, pointClick2);
      }
    };
    Selection2.prototype.performSelection = function(index, chart, element, pointClick2) {
      this.isSeriesMode = this.currentMode === "Series";
      if (chart.visibleSeries[index.series].type === "BoxAndWhisker" && element && element.id === chart.element.id + "_Series_" + index.series + "_Point_" + index.point + "_BoxPath") {
        element = element.parentNode;
      }
      if (chart.visibleSeries[index.series].type === "Area" && (this.currentMode === "Point" || this.currentMode === "Cluster") && element && element.id === this.chart.element.id + "_Series_" + index.series) {
        var className = this.generateStyle(chart.series[index.series]);
        var selectionEle = document.querySelectorAll("." + className);
        this.findTrackballElements(selectionEle, className);
        this.blurEffect(chart.element.id, chart.visibleSeries, false, index.point);
      }
      switch (this.currentMode) {
        case "Series":
          this.selection(chart, index, this.getSeriesElements(chart.series[index.series]));
          this.selectionComplete(chart, index, this.currentMode);
          this.blurEffect(chart.element.id, chart.visibleSeries, false, index.point);
          break;
        case "Point":
          if (!isNaN(index.point) && element || !pointClick2 && isNaN(index.point)) {
            var pointElements = [];
            pointElements.push(element);
            var series = this.chart.visibleSeries[index.series];
            var baseId = chart.element.id + "_Series_" + index.series + "_Point_" + index.point;
            var textElement3 = document.getElementById(baseId + "_Text_0");
            if (series.marker.dataLabel.visible && textElement3 !== null) {
              pointElements.push(textElement3);
              pointElements.push(document.getElementById(baseId + "_TextShape_0"));
            }
            if (pointElements[0] !== null && chart.series[index.series].marker.visible && (chart.series[index.series].type.indexOf("Column") !== -1 || chart.series[index.series].type.indexOf("Bar") !== -1)) {
              if (!(element.id.indexOf("_Symbol") !== -1) && getElement2(element.id + "_Symbol")) {
                pointElements.push(getElement2(element.id + "_Symbol"));
              } else if (element.id.indexOf("_Symbol") !== -1 && getElement2(element.id.replace("_Symbol", ""))) {
                pointElements.push(getElement2(element.id.replace("_Symbol", "")));
              }
            }
            this.selection(chart, index, !pointClick2 && isNaN(index.point) ? this.getSeriesElements(chart.series[index.series]) : pointElements);
            this.selectionComplete(chart, index, this.currentMode);
            this.blurEffect(chart.element.id, chart.visibleSeries, false, index.point);
          }
          break;
        case "Cluster":
          if (!isNaN(index.point) || !pointClick2 && isNaN(index.point)) {
            if (!pointClick2 && isNaN(index.point)) {
              this.selection(chart, index, this.getSeriesElements(chart.series[index.series]));
            } else {
              this.clusterSelection(chart, index);
            }
            this.selectionComplete(chart, index, this.currentMode);
            this.blurEffect(chart.element.id, chart.visibleSeries, false, index.point);
          }
          break;
      }
    };
    Selection2.prototype.selectionComplete = function(chart, index, selectionMode) {
      var points;
      var pointIndex;
      var seriesIndex;
      var selectedPointValues = [];
      var yValue;
      var selectedPointX;
      if (selectionMode === "Cluster") {
        for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
          var series = _a[_i];
          if (series.visible) {
            for (var i = 0; i < this.selectedDataIndexes.length; i++) {
              pointIndex = chart.isMultiSelect ? this.selectedDataIndexes[i].point : index.point;
              seriesIndex = series.index;
              points = series.points;
              if (!isNaN(pointIndex) && pointIndex < points.length) {
                yValue = series.type !== "RangeArea" || series.type.indexOf("SplineRangeArea") > -1 || series.type.indexOf("RangeStepArea") > -1 ? points[pointIndex].yValue : points[pointIndex].regions[0].y;
                selectedPointX = points[pointIndex].xValue;
                if (chart.primaryXAxis.valueType === "Category") {
                  selectedPointX = points[pointIndex].x.toLocaleString();
                } else if (chart.primaryXAxis.valueType === "DateTime") {
                  selectedPointX = new Date(points[pointIndex].xValue);
                }
                if (series.category !== "Indicator") {
                  selectedPointValues.push({
                    x: selectedPointX,
                    y: yValue,
                    seriesIndex,
                    pointIndex
                  });
                }
                if (series.type === "RangeArea" || series.type === "SplineRangeArea" || series.type === "RangeStepArea") {
                  selectedPointValues.push({
                    x: selectedPointX,
                    y: points[pointIndex].regions[0].y,
                    seriesIndex,
                    pointIndex
                  });
                }
              }
            }
          }
        }
      } else if (selectionMode === "Series") {
        if (chart.isMultiSelect) {
          for (var i = 0; i < this.selectedDataIndexes.length; i++) {
            seriesIndex = this.selectedDataIndexes[i].series;
            if (this.selectedDataIndexes.length > 0) {
              selectedPointValues.push({
                seriesIndex
              });
            }
          }
        } else {
          seriesIndex = this.selectedDataIndexes.length > 0 ? this.selectedDataIndexes[0].series : this.highlightDataIndexes && this.highlightDataIndexes.length > 0 ? this.highlightDataIndexes[0].series : 0;
          if (this.selectedDataIndexes.length > 0 || this.highlightDataIndexes && this.highlightDataIndexes.length > 0) {
            selectedPointValues.push({
              seriesIndex
            });
          }
        }
      } else if (selectionMode === "Point") {
        var selectedData = [];
        if (this.styleId.indexOf("highlight") > -1) {
          selectedData = this.highlightDataIndexes;
        } else {
          selectedData = this.selectedDataIndexes;
        }
        for (var i = 0; i < selectedData.length; i++) {
          pointIndex = selectedData[i].point;
          seriesIndex = selectedData[i].series;
          var series = chart.series[seriesIndex];
          points = series.points;
          if (!isNaN(pointIndex)) {
            selectedPointX = points[pointIndex].xValue;
            yValue = series.type !== "RangeArea" || series.type.indexOf("SplineRangeArea") > -1 || series.type.indexOf("RangeStepArea") > -1 ? points[pointIndex].yValue : points[pointIndex].regions[0].y;
            if (chart.primaryXAxis.valueType === "Category") {
              selectedPointX = points[pointIndex].x.toLocaleString();
            } else if (chart.primaryXAxis.valueType === "DateTime") {
              selectedPointX = new Date(points[pointIndex].xValue);
            }
            selectedPointValues.push({
              x: selectedPointX,
              y: yValue,
              seriesIndex,
              pointIndex
            });
          }
        }
      }
      var args = {
        name: selectionComplete,
        selectedDataValues: selectedPointValues,
        cancel: false,
        chart
      };
      chart.trigger(selectionComplete, args);
    };
    Selection2.prototype.selection = function(chart, index, selectedElements) {
      if (!(this.currentMode === "Lasso")) {
        if (!chart.isMultiSelect && this.currentMode.indexOf("Drag") === -1 && this.styleId.indexOf("highlight") === -1 && chart.selectionMode !== "None") {
          this.removeMultiSelectElements(chart, this.selectedDataIndexes, index, chart.series);
        }
      }
      var indexValue = this.rangeColorMappingEnabled() ? 0 : index.series;
      if (!isNullOrUndefined(selectedElements[0])) {
        if (chart.visibleSeries[indexValue].isRectSeries) {
          if (selectedElements[0].id) {
            if (document.getElementById(selectedElements[0].id + "_Symbol")) {
              selectedElements.push(getElement2(selectedElements[0].id + "_Symbol"));
            } else if (selectedElements[0].id.indexOf("SeriesGroup") !== -1) {
              if (document.getElementById(selectedElements[0].id.replace("SeriesGroup", "SymbolGroup"))) {
                selectedElements.push(getElement2(selectedElements[0].id.replace("SeriesGroup", "SymbolGroup")));
              }
            }
          }
        }
        var isAdd = void 0;
        var className = selectedElements[0] && (selectedElements[0].getAttribute("class") || "");
        className = className.replace("e-chart-focused", "").trim();
        var pClassName = selectedElements[0].parentNode && (selectedElements[0].parentNode.getAttribute("class") || "");
        if (className !== "" && this.currentMode !== "Cluster") {
          this.findTrackballElements(selectedElements, className);
        }
        if (selectedElements[0] && className.indexOf(this.getSelectionClass(selectedElements[0].id)) > -1) {
          this.removeStyles(selectedElements);
        } else if (selectedElements[0].parentNode && pClassName.indexOf(this.getSelectionClass(selectedElements[0].id)) > -1) {
          this.removeStyles([selectedElements[0].parentNode]);
        } else {
          this.previousSelectedEle = chart.highlightMode !== "None" || chart.legendSettings.enableHighlight ? selectedElements : [];
          this.applyStyles(selectedElements);
          isAdd = true;
        }
        if (this.styleId.indexOf("highlight") > 0 && (chart.highlightMode !== "None" || chart.legendSettings.enableHighlight)) {
          this.addOrRemoveIndex(this.highlightDataIndexes, index, isAdd);
        } else {
          this.addOrRemoveIndex(this.selectedDataIndexes, index, isAdd);
        }
      }
    };
    Selection2.prototype.clusterSelection = function(chart, index) {
      this.selection(chart, index, this.getClusterElements(chart, new Index(index.series, index.point)));
    };
    Selection2.prototype.removeMultiSelectElements = function(chart, index, currentIndex, seriesCollection) {
      var series;
      for (var i = 0; i < index.length; i++) {
        series = seriesCollection[index[i].series];
        if (this.isSeriesMode && !this.toEquals(index[i], currentIndex, this.isSeriesMode) || this.currentMode === "Cluster" && !this.toEquals(index[i], currentIndex, false) || !this.isSeriesMode && this.toEquals(index[i], currentIndex, true) && !this.toEquals(index[i], currentIndex, false)) {
          this.removeStyles(this.findElements(chart, series, index[i], "", false));
          if (series.marker.visible) {
            this.removeStyles(this.findElements(chart, series, index[i], "", true));
          }
          if (series.marker.dataLabel.visible) {
            this.removeStyles(this.findElements(chart, series, index[i], "", false, true));
          }
          index.splice(i, 1);
          i--;
        }
      }
    };
    Selection2.prototype.blurEffect = function(chartId, visibleSeries, isLegend, index) {
      if (isLegend === void 0) {
        isLegend = false;
      }
      if (index === void 0) {
        index = 0;
      }
      var visibility = this.checkVisibility(this.highlightDataIndexes, this.chart) || this.checkVisibility(this.selectedDataIndexes, this.chart);
      for (var _i = 0, visibleSeries_1 = visibleSeries; _i < visibleSeries_1.length; _i++) {
        var series = visibleSeries_1[_i];
        var legendIndex = void 0;
        var legendStrokeColor = void 0;
        if (this.rangeColorMappingEnabled()) {
          if (isLegend === false) {
            legendIndex = Object.keys(series.rangeColorPoints).indexOf(series.points[index].interior);
            legendStrokeColor = series.points[index].interior;
          } else {
            legendIndex = index;
            legendStrokeColor = document.getElementById(chartId + "_chart_legend_shape_" + index).getAttribute("fill");
          }
        } else {
          legendIndex = series.index;
          legendStrokeColor = this.chart.visibleSeries[series.index].interior;
        }
        if (series.visible) {
          this.checkSelectionElements(getElement2(chartId + "SeriesGroup" + series.index), this.generateStyle(series), visibility, isLegend, legendIndex, legendStrokeColor);
          if (series.marker.dataLabel.visible && !isNullOrUndefined(series.shapeElement)) {
            this.checkSelectionElements(series.shapeElement, this.generateStyle(series), visibility, isLegend, legendIndex, legendStrokeColor);
            this.checkSelectionElements(series.textElement, this.generateStyle(series), visibility, isLegend, legendIndex, legendStrokeColor);
          }
          if (!isNullOrUndefined(getElement2(chartId + "SymbolGroup" + series.index))) {
            this.checkSelectionElements(getElement2(chartId + "SymbolGroup" + series.index), this.generateStyle(series), visibility, isLegend, legendIndex, legendStrokeColor);
          }
        }
      }
    };
    Selection2.prototype.checkSelectionElements = function(element, className, visibility, isLegend, series, legendStrokeColor) {
      if (isLegend === void 0) {
        isLegend = true;
      }
      if (series === void 0) {
        series = 0;
      }
      if (legendStrokeColor === void 0) {
        legendStrokeColor = "#D3D3D3";
      }
      var children = this.isSeriesMode ? element.childNodes || [element] : element.childNodes || element;
      if (this.chart.selectionMode !== "None" && (this.chart.highlightMode !== "None" || this.chart.legendSettings.enableHighlight)) {
        children = element.childNodes || element;
      }
      if (this.chart.selectionMode === "Cluster" && element.tagName.toLowerCase() === "text" && element.id.indexOf("_Text_") >= 0) {
        children = [element];
      }
      var elementClassName;
      var parentClassName;
      var legendShape;
      var selectElement = element;
      var isDataLabelTextElement = this.chart.visibleSeries[this.rangeColorMappingEnabled() ? 0 : series].marker.dataLabel.visible && (element.id.indexOf("Text") > -1 || element.id.indexOf("TextShape") > -1) && element.tagName !== "g";
      for (var i = 0; i < children.length && !isDataLabelTextElement; i++) {
        elementClassName = children[i].getAttribute("class") || "";
        parentClassName = children[i].parentNode.getAttribute("class") || "";
        if (this.chart.selectionMode !== "None" && (this.chart.highlightMode !== "None" || this.chart.legendSettings.enableHighlight)) {
          className = elementClassName.indexOf("selection") > 0 || elementClassName.indexOf("highlight") > 0 ? elementClassName : className;
          className = parentClassName.indexOf("selection") > 0 || parentClassName.indexOf("highlight") > 0 ? parentClassName : className;
        }
        if (elementClassName.indexOf(className) === -1 && parentClassName.indexOf(className) === -1 && visibility) {
          this.addSvgClass(children[i], this.unselected);
        } else {
          selectElement = children[i];
          this.removeSvgClass(children[i], this.unselected);
          this.removeSvgClass(children[i].parentNode, this.unselected);
          if (children[i].id !== "" && elementClassName.indexOf(this.unselected) !== -1 && parentClassName.indexOf(className) === -1) {
            this.highlightAnimation(children[i], this.chart.series.length === 1 ? 0 : this.indexFinder(children[i].id).series, 700, 0.3);
          }
        }
        if (children[i].id.indexOf("Trackball") > 0 && selectElement.classList[0] === className) {
          this.removeSvgClass(children[i], this.unselected);
          this.removeSvgClass(children[i].parentNode, this.unselected);
          this.addSvgClass(children[i], className);
        }
      }
      if (element.id.indexOf("Symbol") > -1) {
        if (element.querySelectorAll("." + className)[0] && element.querySelectorAll("." + className)[0].getAttribute("class") === className) {
          var symbolEle = getElement2(this.control.element.id + "_Series_" + element.id[element.id.length - 1]);
          var seriesClassName = symbolEle && symbolEle.hasAttribute("class") ? symbolEle.getAttribute("class") : "";
          if (seriesClassName.indexOf(this.unselected) > -1) {
            this.removeSvgClass(symbolEle, this.unselected);
          }
        }
      }
      if (this.control.legendModule && this.control.legendSettings.visible && this.control.legendSettings.visible && !(isLegend && this.rangeColorMappingEnabled && (element === this.control.visibleSeries[0].textElement || element === this.control.visibleSeries[0].shapeElement))) {
        legendShape = getElement2(this.control.element.id + "_chart_legend_shape_" + series);
        if (legendShape) {
          if (legendShape.hasAttribute("class")) {
            this.removeSvgClass(legendShape, legendShape.getAttribute("class"));
            if (!isNullOrUndefined(this.chart.highlightColor && this.chart.highlightColor !== "") && !this.chart.legendSettings.enableHighlight) {
              legendShape.setAttribute("stroke", legendStrokeColor);
              if (this.chart.highlightPattern === "None") {
                legendShape.setAttribute("fill", legendStrokeColor);
              }
            }
          }
          elementClassName = selectElement.getAttribute("class") || "";
          parentClassName = selectElement.parentNode.getAttribute("class") || "";
          if (elementClassName.indexOf(className) === -1 && parentClassName.indexOf(className) === -1 && visibility) {
            this.addSvgClass(legendShape, this.chart.highlightMode === "None" && this.chart.legendSettings.enableHighlight && (!this.chart.selectionModule || this.chart.selectionModule.selectedDataIndexes.length === 0) ? className : this.unselected);
            this.removeSvgClass(legendShape, className);
            if (this.chart.highlightColor !== "" && !isNullOrUndefined(this.chart.highlightColor)) {
              legendShape.setAttribute("stroke", this.control.visibleSeries[series].interior);
              if (this.chart.highlightPattern === "None") {
                legendShape.setAttribute("fill", this.control.visibleSeries[series].interior);
              }
            }
          } else {
            this.removeSvgClass(legendShape, this.unselected);
            if (!isNullOrUndefined(this.chart.highlightColor) && this.chart.highlightColor !== "") {
              legendShape.setAttribute("stroke", this.control.visibleSeries[series].interior);
              if (this.chart.highlightPattern === "None") {
                legendShape.setAttribute("fill", this.control.visibleSeries[series].interior);
              }
            }
            if (elementClassName === "" && parentClassName === "" || elementClassName.trim() === "EJ2-Trackball") {
              this.removeSvgClass(legendShape, className);
            } else {
              this.addSvgClass(legendShape, className);
              if (className.indexOf("highlight") > 0 && this.chart.highlightColor !== "" && this.chart.highlightColor !== "transparent" && !isNullOrUndefined(this.chart.highlightColor)) {
                legendShape.setAttribute("stroke", this.chart.highlightColor);
                if (this.styleId.indexOf("highlight") > 0 && this.chart.highlightPattern === "None") {
                  legendShape.setAttribute("fill", this.chart.highlightColor);
                }
              }
            }
          }
          var legendItemsId = void 0;
          if (this.rangeColorMappingEnabled()) {
            for (var i = 0; i < this.chart.rangeColorSettings.length; i++) {
              legendItemsId = document.getElementById(this.chart.element.id + "_chart_legend_shape_" + i);
              if (legendShape !== legendItemsId) {
                this.addSvgClass(legendItemsId, this.unselected);
                this.removeSvgClass(legendItemsId, className);
              } else if (isLegend === true) {
                this.addSvgClass(legendItemsId, className);
              }
              if (elementClassName.indexOf(className) === -1 && isLegend === false) {
                this.removeSvgClass(legendItemsId, this.unselected);
              }
            }
          }
          if (isLegend && parentClassName.indexOf(className) > -1) {
            this.addSvgClass(legendShape, className);
          }
        }
      }
    };
    Selection2.prototype.applyStyles = function(elements) {
      for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
        var element = elements_1[_i];
        if (element) {
          this.removeSvgClass(element.parentNode, this.unselected);
          this.removeSvgClass(element, this.unselected);
          if (this.chart.series[0].pointColorMapping === "fill" || this.rangeColorMappingEnabled()) {
            var className = this.getSelectionClass(element.id);
            var index = className.indexOf("highlight") > -1 ? parseInt(className.split(this.chart.element.id + "_ej2_chart_highlight_series_")[1], 10) : parseInt(className.split(this.chart.element.id + "_ej2_chart_selection_series_")[1], 10);
            var patternName = this.styleId.indexOf("highlight") > 0 ? this.chart.highlightPattern : this.chart.selectionPattern;
            var pattern = void 0;
            if (className.indexOf("highlight") > -1 || className.indexOf("selection") > -1) {
              pattern = document.getElementById(this.chart.element.id + "_" + patternName + "_Selection_" + index);
            }
            if (element.id.indexOf("legend") === -1 && element.id.indexOf("Text") === -1 && element.id.indexOf("TextShape") === -1 && element.id.indexOf("Group") === -1 && pattern != null) {
              for (var i = 1; i < pattern.children.length; i++) {
                pattern.children[i].setAttribute("fill", element.getAttribute("fill"));
                pattern.children[i].setAttribute("stroke", element.getAttribute("fill"));
              }
            }
          }
          this.addSvgClass(element, this.getSelectionClass(element.id));
          if (element.id.indexOf("Group") > 0) {
            var seriesIndex = this.indexFinder(element.id);
            for (var i = 0; i < element.children.length; i++) {
              if (element.children[i].nodeName !== "defs") {
                this.stopElementAnimation(element.children[i], seriesIndex.series);
              }
            }
          }
          if (this.styleId.indexOf("highlight") > 0 && this.chart.highlightColor !== "" && !isNullOrUndefined(this.chart.highlightColor) && this.chart.highlightPattern === "None" && this.chart.highlightColor !== "transparent") {
            if (element.id.indexOf("Group") > 0) {
              for (var i = 0; i < element.children.length; i++) {
                element.children[i].setAttribute("fill", element.id.indexOf("Text") > -1 || element.id.indexOf("TextShape") > -1 ? element.children[i].getAttribute("fill") : this.chart.highlightColor);
              }
            } else {
              element.setAttribute("fill", element.id.indexOf("Text") > -1 || element.id.indexOf("TextShape") > -1 ? element.getAttribute("fill") : this.chart.highlightColor);
            }
          }
        }
      }
    };
    Selection2.prototype.getSelectionClass = function(id) {
      return this.generateStyle(this.control.visibleSeries[this.indexFinder(id).series]);
    };
    Selection2.prototype.removeStyles = function(elements) {
      for (var _i = 0, elements_2 = elements; _i < elements_2.length; _i++) {
        var element = elements_2[_i];
        if (element) {
          this.removeSvgClass(element, this.getSelectionClass(element.id));
          if (this.chart.highlightPattern === "None" && this.chart.highlightColor !== "" && !isNullOrUndefined(this.chart.highlightColor) && this.chart.highlightColor !== "transparent") {
            if (element.id.indexOf("Group") > 0) {
              for (var i = 0; i < element.children.length; i++) {
                element.children[i].setAttribute("fill", element.id.indexOf("Text") > -1 || element.id.indexOf("TextShape") > -1 ? element.children[i].getAttribute("fill") : this.control.visibleSeries[this.indexFinder(element.id).series].interior);
              }
            } else {
              element.setAttribute("fill", element.id.indexOf("Text") > -1 || element.id.indexOf("TextShape") > -1 ? element.getAttribute("fill") : this.control.visibleSeries[this.indexFinder(element.id).series].interior);
            }
          }
        }
      }
    };
    Selection2.prototype.addOrRemoveIndex = function(indexes, index, isAdd) {
      for (var i = 0; i < indexes.length; i++) {
        if (this.toEquals(indexes[i], index, this.isSeriesMode)) {
          indexes.splice(i, 1);
          i--;
        }
      }
      if (isAdd) {
        indexes.push(index);
      }
    };
    Selection2.prototype.toEquals = function(first, second, checkSeriesOnly) {
      return (first.series === second.series || this.currentMode === "Cluster" && !checkSeriesOnly) && (checkSeriesOnly || first.point === second.point);
    };
    Selection2.prototype.redrawSelection = function(chart, oldMode, chartRedraw) {
      this.isSeriesMode = oldMode === "Series";
      if (!isNullOrUndefined(oldMode)) {
        if (oldMode.indexOf("Drag") !== -1 || oldMode === "Lasso" || chartRedraw) {
          chart.isRedrawSelection = false;
        } else {
          chart.isRedrawSelection = true;
        }
      }
      var selectedDataIndexes = extend([], this.selectedDataIndexes, null, true);
      var highlightDataIndexes = extend([], this.highlightDataIndexes, null, true);
      if (this.styleId.indexOf("highlight") > 0 && highlightDataIndexes.length > 0) {
        this.removeSelectedElements(chart, this.highlightDataIndexes, chart.series);
        selectedDataIndexes = highlightDataIndexes;
      } else {
        this.removeSelectedElements(chart, this.selectedDataIndexes, chart.series);
      }
      this.blurEffect(chart.element.id, chart.visibleSeries, false);
      this.selectDataIndex(chart, selectedDataIndexes);
    };
    Selection2.prototype.legendSelection = function(chart, series, targetElement, eventType) {
      if (eventType === "mousemove") {
        if (targetElement.id.indexOf("text") > 1) {
          targetElement = getElement2(targetElement.id.replace("text", "shape"));
        }
        if (targetElement.id.indexOf("marker") > 1) {
          targetElement = getElement2(targetElement.id.replace("_marker", ""));
        }
        if (targetElement.id.indexOf("g") > 1) {
          targetElement = getElement2(targetElement.id.replace("_g_", "_shape_"));
        }
        if (targetElement.hasAttribute("class") && (targetElement.getAttribute("class").indexOf("highlight") > -1 || targetElement.getAttribute("class").indexOf("selection") > -1)) {
          return;
        }
        this.currentMode = this.chart.highlightMode;
      }
      var isPreSelected = this.isAlreadySelected(targetElement, eventType);
      if (isPreSelected) {
        var seriesStyle = this.generateStyle(chart.visibleSeries[series]);
        var selectedElements = document.querySelectorAll("." + seriesStyle);
        this.isSeriesMode = this.currentMode === "Series";
        var isBlurEffectNeeded = true;
        if (selectedElements.length > 0) {
          this.removeSelection(chart, series, selectedElements, seriesStyle, isBlurEffectNeeded);
        } else {
          for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
            var element = _a[_i];
            if (element.index !== series && !chart.isMultiSelect) {
              seriesStyle = this.generateStyle(chart.visibleSeries[element.index]);
              selectedElements = document.querySelectorAll("." + seriesStyle);
              this.removeSelection(chart, series, selectedElements, seriesStyle, isBlurEffectNeeded);
            }
          }
          var seriesElements = [];
          if (this.rangeColorMappingEnabled()) {
            for (var i = 0, a = chart.visibleSeries[0].seriesElement.children; i < a.length; i++) {
              var point = a[i];
              if (targetElement.getAttribute("fill") === point.getAttribute("fill")) {
                if (chart.visibleSeries[0].marker.dataLabel.visible) {
                  var pointIndex = this.indexFinder(point.id).point;
                  if (!isNaN(pointIndex) && pointIndex >= 0) {
                    var dataLabel = document.getElementById(this.chart.element.id + "_Series_0_Point_" + pointIndex + "_Text_0");
                    var dataLabelBorder = document.getElementById(this.chart.element.id + "_Series_0_Point_" + pointIndex + "_TextShape_0");
                    if (dataLabel) {
                      seriesElements.push(dataLabel);
                    }
                    if (dataLabelBorder) {
                      seriesElements.push(dataLabelBorder);
                    }
                  }
                }
                seriesElements.push(point);
              }
            }
            for (var _b = 0, seriesElements_1 = seriesElements; _b < seriesElements_1.length; _b++) {
              var element = seriesElements_1[_b];
              if (isNullOrUndefined(element)) {
                return;
              }
              this.checkSelectionElements(element, seriesStyle, false, true, series);
            }
          } else {
            if (chart.visibleSeries[series].visible) {
              seriesElements = this.getSeriesElements(chart.visibleSeries[series]);
              for (var _c = 0, seriesElements_2 = seriesElements; _c < seriesElements_2.length; _c++) {
                var seriesElement = seriesElements_2[_c];
                if (isNullOrUndefined(seriesElement)) {
                  return;
                }
                this.checkSelectionElements(seriesElement, seriesStyle, false, true, series);
              }
            }
          }
          this.isSeriesMode = true;
          this.selection(chart, new Index(series, NaN), seriesElements);
          this.isSeriesMode = chart.selectionMode === "Series";
          this.blurEffect(chart.element.id, chart.visibleSeries, true, series);
        }
      }
    };
    Selection2.prototype.rangeColorMappingEnabled = function() {
      if (this.chart.rangeColorSettings && this.chart.rangeColorSettings.length > 0 && this.chart.visibleSeries.length === 1 && this.chart.rangeColorSettings[0].colors.length > 0 && (this.chart.series[0].type === "Column" || this.chart.series[0].type === "Bar" || this.chart.series[0].type === "Scatter" || this.chart.series[0].type === "Bubble")) {
        return true;
      } else {
        return false;
      }
    };
    Selection2.prototype.removeSelection = function(chart, series, selectedElements, seriesStyle, isBlurEffectNeeded) {
      if (selectedElements.length > 0) {
        var elements = [];
        for (var i = 0; i < selectedElements.length; i++) {
          elements.push(selectedElements[i]);
        }
        this.removeStyles(elements);
        this.isSeriesMode = true;
        this.addOrRemoveIndex(this.selectedDataIndexes, new Index(series, NaN));
        for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
          var value = _a[_i];
          seriesStyle = this.generateStyle(value);
          if (document.querySelectorAll("." + seriesStyle).length > 0) {
            for (var _b = 0, elements_3 = elements; _b < elements_3.length; _b++) {
              var element = elements_3[_b];
              this.checkSelectionElements(element, seriesStyle, true, true, series);
            }
            isBlurEffectNeeded = false;
            break;
          }
        }
        if (isBlurEffectNeeded) {
          this.isSeriesMode = chart.selectionMode === "Series";
          this.blurEffect(chart.element.id, chart.visibleSeries);
        }
      }
    };
    Selection2.prototype.getSeriesElements = function(series) {
      var seriesElements = [series.seriesElement];
      if (series.marker.visible && series.type !== "Scatter" && series.type !== "Bubble" && !series.isRectSeries) {
        seriesElements.push(series.symbolElement);
      } else if (series.marker.visible && series.isRectSeries) {
        seriesElements.push(series.symbolElement);
      }
      if (series.marker.dataLabel.visible) {
        seriesElements.push(series.textElement);
        seriesElements.push(series.shapeElement);
      }
      return seriesElements;
    };
    Selection2.prototype.indexFinder = function(id) {
      var ids = ["NaN", "NaN"];
      if (id.indexOf("SeriesGroup") > -1) {
        ids = id.split("SeriesGroup");
        ids[0] = ids[1];
      } else if (id.indexOf("SymbolGroup") > -1) {
        ids = id.split("SymbolGroup");
        ids[0] = ids[1];
      } else if (id.indexOf("_Point_") > -1) {
        ids = id.split("_Series_")[1].split("_Point_");
      } else if (id.indexOf("_border_") > -1) {
        ids[0] = id.split("_border_")[1];
      } else if (id.indexOf("_Series_") > -1) {
        ids[0] = id.split("_Series_")[1];
      } else if (id.indexOf("_chart_legend_shape_") > -1) {
        ids = id.split("_chart_legend_shape_");
        ids[0] = ids[1];
      } else if (id.indexOf("TextGroup") > -1) {
        ids = id.split("TextGroup");
        ids[0] = ids[1];
      } else if (id.indexOf("ShapeGroup") > -1) {
        ids = id.split("ShapeGroup");
        ids[0] = ids[1];
      }
      return new Index(parseInt(ids[0], 10), parseInt(ids[1], 10));
    };
    Selection2.prototype.calculateDragSelectedElements = function(chart, dragRect, isClose) {
      this.removeSelectedElements(chart, this.selectedDataIndexes, chart.series);
      var isLasso = chart.selectionMode === "Lasso";
      var rect = new Rect(dragRect.x, dragRect.y, dragRect.width, dragRect.height);
      var axisOffset = new ChartLocation(chart.chartAxisLayoutPanel.seriesClipRect.x, chart.chartAxisLayoutPanel.seriesClipRect.y);
      this.removeOffset(rect, axisOffset);
      var points;
      var index;
      var selectedPointValues = [];
      var selectedSeriesValues = [];
      this.isSeriesMode = false;
      var isDragResize = chart.allowMultiSelection && (this.rectGrabbing || this.resizing);
      this.rectPoints = this.dragRectArray[isDragResize ? this.targetIndex : this.count] = new Rect(dragRect.x, dragRect.y, dragRect.width, dragRect.height);
      if (dragRect.width && dragRect.height && !isClose) {
        var rt = new Rect(dragRect.x, dragRect.y, dragRect.width, dragRect.height);
        this.removeOffset(rt, axisOffset);
        this.filterArray[isDragResize ? this.targetIndex : this.count] = rt;
      }
      var _loop_1 = function(series2) {
        if (series2.visible) {
          points = series2.points;
          selectedPointValues = [];
          var xAxisOffset_1;
          var yAxisOffset_1;
          if ((chart.isTransposed || series2.type.indexOf("Bar") !== -1) && !(chart.isTransposed && series2.type.indexOf("Bar") !== -1)) {
            xAxisOffset_1 = series2.xAxis.rect.y - axisOffset.y;
            yAxisOffset_1 = series2.yAxis.rect.x - axisOffset.x;
          } else {
            xAxisOffset_1 = series2.xAxis.rect.x - axisOffset.x;
            yAxisOffset_1 = series2.yAxis.rect.y - axisOffset.y;
          }
          for (var j = 0; j < points.length; j++) {
            var yValue = series2.type !== "RangeArea" || series2.type.indexOf("SplineRangeArea") > -1 || series2.type.indexOf("RangeStepArea") > -1 ? points[j].yValue : points[j].regions[0].y;
            var isCurrentPoint = void 0;
            var selectedPointX = points[j].xValue;
            if (chart.primaryXAxis.valueType === "Category") {
              selectedPointX = points[j].x.toLocaleString();
            } else if (chart.primaryXAxis.valueType === "DateTime") {
              selectedPointX = new Date(points[j].xValue);
            }
            if (series2.type === "BoxAndWhisker") {
              isCurrentPoint = points[j].regions.some(function(region) {
                return withInBounds(region.x + xAxisOffset_1, region.y + yAxisOffset_1, rect);
              });
            } else {
              if (chart.selectionMode === "Lasso") {
                isCurrentPoint = points[j].isSelect;
              } else {
                isCurrentPoint = chart.allowMultiSelection ? this_1.isPointSelect(points[j], xAxisOffset_1, yAxisOffset_1, this_1.filterArray) : points[j].symbolLocations.some(function(location) {
                  return location && withInBounds(location.x + xAxisOffset_1, location.y + yAxisOffset_1, rect);
                });
              }
            }
            if (isCurrentPoint && series2.category !== "Indicator") {
              index = new Index(series2.index, points[j].index);
              this_1.selection(chart, index, this_1.findElements(chart, series2, index, "", !series2.isRectSeries ? series2.marker.visible : false));
              selectedPointValues.push({
                x: selectedPointX,
                y: yValue
              });
            }
            if (isCurrentPoint && (series2.type === "RangeArea" || series2.type === "SplineRangeArea" || series2.type === "RangeStepArea")) {
              selectedPointValues.push({
                x: selectedPointX,
                y: points[j].regions[0].y
              });
            }
          }
          selectedSeriesValues.push(selectedPointValues);
        }
      };
      var this_1 = this;
      for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
        var series = _a[_i];
        _loop_1(series);
      }
      this.blurEffect(chart.element.id, chart.visibleSeries);
      var x = isLasso ? chart.mouseDownX : dragRect.x + dragRect.width;
      var y = isLasso ? chart.mouseDownY : dragRect.y;
      if (!isClose) {
        this.createCloseButton(x, y);
      }
      var args = {
        name: dragComplete,
        selectedDataValues: selectedSeriesValues,
        cancel: false
      };
      chart.trigger(dragComplete, args);
    };
    Selection2.prototype.removeOffset = function(rect, clip) {
      rect.x -= clip.x;
      rect.y -= clip.y;
    };
    Selection2.prototype.isPointSelect = function(points, xAxisOffset, yAxisOffset, rectCollection) {
      var location = points.symbolLocations[0];
      for (var _i = 0, rectCollection_1 = rectCollection; _i < rectCollection_1.length; _i++) {
        var rect = rectCollection_1[_i];
        if (rect && location && withInBounds(location.x + xAxisOffset, location.y + yAxisOffset, rect)) {
          return true;
        }
      }
      return false;
    };
    Selection2.prototype.drawDraggingRect = function(chart, dragRect) {
      var cartesianLayout = chart.chartAxisLayoutPanel.seriesClipRect;
      var border = chart.chartArea.border.width;
      var rectFill = chart.themeStyle.selectionRectFill;
      var rectStroke = chart.themeStyle.selectionRectStroke;
      var isLasso = chart.selectionMode === "Lasso";
      if (this.isdrawRect) {
        cartesianLayout.x = cartesianLayout.x - border / 2;
        cartesianLayout.y = cartesianLayout.y - border / 2;
        cartesianLayout.width = cartesianLayout.width + border;
        cartesianLayout.height = cartesianLayout.height + border;
        this.isdrawRect = false;
      }
      switch (chart.selectionMode) {
        case "DragX":
          dragRect.y = cartesianLayout.y;
          dragRect.height = cartesianLayout.height;
          break;
        case "DragY":
          dragRect.x = cartesianLayout.x;
          dragRect.width = cartesianLayout.width;
          break;
      }
      if ((dragRect.width < 5 || dragRect.height < 5) && !isLasso) {
        return null;
      }
      var isDragMode = chart.selectionMode.indexOf("Drag") > -1 || chart.selectionMode === "Lasso";
      if (chart.allowMultiSelection && isDragMode) {
        var element = void 0;
        var dragGroup = void 0;
        var multiGroup = getElement2(this.multiRectGroup);
        if (!multiGroup) {
          multiGroup = chart.svgRenderer.createGroup({
            id: this.multiRectGroup
          });
          chart.svgObject.appendChild(multiGroup);
        }
        if (this.rectGrabbing || this.resizing) {
          var rectElement = getElement2(this.draggedRect + this.targetIndex);
          if (rectElement.nextSibling) {
            remove(rectElement.nextSibling);
          }
          this.setAttributes(rectElement, dragRect);
        } else if (!getElement2(this.draggedRectGroup + this.count)) {
          dragGroup = chart.svgRenderer.createGroup({
            id: this.draggedRectGroup + this.count
          });
          var svgElement = document.getElementById(chart.element.id + "_series_svg");
          if (chart.enableCanvas) {
            svgElement.appendChild(dragGroup);
          } else {
            multiGroup.appendChild(dragGroup);
          }
        }
        if (!(chart.selectionMode === "Lasso")) {
          element = chart.svgRenderer.drawRectangle(new RectOption(this.draggedRect + this.count, rectFill, {
            color: rectStroke,
            width: 1
          }, 1, dragRect, 0, 0, "", chart.theme.indexOf("Fluent2") < 1 ? "3" : ""));
          element.style.cursor = "move";
        } else {
          element = chart.svgRenderer.drawPath(new PathOption(this.lassoPath + this.count, rectFill, 3, rectStroke, 1, "", this.path));
        }
        if (!dragGroup && !this.rectGrabbing && !this.resizing) {
          getElement2(this.draggedRectGroup + this.count).appendChild(element);
        } else if (!this.rectGrabbing && !this.resizing) {
          dragGroup.appendChild(element);
        }
      } else {
        var element = isLasso ? getElement2(this.lassoPath) : getElement2(this.draggedRect);
        if (this.closeIcon) {
          removeElement2(this.closeIconId);
        }
        if (element) {
          if (isLasso) {
            element.setAttribute("d", this.path);
          } else {
            this.setAttributes(element, dragRect);
          }
        } else {
          var dragGroup = chart.svgRenderer.createGroup({
            id: this.draggedRectGroup
          });
          var svgElement = document.getElementById(chart.element.id + "_series_svg");
          if (chart.enableCanvas) {
            svgElement.appendChild(dragGroup);
          } else {
            chart.svgObject.appendChild(dragGroup);
          }
          if (!(chart.selectionMode === "Lasso")) {
            element = chart.svgRenderer.drawRectangle(new RectOption(this.draggedRect, rectFill, {
              color: rectStroke,
              width: 1
            }, 1, dragRect, 0, 0, "", chart.theme.indexOf("Fluent2") < 1 ? "3" : ""));
          } else {
            element = chart.svgRenderer.drawPath(new PathOption(this.lassoPath, rectFill, 3, rectStroke, 1, "", this.path));
          }
          dragGroup.appendChild(element);
        }
      }
    };
    Selection2.prototype.getIndex = function(id) {
      var i;
      for (i = id.length - 1; i > 0; i--) {
        var x = Number(id[i]);
        if (!isNaN(x)) {
          continue;
        } else {
          break;
        }
      }
      var index = +id.substr(i + 1, id.length - 1);
      return index;
    };
    Selection2.prototype.createCloseButton = function(x, y) {
      var isMultiDrag = this.chart.allowMultiSelection;
      var circleStroke = this.chart.themeStyle.selectionCircleStroke;
      var isDrag = this.rectGrabbing || this.resizing;
      var closeIcon = this.chart.svgRenderer.createGroup({
        id: this.closeIconId + (isMultiDrag ? isDrag ? this.targetIndex : this.count : ""),
        style: "cursor:pointer; visibility: visible;"
      });
      closeIcon.appendChild(this.chart.svgRenderer.drawCircle(new CircleOption(this.closeIconId + "_circle" + (isMultiDrag ? isDrag ? this.targetIndex : this.count : ""), "#FFFFFF", {
        color: circleStroke,
        width: 1
      }, 1, x, y, 10)));
      var direction = "M " + (x - 4) + " " + (y - 4) + " L " + (x + 4) + " " + (y + 4) + " M " + (x - 4) + " " + (y + 4) + " L " + (x + 4) + " " + (y - 4);
      closeIcon.appendChild(this.chart.svgRenderer.drawPath({
        id: this.closeIconId + "_cross" + (isMultiDrag ? isDrag ? this.targetIndex : this.count : ""),
        d: direction,
        stroke: circleStroke,
        "stroke-width": 2,
        fill: circleStroke
      }));
      this.closeIcon = closeIcon;
      var pathElement = getElement2(this.draggedRectGroup + (isMultiDrag ? isDrag ? this.targetIndex : this.count : ""));
      if (pathElement) {
        pathElement.appendChild(closeIcon);
      }
    };
    Selection2.prototype.removeDraggedElements = function(chart, targetElement, eventType) {
      if (targetElement.id && targetElement.id.indexOf(this.closeIconId) > -1 && eventType.indexOf("move") === -1) {
        var isSelectedvalues = true;
        if (chart.allowMultiSelection) {
          var index = this.getIndex(targetElement.id);
          var multiRectGroupElement = getElement2(this.multiRectGroup);
          remove(getElement2(this.draggedRectGroup + index));
          this.dragRectArray[index] = null;
          this.filterArray[index] = null;
          this.totalSelectedPoints[index] = null;
          if (multiRectGroupElement && multiRectGroupElement.childElementCount === 0) {
            removeElement2(multiRectGroupElement);
            this.dragRectArray = [];
            this.filterArray = [];
            this.totalSelectedPoints = [];
          }
          if (this.currentMode === "Lasso") {
            if (this.multiDataIndexes[index] != null) {
              for (var i = 0; i < this.multiDataIndexes[index].length; i++) {
                this.multiDataIndexes[index][i].isSelect = false;
              }
            }
            this.multiDataIndexes[index] = null;
            for (var j = 0; j < this.multiDataIndexes.length; j++) {
              if (this.multiDataIndexes[j] != null) {
                isSelectedvalues = false;
                for (var k = 0; k < this.multiDataIndexes[j].length; k++) {
                  this.multiDataIndexes[j][k].isSelect = true;
                }
              }
            }
            this.calculateDragSelectedElements(chart, this.dragRect, true);
          } else if (this.filterArray.length) {
            for (var i = 0; i < this.filterArray.length; i++) {
              if (this.filterArray[i]) {
                isSelectedvalues = false;
                this.calculateDragSelectedElements(chart, this.filterArray[i], true);
              }
            }
          } else {
            this.calculateDragSelectedElements(chart, new Rect(0, 0, 0, 0), true);
          }
        } else {
          remove(getElement2(this.draggedRectGroup));
          this.removeSelectedElements(chart, this.selectedDataIndexes, chart.series);
        }
        this.blurEffect(chart.element.id, chart.visibleSeries);
        this.changeCursorStyle(false, chart.svgObject, "auto");
        if (!chart.allowMultiSelection || isSelectedvalues) {
          this.rectPoints = null;
        }
      }
    };
    Selection2.prototype.resizingSelectionRect = function(chart, location, tapped, target) {
      var rect;
      if (chart.allowMultiSelection && target.id.indexOf("_ej2_drag_rect") > -1 || this.dragRectArray[this.targetIndex]) {
        if (target.id.indexOf("_ej2_drag_rect") > -1) {
          this.targetIndex = this.getIndex(target.id);
        }
        var r = this.dragRectArray[this.targetIndex];
        rect = new Rect(r.x, r.y, r.width, r.height);
      }
      if (!chart.allowMultiSelection) {
        rect = new Rect(this.rectPoints.x, this.rectPoints.y, this.rectPoints.width, this.rectPoints.height);
      }
      if (rect) {
        var resize = this.findResizeMode(chart.svgObject, rect, location);
        if (this.resizing) {
          rect = getDraggedRectLocation(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, chart.chartAxisLayoutPanel.seriesClipRect);
          this.drawDraggingRect(chart, rect);
          this.dragRect = rect;
        }
        if (tapped) {
          this.resizing = resize;
        }
      } else {
        return;
      }
    };
    Selection2.prototype.findResizeMode = function(chartSvgObject, rect, location) {
      var cursorStyle = "se-resize";
      var resize = false;
      if (!this.resizing) {
        var resizeEdges = [new Rect(rect.x, rect.y, rect.width - 5, 5), new Rect(rect.x, rect.y, 5, rect.height), new Rect(rect.x, rect.y + rect.height - 5, rect.width - 5, 5), new Rect(rect.x + rect.width - 5, rect.y + 5, 5, rect.height - 15), new Rect(rect.x + rect.width - 10, rect.y + rect.height - 10, 10, 10)];
        for (var i = 0; i < resizeEdges.length; i++) {
          if (withInBounds(location.x, location.y, resizeEdges[i])) {
            cursorStyle = i === 4 ? cursorStyle : i % 2 === 0 ? "ns-resize" : "ew-resize";
            resize = true;
            this.resizeMode = i;
            break;
          }
        }
      } else {
        var x = rect.x;
        var y = rect.y;
        var width = location.x - x;
        var height = location.y - y;
        switch (this.resizeMode) {
          case 0:
            height = Math.abs(rect.height + rect.y - location.y);
            rect.y = Math.min(rect.height + rect.y, location.y);
            rect.height = height;
            break;
          case 1:
            width = Math.abs(rect.width + rect.x - location.x);
            rect.x = Math.min(rect.width + rect.x, location.x);
            rect.width = width;
            break;
          case 2:
            rect.height = Math.abs(height);
            rect.y = Math.min(location.y, y);
            break;
          case 3:
            rect.width = Math.abs(width);
            rect.x = Math.min(location.x, x);
            break;
          case 4:
            rect.width = Math.abs(width);
            rect.height = Math.abs(height);
            rect.x = Math.min(location.x, x);
            rect.y = Math.min(location.y, y);
            break;
        }
      }
      if (this.currentMode !== "Lasso") {
        this.changeCursorStyle(resize, getElement2(this.chart.allowMultiSelection ? this.draggedRect + this.targetIndex : this.draggedRect), cursorStyle);
      }
      this.changeCursorStyle(resize, chartSvgObject, cursorStyle);
      return resize;
    };
    Selection2.prototype.changeCursorStyle = function(isResize, rectelement, cursorStyle) {
      cursorStyle = isResize ? cursorStyle : this.control.svgObject === rectelement ? "auto" : "move";
      if (rectelement) {
        rectelement.style.cursor = cursorStyle;
      }
    };
    Selection2.prototype.removeSelectedElements = function(chart, index, seriesCollection) {
      index = chart.isRedrawSelection ? index : index.splice(0, index.length);
      var seriesElements;
      for (var _i = 0, seriesCollection_1 = seriesCollection; _i < seriesCollection_1.length; _i++) {
        var series = seriesCollection_1[_i];
        if (series.visible) {
          seriesElements = this.getSeriesElements(series);
          this.removeStyles(seriesElements);
          for (var _a = 0, seriesElements_3 = seriesElements; _a < seriesElements_3.length; _a++) {
            var seriesElement = seriesElements_3[_a];
            this.removeStyles(this.getChildren(seriesElement));
          }
        }
      }
    };
    Selection2.prototype.setAttributes = function(ele, object) {
      var keys = Object.keys(object);
      for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        ele.setAttribute(key, object[key]);
      }
    };
    Selection2.prototype.draggedRectMoved = function(chart, grabbedPoint, doDrawing) {
      var rect;
      if ((this.resizing || this.rectGrabbing) && chart.allowMultiSelection) {
        var r = this.dragRectArray[this.targetIndex];
        rect = new Rect(r.x, r.y, r.width, r.height);
      } else {
        rect = new Rect(this.rectPoints.x, this.rectPoints.y, this.rectPoints.width, this.rectPoints.height);
      }
      rect.x -= grabbedPoint.x - chart.mouseX;
      rect.y -= grabbedPoint.y - chart.mouseY;
      rect = getDraggedRectLocation(rect.x, rect.y, rect.x + rect.width, rect.height + rect.y, chart.chartAxisLayoutPanel.seriesClipRect);
      if (doDrawing) {
        this.drawDraggingRect(chart, rect);
      } else {
        this.calculateDragSelectedElements(chart, rect);
      }
    };
    Selection2.prototype.mouseLeave = function(event2) {
      this.completeSelection(event2.target, event2.type);
    };
    Selection2.prototype.completeSelection = function(target, eventType) {
      var chart = this.chart;
      if (chart.selectionMode === "None") {
        return;
      }
      this.currentMode = chart.selectionMode;
      if ((this.dragging || this.resizing) && this.dragRect.width > 5 && this.dragRect.height > 5) {
        this.calculateDragSelectedElements(chart, this.dragRect);
      } else if (!chart.allowMultiSelection && this.rectGrabbing && this.rectPoints.width && this.rectPoints.height) {
        this.draggedRectMoved(chart, this.dragRect);
      } else if (this.rectGrabbing && this.dragRectArray[this.targetIndex].width && this.dragRectArray[this.targetIndex].height) {
        this.draggedRectMoved(chart, this.dragRect);
      }
      if (chart.selectionMode === "Lasso" && this.dragging && this.path) {
        if (this.path.indexOf("L") !== -1) {
          if (!chart.allowMultiSelection) {
            getElement2(this.lassoPath).setAttribute("d", this.path + "Z");
            this.pointChecking(getElement2(this.lassoPath));
          } else if (getElement2(this.lassoPath + this.count)) {
            getElement2(this.lassoPath + this.count).setAttribute("d", this.path + "Z");
            this.pointChecking(getElement2(this.lassoPath + this.count));
          }
          if (this.dragging || this.resizing) {
            this.calculateDragSelectedElements(chart, this.dragRect);
          }
        }
      }
      this.dragging = false;
      this.rectGrabbing = false;
      this.resizing = false;
      this.removeDraggedElements(chart, target, eventType);
    };
    Selection2.prototype.getDragRect = function(chart, seriesClipRect) {
      return getDraggedRectLocation(chart.mouseDownX, chart.mouseDownY, chart.mouseX, chart.mouseY, seriesClipRect);
    };
    Selection2.prototype.dragStart = function(chart, seriesClipRect, mouseDownX, mouseDownY, event2) {
      var mode = chart.selectionMode;
      this.currentMode = chart.selectionMode;
      this.dragging = (mode.indexOf("Drag") > -1 || mode === "Lasso") && (chart.isDoubleTap || !chart.isTouch) && chart.chartAreaType !== "PolarRadar";
      var target = event2.target;
      this.path = void 0;
      if (this.dragging) {
        this.count = getElement2(this.multiRectGroup) ? this.count + 1 : 0;
        this.dragRect = new Rect(chart.mouseDownX, chart.mouseDownY, 0, 0);
        if (chart.mouseDownX < seriesClipRect.x || chart.mouseDownX > seriesClipRect.x + seriesClipRect.width || chart.mouseDownY < seriesClipRect.y || chart.mouseDownY > seriesClipRect.y + seriesClipRect.height) {
          this.dragging = false;
        }
      }
      if (mode === "Lasso") {
        for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
          var series = _a[_i];
          if (series.visible) {
            for (var _b = 0, _c = series.points; _b < _c.length; _b++) {
              var point = _c[_b];
              if (!chart.allowMultiSelection) {
                point.isSelect = false;
              }
            }
          }
        }
      }
      if (!(mode === "Lasso")) {
        if (this.rectPoints && !chart.allowMultiSelection) {
          this.dragRect = new Rect(chart.mouseDownX, chart.mouseDownY, 0, 0);
          this.resizingSelectionRect(chart, new ChartLocation(mouseDownX, mouseDownY), true);
          this.rectGrabbing = withInBounds(mouseDownX, mouseDownY, this.rectPoints);
        }
        if (chart.allowMultiSelection) {
          var index = this.getIndex(target.id);
          this.targetIndex = this.isDragRect(target.id) ? index : void 0;
          if (this.dragRectArray.length && this.isDragRect(target.id)) {
            this.resizingSelectionRect(chart, new ChartLocation(mouseDownX, mouseDownY), true, target);
            this.rectGrabbing = withInBounds(mouseDownX, mouseDownY, this.dragRectArray[index]);
          }
        }
      }
    };
    Selection2.prototype.isDragRect = function(id) {
      return id.indexOf("_ej2_drag_rect") > -1;
    };
    Selection2.prototype.mouseMove = function(event2) {
      var chart = this.chart;
      var target = event2.target;
      var eventType = event2.type;
      this.highlightChart(target, eventType);
      if (chart.selectionMode === "None") {
        return;
      }
      if (eventType === "touchmove" && (Browser.isIos || Browser.isIos7) && this.dragging && event2.preventDefault) {
        event2.preventDefault();
      }
      this.selectionAndDrag(chart, target, eventType);
    };
    Selection2.prototype.highlightChart = function(target, eventType) {
      if (this.chart.highlightMode !== "None" || this.chart.legendSettings.enableHighlight) {
        if (!isNullOrUndefined(target)) {
          if (target.id.indexOf("_legend_text") > 1) {
            target = getElement2(target.id.replace("text", "shape"));
          }
          if (target.hasAttribute("class") && (target.getAttribute("class").indexOf("highlight") > -1 || target.getAttribute("class").indexOf("selection") > -1)) {
            return;
          }
          this.calculateSelectedElements(target, eventType);
          if (this.chart.highlightModule.highlightDataIndexes && this.chart.highlightModule.highlightDataIndexes.length > 0 && target.id.indexOf("_chart_legend_g_") === -1 && target.id.indexOf("chart_legend_shape") === -1 && target.id.indexOf("_Series_") === -1) {
            this.removeLegendHighlightStyles();
          } else if (this.chart.highlightModule.highlightDataIndexes && this.chart.highlightModule.highlightDataIndexes.length > 0 && target.id.indexOf("_chart_legend_") === -1 && target.id.indexOf("_Series_") > -1 && this.chart.tooltip && this.chart.tooltip.enableHighlight && this.chart.highlightMode === "None") {
            this.removeLegendHighlightStyles(true);
          }
        }
        return;
      }
    };
    Selection2.prototype.selectionAndDrag = function(chart, target, eventType) {
      var insideMoving = withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect);
      if (insideMoving && !this.chart.enableCanvas) {
        if (this.rectGrabbing && !this.resizing) {
          this.draggedRectMoved(chart, this.dragRect, true);
        } else if (this.dragging && !this.resizing) {
          if (chart.selectionMode === "Lasso") {
            this.getPath(chart.mouseDownX, chart.mouseDownY, chart.mouseX, chart.mouseY);
            this.drawDraggingRect(chart, this.dragRect);
          } else {
            this.dragRect = this.getDragRect(chart, chart.chartAxisLayoutPanel.seriesClipRect);
            this.drawDraggingRect(chart, this.dragRect);
          }
        }
        if (this.rectPoints && !chart.allowMultiSelection) {
          this.resizingSelectionRect(chart, new ChartLocation(chart.mouseX, chart.mouseY), null, target);
        } else if (chart.allowMultiSelection && !this.dragging || this.resizing) {
          this.resizingSelectionRect(chart, new ChartLocation(chart.mouseX, chart.mouseY), null, target);
        }
      } else {
        this.completeSelection(target, eventType);
      }
    };
    Selection2.prototype.removeLegendHighlightStyles = function(tooltipHighlight) {
      this.chart.highlightModule.highlightDataIndexes = [];
      var elementCollection;
      for (var i = 0; i < this.chart.visibleSeries.length; i++) {
        elementCollection = document.getElementsByClassName(this.generateStyle(this.chart.visibleSeries[i]));
        if (this.selectedDataIndexes.length === 0) {
          elementCollection = document.getElementsByClassName(this.generateStyle(this.chart.visibleSeries[i]));
          while (elementCollection.length > 0) {
            var element = elementCollection[0];
            if (element) {
              this.removeSvgClass(element, element.getAttribute("class"));
              if (element.id.indexOf("Group") > 0 && !this.chart.visibleSeries[i].isRectSeries) {
                var seriesIndex = this.indexFinder(element.id);
                for (var j = 0; j < element.children.length; j++) {
                  if (element.children[j].nodeName !== "defs") {
                    this.highlightAnimation(element.children[j], seriesIndex.series, tooltipHighlight ? 0 : 700, 0.3, !tooltipHighlight);
                  }
                }
              }
            }
          }
          elementCollection = document.getElementsByClassName(this.unselected);
          while (elementCollection.length > 0) {
            var element = elementCollection[0];
            if (element) {
              this.removeSvgClass(element, element.getAttribute("class"));
              if (element.id !== "") {
                this.highlightAnimation(element, this.chart.series.length === 1 ? 0 : this.indexFinder(element.id).series, tooltipHighlight ? 0 : 700, 0.3);
              }
            }
          }
        } else {
          elementCollection = document.getElementsByClassName(this.generateStyle(this.chart.visibleSeries[i]));
          while (elementCollection.length > 0) {
            var element = elementCollection[0];
            if (element) {
              this.removeSvgClass(element, element.getAttribute("class"));
              this.addSvgClass(element, this.unselected);
            }
          }
        }
      }
    };
    Selection2.prototype.getPath = function(startX, startY, endX, endY) {
      if (this.dragging) {
        if (this.path) {
          this.path = this.path + " L" + endX + " " + endY;
        } else {
          this.path = "M " + startX + " " + startY;
        }
      }
    };
    Selection2.prototype.highlightAnimation = function(element, index, duration, startOpacity, strokeWidth) {
      var _this = this;
      var endOpacity;
      var endWidth;
      var startWidth = parseFloat(this.chart.visibleSeries[index].width.toString()) + 1;
      if (strokeWidth) {
        if (element.id.indexOf("border") !== -1 && this.chart.visibleSeries[index].border.width) {
          endWidth = parseFloat(this.chart.visibleSeries[index].border.width.toString());
        } else if (element.id.indexOf("Symbol") !== -1 && this.chart.visibleSeries[index].marker.border.width) {
          endWidth = parseFloat(this.chart.visibleSeries[index].marker.border.width.toString());
        } else {
          endWidth = parseFloat(this.chart.visibleSeries[index].width.toString());
        }
      } else {
        if (element.id.indexOf("border") !== -1) {
          endOpacity = 1;
        } else if (element.id.indexOf("Symbol") !== -1) {
          endOpacity = parseFloat(this.chart.visibleSeries[index].marker.opacity.toString());
        } else if (element.id.indexOf("legend_shape") !== -1) {
          endOpacity = parseFloat(this.chart.legendSettings.opacity.toString());
        } else {
          endOpacity = parseFloat(this.chart.visibleSeries[index].opacity.toString());
        }
        if (isNullOrUndefined(this.chart.selectionModule) && this.chart.selectionMode === "None" && this.chart.highlightColor !== "") {
          startOpacity = 1;
        }
      }
      if (endOpacity || strokeWidth && endWidth && startWidth) {
        new Animation({}).animate(element, {
          duration,
          progress: function(args) {
            element.style.animation = "";
            if (_this.chart.tooltip.enableHighlight && _this.chart.tooltipModule.svgTooltip) {
              return;
            }
            var progress = args.timeStamp / args.duration;
            if (strokeWidth) {
              var currentWidth = startWidth + (endWidth - startWidth) * progress;
              element.setAttribute("stroke-width", currentWidth.toString());
            } else {
              var currentOpacity = startOpacity + (endOpacity - startOpacity) * progress;
              element.setAttribute("opacity", currentOpacity.toString());
            }
          },
          end: function() {
            if (_this.chart.tooltip.enableHighlight && _this.chart.tooltipModule.svgTooltip) {
              return;
            }
            if (strokeWidth) {
              element.setAttribute("stroke-width", endWidth.toString());
            } else {
              element.setAttribute("opacity", endOpacity.toString());
            }
          }
        });
      }
    };
    Selection2.prototype.stopElementAnimation = function(element, index) {
      var endOpacity;
      if (element.id.indexOf("border") !== -1) {
        endOpacity = 1;
      } else if (element.id.indexOf("Symbol") !== -1) {
        endOpacity = parseFloat(this.chart.visibleSeries[index].marker.opacity.toString());
      } else {
        endOpacity = parseFloat(this.chart.visibleSeries[index].opacity.toString());
      }
      if (element.getAttribute("e-animate")) {
        Animation.stop(element);
      }
      element.setAttribute("opacity", endOpacity.toString());
    };
    Selection2.prototype.pointChecking = function(path) {
      var _this = this;
      var chart = this.chart;
      var element;
      var svgRect = getElement2(chart.svgId).getBoundingClientRect();
      var offsetX = chart.chartAxisLayoutPanel.seriesClipRect.x + Math.max(svgRect.left, 0);
      var offsetY = chart.chartAxisLayoutPanel.seriesClipRect.y + Math.max(svgRect.top, 0);
      this.multiDataIndexes[this.count] = [];
      for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
        var series = _a[_i];
        series.points.filter(function(point) {
          if (point.symbolLocations && point.symbolLocations.length) {
            element = document.elementFromPoint(point.symbolLocations[0].x + offsetX, point.symbolLocations[0].y + offsetY);
          }
          if (element === path) {
            point.isSelect = true;
            if (_this.chart.allowMultiSelection && _this.currentMode === "Lasso") {
              _this.multiDataIndexes[_this.count][_this.seriesIndex] = point;
              _this.seriesIndex++;
            }
          } else if (!chart.allowMultiSelection) {
            point.isSelect = false;
          }
        });
      }
      this.seriesIndex = 0;
    };
    Selection2.prototype.getModuleName = function() {
      return "Selection";
    };
    Selection2.prototype.destroy = function() {
      this.removeEventListener();
    };
    return Selection2;
  }(BaseSelection)
);

// node_modules/@syncfusion/ej2-charts/src/common/user-interaction/tooltip.js
var __extends55 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var BaseTooltip = (
  /** @class */
  function(_super) {
    __extends55(BaseTooltip2, _super);
    function BaseTooltip2(chart) {
      var _this = _super.call(this, chart) || this;
      _this.element = _this.chart.element;
      _this.textStyle = chart.tooltip.textStyle;
      _this.control = chart;
      _this.template = chart.tooltip.template;
      return _this;
    }
    BaseTooltip2.prototype.getElement = function(id) {
      return document.getElementById(id);
    };
    BaseTooltip2.prototype.getTooltipElement = function(isTooltip) {
      this.inverted = this.chart.requireInvertedAxis;
      this.header = this.control.tooltip.header === null ? this.control.tooltip.shared ? "${point.x}" : "${series.name}" : this.control.tooltip.header;
      this.formattedText = [];
      var tooltipDiv = document.getElementById(this.chart.element.id + "_tooltip");
      var isStockChart = this.chart.element.id.indexOf("stockChart") > -1;
      if (!isTooltip && !tooltipDiv || isStockChart) {
        return this.createElement();
      }
      return null;
    };
    BaseTooltip2.prototype.createElement = function() {
      var tooltipDiv = document.createElement("div");
      tooltipDiv.id = this.element.id + "_tooltip";
      tooltipDiv.className = "ejSVGTooltip";
      tooltipDiv.style.pointerEvents = "none";
      tooltipDiv.style.position = "absolute";
      tooltipDiv.style.zIndex = "1";
      return tooltipDiv;
    };
    BaseTooltip2.prototype.pushData = function(data, isFirst, tooltipDiv, isChart, enable3D) {
      if (data.series.enableTooltip) {
        if (enable3D) {
          this.currentPoints.push(data);
        } else if (isChart) {
          this.currentPoints.push(data);
        } else {
          this.currentPoints.push(data);
        }
        this.stopAnimation();
        if (tooltipDiv && !document.getElementById(tooltipDiv.id)) {
          if (!this.chart.stockChart) {
            document.getElementById(this.element.id + "_Secondary_Element").appendChild(tooltipDiv);
          } else {
            document.getElementById(this.chart.stockChart.element.id + "_Secondary_Element").appendChild(tooltipDiv);
          }
        }
        return true;
      }
      return false;
    };
    BaseTooltip2.prototype.removeHighlight = function() {
      var item;
      for (var i = 0, len = this.previousPoints.length; i < len; i++) {
        item = this.previousPoints[i];
        if (item.series.isRectSeries || this.chart.tooltip.enableHighlight) {
          if (item.series.visible) {
            this.highlightPoint(item.series, item.point.index, false);
          }
          continue;
        }
      }
    };
    BaseTooltip2.prototype.animateHighlight = function(targetOpacity, targetElement, duration, targetStrokeWidth) {
      var _this = this;
      var initialOpacity = parseFloat(targetElement.getAttribute("opacity"));
      var initialStrokeWidth = null;
      if (targetStrokeWidth !== null) {
        initialStrokeWidth = parseFloat(targetElement.getAttribute("stroke-width"));
      }
      new Animation({}).animate(targetElement, {
        duration,
        progress: function(args) {
          targetElement.style.animation = "";
          if (_this.svgTooltip) {
            return;
          }
          if (targetStrokeWidth !== null) {
            var newStrokeWidth = initialStrokeWidth + args.timeStamp / args.duration * (targetStrokeWidth - initialStrokeWidth);
            targetElement.setAttribute("stroke-width", Math.max(newStrokeWidth, targetStrokeWidth).toString());
          }
          var newOpacity = initialOpacity + args.timeStamp / args.duration * (targetOpacity - initialOpacity);
          targetElement.setAttribute("opacity", Math.min(newOpacity, targetOpacity).toString());
        },
        end: function() {
          if (_this.svgTooltip) {
            return;
          }
          if (targetStrokeWidth !== null) {
            targetElement.setAttribute("stroke-width", targetStrokeWidth.toString());
          }
          targetElement.setAttribute("opacity", targetOpacity.toString());
        }
      });
    };
    BaseTooltip2.prototype.highlightPoint = function(series, pointIndex, highlight) {
      var _this = this;
      var element = series.type === "BoxAndWhisker" ? this.getElement(this.element.id + "_Series_" + series.index + "_Point_" + pointIndex + "_BoxPath") : this.getElement(this.element.id + "_Series_" + series.index + "_Point_" + pointIndex);
      var selectionModule = this.control.accumulationSelectionModule;
      var isAccumulation = this.chart.getModuleName() === "accumulationchart";
      var isSelectedElement = selectionModule && selectionModule.selectedDataIndexes.length > 0 ? true : false;
      if (element || !series.isRectSeries) {
        if (!isSelectedElement || isSelectedElement && element.getAttribute("class") && element.getAttribute("class").indexOf("_ej2_chart_selection_series_") === -1 || !series.isRectSeries) {
          if (series.isRectSeries && this.chart.highlightColor !== "" && !isNullOrUndefined(this.chart.highlightColor)) {
            element.setAttribute("fill", highlight && this.chart.highlightColor !== "transparent" ? this.chart.highlightColor : series.pointColorMapping !== "" ? series.points[0].color : series.points[pointIndex].color || series.interior);
          } else {
            if (this.control.highlightMode === "None" && this.chart.tooltip.enableHighlight && (!this.chart.tooltip.shared || isAccumulation)) {
              if (highlight && (isAccumulation ? this.control.accumulationSelectionModule && this.control.accumulationSelectionModule.selectedDataIndexes.length > 0 : this.chart.selectionModule && this.chart.selectionModule.selectedDataIndexes.length > 0)) {
                return;
              }
              var target_1 = this.element.id + "_Series_" + series.index + "_Point_" + pointIndex;
              var _loop_1 = function(currentSeries2) {
                var seriesElementsGroupCollections = [];
                var currentSeriesWidth = typeof currentSeries2.width === "number" ? currentSeries2.width : parseFloat(currentSeries2.width);
                seriesElementsGroupCollections = isAccumulation ? [this_1.getElement(this_1.chart.element.id + "_Series_" + currentSeries2.index)] : new Selection(this_1.chart).getSeriesElements(currentSeries2);
                if (isAccumulation && this_1.control.series[0].dataLabel.visible) {
                  var dataLabelCollection = this_1.getElement(this_1.element.id + "_datalabel_Series_0");
                  if (dataLabelCollection) {
                    seriesElementsGroupCollections.push(dataLabelCollection);
                  }
                }
                seriesElementsGroupCollections.forEach(function(seriesElementsGroup) {
                  seriesElementsGroup.childNodes.forEach(function(seriesElement) {
                    var targetOpacity = seriesElement.id.indexOf("border") > -1 ? 1 : seriesElement.id.indexOf("Symbol") > -1 ? currentSeries2.marker.opacity : currentSeries2.opacity;
                    var targetStrokeWidth = seriesElement.id.indexOf("border") > -1 && currentSeries2.border.width ? parseFloat(currentSeries2.border.width.toString()) : seriesElement.id.indexOf("Symbol") > -1 && currentSeries2.marker.border.width ? parseFloat(currentSeries2.marker.border.width.toString()) : currentSeriesWidth;
                    if (highlight && _this.chart.highlightColor !== "transparent" && seriesElement.id !== "") {
                      if (isAccumulation ? seriesElementsGroup.getAttribute("id").indexOf("datalabel") > -1 ? indexFinder(seriesElement.id).point === pointIndex : seriesElement.id === target_1 : seriesElementsGroup.getAttribute("id") === _this.element.id + "DataLabelCollection" ? indexFinder(seriesElement.id).series === series.index : currentSeries2.index === series.index) {
                        seriesElement.setAttribute("opacity", targetOpacity.toString());
                        if ((!series.isRectSeries || seriesElement.id.indexOf("border") > -1) && !isAccumulation) {
                          seriesElement.setAttribute("stroke-width", (targetStrokeWidth + 1).toString());
                        }
                      } else {
                        seriesElement.setAttribute("opacity", isAccumulation ? seriesElement.id.indexOf("datalabel") > -1 ? "0.5" : "0.3" : seriesElement.getAttribute("id").indexOf("Text") > -1 ? "0.5" : "0.3");
                        if ((!series.isRectSeries || seriesElement.id.indexOf("border") > -1) && !isAccumulation) {
                          seriesElement.setAttribute("stroke-width", targetStrokeWidth.toString());
                        }
                      }
                    } else if (!_this.currentPoints[0] && seriesElement.id !== "") {
                      _this.animateHighlight(targetOpacity, seriesElement, _this.chart.tooltip.duration, (!series.isRectSeries || seriesElement.id.indexOf("border") > -1) && !isAccumulation ? targetStrokeWidth : null);
                    }
                  });
                });
              };
              var this_1 = this;
              for (var _i = 0, _a = this.chart.visibleSeries; _i < _a.length; _i++) {
                var currentSeries = _a[_i];
                _loop_1(currentSeries);
              }
            } else if (series.isRectSeries) {
              element.setAttribute("opacity", (highlight && this.chart.highlightColor !== "transparent" ? series.opacity / 2 : series.opacity).toString());
            }
          }
        } else {
          element.setAttribute("opacity", series.opacity.toString());
        }
      }
    };
    BaseTooltip2.prototype.highlightPoints = function() {
      for (var _i = 0, _a = this.currentPoints; _i < _a.length; _i++) {
        var item = _a[_i];
        if ((item.series.isRectSeries || this.chart.tooltip.enableHighlight) && item.series.category === "Series") {
          this.highlightPoint(item.series, item.point.index, true);
        }
      }
    };
    BaseTooltip2.prototype.createTooltip = function(chart, isFirst, location, clipLocation, point, shapes, offset, bounds, crosshairEnabled, extraPoints, templatePoint, customTemplate) {
      if (crosshairEnabled === void 0) {
        crosshairEnabled = false;
      }
      if (extraPoints === void 0) {
        extraPoints = null;
      }
      if (templatePoint === void 0) {
        templatePoint = null;
      }
      var series = this.currentPoints[0].series;
      var tooltipModule = chart.tooltipModule || chart.tooltip3DModule || chart.accumulationTooltipModule;
      if (!tooltipModule || location === null) {
        removeElement2(this.chart.element.id + "_tooltip");
        return;
      }
      if (isFirst) {
        this.svgTooltip = new Tooltip({
          opacity: chart.tooltip.opacity ? chart.tooltip.opacity : this.chart.theme === "Material3" || this.chart.theme === "Material3Dark" || this.chart.theme.indexOf("Bootstrap5") > -1 ? 1 : 0.75,
          header: this.headerText,
          content: this.text,
          fill: chart.tooltip.fill,
          border: chart.tooltip.border,
          enableAnimation: chart.tooltip.enableAnimation,
          location,
          shared: this.control.tooltip.shared,
          crosshair: crosshairEnabled,
          shapes,
          clipBounds: this.chart.chartAreaType === "PolarRadar" ? new ChartLocation(0, 0) : clipLocation,
          areaBounds: bounds,
          palette: this.findPalette(),
          template: customTemplate || this.template,
          data: templatePoint,
          theme: chart.theme,
          offset,
          textStyle: chart.tooltip.textStyle,
          isNegative: series.isRectSeries && series.type !== "Waterfall" && point && point.y < 0,
          inverted: this.chart.requireInvertedAxis && series.isRectSeries,
          arrowPadding: this.text.length > 1 || this.chart.stockChart || this.chart.tooltip.location.x !== null || this.chart.tooltip.location.y !== null ? 0 : 7,
          availableSize: chart.availableSize,
          duration: this.chart.tooltip.duration,
          isCanvas: this.chart.enableCanvas,
          isFixed: this.chart.tooltip.location.x !== null || this.chart.tooltip.location.y !== null,
          isTextWrap: chart.tooltip.enableTextWrap && chart.getModuleName() === "chart",
          blazorTemplate: {
            name: "Template",
            parent: this.chart.tooltip
          },
          controlInstance: this.chart,
          enableRTL: chart.enableRtl,
          controlName: "Chart",
          allowHighlight: chart.getModuleName() === "chart" && !series.marker.allowHighlight,
          tooltipRender: function() {
            tooltipModule.removeHighlight();
            tooltipModule.highlightPoints();
            tooltipModule.updatePreviousPoint(extraPoints);
          },
          animationComplete: function(args) {
            if (args.tooltip.fadeOuted) {
              tooltipModule.fadeOut(tooltipModule.previousPoints);
            }
          },
          showHeaderLine: this.chart.tooltip.showHeaderLine,
          showNearestTooltip: this.chart.tooltip.showNearestTooltip
        });
        this.svgTooltip.appendTo(this.getElement(this.element.id + "_tooltip"));
      } else {
        if (this.svgTooltip) {
          this.svgTooltip.location = location;
          this.svgTooltip.content = this.text;
          this.svgTooltip.header = this.headerText;
          this.svgTooltip.offset = offset;
          this.svgTooltip.palette = this.findPalette();
          this.svgTooltip.shapes = shapes;
          this.svgTooltip.data = templatePoint;
          this.svgTooltip.template = this.template;
          this.svgTooltip.controlName = "Chart";
          this.svgTooltip.crosshair = crosshairEnabled;
          this.svgTooltip.textStyle = chart.tooltip.textStyle;
          this.svgTooltip.isNegative = series.isRectSeries && series.type !== "Waterfall" && point && point.y < 0;
          this.svgTooltip.clipBounds = this.chart.chartAreaType === "PolarRadar" ? new ChartLocation(0, 0) : clipLocation;
          this.svgTooltip.arrowPadding = this.text.length > 1 || this.chart.stockChart || this.chart.tooltip.location.x !== null || this.chart.tooltip.location.y !== null ? 0 : 7;
          this.svgTooltip.allowHighlight = chart.getModuleName() === "chart" && !series.marker.allowHighlight;
          this.svgTooltip.dataBind();
        }
      }
      if (this.chart.isReact) {
        this.chart.renderReactTemplates();
      }
    };
    BaseTooltip2.prototype.findPalette = function() {
      var colors = [];
      for (var _i = 0, _a = this.currentPoints; _i < _a.length; _i++) {
        var data = _a[_i];
        colors.push(this.findColor(data, data.series));
      }
      return colors;
    };
    BaseTooltip2.prototype.findColor = function(data, series) {
      if (series.isRectSeries && (series.type === "Candle" || series.type === "Hilo" || series.type === "HiloOpenClose")) {
        return data.point.color;
      } else {
        return (data.point.color && data.point.color !== "#ffffff" ? data.point.color : data.point.interior) || series.marker.fill || series.interior;
      }
    };
    BaseTooltip2.prototype.updatePreviousPoint = function(extraPoints) {
      if (extraPoints) {
        this.currentPoints = this.currentPoints.concat(extraPoints);
      }
      this.previousPoints = extend([], this.currentPoints, null, true);
    };
    BaseTooltip2.prototype.fadeOut = function(data) {
      var svgElement = this.chart.enableCanvas ? this.getElement(this.element.id + "_tooltip_group") : this.getElement(this.element.id + "_tooltip_svg") || this.getElement(this.element.id + "_tooltipparent_template");
      var isTooltip = svgElement && parseInt(svgElement.getAttribute("opacity"), 10) > 0;
      if (!isTooltip) {
        this.valueX = null;
        this.valueY = null;
        this.currentPoints = [];
        this.removeHighlight();
        this.removeHighlightedMarker(data, true);
        this.svgTooltip = null;
        this.control.trigger("animationComplete", {});
      }
    };
    BaseTooltip2.prototype.removeHighlightedMarker = function(data, fadeOut) {
      if (this.chart.markerRender) {
        for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
          var item = data_1[_i];
          removeElement2(this.element.id + "_Series_" + item.series.index + "_Point_" + item.point.index + "_Trackball");
          this.chart.markerRender.removeHighlightedMarker(item.series, item.point, fadeOut);
        }
      }
      this.previousPoints = [];
    };
    BaseTooltip2.prototype.removeText = function() {
      this.textElements = [];
      var element = this.getElement(this.element.id + "_tooltip_group");
      if (element && element.childNodes.length > 0) {
        while (element.lastChild && element.childNodes.length !== 1) {
          element.removeChild(element.lastChild);
        }
      }
    };
    BaseTooltip2.prototype.stopAnimation = function() {
      stopTimer(this.toolTipInterval);
    };
    BaseTooltip2.prototype.removeTooltip = function(duration) {
      var _this = this;
      var tooltipElement = this.getElement(this.element.id + "_tooltip");
      this.stopAnimation();
      if (tooltipElement && this.previousPoints.length > 0) {
        this.toolTipInterval = +setTimeout(function() {
          if (_this.svgTooltip) {
            _this.svgTooltip.fadeOut();
          }
        }, duration);
      }
    };
    return BaseTooltip2;
  }(ChartData)
);

// node_modules/@syncfusion/ej2-charts/src/chart/user-interaction/tooltip.js
var __extends56 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Tooltip2 = (
  /** @class */
  function(_super) {
    __extends56(Tooltip3, _super);
    function Tooltip3(chart) {
      var _this = _super.call(this, chart) || this;
      _this.commonXvalues = [];
      _this.addEventListener();
      return _this;
    }
    Tooltip3.prototype.addEventListener = function() {
      if (this.chart.isDestroyed) {
        return;
      }
      var cancelEvent = Browser.isPointer ? "pointerleave" : "mouseleave";
      this.chart.on(cancelEvent, this.mouseLeaveHandler, this);
      this.chart.on("tapHold", this.longPress, this);
      this.chart.on(Browser.touchMoveEvent, this.mouseMoveHandler, this);
      this.chart.on(Browser.touchEndEvent, this.mouseUpHandler, this);
    };
    Tooltip3.prototype.mouseUpHandler = function() {
      var chart = this.control;
      var data = this.getData();
      data.lierIndex = this.lierIndex;
      if (chart.isTouch && !this.isSelected(chart) && (withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect) && chart.tooltip.shared || !chart.tooltip.shared)) {
        if (!chart.crosshair.enable) {
          this.tooltip();
          if (chart.tooltip.fadeOutMode === "Move") {
            this.removeTooltip(chart.tooltip.fadeOutDuration);
          }
        } else if (chart.startMove && chart.tooltip.fadeOutMode === "Move") {
          this.removeTooltip(2e3);
        }
      } else if (!this.findData(data, this.previousPoints[0]) && chart.tooltip.fadeOutMode === "Click") {
        this.removeTooltip(0);
      }
    };
    Tooltip3.prototype.mouseLeaveHandler = function() {
      this.removeTooltip(this.chart.tooltip.fadeOutDuration);
    };
    Tooltip3.prototype.mouseMoveHandler = function() {
      var chart = this.chart;
      if (chart.stockChart && chart.stockChart.onPanning) {
        if (chart.mouseY < chart.chartAxisLayoutPanel.seriesClipRect.y) {
          chart.mouseY = chart.chartAxisLayoutPanel.seriesClipRect.y;
        } else if (chart.mouseY > chart.chartAxisLayoutPanel.seriesClipRect.y + chart.chartAxisLayoutPanel.seriesClipRect.height) {
          chart.mouseY = chart.chartAxisLayoutPanel.seriesClipRect.y + chart.chartAxisLayoutPanel.seriesClipRect.height;
        }
      }
      if (!chart.disableTrackTooltip && !this.isSelected(chart)) {
        if (!chart.tooltip.shared && (!chart.isTouch || chart.startMove)) {
          this.tooltip();
        }
        if (withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect)) {
          if (chart.tooltip.shared && (!chart.isTouch || chart.startMove)) {
            this.tooltip();
          }
        } else {
          if (chart.tooltip.shared && chart.tooltip.fadeOutMode === "Move") {
            this.removeTooltip(this.chart.tooltip.fadeOutDuration);
          }
        }
      }
    };
    Tooltip3.prototype.longPress = function() {
      var chart = this.chart;
      if (chart.crosshair.enable && withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect)) {
        this.tooltip();
        chart.markerRender.markerMove(false);
      }
      return false;
    };
    Tooltip3.prototype.tooltip = function() {
      var elementId = this.chart.enableCanvas ? this.element.id + "_tooltip_group" : this.element.id + "_tooltip_svg";
      var svgElement = this.getElement(elementId);
      var isStockSvg = this.chart.stockChart && svgElement && svgElement.firstChild.childNodes.length > 1;
      var isTooltip = svgElement && parseInt(svgElement.getAttribute("opacity"), 10) > 0 && !isStockSvg;
      var tooltipDiv = this.getTooltipElement(isTooltip);
      if (this.chart.enableCanvas && tooltipDiv) {
        document.getElementById(this.chart.element.id + "_Secondary_Element").appendChild(tooltipDiv);
        tooltipDiv.appendChild(document.getElementById(this.chart.element.id + "_tooltip_svg"));
      }
      if (!this.chart.tooltip.shared) {
        this.renderSeriesTooltip(this.chart, !isTooltip, tooltipDiv);
      } else {
        this.renderGroupedTooltip(this.chart, !isTooltip, tooltipDiv);
      }
    };
    Tooltip3.prototype.findHeader = function(data) {
      if (this.header === "") {
        return "";
      }
      this.header = this.parseTemplate(data.point, data.series, this.header, data.series.xAxis, data.series.yAxis);
      if (this.header.replace(/<b>/g, "").replace(/<\/b>/g, "").trim() !== "") {
        return this.header;
      }
      return "";
    };
    Tooltip3.prototype.findShapes = function() {
      if (!this.chart.tooltip.enableMarker) {
        return [];
      }
      var marker = [];
      for (var _i = 0, _a = this.currentPoints; _i < _a.length; _i++) {
        var data = _a[_i];
        marker.push(data.point.marker.shape || data.series.marker.shape || "Circle");
      }
      return marker;
    };
    Tooltip3.prototype.renderSeriesTooltip = function(chart, isFirst, tooltipDiv) {
      var data = this.getData();
      var closestPointData = null;
      var smallestDistance = Infinity;
      data.lierIndex = this.lierIndex;
      this.currentPoints = [];
      if (this.findData(data, this.previousPoints[0])) {
        if (!(chart.dataEditingModule && chart.dataEditingModule.isPointDragging) && this.previousPoints[0] && data.point.index === this.previousPoints[0].point.index && data.series.index === this.previousPoints[0].series.index) {
          return null;
        }
        if (this.pushData(data, isFirst, tooltipDiv, true)) {
          this.triggerTooltipRender(data, isFirst, this.getTooltipText(data), this.findHeader(data));
        }
      } else {
        var tooltipWithInBounds = withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect);
        if (!data.point && this.isRemove && chart.tooltip.fadeOutMode === "Move" && (!chart.tooltip.showNearestTooltip || !tooltipWithInBounds)) {
          this.removeTooltip(this.chart.tooltip.fadeOutDuration);
          this.isRemove = false;
        } else {
          var commonXvalues = this.mergeXvalues(this.chart.visibleSeries);
          for (var i = chart.visibleSeries.length - 1; i >= 0; i--) {
            var series = chart.visibleSeries[i];
            if (series.visible && !(series.category === "TrendLine")) {
              data = this.getClosestX(chart, series, commonXvalues) || data;
              if (chart.tooltip.showNearestTooltip && tooltipWithInBounds && series.showNearestTooltip && data && data.point && series.enableTooltip && data.point.symbolLocations[0]) {
                var currentDistance = Math.sqrt(Math.pow(chart.mouseX - data.series.clipRect.x - data.point.symbolLocations[0].x, 2) + Math.pow(chart.mouseY - data.series.clipRect.y - data.point.symbolLocations[0].y, 2));
                if (currentDistance < smallestDistance) {
                  smallestDistance = currentDistance;
                  closestPointData = data;
                }
              }
            }
          }
          if (chart.tooltip.showNearestTooltip && closestPointData && this.pushData(closestPointData, isFirst, tooltipDiv, true)) {
            data = closestPointData;
            this.triggerTooltipRender(data, isFirst, this.getTooltipText(data), this.findHeader(data));
          }
        }
      }
      if (data && data.point) {
        this.findMouseValues(data, chart, this);
      }
    };
    Tooltip3.prototype.triggerTooltipRender = function(point, isFirst, textCollection, headerText) {
      var _this = this;
      var tooltipTemplate;
      var argsData = {
        cancel: false,
        name: tooltipRender,
        text: textCollection,
        headerText,
        template: tooltipTemplate,
        series: this.chart.isBlazor ? {} : point.series,
        textStyle: this.textStyle,
        point: point.point,
        data: {
          pointX: point.point.x,
          pointY: point.point.y,
          seriesIndex: point.series.index,
          seriesName: point.series.name,
          pointIndex: point.point.index,
          pointText: point.point.text
        }
      };
      var borderWidth = this.chart.border.width;
      var padding = 3;
      var tooltip = this.chart.tooltip;
      var chartTooltipSuccess = function(argsData2) {
        if (!argsData2.cancel) {
          if (point.series.type === "BoxAndWhisker") {
            _this.removeText();
            isFirst = true;
          }
          _this.headerText = argsData2.headerText;
          _this.formattedText = _this.formattedText.concat(argsData2.text);
          _this.text = _this.formattedText;
          var location_1 = _this.getSymbolLocation(point);
          location_1 = location_1 ? location_1 : new ChartLocation(null, null);
          location_1.x = tooltip.location.x !== null ? tooltip.location.x : location_1.x;
          location_1.y = tooltip.location.y !== null ? tooltip.location.y : location_1.y;
          location_1 = location_1.x === null && location_1.y === null ? null : location_1;
          _this.createTooltip(_this.chart, isFirst, location_1, point.series.clipRect, point.point, _this.findShapes(), _this.findMarkerHeight(_this.currentPoints[0]), new Rect(borderWidth, borderWidth, _this.chart.availableSize.width - padding - borderWidth * 2, _this.chart.availableSize.height - padding - borderWidth * 2), _this.chart.crosshair.enable, null, _this.getTemplateText(point), _this.template ? argsData2.template : "");
        } else {
          _this.removeHighlight();
          remove(_this.getElement(_this.element.id + "_tooltip"));
        }
        _this.isRemove = true;
      };
      chartTooltipSuccess.bind(this, point);
      this.chart.trigger(tooltipRender, argsData, chartTooltipSuccess);
    };
    Tooltip3.prototype.findMarkerHeight = function(pointData) {
      var markerHeight = 0;
      var series = pointData.series;
      markerHeight = (series.marker.visible || this.chart.tooltip.shared && (!series.isRectSeries || series.marker.visible) || series.type === "Scatter" || series.drawType === "Scatter") && !(series.type === "Candle" || series.type === "Hilo" || series.type === "HiloOpenClose") ? (series.marker.height + 2) / 2 + 2 * series.marker.border.width : 0;
      return markerHeight;
    };
    Tooltip3.prototype.findData = function(data, previous) {
      return data.point && (!previous || previous.point !== data.point || previous && previous.lierIndex > 3 && previous.lierIndex !== this.lierIndex || previous.point === data.point);
    };
    Tooltip3.prototype.getSymbolLocation = function(data) {
      var location;
      if (data.series.type !== "BoxAndWhisker") {
        if (!data.point.symbolLocations[0]) {
          return null;
        }
        location = new ChartLocation(data.point.symbolLocations[0].x, data.point.symbolLocations[0].y);
      }
      switch (data.series.type) {
        case "BoxAndWhisker":
          return this.getBoxLocation(data);
        case "Waterfall":
          return this.getWaterfallRegion(data, location);
        case "RangeArea":
        case "RangeStepArea":
        case "SplineRangeArea":
        case "RangeColumn":
          return this.getRangeArea(data, location);
        default:
          return location;
      }
    };
    Tooltip3.prototype.getRangeArea = function(data, location) {
      if (data.point.regions[0]) {
        if (!this.inverted) {
          location.y = data.point.regions[0].y + data.point.regions[0].height / 2;
        } else {
          location.x = data.point.regions[0].x + data.point.regions[0].width / 2;
        }
        if (data.series.type === "RangeStepArea") {
          location.y = data.point.regions[0].y + data.point.regions[0].height / 2 + data.point.regions[0].width;
        }
      }
      return location;
    };
    Tooltip3.prototype.getWaterfallRegion = function(data, location) {
      if (!this.inverted) {
        location.y = data.point.y < 0 ? location.y - data.point.regions[0].height : location.y;
      } else {
        location.x = data.point.y < 0 ? location.x + (this.chart.enableRtl ? -data.point.regions[0].width : data.point.regions[0].width) : location.x;
      }
      return location;
    };
    Tooltip3.prototype.getTooltipText = function(pointData) {
      var series = pointData.series;
      return this.parseTemplate(pointData.point, series, this.getFormat(this.chart, series), series.xAxis, series.yAxis);
    };
    Tooltip3.prototype.getTemplateText = function(data) {
      this.template = this.chart.enableHtmlSanitizer ? this.chart.sanitize(this.template) : this.template;
      if (this.template && this.chart.tooltip.shared) {
        var point = [];
        for (var i = 0; i < data.length; i++) {
          point[i] = extend({}, data[i].point);
          point[i].x = this.formatPointValue(data[i].point, data[i].series.xAxis, "x", true, false);
          if (data[i].series.seriesType === "XY") {
            point[i].y = this.formatPointValue(data[i].point, data[i].series.yAxis, "y", false, true);
          } else {
            point[i].low = this.formatPointValue(data[i].point, data[i].series.yAxis, "low", false, true);
            point[i].high = this.formatPointValue(data[i].point, data[i].series.yAxis, "high", false, true);
          }
        }
        return point;
      } else if (this.template) {
        var point = extend({}, data.point);
        point.x = this.formatPointValue(data.point, data.series.xAxis, "x", true, false);
        if (data.series.seriesType === "XY") {
          point.y = this.formatPointValue(data.point, data.series.yAxis, "y", false, true);
        } else {
          point.low = this.formatPointValue(data.point, data.series.yAxis, "low", false, true);
          point.high = this.formatPointValue(data.point, data.series.yAxis, "high", false, true);
        }
        return point;
      } else {
        return data.point;
      }
    };
    Tooltip3.prototype.renderGroupedTooltip = function(chart, isFirst, tooltipDiv) {
      var data;
      var dataCollection = [];
      var lastData;
      var pointData = chart.chartAreaType === "PolarRadar" ? this.getData() : null;
      this.stopAnimation();
      this.removeHighlight();
      this.currentPoints = [];
      var extraPoints = [];
      var closestXValue = Number.MAX_VALUE;
      var closetYValue = Number.MAX_VALUE;
      var pointXValue;
      var pointYValue;
      var tempData;
      if (isFirst) {
        if (!chart.stockChart) {
          if (tooltipDiv) {
            document.getElementById(this.element.id + "_Secondary_Element").appendChild(tooltipDiv);
          }
        } else {
          if (tooltipDiv && !getElement(tooltipDiv.id)) {
            document.getElementById(chart.stockChart.element.id + "_Secondary_Element").appendChild(tooltipDiv);
          }
        }
      }
      this.removeText();
      var argument = {
        text: [],
        cancel: false,
        name: sharedTooltipRender,
        data: [],
        point: [],
        series: [],
        headerText: "",
        textStyle: this.textStyle,
        template: []
      };
      var i = 0;
      for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
        var series = _a[_i];
        if (!series.enableTooltip || !series.visible) {
          continue;
        }
        if (chart.chartAreaType === "Cartesian" && series.visible) {
          data = this.getClosestX(chart, series, this.commonXValue(this.chart.visibleSeries));
        } else if (chart.chartAreaType === "PolarRadar" && series.visible && pointData.point !== null) {
          data = new PointData(series.points[pointData.point.index], series);
        }
        if (chart.tooltip.showNearestPoint && !data) {
          data = this.getClosestX(chart, series, this.commonXValue([series]));
        }
        if (data) {
          argument.data.push({
            pointX: data.point.x,
            pointY: data.point.y,
            seriesIndex: data.series.index,
            seriesName: data.series.name,
            pointIndex: data.point.index,
            pointText: data.point.text
          });
          argument.series[i] = data.series;
          argument.point[i] = data.point;
          argument.headerText = this.findHeader(data);
          this.currentPoints.push(data);
          if (this.template != null) {
            argument.template.push(chart.enableHtmlSanitizer ? chart.sanitize(this.template.toString()) : this.template.toString());
          }
          argument.text.push(this.getTooltipText(data));
          pointXValue = !chart.requireInvertedAxis ? chart.mouseX - data.series.clipRect.x : chart.mouseY - data.series.clipRect.y;
          pointYValue = chart.mouseY - data.series.clipRect.y;
          if (data.point.symbolLocations && data.point.symbolLocations.length && Math.abs(pointXValue - data.point.symbolLocations[0].x) <= closestXValue && Math.abs(data.point.symbolLocations[0].y - pointYValue) < Math.abs(closetYValue - pointYValue)) {
            closestXValue = Math.abs(pointXValue - data.point.symbolLocations[0].x);
            closetYValue = data.point.symbolLocations[0].y;
            tempData = data;
          }
          lastData = data.series.category === "TrendLine" && chart.tooltip.shared ? lastData : tempData || data;
          dataCollection.push(data);
        }
        i++;
      }
      if (!chart.tooltip.showNearestPoint) {
        var collection = [];
        this.currentPoints = [];
        argument.point = [];
        argument.series = [];
        argument.data = [];
        argument.text = [];
        for (var _b = 0, dataCollection_1 = dataCollection; _b < dataCollection_1.length; _b++) {
          var data_1 = dataCollection_1[_b];
          if (data_1.point.symbolLocations[0].x === lastData.point.symbolLocations[0].x || (data_1.series.type.indexOf("Column") !== -1 || lastData.series.type.indexOf("Column") !== -1) && data_1.point.xValue === lastData.point.xValue) {
            argument.point.push(data_1.point);
            argument.series.push(data_1.series);
            argument.text.push(this.getTooltipText(data_1));
            argument.headerText = this.findHeader(data_1);
            collection.push(data_1);
            argument.data.push({
              pointX: data_1.point.x,
              pointY: data_1.point.y,
              seriesIndex: data_1.series.index,
              seriesName: data_1.series.name,
              pointIndex: data_1.point.index,
              pointText: data_1.point.text
            });
          }
        }
        dataCollection = collection;
        this.currentPoints = collection;
      }
      if (dataCollection.length > 0 && this.currentPoints.length > 0) {
        this.triggerSharedTooltip(argument, lastData, extraPoints, chart, isFirst, dataCollection);
      } else if (this.getElement(this.element.id + "_tooltip_path")) {
        this.getElement(this.element.id + "_tooltip_path").setAttribute("d", "");
      }
    };
    Tooltip3.prototype.triggerSharedTooltip = function(argument, point, extraPoints, chart, isFirst, dataCollection) {
      var _this = this;
      var tooltipTemplate = argument.template;
      var argsData = {
        cancel: false,
        name: sharedTooltipRender,
        text: argument.text,
        headerText: argument.headerText,
        textStyle: argument.textStyle,
        template: tooltipTemplate,
        point: argument.point,
        series: argument.series,
        data: argument.data
      };
      var borderWidth = this.chart.border.width;
      var padding = 3;
      var toolbarHeight;
      var titleHeight;
      var currentPoints = [];
      if (chart.stockChart) {
        toolbarHeight = chart.stockChart.enablePeriodSelector ? chart.stockChart.toolbarHeight : 0;
        titleHeight = measureText(this.chart.stockChart.title, this.chart.stockChart.titleStyle, this.chart.themeStyle.tooltipLabelFont).height + 10;
      }
      var sharedTooltip = function(argsData2) {
        if (!argsData2.cancel) {
          if (point.series.type === "BoxAndWhisker") {
            _this.removeText();
            isFirst = true;
          }
          for (var i = 0; i < argsData2.text.length; i++) {
            if (argsData2.text[i]) {
              currentPoints.push(_this.currentPoints[i]);
            }
          }
          _this.currentPoints = currentPoints;
          _this.formattedText = _this.formattedText.concat(argsData2.text);
          _this.text = argsData2.text;
          _this.headerText = argsData2.headerText;
          if (typeof argsData2.template != "object") {
            argsData2.template = argsData2.template.split(",");
            if (argsData2.template.length > currentPoints.length) {
              argsData2.template = argsData2.template.splice(argsData2.template.length - 1);
            }
          } else {
            if (argsData2.template.length > currentPoints.length) {
              argsData2.template.splice(argsData2.template.length - 1);
            }
          }
          var tooltip = _this.chart.tooltip;
          _this.findMouseValues(point, _this.chart, _this);
          var location_2 = _this.findSharedLocation();
          location_2 = location_2 ? location_2 : new ChartLocation(null, null);
          location_2.x = tooltip.location.x !== null ? tooltip.location.x : location_2.x;
          location_2.y = tooltip.location.y !== null ? tooltip.location.y : location_2.y;
          location_2 = location_2.x === null && location_2.y === null ? null : location_2;
          _this.createTooltip(chart, isFirst, location_2, _this.currentPoints.length === 1 ? _this.currentPoints[0].series.clipRect : null, dataCollection.length === 1 ? dataCollection[0].point : null, _this.findShapes(), _this.findMarkerHeight(_this.currentPoints[0]), new Rect(borderWidth, chart.stockChart ? toolbarHeight + titleHeight + borderWidth : borderWidth, _this.chart.availableSize.width - padding - borderWidth * 2, _this.chart.availableSize.height - padding - borderWidth * 2), _this.chart.crosshair.enable, extraPoints, _this.template ? _this.getTemplateText(dataCollection) : null, _this.template ? argsData2.template.join("") : "");
          point = null;
        } else {
          removeElement2(_this.element.id + "_tooltip");
          extraPoints.push(point);
        }
      };
      sharedTooltip.bind(this, point, extraPoints);
      this.chart.trigger(sharedTooltipRender, argsData, sharedTooltip);
    };
    Tooltip3.prototype.findSharedLocation = function() {
      var stockChart = this.chart.stockChart;
      if (stockChart) {
        if (this.text.length === 1) {
          this.text.push("");
        }
        var toolbarHeight = stockChart.enablePeriodSelector ? stockChart.toolbarHeight : 0;
        var element = document.getElementById(stockChart.element.id + "_ChartTitle");
        var titleHeight = stockChart.title !== "" ? element.getBoundingClientRect().height + 10 : 0;
        if (stockChart.tooltip.position === "Nearest") {
          return new ChartLocation(this.valueX, this.valueY + toolbarHeight + titleHeight);
        }
        return new ChartLocation(this.chart.chartAxisLayoutPanel.seriesClipRect.x + 5, this.chart.chartAxisLayoutPanel.seriesClipRect.y + toolbarHeight + 5 + titleHeight);
      } else {
        if (this.currentPoints.length > 1) {
          return new ChartLocation(this.valueX, this.valueY);
        } else {
          return this.getSymbolLocation(this.currentPoints[0]);
        }
      }
    };
    Tooltip3.prototype.getBoxLocation = function(data) {
      var location = this.lierIndex > 3 ? data.point.outliers.length > 0 ? data.point.symbolLocations[this.lierIndex - 4] : null : {
        x: data.point.regions[0].x + data.point.regions[0].width / 2,
        y: data.point.regions[0].y + data.point.regions[0].height / 2
      };
      return location;
    };
    Tooltip3.prototype.parseTemplate = function(point, series, format, xAxis, yAxis) {
      var val;
      var textValue;
      var regExp = RegExp;
      for (var _i = 0, _a = Object.keys(point); _i < _a.length; _i++) {
        var dataValue = _a[_i];
        val = new regExp("${point." + dataValue + "}", "gm");
        format = format.replace(val.source, this.formatPointValue(point, val.source === "${point.x}" ? xAxis : yAxis, dataValue, val.source === "${point.x}", val.source === "${point.high}" || val.source === "${point.open}" || val.source === "${point.close}" || val.source === "${point.low}" || val.source === "${point.y}" || val.source === "${point.minimum}" || val.source === "${point.maximum}" || val.source === "${point.outliers}" || val.source === "${point.upperQuartile}" || val.source === "${point.lowerQuartile}" || val.source === "${point.median}"));
      }
      for (var _b = 0, _c = Object.keys(Object.getPrototypeOf(series)); _b < _c.length; _b++) {
        var dataValue = _c[_b];
        val = new regExp("${series." + dataValue + "}", "gm");
        textValue = series[dataValue];
        format = format.replace(val.source, textValue);
      }
      return format;
    };
    Tooltip3.prototype.formatPointValue = function(point, axis, dataValue, isXPoint, isYPoint) {
      var textValue;
      var customLabelFormat;
      var value;
      if (axis.valueType !== "Category" && isXPoint) {
        customLabelFormat = axis.labelFormat && axis.labelFormat.match("{value}") !== null;
        var formattedValue = axis.valueType === "Double" ? +point[dataValue] : point[dataValue];
        textValue = customLabelFormat ? axis.labelFormat.replace("{value}", axis.format(formattedValue)) : axis.format(formattedValue);
      } else if (isYPoint && !isNullOrUndefined(point[dataValue])) {
        customLabelFormat = axis.labelFormat && axis.labelFormat.match("{value}") !== null;
        value = dataValue === "outliers" ? axis.format(point[dataValue][this.lierIndex - 4]) : axis.format(+point[dataValue]);
        textValue = customLabelFormat ? axis.labelFormat.replace("{value}", value) : value;
      } else if (dataValue === "size") {
        var format = this.chart.intl.getNumberFormat({
          format: "",
          useGrouping: this.chart.useGroupingSeparator
        });
        textValue = typeof point[dataValue] === "number" ? format(point[dataValue]) : point[dataValue];
        textValue = textValue ? textValue : "";
      } else {
        textValue = point[dataValue];
      }
      return textValue;
    };
    Tooltip3.prototype.getFormat = function(chart, series) {
      if (series.tooltipFormat) {
        if (series.seriesType === "XY" && series.category === "Indicator") {
          return this.getIndicatorTooltipFormat(series, chart, chart.tooltip.format);
        }
        return series.tooltipFormat;
      }
      if (!series.tooltipFormat && chart.tooltip.format) {
        if (series.seriesType === "XY" && series.category === "Indicator") {
          return this.getIndicatorTooltipFormat(series, chart, chart.tooltip.format);
        }
        return chart.tooltip.format;
      }
      var textX = series.type === "Histogram" ? "${point.minimum}-${point.maximum}" : "${point.x}";
      var format = !chart.tooltip.shared ? textX : "${series.name}";
      switch (series.seriesType) {
        case "XY":
          if (series.category === "Indicator") {
            this.getIndicatorTooltipFormat(series, chart, chart.tooltip.format);
          }
          return format + " : " + (series.type === "Bubble" ? chart.theme.indexOf("Tailwind3") > -1 ? "${point.y}  Size : ${point.size}" : "<b>${point.y}</b>  Size : <b>${point.size}</b>" : chart.theme.indexOf("Tailwind3") > -1 ? "${point.y}" : "<b>${point.y}</b>");
        case "HighLow":
          return format + "<br/>High : <b>${point.high}</b><br/>Low : <b>${point.low}</b>";
        case "HighLowOpenClose":
          return format + "<br/>High : <b>${point.high}</b><br/>Low : <b>${point.low}</b><br/>Open : <b>${point.open}</b><br/>Close : <b>${point.close}</b>";
        case "BoxPlot": {
          return format + "<br/>" + (this.lierIndex > 3 ? "Outliers : <b>${point.outliers}</b>" : "Maximum : <b>${point.maximum}</b><br/>Q3 : <b>${point.upperQuartile}</b><br/>Median : <b>${point.median}</b><br/>Q1 : <b>${point.lowerQuartile}</b><br/>Minimum : <b>${point.minimum}</b>");
        }
      }
    };
    Tooltip3.prototype.getIndicatorTooltipFormat = function(series, chart, format) {
      var toolTip;
      if (series.seriesType === "XY") {
        toolTip = series.name + " : <b>${point.y}</b>";
      } else {
        toolTip = format;
      }
      return toolTip;
    };
    Tooltip3.prototype.removeHighlightedMarker = function(data, fadeOut) {
      for (var _i = 0, data_2 = data; _i < data_2.length; _i++) {
        var item = data_2[_i];
        removeElement2(this.element.id + "_Series_" + item.series.index + "_Point_" + item.point.index + "_Trackball");
        if (this.chart.markerRender) {
          this.chart.markerRender.removeHighlightedMarker(item.series, item.point, fadeOut);
        }
      }
      this.previousPoints = [];
    };
    Tooltip3.prototype.getModuleName = function() {
      return "Tooltip";
    };
    Tooltip3.prototype.destroy = function() {
    };
    return Tooltip3;
  }(BaseTooltip)
);

// node_modules/@syncfusion/ej2-charts/src/chart/user-interaction/zooming-toolkit.js
var Toolkit = (
  /** @class */
  function() {
    function Toolkit2(chart) {
      this.iconRectOverFill = "transparent";
      this.iconRectSelectionFill = "transparent";
      this.zoomCompleteEvtCollection = [];
      this.isZoomed = false;
      this.chart = chart;
      this.elementId = chart.element.id;
      this.chart.svgRenderer = new SvgRenderer(this.elementId);
    }
    Toolkit2.prototype.createPanButton = function(childElement, parentElement) {
      var render = this.chart.svgRenderer;
      var fillColor = this.chart.zoomModule.isPanning ? this.chart.themeStyle.toolkitSelectionColor : this.chart.themeStyle.toolkitFill;
      var direction = "M5,3h2.3L7.275,5.875h1.4L8.65,3H11L8,0L5,3z M3,11V8.7l2.875,0.025v-1.4L3,7.35V5L0,8L3,";
      direction += "11z M11,13H8.7l0.025-2.875h-1.4L7.35,13H5l3,3L11,13z M13,5v2.3l-2.875-0.025v1.4L13,8.65V11l3-3L13,5z";
      this.elementOpacity = !this.chart.zoomModule.isZoomed && this.chart.zoomSettings.showToolbar ? "0.2" : "1";
      childElement.setAttribute("opacity", this.chart.theme === "Fluent2HighContrast" ? "1" : this.elementOpacity);
      childElement.id = this.elementId + "_Zooming_Pan";
      childElement.setAttribute("role", this.chart.zoomSettings.accessibility.accessibilityRole ? this.chart.zoomSettings.accessibility.accessibilityRole : "button");
      childElement.setAttribute("tabindex", this.chart.zoomSettings.accessibility.focusable ? String(this.chart.zoomSettings.accessibility.tabIndex) : "-1");
      childElement.setAttribute("aria-label", this.chart.zoomSettings.accessibility.accessibilityDescription ? this.chart.zoomSettings.accessibility.accessibilityDescription : this.chart.getLocalizedLabel("Pan"));
      this.panElements = childElement;
      childElement.appendChild(render.drawRectangle(new RectOption(this.elementId + "_Zooming_Pan_1", "transparent", {}, 1, this.chart.themeStyle.toolkitIconRect, this.chart.theme.indexOf("Fluent2") > -1 || this.chart.theme.indexOf("Bootstrap5") > -1 ? 4 : 0, this.chart.theme.indexOf("Fluent2") > -1 || this.chart.theme.indexOf("Bootstrap5") > -1 ? 4 : 0)));
      childElement.appendChild(render.drawPath(new PathOption(this.elementId + "_Zooming_Pan_2", this.chart.theme === "Fluent2HighContrast" && this.elementOpacity === "0.2" ? "#3FF23F" : fillColor, null, null, 1, null, direction)));
      parentElement.appendChild(childElement);
      this.wireEvents(childElement, this.pan);
    };
    Toolkit2.prototype.createZoomButton = function(childElement, parentElement) {
      var render = this.chart.svgRenderer;
      var fillColor = this.chart.zoomModule.isPanning || !this.chart.zoomModule.isZoomed && this.chart.zoomSettings.showToolbar ? this.chart.themeStyle.toolkitFill : this.chart.themeStyle.toolkitSelectionColor;
      this.elementOpacity = !this.chart.zoomModule.isPanning && !this.chart.zoomModule.isZoomed && this.chart.zoomSettings.showToolbar ? "0.2" : "1";
      var rectColor = this.chart.zoomModule.isPanning ? "transparent" : this.chart.themeStyle.toolkitIconRectSelectionFill;
      var direction = "M0.001,14.629L1.372,16l4.571-4.571v-0.685l0.228-0.274c1.051,0.868,2.423,1.417,3.885,1.417c3.291,0,";
      direction += "5.943-2.651,5.943-5.943S13.395,0,10.103,0S4.16,2.651,4.16,5.943c0,1.508,0.503,2.834,1.417,3.885l-0.274,0.228H4.571";
      direction = direction + "L0.001,14.629L0.001,14.629z M5.943,5.943c0-2.285,1.828-4.114,4.114-4.114s4.114,1.828,4.114,";
      childElement.id = this.elementId + "_Zooming_Zoom";
      childElement.setAttribute("role", this.chart.zoomSettings.accessibility.accessibilityRole ? this.chart.zoomSettings.accessibility.accessibilityRole : "button");
      childElement.setAttribute("tabindex", this.chart.zoomSettings.accessibility.focusable ? String(this.chart.zoomSettings.accessibility.tabIndex) : "-1");
      childElement.setAttribute("aria-label", this.chart.zoomSettings.accessibility.accessibilityDescription ? this.chart.zoomSettings.accessibility.accessibilityDescription : this.chart.getLocalizedLabel("Zoom"));
      childElement.setAttribute("opacity", this.elementOpacity);
      this.zoomElements = childElement;
      this.selectedID = this.chart.zoomModule.isPanning ? this.chart.element.id + "_Zooming_Pan_1" : this.elementId + "_Zooming_Zoom_1";
      childElement.appendChild(render.drawRectangle(new RectOption(this.elementId + "_Zooming_Zoom_1", rectColor, {}, 1, this.chart.themeStyle.toolkitIconRect, this.chart.theme.indexOf("Fluent2") > -1 || this.chart.theme.indexOf("Bootstrap5") > -1 ? 4 : 0, this.chart.theme.indexOf("Fluent2") > -1 || this.chart.theme.indexOf("Bootstrap5") > -1 ? 4 : 0)));
      childElement.appendChild(render.drawPath(new PathOption(this.elementId + "_Zooming_Zoom_3", fillColor, null, null, 1, null, direction + "4.114s-1.828,4.114-4.114,4.114S5.943,8.229,5.943,5.943z")));
      parentElement.appendChild(childElement);
      this.wireEvents(childElement, this.zoom);
    };
    Toolkit2.prototype.createZoomInButton = function(childElement, parentElement, chart) {
      var render = this.chart.svgRenderer;
      var fillColor = this.chart.themeStyle.toolkitFill;
      var direction = "M10.103,0C6.812,0,4.16,2.651,4.16,5.943c0,1.509,0.503,2.834,1.417,3.885l-0.274,0.229H4.571L0,";
      direction += "14.628l0,0L1.372,16l4.571-4.572v-0.685l0.228-0.275c1.052,0.868,2.423,1.417,3.885,1.417c3.291,0,5.943-2.651,";
      direction += "5.943-5.943C16,2.651,13.395,0,10.103,0z M10.058,10.058c-2.286,0-4.114-1.828-4.114-4.114c0-2.286,1.828-4.114,";
      childElement.id = this.elementId + "_Zooming_ZoomIn";
      childElement.setAttribute("role", this.chart.zoomSettings.accessibility.accessibilityRole ? this.chart.zoomSettings.accessibility.accessibilityRole : "button");
      childElement.setAttribute("tabindex", this.chart.zoomSettings.accessibility.focusable ? String(this.chart.zoomSettings.accessibility.tabIndex) : "-1");
      childElement.setAttribute("aria-label", this.chart.zoomSettings.accessibility.accessibilityDescription ? this.chart.zoomSettings.accessibility.accessibilityDescription : this.chart.getLocalizedLabel("ZoomIn"));
      var polygonDirection = "12.749,5.466 10.749,5.466 10.749,3.466 9.749,3.466 9.749,5.466 7.749,5.466 7.749,6.466";
      childElement.appendChild(render.drawRectangle(new RectOption(this.elementId + "_Zooming_ZoomIn_1", "transparent", {}, 1, this.chart.themeStyle.toolkitIconRect, this.chart.theme.indexOf("Fluent2") > -1 ? 4 : this.chart.theme.indexOf("Bootstrap5") > -1 ? 2 : 0, this.chart.theme.indexOf("Fluent2") > -1 ? 4 : this.chart.theme.indexOf("Bootstrap5") > -1 ? 2 : 0)));
      childElement.appendChild(render.drawPath(new PathOption(this.elementId + "_Zooming_ZoomIn_2", fillColor, null, null, 1, null, direction + "4.114-4.114c2.286,0,4.114,1.828,4.114,4.114C14.172,8.229,12.344,10.058,10.058,10.058z")));
      childElement.appendChild(render.drawPolygon(new PolygonOption(this.elementId + "_Zooming_ZoomIn_3", polygonDirection + " 9.749,6.466 9.749,8.466 10.749,8.466 10.749,6.466 12.749,6.466", fillColor)));
      this.zoomInElements = childElement;
      this.elementOpacity = chart.zoomModule.isPanning || !chart.zoomModule.isZoomed && !chart.zoomSettings.showToolbar && !this.enableZoomButton ? "0.2" : "1";
      childElement.setAttribute("opacity", this.elementOpacity);
      parentElement.appendChild(childElement);
      this.wireEvents(childElement, this.zoomIn);
    };
    Toolkit2.prototype.createZoomOutButton = function(childElement, parentElement, chart) {
      var render = this.chart.svgRenderer;
      var fillColor = this.chart.themeStyle.toolkitFill;
      var direction = "M0,14.622L1.378,16l4.533-4.533v-0.711l0.266-0.266c1.022,0.889,2.4,1.422,3.866,";
      direction += "1.422c3.289,0,5.955-2.666,5.955-5.955S13.333,0,10.044,0S4.089,2.667,4.134,5.911c0,1.466,0.533,2.844,";
      direction += "1.422,3.866l-0.266,0.266H4.578L0,14.622L0,14.622z M5.911,5.911c0-2.311,1.822-4.133,4.133-4.133s4.133,1.822,4.133,";
      childElement.id = this.elementId + "_Zooming_ZoomOut";
      childElement.setAttribute("role", this.chart.zoomSettings.accessibility.accessibilityRole ? this.chart.zoomSettings.accessibility.accessibilityRole : "button");
      childElement.setAttribute("tabindex", this.chart.zoomSettings.accessibility.focusable ? String(this.chart.zoomSettings.accessibility.tabIndex) : "-1");
      childElement.setAttribute("aria-label", this.chart.zoomSettings.accessibility.accessibilityDescription ? this.chart.zoomSettings.accessibility.accessibilityDescription : this.chart.getLocalizedLabel("ZoomOut"));
      childElement.appendChild(render.drawRectangle(new RectOption(this.elementId + "_Zooming_ZoomOut_1", "transparent", {}, 1, this.chart.themeStyle.toolkitIconRect, this.chart.theme.indexOf("Fluent2") > -1 || this.chart.theme.indexOf("Bootstrap5") > -1 ? 4 : 0, this.chart.theme.indexOf("Fluent2") > -1 || this.chart.theme.indexOf("Bootstrap5") > -1 ? 4 : 0)));
      childElement.appendChild(render.drawPath(new PathOption(this.elementId + "_Zooming_ZoomOut_2", chart.theme === "Fluent2HighContrast" && !chart.zoomModule.isZoomed || chart.theme === "Fluent2HighContrast" && chart.zoomModule.isPanning ? "#3FF23F" : fillColor, null, null, 1, null, direction + "4.133s-1.866,4.133-4.133,4.133S5.911,8.222,5.911,5.911z M12.567,6.466h-5v-1h5V6.466z")));
      this.zoomOutElements = childElement;
      this.elementOpacity = chart.zoomModule.isPanning || !chart.zoomModule.isZoomed && chart.zoomSettings.showToolbar && !this.enableZoomButton ? "0.2" : "1";
      childElement.setAttribute("opacity", chart.theme === "Fluent2HighContrast" ? "1" : this.elementOpacity);
      parentElement.appendChild(childElement);
      this.wireEvents(childElement, this.zoomOut);
    };
    Toolkit2.prototype.createResetButton = function(childElement, parentElement, chart, isDevice) {
      var render = this.chart.svgRenderer;
      var fillColor = this.chart.themeStyle.toolkitFill;
      var size;
      var direction = "M12.364,8h-2.182l2.909,3.25L16,8h-2.182c0-3.575-2.618-6.5-5.818-6.5c-1.128,0-2.218,0.366-3.091,";
      direction += "1.016l1.055,1.178C6.581,3.328,7.272,3.125,8,3.125C10.4,3.125,12.363,5.319,12.364,8L12.364,8z M11.091,";
      direction += "13.484l-1.055-1.178C9.419,12.672,8.728,12.875,8,12.875c-2.4,0-4.364-2.194-4.364-4.875h2.182L2.909,4.75L0,8h2.182c0,";
      childElement.id = this.elementId + "_Zooming_Reset";
      childElement.setAttribute("role", this.chart.zoomSettings.accessibility.accessibilityRole ? this.chart.zoomSettings.accessibility.accessibilityRole : "button");
      childElement.setAttribute("tabindex", this.chart.zoomSettings.accessibility.focusable ? String(this.chart.zoomSettings.accessibility.tabIndex) : "-1");
      childElement.setAttribute("aria-label", this.chart.zoomSettings.accessibility.accessibilityDescription ? this.chart.zoomSettings.accessibility.accessibilityDescription : this.chart.getLocalizedLabel("Reset"));
      this.elementOpacity = !chart.zoomModule.isZoomed && chart.zoomSettings.showToolbar ? "0.2" : "1";
      childElement.setAttribute("opacity", chart.theme === "Fluent2HighContrast" ? "1" : this.elementOpacity);
      if (!isDevice) {
        childElement.appendChild(render.drawRectangle(new RectOption(this.elementId + "_Zooming_Reset_1", "transparent", {}, 1, this.chart.themeStyle.toolkitIconRect, this.chart.theme.indexOf("Fluent2") > -1 || this.chart.theme.indexOf("Bootstrap5") > -1 ? 4 : 0, this.chart.theme.indexOf("Fluent2") > -1 || this.chart.theme.indexOf("Bootstrap5") > -1 ? 4 : 0)));
        childElement.appendChild(render.drawPath(new PathOption(this.elementId + "_Zooming_Reset_2", chart.theme === "Fluent2HighContrast" && this.elementOpacity === "0.2" ? "#3FF23F" : fillColor, null, null, 1, null, direction + "3.575,2.618,6.5,5.818,6.5C9.128,14.5,10.219,14.134,11.091,13.484L11.091,13.484z")));
      } else {
        size = measureText(this.chart.getLocalizedLabel("ResetZoom"), {
          size: "12px"
        }, {
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400",
          fontFamily: "Segoe UI"
        });
        childElement.appendChild(render.drawRectangle(new RectOption(this.elementId + "_Zooming_Reset_1", "transparent", {}, 1, new Rect(0, 0, size.width, size.height))));
        textElement2(chart.renderer, new TextOption(this.elementId + "_Zooming_Reset_2", 0 + size.width / 2, 0 + size.height * 3 / 4, "middle", this.chart.getLocalizedLabel("ResetZoom"), "rotate(0,0,0)", "auto"), {
          size: "12px"
        }, this.chart.theme === "Material3Dark" || this.chart.theme === "Fluent2Dark" || this.chart.theme === "Fluent2HighContrast" ? "White" : "black", childElement, null, null, null, null, null, null, null, null, chart.enableCanvas, null, {
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400",
          fontFamily: "Segoe UI"
        });
      }
      parentElement.appendChild(childElement);
      this.wireEvents(childElement, this.reset);
    };
    Toolkit2.prototype.wireEvents = function(element, process) {
      EventHandler.add(element, "mousedown touchstart", process, this);
      EventHandler.add(element, "mouseover", this.showTooltip, this);
      EventHandler.add(element, "mouseout", this.removeTooltip, this);
      EventHandler.add(this.chart.element, "mousemove", this.mouseMoveHandler, this);
      EventHandler.add(this.chart.zoomModule.toolkitElements, "mousedown", this.mouseDownHandler, this);
      window.addEventListener("mouseup", this.mouseUpHandler.bind(this), true);
    };
    Toolkit2.prototype.mouseMoveHandler = function(e) {
      if (this.chart.zoomSettings.toolbarPosition.draggable) {
        if (this.isDragging) {
          this.performDragAndDrop(e);
        } else {
          this.chart.zoomModule.toolkitElements.setAttribute("cursor", e.target.id.indexOf("Zooming_Rect") > -1 ? "grab" : "none");
        }
      }
    };
    Toolkit2.prototype.mouseDownHandler = function(e) {
      if (this.chart.zoomSettings.toolbarPosition.draggable && !this.isDragging && e.target.id.indexOf("Zooming_Rect") > -1) {
        this.isDragging = true;
        this.chart.zoomModule.toolkitElements.setAttribute("cursor", "grabbing");
      }
    };
    Toolkit2.prototype.mouseUpHandler = function(e) {
      if (this.isDragging) {
        this.isDragging = false;
        this.chart.zoomModule.toolkitElements.setAttribute("cursor", e.target.id.indexOf("Zooming_Rect") > -1 ? "grab" : "none");
      }
    };
    Toolkit2.prototype.performDragAndDrop = function(e) {
      var elementWidth = this.chart.zoomModule.toolkitElements.getBoundingClientRect().width;
      var elementHeight = this.chart.zoomModule.toolkitElements.getBoundingClientRect().height;
      var toolkitShadowPadding = 2;
      var x = e.type.indexOf("touch") > -1 ? e.changedTouches[0].clientX : this.chart.mouseX;
      var y = e.type.indexOf("touch") > -1 ? e.changedTouches[0].clientY : this.chart.mouseY;
      var transX = Math.max(this.chart.border.width + toolkitShadowPadding, Math.min(x - elementWidth / 2, this.chart.availableSize.width - elementWidth - this.chart.border.width - toolkitShadowPadding));
      var transY = Math.max(this.chart.border.width + toolkitShadowPadding, Math.min(y - elementHeight / 2, this.chart.availableSize.height - elementHeight - this.chart.border.width - toolkitShadowPadding));
      if (x < this.chart.availableSize.width && y < this.chart.availableSize.height) {
        this.chart.zoomModule.toolkitElements.setAttribute("transform", "translate(" + transX + "," + transY + ")");
        this.dragHorizontalRatio = transX / this.chart.availableSize.width;
        this.dragVerticalRatio = transY / this.chart.availableSize.height;
      }
    };
    Toolkit2.prototype.showTooltip = function(event2) {
      var text = event2.currentTarget.id.split("_Zooming_")[1];
      var left = event2.pageX - (measureText(text, {
        size: "10px"
      }, {
        size: "10px",
        fontStyle: "Normal",
        fontWeight: "400",
        fontFamily: "Segoe UI"
      }).width + 5);
      var rect = getElement2(event2.currentTarget.id + "_1");
      var icon2 = getElement2(event2.currentTarget.id + "_2");
      var icon3 = getElement2(event2.currentTarget.id + "_3");
      if (event2.currentTarget.getAttribute("opacity") === "1") {
        event2.currentTarget.setAttribute("cursor", "pointer");
      } else {
        event2.currentTarget.setAttribute("cursor", "auto");
      }
      if (rect) {
        this.hoveredID = rect.id;
        rect.setAttribute("fill", this.chart.theme === "Fluent2HighContrast" && event2.currentTarget.childNodes[1].getAttribute("fill") === "#3FF23F" ? "transparent" : this.chart.themeStyle.toolkitIconRectOverFill);
      }
      if (icon2) {
        icon2.setAttribute("fill", this.chart.theme === "Fluent2HighContrast" && event2.currentTarget.childNodes[1].getAttribute("fill") === "#3FF23F" ? "#3FF23F" : this.chart.themeStyle.toolkitSelectionColor);
      }
      if (icon3) {
        icon3.setAttribute("fill", this.chart.theme === "Fluent2HighContrast" && event2.currentTarget.childNodes[1].getAttribute("fill") === "#3FF23F" ? "#3FF23F" : this.chart.themeStyle.toolkitSelectionColor);
      }
      if (!this.chart.isTouch && !this.isDragging) {
        createTooltip("EJ2_Chart_ZoomTip", this.chart.getLocalizedLabel(text), event2.pageY + 10, left, "10px");
      }
    };
    Toolkit2.prototype.removeTooltip = function() {
      if (this.hoveredID && getElement2(this.hoveredID)) {
        var rectColor = this.chart.zoomModule.isPanning ? this.hoveredID.indexOf("_Pan_") > -1 ? this.chart.themeStyle.toolkitIconRectSelectionFill : "transparent" : this.hoveredID.indexOf("_Zoom_") > -1 && this.elementOpacity !== "0.2" && this.chart.theme !== "Fluent2HighContrast" ? this.chart.themeStyle.toolkitIconRectSelectionFill : "transparent";
        getElement2(this.hoveredID).setAttribute("fill", rectColor);
      }
      var icon2 = this.hoveredID ? getElement2(this.hoveredID.replace("_1", "_2")) : null;
      var icon3 = this.hoveredID ? getElement2(this.hoveredID.replace("_1", "_3")) : null;
      if (icon2) {
        var iconColor = this.chart.zoomModule.isPanning ? this.hoveredID.indexOf("_Pan_") > -1 ? this.chart.themeStyle.toolkitSelectionColor : this.elementOpacity === "0.2" && this.chart.theme === "Fluent2HighContrast" && getElement2(this.hoveredID).nextElementSibling.getAttribute("fill") === "#3FF23F" ? "#3FF23F" : this.elementOpacity === "1" && this.chart.theme === "Tailwind3" ? "#212529" : this.chart.themeStyle.toolkitFill : this.hoveredID.indexOf("_Zoom_") > -1 ? this.chart.themeStyle.toolkitSelectionColor : this.chart.theme === "Fluent2HighContrast" && getElement2(this.hoveredID).nextElementSibling.getAttribute("fill") === "#3FF23F" ? "#3FF23F" : this.chart.theme === "Tailwind3Dark" && this.chart.zoomModule.isDevice ? "black" : this.chart.themeStyle.toolkitFill;
        icon2.setAttribute("fill", iconColor);
      }
      if (icon3) {
        var iconColor = this.chart.zoomModule.isPanning || !this.chart.isZoomed && this.chart.zoomSettings.showToolbar ? this.chart.theme === "Fluent2HighContrast" && getElement2(this.hoveredID).nextElementSibling.getAttribute("fill") === "#3FF23F" && this.elementOpacity === "1" ? "#3FF23F" : this.elementOpacity === "1" && this.chart.theme === "Tailwind3" ? "#212529" : this.chart.themeStyle.toolkitFill : this.hoveredID.indexOf("_Zoom_") > -1 ? this.chart.themeStyle.toolkitSelectionColor : this.chart.theme === "Fluent2HighContrast" && getElement2(this.hoveredID).nextElementSibling.getAttribute("fill") === "#3FF23F" ? "#3FF23F" : this.chart.themeStyle.toolkitFill;
        icon3.setAttribute("fill", iconColor);
      }
      removeElement2("EJ2_Chart_ZoomTip");
    };
    Toolkit2.prototype.reset = function(event2) {
      var _this = this;
      if (!this.chart.zoomModule.isZoomed) {
        return false;
      }
      var chart = this.chart;
      this.enableZoomButton = false;
      chart.redraw = chart.enableCanvas ? chart.redraw : chart.zoomSettings.enableAnimation;
      if (!chart.zoomModule.isDevice && chart.zoomModule.toolkitElements) {
        remove(chart.zoomModule.toolkitElements);
      } else if (event2.type === "touchstart") {
        event2.stopPropagation();
      }
      var argsData;
      this.removeTooltip();
      chart.svgObject.setAttribute("cursor", "auto");
      var zoomedAxisCollection = [];
      this.zoomCompleteEvtCollection = [];
      for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {
        var axis = _a[_i];
        argsData = {
          cancel: false,
          name: zoomComplete,
          axis,
          previousZoomFactor: axis.zoomFactor,
          previousZoomPosition: axis.zoomPosition,
          currentZoomFactor: 1,
          currentZoomPosition: 0,
          previousVisibleRange: axis.visibleRange,
          currentVisibleRange: null
        };
        axis.zoomFactor = 1;
        axis.zoomPosition = 0;
        if (axis.zoomingScrollBar) {
          axis.zoomingScrollBar.isScrollUI = false;
        }
        if (!argsData.cancel) {
          axis.zoomFactor = argsData.currentZoomFactor;
          axis.zoomPosition = argsData.currentZoomPosition;
          this.zoomCompleteEvtCollection.push(argsData);
        }
        zoomedAxisCollection.push({
          zoomFactor: axis.zoomFactor,
          zoomPosition: axis.zoomFactor,
          axisName: axis.name,
          axisRange: axis.visibleRange
        });
        if (chart.zoomModule.isDevice && !this.chart.isBlazor) {
          chart.trigger(zoomComplete, argsData);
        }
      }
      var zoomingEventArgs = {
        cancel: false,
        axisCollection: zoomedAxisCollection,
        name: onZooming
      };
      if (!zoomingEventArgs.cancel && this.chart.isBlazor) {
        this.chart.trigger(onZooming, zoomingEventArgs, function() {
          _this.setDefferedZoom(chart);
        });
        return false;
      } else {
        return this.setDefferedZoom(chart);
      }
    };
    Toolkit2.prototype.setDefferedZoom = function(chart) {
      chart.disableTrackTooltip = false;
      var chartDuration = chart.duration;
      chart.duration = 600;
      chart.zoomModule.isZoomed = chart.zoomModule.isPanning = chart.isChartDrag = chart.delayRedraw = false;
      chart.zoomModule.touchMoveList = chart.zoomModule.touchStartList = [];
      chart.zoomModule.pinchTarget = null;
      chart.zoomRedraw = chart.zoomSettings.enableAnimation;
      if (chart.redraw) {
        var zoomToolBar = getElement2(chart.element.id + "_Zooming_KitCollection");
        if (zoomToolBar) {
          zoomToolBar.remove();
        }
        if (chart.tooltipModule) {
          if (getElement2(chart.element.id + "_tooltip")) {
            getElement2(chart.element.id + "_tooltip").remove();
          }
          for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
            var series = _a[_i];
            if (!isNullOrUndefined(series) && (series.marker.visible || chart.tooltip.shared || series.type === "Scatter" || series.type === "Bubble")) {
              chart.markerRender.removeHighlightedMarker(series, null, true);
            }
          }
        }
      } else {
        chart.removeSvg();
      }
      chart.refreshAxis();
      chart.refreshBound();
      this.elementOpacity = "1";
      chart.duration = chartDuration;
      chart.redraw = false;
      return false;
    };
    Toolkit2.prototype.zoomIn = function() {
      this.zoomInOutCalculation(1, this.chart, this.chart.axisCollections, this.chart.zoomSettings.mode);
      return false;
    };
    Toolkit2.prototype.zoomOut = function() {
      this.enableZoomButton = false;
      this.zoomInOutCalculation(-1, this.chart, this.chart.axisCollections, this.chart.zoomSettings.mode);
      return false;
    };
    Toolkit2.prototype.zoom = function() {
      this.chart.zoomModule.isPanning = false;
      this.elementOpacity = "1";
      this.chart.svgObject.setAttribute("cursor", "auto");
      if (this.zoomInElements) {
        this.zoomInElements.setAttribute("opacity", this.elementOpacity);
      }
      this.elementOpacity = !this.chart.zoomModule.isZoomed && this.chart.zoomSettings.showToolbar ? "0.2" : "1";
      if (this.zoomOutElements) {
        this.zoomOutElements.setAttribute("opacity", this.elementOpacity);
      }
      this.applySelection(this.zoomElements.childNodes, this.chart.themeStyle.toolkitSelectionColor);
      if (this.chart.theme === "Fluent2HighContrast") {
        if (this.zoomInElements) {
          this.applySelection(this.zoomInElements.childNodes, this.chart.themeStyle.toolkitFill);
        }
        if (this.zoomOutElements) {
          this.applySelection(this.zoomOutElements.childNodes, this.chart.themeStyle.toolkitFill);
        }
      }
      if (this.panElements) {
        this.applySelection(this.panElements.childNodes, this.chart.theme === "Tailwind3Dark" ? "#FFFFFF" : "#737373");
      }
      if (getElement2(this.selectedID)) {
        getElement2(this.selectedID).setAttribute("fill", "transparent");
      }
      this.selectedID = this.chart.element.id + "_Zooming_Zoom_1";
      getElement2(this.selectedID).setAttribute("fill", this.chart.themeStyle.toolkitIconRectSelectionFill);
      return false;
    };
    Toolkit2.prototype.pan = function() {
      if (!this.chart.zoomModule.isZoomed) {
        return false;
      }
      var element;
      this.chart.zoomModule.isPanning = true;
      this.chart.svgObject.setAttribute("cursor", "pointer");
      this.elementOpacity = "0.2";
      element = this.zoomInElements ? this.zoomInElements.setAttribute("opacity", this.elementOpacity) : null;
      element = this.zoomOutElements ? this.zoomOutElements.setAttribute("opacity", this.elementOpacity) : null;
      if (this.chart.theme === "Fluent2HighContrast") {
        var zoomOut = getElement2(this.chart.element.id + "_Zooming_ZoomOut");
        if (zoomOut) {
          zoomOut.setAttribute("opacity", "1");
        }
        var zoomIn = getElement2(this.chart.element.id + "_Zooming_ZoomIn");
        if (zoomIn) {
          zoomIn.setAttribute("opacity", "1");
        }
        var zoomOut2 = getElement2(this.chart.element.id + "_Zooming_ZoomOut_2");
        if (zoomOut2) {
          zoomOut2.setAttribute("fill", "#3FF23F");
        }
        var zoomIn2 = getElement2(this.chart.element.id + "_Zooming_ZoomIn_2");
        if (zoomIn2) {
          zoomIn2.setAttribute("fill", "#3FF23F");
        }
        var zoomIn3 = getElement2(this.chart.element.id + "_Zooming_ZoomIn_3");
        if (zoomIn3) {
          zoomIn3.setAttribute("fill", "#3FF23F");
        }
      }
      element = this.panElements ? this.applySelection(this.panElements.childNodes, this.chart.themeStyle.toolkitSelectionColor) : null;
      element = this.zoomElements ? this.applySelection(this.zoomElements.childNodes, this.chart.theme === "Tailwind3Dark" ? "#FFFFFF" : "#737373") : null;
      if (getElement2(this.selectedID)) {
        getElement2(this.selectedID).setAttribute("fill", "transparent");
      }
      this.selectedID = this.chart.element.id + "_Zooming_Pan_1";
      getElement2(this.selectedID).setAttribute("fill", this.chart.themeStyle.toolkitIconRectSelectionFill);
      return false;
    };
    Toolkit2.prototype.zoomInOutCalculation = function(scale, chart, axes, mode) {
      var _this = this;
      this.isZoomed = true;
      if (chart.zoomSettings.showToolbar) {
        this.elementOpacity = this.zoomInElements.getAttribute("opacity");
      }
      if (!chart.zoomModule.isPanning && this.elementOpacity !== "0.2") {
        if (chart.zoomSettings.showToolbar && !chart.isZoomed) {
          chart.zoomModule.isZoomed = true;
        }
        var zoomFactor = void 0;
        var zoomPosition = void 0;
        var cumulative = void 0;
        chart.disableTrackTooltip = true;
        chart.delayRedraw = true;
        var argsData = void 0;
        this.zoomCompleteEvtCollection = [];
        var zoomedAxisCollection = [];
        for (var _i = 0, _a = axes; _i < _a.length; _i++) {
          var axis = _a[_i];
          argsData = {
            cancel: false,
            name: zoomComplete,
            axis,
            previousZoomFactor: axis.zoomFactor,
            previousZoomPosition: axis.zoomPosition,
            currentZoomFactor: axis.zoomFactor,
            currentZoomPosition: axis.zoomPosition,
            previousVisibleRange: axis.visibleRange,
            currentVisibleRange: null
          };
          if (axis.orientation === "Horizontal" && mode !== "Y" || axis.orientation === "Vertical" && mode !== "X") {
            cumulative = Math.max(Math.max(1 / minMax(axis.zoomFactor, 0, 1), 1) + 0.25 * scale, 1);
            zoomFactor = cumulative === 1 ? 1 : minMax(1 / cumulative, 0, 1);
            zoomPosition = cumulative === 1 ? 0 : axis.zoomPosition + (axis.zoomFactor - zoomFactor) * 0.5;
            if (axis.zoomPosition !== zoomPosition || axis.zoomFactor !== zoomFactor) {
              zoomFactor = zoomPosition + zoomFactor > 1 ? 1 - zoomPosition : zoomFactor;
            }
            argsData.currentZoomFactor = zoomFactor;
            argsData.currentZoomPosition = zoomPosition;
            if (!argsData.cancel) {
              axis.zoomFactor = argsData.currentZoomFactor;
              axis.zoomPosition = argsData.currentZoomPosition;
              this.zoomCompleteEvtCollection.push(argsData);
            }
            zoomedAxisCollection.push({
              zoomFactor: axis.zoomFactor,
              zoomPosition: axis.zoomFactor,
              axisName: axis.name,
              axisRange: axis.visibleRange
            });
          }
        }
        var zoomingEventArgs_1 = {
          cancel: false,
          axisCollection: zoomedAxisCollection,
          name: onZooming
        };
        this.chart.trigger(onZooming, zoomingEventArgs_1, function() {
          if (zoomingEventArgs_1.cancel) {
            var zoom = new Zoom(chart);
            zoom.zoomCancel(axes, _this.zoomCompleteEvtCollection);
          }
        });
      }
    };
    Toolkit2.prototype.applySelection = function(elements, color) {
      for (var i = 1, length_1 = elements.length; i < length_1; i++) {
        elements[i].setAttribute("fill", color);
      }
    };
    return Toolkit2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart/user-interaction/zooming.js
var Zoom = (
  /** @class */
  function() {
    function Zoom2(chart) {
      this.zoomCompleteEvtCollection = [];
      this.startPanning = false;
      this.chart = chart;
      this.isPointer = Browser.isPointer;
      this.browserName = Browser.info.name;
      this.wheelEvent = this.browserName === "mozilla" ? this.isPointer ? "mousewheel" : "DOMMouseScroll" : "mousewheel";
      this.cancelEvent = this.isPointer ? "pointerleave" : "mouseleave";
      this.addEventListener();
      this.isDevice = Browser.isDevice;
      var zooming = chart.zoomSettings;
      this.toolkit = new Toolkit(chart);
      this.zooming = zooming;
      this.elementId = chart.element.id;
      this.zoomingRect = new Rect(0, 0, 0, 0);
      this.zoomAxes = [];
      this.zoomkitOpacity = 1;
      this.isIOS = Browser.isIos || Browser.isIos7;
      this.isZoomed = this.performedUI = this.zooming.enablePan || this.chart.primaryXAxis.zoomFactor < 1 && this.chart.primaryXAxis.zoomPosition > 0 || this.chart.primaryYAxis.zoomFactor < 1 && this.chart.primaryYAxis.zoomPosition > 0 || this.isAxisZoomed(this.chart.axes);
      if (zooming.enableScrollbar) {
        chart.scrollElement = createElement("div", {
          id: chart.element.id + "_scrollElement"
        });
      }
    }
    Zoom2.prototype.renderZooming = function(e, chart, isTouch) {
      this.calculateZoomAxesRange(chart);
      if (this.zooming.enableSelectionZooming && (!isTouch || chart.isDoubleTap && this.touchStartList.length === 1) && (!this.isPanning || chart.isDoubleTap)) {
        this.isPanning = this.isDevice ? true : this.isPanning;
        this.performedUI = true;
        this.drawZoomingRectangle(chart);
      } else if (this.isPanning && chart.isChartDrag) {
        if (!isTouch || isTouch && this.touchStartList.length === 1) {
          this.pinchTarget = isTouch ? e.target : null;
          this.doPan(chart, chart.axisCollections);
        }
      }
    };
    Zoom2.prototype.drawZoomingRectangle = function(chart) {
      var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;
      var startLocation = new ChartLocation(chart.previousMouseMoveX, chart.previousMouseMoveY);
      var endLocation = new ChartLocation(chart.mouseX, chart.mouseY);
      var rect = this.zoomingRect = getRectLocation(startLocation, endLocation, areaBounds);
      if (rect.width > 0 && rect.height > 0) {
        this.isZoomed = true;
        chart.disableTrackTooltip = true;
        chart.svgObject.setAttribute("cursor", "crosshair");
        if (this.zooming.mode === "X") {
          rect.height = areaBounds.height;
          rect.y = areaBounds.y;
        } else if (this.zooming.mode === "Y") {
          rect.width = areaBounds.width;
          rect.x = areaBounds.x;
        }
        if (chart.tooltipModule) {
          chart.tooltipModule.removeTooltip(0);
          for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
            var series = _a[_i];
            if (!isNullOrUndefined(series) && (series.marker.visible || chart.tooltip.shared)) {
              chart.markerRender.removeHighlightedMarker(series, null, true);
            }
          }
        }
        if (chart.crosshairModule) {
          chart.crosshairModule.removeCrosshair(0);
        }
        var svg = chart.svgObject;
        if (this.chart.enableCanvas) {
          var secondaryElement = document.getElementById(this.chart.element.id + "_Secondary_Element");
          svg = this.chart.svgRenderer.createSvg({
            id: this.chart.element.id + "_zoomRect_svg",
            width: this.chart.availableSize.width,
            height: this.chart.availableSize.height
          });
          svg.style.cssText = "position: absolute; display:block; pointer-events: none";
          secondaryElement.appendChild(svg);
        }
        svg.appendChild(chart.svgRenderer.drawRectangle(new RectOption(this.elementId + "_ZoomArea", chart.themeStyle.selectionRectFill, {
          color: chart.themeStyle.selectionRectStroke,
          width: 1
        }, 1, rect, 0, 0, "", "3")));
      }
    };
    Zoom2.prototype.doPan = function(chart, axes, xDifference, yDifference) {
      var _this = this;
      if (xDifference === void 0) {
        xDifference = 0;
      }
      if (yDifference === void 0) {
        yDifference = 0;
      }
      if (chart.startMove && chart.crosshair.enable) {
        return null;
      }
      var currentScale;
      var offset;
      this.isZoomed = true;
      this.startPanning = true;
      this.offset = !chart.delayRedraw ? chart.chartAxisLayoutPanel.seriesClipRect : this.offset;
      chart.delayRedraw = true;
      this.zoomCompleteEvtCollection = [];
      chart.disableTrackTooltip = true;
      var argsData;
      var zoomedAxisCollection = [];
      for (var _i = 0, _a = axes; _i < _a.length; _i++) {
        var axis = _a[_i];
        argsData = {
          cancel: false,
          name: zoomComplete,
          axis,
          previousZoomFactor: axis.zoomFactor,
          previousZoomPosition: axis.zoomPosition,
          currentZoomFactor: axis.zoomFactor,
          currentZoomPosition: axis.zoomPosition,
          previousVisibleRange: axis.visibleRange,
          currentVisibleRange: null
        };
        currentScale = Math.max(1 / minMax(axis.zoomFactor, 0, 1), 1);
        if (axis.orientation === "Horizontal") {
          offset = (xDifference !== 0 ? xDifference : chart.previousMouseMoveX - chart.mouseX) / axis.rect.width / currentScale;
          argsData.currentZoomPosition = minMax(axis.zoomPosition + offset, 0, 1 - axis.zoomFactor);
        } else {
          offset = (yDifference !== 0 ? yDifference : chart.previousMouseMoveY - chart.mouseY) / axis.rect.height / currentScale;
          argsData.currentZoomPosition = minMax(axis.zoomPosition - offset, 0, 1 - axis.zoomFactor);
        }
        if (!argsData.cancel) {
          axis.zoomFactor = argsData.currentZoomFactor;
          axis.zoomPosition = argsData.currentZoomPosition;
          this.zoomCompleteEvtCollection.push(argsData);
        }
        zoomedAxisCollection.push({
          zoomFactor: axis.zoomFactor,
          zoomPosition: axis.zoomFactor,
          axisName: axis.name,
          axisRange: axis.visibleRange
        });
      }
      if (chart.tooltipModule) {
        var tooltipElement = getElement2(chart.element.id + "_tooltip");
        if (tooltipElement) {
          tooltipElement.remove();
        }
        for (var _b = 0, _c = chart.visibleSeries; _b < _c.length; _b++) {
          var series = _c[_b];
          if (!isNullOrUndefined(series) && (series.marker.visible || chart.tooltip.shared || series.type === "Scatter" || series.type === "Bubble")) {
            chart.markerRender.removeHighlightedMarker(series, null, true);
          }
        }
      }
      var zoomingEventArgs = {
        cancel: false,
        axisCollection: zoomedAxisCollection,
        name: onZooming
      };
      if (!zoomingEventArgs.cancel && this.chart.isBlazor) {
        this.chart.trigger(onZooming, zoomingEventArgs, function() {
          if (zoomingEventArgs.cancel) {
            _this.zoomCancel(axes, _this.zoomCompleteEvtCollection);
          } else {
            _this.performDefferedZoom(chart);
          }
        });
      } else {
        this.chart.trigger(onZooming, zoomingEventArgs, function() {
          if (zoomingEventArgs.cancel) {
            _this.zoomCancel(axes, _this.zoomCompleteEvtCollection);
          } else {
            _this.performDefferedZoom(chart);
            _this.redrawOnZooming(chart, false);
          }
        });
      }
    };
    Zoom2.prototype.performDefferedZoom = function(chart) {
      var translateX;
      var translateY;
      if (this.zooming.enableDeferredZooming) {
        translateX = chart.mouseX - chart.mouseDownX;
        translateY = chart.mouseY - chart.mouseDownY;
        switch (this.zooming.mode) {
          case "X":
            translateY = 0;
            break;
          case "Y":
            translateX = 0;
            break;
        }
        this.setTransform(translateX, translateY, null, null, chart, false);
        this.refreshAxis(chart.chartAxisLayoutPanel, chart, chart.axisCollections);
        if (chart.enableCanvas) {
          this.performZoomRedraw(chart);
        }
      } else {
        this.performZoomRedraw(chart);
      }
      chart.previousMouseMoveX = chart.mouseX;
      chart.previousMouseMoveY = chart.mouseY;
    };
    Zoom2.prototype.performZoomRedraw = function(chart) {
      var rect = this.zoomingRect;
      chart.animateSeries = false;
      if (this.isZoomed) {
        if (rect.width > 0 && rect.height > 0) {
          this.performedUI = true;
          chart.svgObject.setAttribute("cursor", "auto");
          this.doZoom(chart, chart.axisCollections, chart.chartAxisLayoutPanel.seriesClipRect);
          chart.isDoubleTap = false;
        } else if (chart.disableTrackTooltip) {
          chart.disableTrackTooltip = false;
          chart.delayRedraw = false;
          if (chart.enableCanvas) {
            chart.createChartSvg();
          } else {
            var zoomArea = getElement2(chart.element.id + "_ZoomArea");
            if (zoomArea) {
              zoomArea.remove();
            }
            var zoomToolBar = getElement2(chart.element.id + "_Zooming_KitCollection");
            if (zoomToolBar) {
              zoomToolBar.remove();
            }
            if (chart.tooltipModule) {
              if (getElement2(chart.element.id + "_tooltip")) {
                getElement2(chart.element.id + "_tooltip").remove();
              }
              for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
                var series = _a[_i];
                if (!isNullOrUndefined(series) && (series.marker.visible || chart.tooltip.shared || series.type === "Scatter" || series.type === "Bubble")) {
                  chart.markerRender.removeHighlightedMarker(series, null, true);
                }
              }
            }
          }
          var chartDuration = chart.duration;
          if (!(this.isPanning && (chart.isChartDrag || this.startPanning)) && !chart.enableCanvas) {
            chart.duration = 600;
            chart.redraw = this.zooming.enableAnimation;
            chart.zoomRedraw = this.zooming.enableAnimation;
          }
          var highlightDataIndexes = [];
          if (chart.highlightModule && (chart.legendSettings.enableHighlight || chart.highlightMode !== "None") && chart.highlightModule.highlightDataIndexes) {
            highlightDataIndexes = chart.highlightModule.highlightDataIndexes;
          }
          chart.refreshAxis();
          chart.refreshBound();
          if (chart.highlightModule && (chart.legendSettings.enableHighlight || chart.highlightMode !== "None") && highlightDataIndexes) {
            chart.highlightModule.highlightDataIndexes = highlightDataIndexes;
          }
          if (!this.isZoomed) {
            chart.zoomRedraw = this.zooming.enableAnimation;
          }
          this.startPanning = false;
          chart.redraw = false;
          chart.duration = chartDuration;
          if (this.toolkit.isZoomed) {
            chart.zoomRedraw = false;
            this.toolkit.isZoomed = false;
          }
        }
      }
    };
    Zoom2.prototype.refreshAxis = function(layout, chart, axes) {
      var mode = chart.zoomSettings.mode;
      layout.measureAxis(new Rect(chart.initialClipRect.x, chart.initialClipRect.y, chart.initialClipRect.width, chart.initialClipRect.height));
      axes.map(function(axis, index) {
        if (axis.orientation === "Horizontal" && mode !== "Y") {
          layout.drawXAxisLabels(axis, index, null, axis.placeNextToAxisLine ? axis.updatedRect : axis.rect);
        }
        if (axis.orientation === "Vertical" && mode !== "X") {
          layout.drawYAxisLabels(axis, index, null, axis.placeNextToAxisLine ? axis.updatedRect : axis.rect);
        }
      });
    };
    Zoom2.prototype.doZoom = function(chart, axes, bounds) {
      var _this = this;
      var zoomRect = this.zoomingRect;
      var mode = this.zooming.mode;
      var argsData;
      this.isPanning = chart.zoomSettings.enablePan || this.isPanning;
      var zoomedAxisCollections = [];
      this.zoomCompleteEvtCollection = [];
      for (var _i = 0, _a = axes; _i < _a.length; _i++) {
        var axis = _a[_i];
        argsData = {
          cancel: false,
          name: zoomComplete,
          axis,
          previousZoomFactor: axis.zoomFactor,
          previousZoomPosition: axis.zoomPosition,
          currentZoomFactor: axis.zoomFactor,
          currentZoomPosition: axis.zoomPosition,
          previousVisibleRange: axis.visibleRange,
          currentVisibleRange: null
        };
        if (axis.orientation === "Horizontal") {
          if (mode !== "Y") {
            argsData.currentZoomPosition += Math.abs((zoomRect.x - bounds.x) / bounds.width) * axis.zoomFactor;
            argsData.currentZoomFactor *= zoomRect.width / bounds.width;
          }
        } else {
          if (mode !== "X") {
            argsData.currentZoomPosition += (1 - Math.abs((zoomRect.height + (zoomRect.y - bounds.y)) / bounds.height)) * axis.zoomFactor;
            argsData.currentZoomFactor *= zoomRect.height / bounds.height;
          }
        }
        if (parseFloat(argsData.currentZoomFactor.toFixed(3)) <= 1e-3) {
          argsData.currentZoomFactor = argsData.previousZoomFactor;
          argsData.currentZoomPosition = argsData.previousZoomPosition;
        }
        if (!argsData.cancel) {
          axis.zoomFactor = argsData.currentZoomFactor;
          axis.zoomPosition = argsData.currentZoomPosition;
          chart.zoomRedraw = this.zooming.enableAnimation;
          this.zoomCompleteEvtCollection.push(argsData);
        }
        zoomedAxisCollections.push({
          zoomFactor: axis.zoomFactor,
          zoomPosition: axis.zoomFactor,
          axisName: axis.name,
          axisRange: axis.visibleRange
        });
      }
      var onZoomingEventArg = {
        cancel: false,
        axisCollection: zoomedAxisCollections,
        name: onZooming
      };
      if (!onZoomingEventArg.cancel && this.chart.isBlazor) {
        this.chart.trigger(onZooming, onZoomingEventArg, function() {
          if (onZoomingEventArg.cancel) {
            _this.zoomCancel(axes, _this.zoomCompleteEvtCollection);
          } else {
            _this.zoomingRect = new Rect(0, 0, 0, 0);
            _this.performZoomRedraw(chart);
          }
        });
      } else {
        this.chart.trigger(onZooming, onZoomingEventArg, function() {
          if (onZoomingEventArg.cancel) {
            _this.zoomCancel(axes, _this.zoomCompleteEvtCollection);
          } else {
            _this.zoomingRect = new Rect(0, 0, 0, 0);
            _this.redrawOnZooming(chart);
          }
        });
      }
    };
    Zoom2.prototype.redrawOnZooming = function(chart, isRedraw, isMouseUp) {
      if (isRedraw === void 0) {
        isRedraw = true;
      }
      if (isMouseUp === void 0) {
        isMouseUp = false;
      }
      var zoomCompleteCollection = isMouseUp ? this.toolkit.zoomCompleteEvtCollection : this.zoomCompleteEvtCollection;
      if (isRedraw) {
        this.performZoomRedraw(chart);
      }
      var argsData;
      for (var i = 0; i < zoomCompleteCollection.length; i++) {
        if (!zoomCompleteCollection[i].cancel) {
          argsData = {
            cancel: false,
            name: zoomComplete,
            axis: chart.axisCollections[i],
            previousZoomFactor: zoomCompleteCollection[i].previousZoomFactor,
            previousZoomPosition: zoomCompleteCollection[i].previousZoomPosition,
            currentZoomFactor: chart.axisCollections[i].zoomFactor,
            currentZoomPosition: chart.axisCollections[i].zoomPosition,
            currentVisibleRange: chart.axisCollections[i].visibleRange,
            previousVisibleRange: zoomCompleteCollection[i].previousVisibleRange
          };
          chart.trigger(zoomComplete, argsData);
        }
      }
    };
    Zoom2.prototype.performMouseWheelZooming = function(e, mouseX, mouseY, chart, axes) {
      var _this = this;
      var direction = this.browserName === "mozilla" && !this.isPointer ? -e.detail / 3 > 0 ? 1 : -1 : e["wheelDelta"] > 0 ? 1 : -1;
      var mode = this.zooming.mode;
      var origin = 0.5;
      var cumulative;
      var zoomFactor;
      var zoomPosition;
      this.isZoomed = true;
      this.calculateZoomAxesRange(chart);
      chart.disableTrackTooltip = true;
      this.performedUI = true;
      this.isPanning = chart.zoomSettings.enablePan || this.isPanning;
      this.zoomCompleteEvtCollection = [];
      var argsData;
      var zoomedAxisCollection = [];
      for (var _i = 0, _a = axes; _i < _a.length; _i++) {
        var axis = _a[_i];
        argsData = {
          cancel: false,
          name: zoomComplete,
          axis,
          previousZoomFactor: axis.zoomFactor,
          previousZoomPosition: axis.zoomPosition,
          currentZoomFactor: axis.zoomFactor,
          currentZoomPosition: axis.zoomPosition,
          currentVisibleRange: null,
          previousVisibleRange: axis.visibleRange
        };
        if (axis.orientation === "Vertical" && mode !== "X" || axis.orientation === "Horizontal" && mode !== "Y") {
          cumulative = Math.max(Math.max(1 / minMax(axis.zoomFactor, 0, 1), 1) + 0.25 * direction, 1);
          cumulative = cumulative > 5e10 ? 5e10 : cumulative;
          if (cumulative >= 1) {
            origin = axis.orientation === "Horizontal" ? mouseX / axis.rect.width : 1 - mouseY / axis.rect.height;
            origin = origin > 1 ? 1 : origin < 0 ? 0 : origin;
            zoomFactor = cumulative === 1 ? 1 : minMax((direction > 0 ? 0.9 : 1.1) / cumulative, 0, 1);
            zoomPosition = cumulative === 1 ? 0 : axis.zoomPosition + (axis.zoomFactor - zoomFactor) * origin;
            if (axis.zoomPosition !== zoomPosition || axis.zoomFactor !== zoomFactor) {
              zoomFactor = zoomPosition + zoomFactor > 1 ? 1 - zoomPosition : zoomFactor;
            }
            if (parseFloat(argsData.currentZoomFactor.toFixed(3)) <= 1e-3) {
              argsData.currentZoomFactor = argsData.previousZoomFactor;
              argsData.currentZoomPosition = argsData.previousZoomPosition;
            } else {
              argsData.currentZoomFactor = zoomFactor;
              argsData.currentZoomPosition = zoomPosition;
            }
          }
          if (argsData.currentZoomFactor === argsData.previousZoomFactor && argsData.currentZoomPosition === argsData.previousZoomPosition) {
            chart.disableTrackTooltip = false;
          }
          if (!argsData.cancel) {
            axis.zoomFactor = argsData.currentZoomFactor;
            axis.zoomPosition = argsData.currentZoomPosition;
            chart.zoomRedraw = this.zooming.enableAnimation;
            this.zoomCompleteEvtCollection.push(argsData);
          }
        }
        zoomedAxisCollection.push({
          zoomFactor: axis.zoomFactor,
          zoomPosition: axis.zoomFactor,
          axisName: axis.name,
          axisRange: axis.visibleRange
        });
      }
      var onZoomingEventArgs = {
        cancel: false,
        axisCollection: zoomedAxisCollection,
        name: onZooming
      };
      if (!onZoomingEventArgs.cancel && this.chart.isBlazor) {
        this.chart.trigger(onZooming, onZoomingEventArgs, function() {
          if (onZoomingEventArgs.cancel) {
            _this.zoomCancel(axes, _this.zoomCompleteEvtCollection);
          } else {
            _this.performZoomRedraw(chart);
          }
        });
      } else {
        this.chart.trigger(onZooming, onZoomingEventArgs, function() {
          if (onZoomingEventArgs.cancel) {
            _this.zoomCancel(axes, _this.zoomCompleteEvtCollection);
          } else {
            _this.redrawOnZooming(chart);
          }
        });
      }
    };
    Zoom2.prototype.performPinchZooming = function(e, chart) {
      if (this.zoomingRect.width > 0 && this.zoomingRect.height > 0 || chart.startMove && chart.crosshair.enable) {
        return false;
      }
      this.calculateZoomAxesRange(chart);
      this.isZoomed = true;
      this.isPanning = true;
      this.performedUI = true;
      this.offset = !chart.delayRedraw ? chart.chartAxisLayoutPanel.seriesClipRect : this.offset;
      chart.delayRedraw = true;
      chart.disableTrackTooltip = true;
      var elementOffset = chart.element.getBoundingClientRect();
      var touchDown = this.touchStartList;
      var touchMove = this.touchMoveList;
      var touch0StartX = touchDown[0].pageX - elementOffset.left;
      var touch0StartY = touchDown[0].pageY - elementOffset.top;
      var touch0EndX = touchMove[0].pageX - elementOffset.left;
      var touch0EndY = touchMove[0].pageY - elementOffset.top;
      var touch1StartX = touchDown[1].pageX - elementOffset.left;
      var touch1StartY = touchDown[1].pageY - elementOffset.top;
      var touch1EndX = touchMove[1].pageX - elementOffset.left;
      var touch1EndY = touchMove[1].pageY - elementOffset.top;
      var scaleX = Math.abs(touch0EndX - touch1EndX) / Math.abs(touch0StartX - touch1StartX);
      var scaleY = Math.abs(touch0EndY - touch1EndY) / Math.abs(touch0StartY - touch1StartY);
      var clipX = (this.offset.x - touch0EndX) / scaleX + touch0StartX;
      var clipY = (this.offset.y - touch0EndY) / scaleY + touch0StartY;
      var pinchRect = new Rect(clipX, clipY, this.offset.width / scaleX, this.offset.height / scaleY);
      var translateXValue = touch0EndX - scaleX * touch0StartX;
      var translateYValue = touch0EndY - scaleY * touch0StartY;
      if (!isNaN(scaleX - scaleX) && !isNaN(scaleY - scaleY)) {
        switch (this.zooming.mode) {
          case "XY":
            this.setTransform(translateXValue, translateYValue, scaleX, scaleY, chart, true);
            break;
          case "X":
            this.setTransform(translateXValue, 0, scaleX, 1, chart, true);
            break;
          case "Y":
            this.setTransform(0, translateYValue, 1, scaleY, chart, true);
            break;
        }
      }
      if (!this.calculatePinchZoomFactor(chart, pinchRect)) {
        this.refreshAxis(chart.chartAxisLayoutPanel, chart, chart.axisCollections);
        this.redrawOnZooming(chart, false);
      }
      return true;
    };
    Zoom2.prototype.calculatePinchZoomFactor = function(chart, pinchRect) {
      var mode = this.zooming.mode;
      var selectionMin;
      var selectionMax;
      var rangeMin;
      var rangeMax;
      var value;
      var axisTrans;
      var argsData;
      var currentZF;
      var currentZP;
      var zoomedAxisCollection = [];
      this.zoomCompleteEvtCollection = [];
      for (var index = 0; index < chart.axisCollections.length; index++) {
        var axis = chart.axisCollections[index];
        if (axis.orientation === "Horizontal" && mode !== "Y" || axis.orientation === "Vertical" && mode !== "X") {
          currentZF = axis.zoomFactor;
          currentZP = axis.zoomPosition;
          argsData = {
            cancel: false,
            name: zoomComplete,
            axis,
            previousZoomFactor: axis.zoomFactor,
            previousZoomPosition: axis.zoomPosition,
            currentZoomFactor: currentZF,
            currentZoomPosition: currentZP,
            previousVisibleRange: axis.visibleRange,
            currentVisibleRange: null
          };
          if (axis.orientation === "Horizontal") {
            value = pinchRect.x - this.offset.x;
            axisTrans = axis.rect.width / this.zoomAxes[index].delta;
            rangeMin = value / axisTrans + this.zoomAxes[index].min;
            value = pinchRect.x + pinchRect.width - this.offset.x;
            rangeMax = value / axisTrans + this.zoomAxes[index].min;
          } else {
            value = pinchRect.y - this.offset.y;
            axisTrans = axis.rect.height / this.zoomAxes[index].delta;
            rangeMin = (value * -1 + axis.rect.height) / axisTrans + this.zoomAxes[index].min;
            value = pinchRect.y + pinchRect.height - this.offset.y;
            rangeMax = (value * -1 + axis.rect.height) / axisTrans + this.zoomAxes[index].min;
          }
          selectionMin = Math.min(rangeMin, rangeMax);
          selectionMax = Math.max(rangeMin, rangeMax);
          currentZP = (selectionMin - this.zoomAxes[index].actualMin) / this.zoomAxes[index].actualDelta;
          currentZF = (selectionMax - selectionMin) / this.zoomAxes[index].actualDelta;
          argsData.currentZoomPosition = currentZP < 0 ? 0 : currentZP;
          argsData.currentZoomFactor = currentZF > 1 ? 1 : currentZF < 0.03 ? 0.03 : currentZF;
          if (!argsData.cancel) {
            axis.zoomFactor = argsData.currentZoomFactor;
            axis.zoomPosition = argsData.currentZoomPosition;
            chart.zoomRedraw = this.zooming.enableAnimation;
            this.zoomCompleteEvtCollection.push(argsData);
          }
          zoomedAxisCollection.push({
            zoomFactor: axis.zoomFactor,
            zoomPosition: axis.zoomFactor,
            axisName: axis.name,
            axisRange: axis.visibleRange
          });
        }
      }
      var onZoomingEventArgs = {
        cancel: false,
        axisCollection: zoomedAxisCollection,
        name: onZooming
      };
      if (!onZoomingEventArgs.cancel) {
        this.chart.trigger(onZooming, onZoomingEventArgs);
        if (onZoomingEventArgs.cancel) {
          this.zoomCancel(chart.axisCollections, this.zoomCompleteEvtCollection);
          return true;
        }
      }
      return false;
    };
    Zoom2.prototype.setTransform = function(transX, transY, scaleX, scaleY, chart, isPinch) {
      if (!chart.enableCanvas) {
        chart.seriesElements.setAttribute("clip-path", "url(#" + this.elementId + "_ChartAreaClipRect_)");
      }
      if (chart.indicatorElements) {
        chart.indicatorElements.setAttribute("clip-path", "url(#" + this.elementId + "_ChartAreaClipRect_)");
      }
      var translate;
      var xAxisLoc;
      var yAxisLoc;
      var element;
      if (transX !== null && transY !== null) {
        for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
          var value = _a[_i];
          xAxisLoc = chart.requireInvertedAxis ? value.yAxis.rect.x : value.xAxis.rect.x;
          yAxisLoc = chart.requireInvertedAxis ? value.xAxis.rect.y : value.yAxis.rect.y;
          translate = "translate(" + (transX + (isPinch ? scaleX * xAxisLoc : xAxisLoc)) + "," + (transY + (isPinch ? scaleY * yAxisLoc : yAxisLoc)) + ")";
          translate = scaleX || scaleY ? translate + " scale(" + scaleX + " " + scaleY + ")" : translate;
          if (value.visible) {
            if (value.category === "Indicator") {
              value.seriesElement.parentNode.setAttribute("transform", translate);
            } else {
              if (!chart.enableCanvas) {
                value.seriesElement.setAttribute("transform", translate);
              }
            }
            element = getElement2(chart.element.id + "_Series_" + value.index + "_DataLabelCollections");
            if (value.errorBarElement) {
              value.errorBarElement.setAttribute("transform", translate);
            }
            if (value.symbolElement) {
              value.symbolElement.setAttribute("transform", translate);
            }
            if (value.textElement) {
              value.textElement.setAttribute("visibility", "hidden");
              value.shapeElement.setAttribute("visibility", "hidden");
            }
            if (element) {
              element.style.visibility = "hidden";
            }
          }
        }
      }
    };
    Zoom2.prototype.calculateZoomAxesRange = function(chart) {
      var range;
      var axisRange;
      for (var index = 0; index < chart.axisCollections.length; index++) {
        var axis = chart.axisCollections[index];
        axisRange = axis.visibleRange;
        if (this.zoomAxes[index]) {
          if (!chart.delayRedraw) {
            this.zoomAxes[index].min = axisRange.min;
            this.zoomAxes[index].delta = axisRange.delta;
          }
        } else {
          range = {
            actualMin: axis.actualRange.min,
            actualDelta: axis.actualRange.delta,
            min: axisRange.min,
            delta: axisRange.delta
          };
          this.zoomAxes[index] = range;
        }
      }
    };
    Zoom2.prototype.showZoomingToolkit = function(chart) {
      var toolboxItems = this.zooming.toolbarItems;
      var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;
      var spacing = 10;
      var render = chart.svgRenderer;
      var length = this.isDevice ? toolboxItems.length === 0 ? 0 : 1 : toolboxItems.length;
      var iconSize = this.isDevice ? measureText("Reset Zoom", {
        size: "12px"
      }, {
        size: "12px",
        fontStyle: "Normal",
        fontWeight: "400",
        fontFamily: "Segoe UI"
      }).width : 16;
      var height = this.isDevice ? measureText("Reset Zoom", {
        size: "12px"
      }, {
        size: "12px",
        fontStyle: "Normal",
        fontWeight: "400",
        fontFamily: "Segoe UI"
      }).height : chart.theme.indexOf("Fluent2") > -1 || chart.theme.indexOf("Bootstrap5") > -1 ? 18 : 22;
      var width = length * iconSize + (length + 1) * spacing + (length - 1) * spacing;
      var toolbarPosition = this.zooming.toolbarPosition;
      var transX;
      var transY;
      switch (toolbarPosition.horizontalAlignment) {
        case "Far":
          transX = areaBounds.x + areaBounds.width - width - spacing;
          break;
        case "Near":
          transX = areaBounds.x + spacing;
          break;
        case "Center":
          transX = areaBounds.width / 2 - width / 2 + areaBounds.x;
          break;
      }
      transX += toolbarPosition.x;
      switch (toolbarPosition.verticalAlignment) {
        case "Bottom":
          transY = areaBounds.height - areaBounds.y + height + spacing;
          break;
        case "Top":
          transY = areaBounds.y + spacing;
          break;
        case "Middle":
          transY = areaBounds.height / 2 - height / 2 + areaBounds.y;
          break;
      }
      var toolkitShadowPadding = 2;
      transY += toolbarPosition.y;
      transX = this.toolkit.dragHorizontalRatio != null ? Math.min(Math.max(this.chart.border.width + toolkitShadowPadding, this.toolkit.dragHorizontalRatio * this.chart.availableSize.width), this.chart.availableSize.width - width - this.chart.border.width - toolkitShadowPadding) : transX;
      transY = this.toolkit.dragVerticalRatio != null ? Math.min(Math.max(this.chart.border.width + toolkitShadowPadding, this.toolkit.dragVerticalRatio * this.chart.availableSize.height), this.chart.availableSize.height - height - this.chart.border.width - toolkitShadowPadding) : transY;
      var xPosition = spacing;
      var toolkit = this.toolkit;
      var element;
      var shadowElement = '<filter id="chart_shadow" height="130%"><feGaussianBlur in="SourceAlpha" stdDeviation="5"/>';
      shadowElement += '<feOffset dx="-3" dy="4" result="offsetblur"/><feComponentTransfer><feFuncA type="linear" slope="1"/>';
      shadowElement += '</feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge></filter>';
      if (length === 0 || getElement2(this.elementId + "_Zooming_KitCollection")) {
        return false;
      }
      var defElement = render.createDefs();
      toolboxItems = this.isDevice ? ["Reset"] : toolboxItems;
      defElement.innerHTML = shadowElement;
      this.toolkitElements = render.createGroup({
        id: this.elementId + "_Zooming_KitCollection",
        transform: "translate(" + transX + "," + transY + ")"
      });
      this.toolkitElements.appendChild(defElement);
      var zoomFillColor = this.chart.theme === "Tailwind3" ? "#F9FAFB" : this.chart.theme === "Fluent" ? "#F3F2F1" : this.chart.theme === "Material3" ? "#FFFFFF" : this.chart.theme === "Material3Dark" ? "#1C1B1F" : this.chart.theme === "Fluent2" ? "#F5F5F5" : this.chart.theme === "Fluent2Dark" ? "#141414" : chart.theme === "Fluent2HighContrast" ? "#000000" : chart.theme === "Bootstrap5" ? "#E9ECEF" : chart.theme === "Bootstrap5Dark" ? "#343A40" : chart.theme === "Tailwind3Dark" && !this.isDevice ? "#1D2432" : this.chart.theme === "Tailwind" ? "#F3F4F6" : "#fafafa";
      this.toolkitElements.appendChild(render.drawRectangle(new RectOption(this.elementId + "_Zooming_Rect", zoomFillColor, {
        color: "transparent",
        width: 1
      }, 1, new Rect(0, 0, width, height + spacing * 2), this.chart.theme.indexOf("Bootstrap5") > -1 ? 1 : 4, this.chart.theme.indexOf("Bootstrap5") > -1 ? 1 : 4)));
      var outerElement = render.drawRectangle(new RectOption(this.elementId + "_Zooming_Rect", zoomFillColor, {
        color: "transparent",
        width: 1
      }, 0.1, new Rect(0, 0, width, height + spacing * 2), 4, 4));
      if (this.chart.theme === "Tailwind" || this.chart.theme === "TailwindDark") {
        outerElement.setAttribute("box-shadow", "0px 1px 2px rgba(0, 0, 0, 0.06), 0px 1px 3px rgba(0, 0, 0, 0.1)");
      } else if (this.chart.theme === "Tailwind3Dark") {
        outerElement.setAttribute("box-shadow", "0px 1px 2px rgba(0, 0, 0, 0.06), 0px 1px 3px rgba(0, 0, 0, 0.1)");
      } else if (this.chart.theme === "Material3" || this.chart.theme === "Material3Dark" || this.chart.theme === "Fluent2" || this.chart.theme === "Fluent2Dark" || this.chart.theme.indexOf("Bootstrap5") > -1) {
        outerElement.setAttribute("filter", "drop-shadow(0px 1px 3px rgba(0, 0, 0, 0.15)) drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3))");
        outerElement.setAttribute("fill", this.chart.theme === "Material3" ? "#FFFFFF" : this.chart.theme === "Fluent2" ? "#F5F5F5" : this.chart.theme === "Bootstrap5" ? "#E9ECEF" : this.chart.theme === "Bootstrap5Dark" ? "#343A40" : "#1C1B1F");
        outerElement.setAttribute("rx", this.chart.theme.indexOf("Bootstrap5") > -1 ? "1px" : "4px");
        outerElement.setAttribute("ry", this.chart.theme.indexOf("Bootstrap5") > -1 ? "1px" : "4px");
        outerElement.setAttribute("opacity", "1");
      } else {
        if (chart.theme === "Tailwind3") {
          outerElement.setAttribute("fill", "#F9FAFB");
        }
        outerElement.setAttribute("filter", "url(#chart_shadow)");
      }
      this.toolkitElements.appendChild(outerElement);
      var currentItem;
      var panIcon = false;
      for (var i = 1; i <= length; i++) {
        currentItem = toolboxItems[i - 1];
        element = render.createGroup({
          transform: "translate(" + xPosition + "," + (this.isDevice ? spacing : chart.theme.indexOf("Fluent2") > -1 || chart.theme.indexOf("Bootstrap5") > -1 ? spacing + 1 : spacing + 3) + ")"
        });
        switch (currentItem) {
          case "Pan":
            toolkit.createPanButton(element, this.toolkitElements);
            panIcon = true;
            break;
          case "Zoom":
            toolkit.createZoomButton(element, this.toolkitElements);
            break;
          case "ZoomIn":
            toolkit.createZoomInButton(element, this.toolkitElements, chart);
            break;
          case "ZoomOut":
            toolkit.createZoomOutButton(element, this.toolkitElements, chart);
            break;
          case "Reset":
            toolkit.createResetButton(element, this.toolkitElements, chart, this.isDevice);
            break;
        }
        xPosition += iconSize + spacing * 2;
      }
      this.toolkitElements.setAttribute("opacity", this.isDevice ? "1" : "" + this.zoomkitOpacity);
      this.toolkitElements.setAttribute("cursor", "auto");
      if (chart.enableCanvas) {
        var zoomDiv = document.createElement("div");
        zoomDiv.id = chart.element.id + "_zoom";
        zoomDiv.style.cssText = "position:absolute; z-index:1";
        var zoomheight = chart.availableSize.height / 2;
        var svg = chart.svgRenderer.createSvg({
          id: chart.element.id + "_zoomkit_svg",
          width: chart.availableSize.width,
          height: zoomheight
        });
        svg.style.position = "absolute";
        svg.appendChild(this.toolkitElements);
        zoomDiv.appendChild(svg);
        document.getElementById(this.elementId + "_Secondary_Element").appendChild(zoomDiv);
      } else {
        chart.svgObject.appendChild(this.toolkitElements);
      }
      if (!this.isDevice) {
        EventHandler.add(this.toolkitElements, "mousemove touchstart", this.zoomToolkitMove, this);
        EventHandler.add(this.toolkitElements, "mouseleave touchend", this.zoomToolkitLeave, this);
        if (this.isPanning && panIcon) {
          toolkit.pan();
        }
      }
      return true;
    };
    Zoom2.prototype.applyZoomToolkit = function(chart, axes) {
      var showToolkit = this.isAxisZoomed(axes);
      if (showToolkit) {
        this.showZoomingToolkit(chart);
        this.isZoomed = true;
      } else if (chart.zoomSettings.showToolbar) {
        this.isZoomed = showToolkit;
        this.showZoomingToolkit(chart);
      } else {
        this.toolkit.removeTooltip();
        this.isPanning = false;
        this.isZoomed = false;
        chart.isZoomed = false;
        chart.svgObject.setAttribute("cursor", "auto");
      }
    };
    Zoom2.prototype.zoomCancel = function(axes, zoomCompleteEventCollection) {
      for (var _i = 0, _a = zoomCompleteEventCollection; _i < _a.length; _i++) {
        var zoomCompleteEvent = _a[_i];
        for (var _b = 0, _c = axes; _b < _c.length; _b++) {
          var axis = _c[_b];
          if (axis.name === zoomCompleteEvent.axis.name) {
            axis.zoomFactor = zoomCompleteEvent.previousZoomFactor;
            axis.zoomPosition = zoomCompleteEvent.previousZoomPosition;
            axis.visibleRange = zoomCompleteEvent.previousVisibleRange;
            break;
          }
        }
      }
    };
    Zoom2.prototype.isAxisZoomed = function(axes) {
      var showToolkit = false;
      for (var _i = 0, _a = axes; _i < _a.length; _i++) {
        var axis = _a[_i];
        showToolkit = showToolkit || axis.zoomFactor !== 1 || axis.zoomPosition !== 0;
      }
      return showToolkit;
    };
    Zoom2.prototype.zoomToolkitMove = function() {
      var element = this.toolkitElements;
      this.zoomkitOpacity = 1;
      element.setAttribute("opacity", "" + this.zoomkitOpacity);
      return false;
    };
    Zoom2.prototype.zoomToolkitLeave = function() {
      var element = this.toolkitElements;
      this.zoomkitOpacity = 1;
      element.setAttribute("opacity", "" + this.zoomkitOpacity);
      return false;
    };
    Zoom2.prototype.addEventListener = function() {
      if (this.chart.isDestroyed) {
        return;
      }
      EventHandler.add(this.chart.element, this.wheelEvent, this.chartMouseWheel, this);
      this.chart.on(Browser.touchMoveEvent, this.mouseMoveHandler, this);
      this.chart.on(Browser.touchStartEvent, this.mouseDownHandler, this);
      this.chart.on(Browser.touchEndEvent, this.mouseUpHandler, this);
      this.chart.on(this.cancelEvent, this.mouseCancelHandler, this);
    };
    Zoom2.prototype.removeEventListener = function() {
      EventHandler.remove(this.chart.element, this.wheelEvent, this.chartMouseWheel);
      if (this.chart.isDestroyed) {
        return;
      }
      this.chart.off(Browser.touchMoveEvent, this.mouseMoveHandler);
      this.chart.off(Browser.touchStartEvent, this.mouseDownHandler);
      this.chart.off(Browser.touchEndEvent, this.mouseUpHandler);
      this.chart.off(this.cancelEvent, this.mouseCancelHandler);
    };
    Zoom2.prototype.chartMouseWheel = function(e) {
      var chart = this.chart;
      var offset = chart.element.getBoundingClientRect();
      var svgRect = getElement2(chart.svgId).getBoundingClientRect();
      var mouseX = e.clientX - offset.left - Math.max(svgRect.left - offset.left, 0);
      var mouseY = e.clientY - offset.top - Math.max(svgRect.top - offset.top, 0);
      if (this.zooming.enableMouseWheelZooming && withInBounds(mouseX, mouseY, chart.chartAxisLayoutPanel.seriesClipRect)) {
        e.preventDefault();
        this.performMouseWheelZooming(e, mouseX, mouseY, chart, chart.axisCollections);
      }
      return false;
    };
    Zoom2.prototype.mouseMoveHandler = function(e) {
      var chart = this.chart;
      var touches = null;
      if (e.type === "touchmove") {
        if (e.preventDefault && this.isIOS && (this.isPanning || chart.isDoubleTap || this.zooming.enablePinchZooming && this.touchStartList.length > 1)) {
          e.preventDefault();
        }
        touches = e.touches;
      }
      if (chart.isChartDrag) {
        if (chart.isTouch) {
          this.touchMoveList = this.addTouchPointer(this.touchMoveList, e, touches);
          if (this.zooming.enablePinchZooming && this.touchMoveList.length > 1 && this.touchStartList.length > 1) {
            this.performPinchZooming(e, chart);
          }
        }
        this.renderZooming(e, chart, chart.isTouch);
      }
    };
    Zoom2.prototype.mouseDownHandler = function(e) {
      var chart = this.chart;
      var touches = null;
      var target;
      if (e.type === "touchstart") {
        touches = e.touches;
        target = e.target;
      } else {
        target = e.target;
      }
      if (target.id.indexOf(chart.element.id + "_Zooming_") === -1 && (chart.zoomSettings.enablePinchZooming || chart.zoomSettings.enableSelectionZooming || this.chart.zoomModule.isPanning) && withInBounds(chart.previousMouseMoveX, chart.previousMouseMoveY, chart.chartAxisLayoutPanel.seriesClipRect)) {
        chart.isChartDrag = true;
      }
      if (chart.isTouch) {
        this.touchStartList = this.addTouchPointer(this.touchStartList, e, touches);
      }
    };
    Zoom2.prototype.mouseUpHandler = function(e) {
      var chart = this.chart;
      var performZoomRedraw = e.target.id.indexOf(chart.element.id + "_ZoomOut_") === -1 || e.target.id.indexOf(chart.element.id + "_ZoomIn_") === -1;
      if (chart.isChartDrag || performZoomRedraw) {
        this.redrawOnZooming(chart, true, true);
      }
      if (chart.isTouch) {
        if (chart.isDoubleTap && withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect) && this.touchStartList.length === 1 && this.isZoomed) {
          this.toolkit.reset(e);
        }
        this.touchStartList = [];
        chart.isDoubleTap = false;
      }
    };
    Zoom2.prototype.mouseCancelHandler = function() {
      if (this.isZoomed) {
        this.performZoomRedraw(this.chart);
      }
      this.pinchTarget = null;
      this.touchStartList = [];
      this.touchMoveList = [];
    };
    Zoom2.prototype.addTouchPointer = function(touchList, e, touches) {
      if (touches) {
        touchList = [];
        for (var i = 0, length_1 = touches.length; i < length_1; i++) {
          touchList.push({
            pageX: touches[i].clientX,
            pageY: touches[i].clientY,
            pointerId: null
          });
        }
      } else {
        touchList = touchList ? touchList : [];
        if (touchList.length === 0) {
          touchList.push({
            pageX: e.clientX,
            pageY: e.clientY,
            pointerId: e.pointerId
          });
        } else {
          for (var i = 0, length_2 = touchList.length; i < length_2; i++) {
            if (touchList[i].pointerId === e.pointerId) {
              touchList[i] = {
                pageX: e.clientX,
                pageY: e.clientY,
                pointerId: e.pointerId
              };
            } else {
              touchList.push({
                pageX: e.clientX,
                pageY: e.clientY,
                pointerId: e.pointerId
              });
            }
          }
        }
      }
      return touchList;
    };
    Zoom2.prototype.getModuleName = function() {
      return "Zoom";
    };
    Zoom2.prototype.destroy = function() {
      this.removeEventListener();
    };
    return Zoom2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart/user-interaction/data-editing.js
var DataEditing = (
  /** @class */
  function() {
    function DataEditing2(chart) {
      this.isPointDragging = false;
      this.chart = chart;
    }
    DataEditing2.prototype.pointMouseDown = function() {
      var chart = this.chart;
      var series;
      var data = new ChartData(chart);
      var pointData = data.getData();
      var isZooming = chart.zoomSettings.enableSelectionZooming || chart.zoomSettings.enablePinchZooming;
      if (pointData.point && (data.insideRegion || !pointData.series.isRectSeries)) {
        this.seriesIndex = pointData.series.index;
        this.pointIndex = pointData.point.index;
        series = chart.series[this.seriesIndex];
        if (series.dragSettings.enable && !isZooming) {
          chart.trigger(dragStart, {
            series: pointData.series,
            seriesIndex: this.seriesIndex,
            pointIndex: this.pointIndex,
            point: pointData.point,
            oldValue: chart.visibleSeries[this.seriesIndex].yData[this.pointIndex],
            newValue: chart.visibleSeries[this.seriesIndex].points[this.pointIndex].yValue
          });
          chart.isPointMouseDown = true;
          chart.zoomSettings.enableDeferredZooming = false;
        }
      }
    };
    DataEditing2.prototype.pointMouseMove = function(event2) {
      var chart = this.chart;
      var series;
      if (event2.type === "touchmove" && event2.preventDefault) {
        event2.preventDefault();
      }
      var data = new ChartData(chart);
      var pointData = data.getData();
      if (pointData.series.dragSettings.enable && pointData.point && (data.insideRegion || !pointData.series.isRectSeries)) {
        this.getCursorStyle(pointData);
      } else {
        chart.svgObject.style.cursor = "null";
      }
      if (chart.isPointMouseDown) {
        series = chart.series[this.seriesIndex];
        if (series.type.indexOf("Spline") > -1) {
          chart[firstToLowerCase(series.type) + "SeriesModule"].findSplinePoint(series);
        }
        this.pointDragging(this.seriesIndex, this.pointIndex);
      }
    };
    DataEditing2.prototype.getCursorStyle = function(pointData) {
      var chart = this.chart;
      if (pointData.series.type.indexOf("Stacking") > -1) {
        chart.svgObject.style.cursor = "";
      } else if (pointData.series.type === "Bar" && chart.isTransposed) {
        chart.svgObject.style.cursor = "ns-resize";
      } else if (chart.isTransposed || pointData.series.type === "Bar") {
        chart.svgObject.style.cursor = "ew-resize";
      } else {
        chart.svgObject.style.cursor = "ns-resize";
      }
    };
    DataEditing2.prototype.pointDragging = function(si, pi) {
      var chart = this.chart;
      var yValueArray = [];
      var y;
      var ySize;
      var yValue;
      var series = chart.visibleSeries[si];
      var pointDrag = series.dragSettings;
      var xAxis = series.xAxis;
      var yAxis = series.yAxis;
      var extra = series.isRectSeries ? 1 : 0;
      var axis = getTransform(xAxis, yAxis, chart.requireInvertedAxis);
      if (series.type === "Bar") {
        y = chart.isTransposed ? axis.y + axis.height - chart.mouseY : chart.mouseX - axis.x;
        ySize = chart.isTransposed ? axis.height : axis.width;
      } else {
        y = chart.isTransposed ? chart.mouseX - axis.x : axis.y + axis.height - chart.mouseY;
        ySize = chart.isTransposed ? axis.width : axis.height;
      }
      yValue = yAxis.isAxisInverse ? 1 - y / ySize : y / ySize;
      yValue = yValue * yAxis.visibleRange.delta + yAxis.visibleRange.min;
      var minRange = yAxis.minimum !== null ? yAxis.visibleRange.min + extra : isNullOrUndefined(pointDrag.minY) ? yValue : pointDrag.minY;
      var maxRange = yAxis.maximum !== null ? yAxis.visibleRange.max + extra : isNullOrUndefined(pointDrag.maxY) ? yValue : pointDrag.maxY;
      if (maxRange >= yValue && minRange <= yValue) {
        series.points[pi].yValue = series.points[pi].y = chart.dragY = yAxis.valueType === "Logarithmic" ? Math.pow(yAxis.logBase, yValue) : parseFloat(yValue.toFixed(2));
        series.points[pi].interior = pointDrag.fill;
        for (var i = 0; i < series.points.length; i++) {
          yValueArray[i] = series.points[i].yValue;
        }
        series.yMin = Math.min.apply(null, yValueArray);
        series.yMax = Math.max.apply(null, yValueArray);
        this.isPointDragging = true;
        chart.refreshBound();
        chart.trigger(drag, {
          seriesIndex: si,
          pointIndex: pi,
          series,
          point: series.points[pi],
          oldValue: chart.visibleSeries[this.seriesIndex].yData[this.pointIndex],
          newValue: series.points[pi].yValue
        });
        chart.zoomRedraw = false;
      }
    };
    DataEditing2.prototype.pointMouseUp = function() {
      var chart = this.chart;
      if (chart.isPointMouseDown) {
        if (chart.series[this.seriesIndex].dragSettings.enable) {
          chart.trigger(dragEnd, {
            series: chart.series[this.seriesIndex],
            point: chart.visibleSeries[this.seriesIndex].points[this.pointIndex],
            seriesIndex: this.seriesIndex,
            pointIndex: this.pointIndex,
            oldValue: chart.visibleSeries[this.seriesIndex].yData[this.pointIndex],
            newValue: chart.visibleSeries[this.seriesIndex].points[this.pointIndex].yValue
          });
          chart.visibleSeries[this.seriesIndex].points[this.pointIndex].y = chart.visibleSeries[this.seriesIndex].points[this.pointIndex].yValue;
          chart.isPointMouseDown = false;
          this.isPointDragging = false;
          this.seriesIndex = this.pointIndex = void 0;
        }
      }
    };
    DataEditing2.prototype.getModuleName = function() {
      return "DataEditing";
    };
    DataEditing2.prototype.destroy = function() {
    };
    return DataEditing2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart/user-interaction/high-light.js
var __extends57 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Highlight = (
  /** @class */
  function(_super) {
    __extends57(Highlight2, _super);
    function Highlight2(chart) {
      var _this = _super.call(this, chart) || this;
      _this.chart = chart;
      _this.renderer = chart.renderer;
      _this.wireEvents();
      return _this;
    }
    Highlight2.prototype.wireEvents = function() {
      if (this.chart.isDestroyed || this.chart.stockChart && this.chart.stockChart.onPanning) {
        return;
      }
      this.chart.on(Browser.touchMoveEvent, this.mouseMove, this);
    };
    Highlight2.prototype.unWireEvents = function() {
      if (this.chart.isDestroyed) {
        return;
      }
      this.chart.off(Browser.touchMoveEvent, this.mouseMove);
    };
    Highlight2.prototype.declarePrivateVariables = function(chart) {
      this.styleId = chart.element.id + "_ej2_chart_highlight";
      this.unselected = chart.element.id + "_ej2_deselected";
      this.selectedDataIndexes = [];
      this.highlightDataIndexes = [];
      this.isSeriesMode = chart.highlightMode === "Series";
    };
    Highlight2.prototype.invokeHighlight = function(chart) {
      this.declarePrivateVariables(chart);
      this.series = extend({}, chart.visibleSeries, null, true);
      this.seriesStyles();
      this.currentMode = chart.highlightMode;
    };
    Highlight2.prototype.getModuleName = function() {
      return "Highlight";
    };
    Highlight2.prototype.destroy = function() {
      this.unWireEvents();
    };
    return Highlight2;
  }(Selection)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/data-label.js
var DataLabel = (
  /** @class */
  function() {
    function DataLabel3(chart) {
      this.errorHeight = 0;
      this.dataLabelRectCollection = {};
      this.chart = chart;
    }
    DataLabel3.prototype.initPrivateVariables = function(series, marker) {
      var transform = "";
      var clipPath = "";
      var render = series.chart.renderer;
      var index = series.index === void 0 ? series.category : series.index;
      if (series.chart.chartAreaType === "Cartesian") {
        transform = "translate(" + series.clipRect.x + "," + series.clipRect.y + ")";
        clipPath = "url(#" + this.chart.element.id + "_ChartSeriesClipRect_" + index + ")";
      }
      if (marker.dataLabel.visible && !this.chart.enableCanvas) {
        series.shapeElement = render.createGroup({
          "id": this.chart.element.id + "ShapeGroup" + index,
          "transform": transform,
          "clip-path": "url(#" + this.chart.element.id + "_ChartSeriesClipRect_" + index + ")"
        });
        series.textElement = render.createGroup({
          "id": this.chart.element.id + "TextGroup" + index,
          "transform": transform,
          "clip-path": clipPath
        });
        series.textElement.setAttribute("aria-hidden", "true");
      }
      this.markerHeight = series.type === "Scatter" || marker.visible ? marker.height / 2 : 0;
      this.commonId = this.chart.element.id + "_Series_" + index + "_Point_";
      this.calculateErrorHeight(series, series.marker.dataLabel.position);
      this.chartBackground = this.chart.chartArea.background === "transparent" ? this.chart.background || this.chart.themeStyle.background : this.chart.chartArea.background;
    };
    DataLabel3.prototype.calculateErrorHeight = function(series, position) {
      if (!series.errorBar.visible) {
        return null;
      } else if (series.errorBar.visible && this.chart.chartAreaType !== "PolarRadar") {
        var direction = series.errorBar.direction;
        var positiveHeight = this.chart.errorBarModule.positiveHeight;
        var negativeHeight = this.chart.errorBarModule.negativeHeight;
        if (this.isRectSeries(series)) {
          if (position === "Top" || position === "Auto") {
            if (direction === "Both" || direction === "Minus") {
              this.errorHeight = negativeHeight;
            } else {
              this.errorHeight = 0;
            }
          }
          if (position === "Outer" || position === "Auto") {
            if (direction === "Both" || direction === "Plus") {
              this.errorHeight = positiveHeight;
            } else {
              this.errorHeight = 0;
            }
          }
        } else {
          if (position === "Top" || position === "Outer" || position === "Auto") {
            if ((direction === "Both" || direction === "Plus") && !series.chart.isTransposed) {
              this.errorHeight = positiveHeight;
            } else {
              this.errorHeight = 0;
            }
          }
          if (position === "Bottom" || position === "Auto") {
            if (direction === "Both" || direction === "Minus") {
              this.errorHeight = negativeHeight;
            } else {
              this.errorHeight = 0;
            }
          }
        }
      } else {
        this.errorHeight = 0;
      }
    };
    DataLabel3.prototype.isRectSeries = function(series) {
      return series.isRectSeries || series.type === "RangeArea" || series.type === "SplineRangeArea" || series.type === "RangeStepArea";
    };
    DataLabel3.prototype.render = function(series, chart, dataLabel) {
      this.initPrivateVariables(series, series.marker);
      this.inverted = chart.requireInvertedAxis;
      this.yAxisInversed = series.yAxis.isAxisInverse;
      var templateId = chart.element.id + "_Series_" + (series.index === void 0 ? series.category : series.index) + "_DataLabelCollections";
      var element = createElement("div", {
        id: templateId
      });
      var visiblePoints = getVisiblePoints(series);
      if (series.visible) {
        for (var i = 0; i < visiblePoints.length; i++) {
          this.renderDataLabel(series, visiblePoints[i], element, dataLabel);
        }
      }
      if (element.childElementCount) {
        if (!chart.enableCanvas) {
          appendChildElement(chart.enableCanvas, getElement2(chart.element.id + "_Secondary_Element"), element, chart.redraw, false, "x", "y", null, "", false, false, null, chart.duration);
        } else {
          getElement2(chart.element.id + "_Secondary_Element").appendChild(element);
        }
      }
    };
    DataLabel3.prototype.renderDataLabel = function(series, point, element, dataLabel) {
      if (!dataLabel.showZero && (point.y === 0 || point.y === 0 && series.emptyPointSettings.mode === "Zero")) {
        return null;
      }
      this.margin = dataLabel.margin;
      var labelText = [];
      var labelLength;
      var xPos;
      var yPos;
      var xValue;
      var yValue;
      var degree;
      var rectCenterX;
      var rectCenterY;
      var labelLocation = {
        x: 0,
        y: 0
      };
      var textSize;
      var clip = series.clipRect;
      var shapeRect;
      var isDataLabelOverlap = false;
      var dataLabelElement = [];
      var startLocation;
      dataLabel.angle = dataLabel.labelIntersectAction === "Rotate90" ? 90 : dataLabel.angle;
      dataLabel.enableRotation = dataLabel.labelIntersectAction === "Rotate90" ? true : dataLabel.enableRotation;
      var angle = degree = dataLabel.angle;
      var border = {
        width: dataLabel.border.width,
        color: dataLabel.border.color
      };
      var argsFont = extend({}, getValue("properties", dataLabel.font), null, true);
      if (point.symbolLocations.length && point.symbolLocations[0] || series.type === "BoxAndWhisker" && point.regions.length) {
        labelText = point.text !== null ? getLabelText(point, series, this.chart) : [];
        labelLength = labelText.length;
        for (var i = 0; i < labelLength; i++) {
          var argsData = {
            cancel: false,
            name: textRender,
            series,
            point,
            text: labelText[i],
            border,
            color: dataLabel.fill,
            template: dataLabel.template,
            font: argsFont,
            location: labelLocation,
            textSize: measureText(labelText[i], dataLabel.font, this.chart.themeStyle.datalabelFont)
          };
          this.chart.trigger(textRender, argsData);
          if (!argsData.cancel) {
            this.fontBackground = argsData.color;
            this.isDataLabelShape(argsData);
            this.markerHeight = series.type === "Bubble" ? point.regions[0].height / 2 : this.markerHeight;
            if (argsData.template !== null) {
              this.createDataLabelTemplate(element, series, dataLabel, point, argsData, i, this.chart.redraw);
            } else {
              if (dataLabel.enableRotation) {
                textSize = rotateTextSize(dataLabel.font, argsData.text, dataLabel.angle, this.chart, this.chart.themeStyle.datalabelFont);
              } else {
                textSize = measureText(argsData.text, dataLabel.font, this.chart.themeStyle.datalabelFont);
              }
              var rect = this.calculateTextPosition(point, series, textSize, dataLabel, i);
              var actualRect = new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height);
              if (dataLabel.enableRotation) {
                var rectCoordinates = this.getRectanglePoints(actualRect);
                rectCenterX = rect.x + rect.width / 2;
                rectCenterY = rect.y + rect.height / 2;
                isDataLabelOverlap = dataLabel.labelIntersectAction === "Rotate90" || angle === -90 ? false : this.isDataLabelOverlapWithChartBound(rectCoordinates, this.chart, {
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0
                });
                if (!isDataLabelOverlap) {
                  this.chart.rotatedDataLabelCollections.push(rectCoordinates);
                  var currentPointIndex = this.chart.rotatedDataLabelCollections.length - 1;
                  for (var index = currentPointIndex; index >= 0; index--) {
                    if (this.chart.rotatedDataLabelCollections[currentPointIndex] && this.chart.rotatedDataLabelCollections[index - 1] && isRotatedRectIntersect(this.chart.rotatedDataLabelCollections[currentPointIndex], this.chart.rotatedDataLabelCollections[index - 1])) {
                      isDataLabelOverlap = true;
                      this.chart.rotatedDataLabelCollections[currentPointIndex] = null;
                      break;
                    }
                  }
                }
              } else {
                isDataLabelOverlap = isCollide(rect, this.chart.dataLabelCollections, clip);
              }
              if (!isDataLabelOverlap || dataLabel.labelIntersectAction === "None") {
                var dataLabelShapeElement = getElement2(this.commonId + point.index + "_TextShape_" + i);
                if (dataLabelShapeElement) {
                  startLocation = {
                    x: +dataLabelShapeElement.getAttribute("x"),
                    y: +dataLabelShapeElement.getAttribute("y")
                  };
                }
                this.chart.dataLabelCollections.push(actualRect);
                if (this.isShape) {
                  shapeRect = this.chart.renderer.drawRectangle(new RectOption(this.commonId + point.index + "_TextShape_" + i, argsData.color, argsData.border, dataLabel.opacity, rect, dataLabel.rx, dataLabel.ry, "", dataLabel.border.dashArray), new Int32Array([clip.x, clip.y]));
                  if (series.shapeElement) {
                    appendChildElement(this.chart.enableCanvas, series.shapeElement, shapeRect, this.chart.redraw, true, "x", "y", startLocation);
                  }
                }
                var backgroundColor = this.fontBackground === "transparent" ? this.chart.theme.indexOf("Dark") > -1 || this.chart.theme.indexOf("HighContrast") > -1 ? "black" : "white" : this.fontBackground;
                var rgbValue = convertHexToColor(colorNameToHex(backgroundColor));
                var contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1e3);
                xPos = rect.x + this.margin.left + textSize.width / 2 + labelLocation.x;
                yPos = dataLabel.enableRotation && this.chart.chartAreaType !== "PolarRadar" ? rect.y + this.margin.top + textSize.height / 2 + textSize.width / 4 + (dataLabel.position === "Auto" ? point.regions[0].width / 10 : 0) + labelLocation.y : rect.y + this.margin.top + textSize.height * 3 / 4 + labelLocation.y;
                labelLocation = {
                  x: 0,
                  y: 0
                };
                if (angle !== 0 && dataLabel.enableRotation) {
                  xValue = rectCenterX;
                  yValue = rectCenterY;
                  degree = angle > 360 ? angle - 360 : angle < -360 ? angle + 360 : angle;
                } else {
                  degree = 0;
                  xValue = rect.x;
                  yValue = rect.y;
                  xPos -= this.chart.chartAreaType === "Cartesian" && xPos + textSize.width / 2 > clip.width ? !this.chart.requireInvertedAxis && xPos > clip.width ? 0 : xPos + textSize.width / 2 - clip.width : 0;
                  yPos -= yPos + textSize.height > clip.y + clip.height && !(series.type.indexOf("Bar") > -1) ? yPos + textSize.height - (clip.y + clip.height) : 0;
                }
                var textAnchor = dataLabel.labelIntersectAction === "Rotate90" ? dataLabel.position === "Top" ? "start" : dataLabel.position === "Middle" ? "middle" : "end" : angle === -90 && dataLabel.enableRotation ? dataLabel.position === "Top" ? "end" : dataLabel.position === "Middle" ? "middle" : "start" : "middle";
                var oldText = void 0;
                if (this.chart.redraw && document.getElementById(this.commonId + point.index + "_Text_" + i)) {
                  oldText = document.getElementById(this.commonId + point.index + "_Text_" + i).textContent;
                }
                dataLabelElement.push(textElement2(this.chart.renderer, new TextOption(this.commonId + (series.removedPointIndex !== null && series.removedPointIndex <= point.index ? point.index + 1 : point.index) + "_Text_" + i, xPos, yPos, textAnchor, argsData.text, "rotate(" + degree + "," + xValue + "," + yValue + ")", "auto", degree), argsData.font, argsData.font.color || (this.chart.theme === "Bootstrap5" ? "#212529" : this.chart.theme === "Bootstrap5Dark" ? "#DEE2E6" : contrast >= 128 || series.type === "Hilo" || series.type === "HiloOpenClose" ? this.chart.theme.indexOf("Tailwind3") > -1 ? "#111827" : "black" : this.chart.theme.indexOf("Tailwind3") > -1 ? "#FFFFFF" : "white"), series.textElement, false, this.chart.redraw, true, false, series.chart.duration, series.clipRect, null, null, this.chart.enableCanvas, null, this.chart.themeStyle.datalabelFont, new ChartLocation(xValue, yValue)));
                if (this.isShape && dataLabel.enableRotation) {
                  shapeRect.setAttribute("transform", "rotate(" + dataLabel.angle + ", " + xValue + ", " + yValue + ")");
                }
                if (this.chart.stackLabels.visible && series.type.indexOf("Stacking") > -1) {
                  this.dataLabelRectCollection = !this.dataLabelRectCollection ? {} : this.dataLabelRectCollection;
                  this.dataLabelRectCollection[this.commonId + (series.removedPointIndex !== null && series.removedPointIndex <= point.index ? point.index + 1 : point.index) + "_Text_" + i] = actualRect;
                  this.dataLabelRectCollection[this.commonId + point.index + "_TextShape_" + i] = actualRect;
                }
                if (series.removedPointIndex !== null && series.removedPointIndex <= point.index) {
                  series.textElement.lastChild.id = this.commonId + point.index + "_Text_" + i;
                }
                if (this.chart.redraw && oldText !== argsData.text) {
                  animateTextElement(series.textElement.querySelector("#" + this.commonId + point.index + "_Text_" + i), this.chart.duration, parseFloat(oldText), parseFloat(argsData.text), series.marker.dataLabel.format || series.yAxis.labelFormat);
                }
              } else if (getElement2(this.commonId + point.index + "_Text_0") && series.chart.redraw && series.currentData) {
                getElement2(this.commonId + point.index + "_Text_0").remove();
              }
            }
          }
        }
      }
      return dataLabelElement;
    };
    DataLabel3.prototype.renderStackLabels = function() {
      var stackLabelGroup = this.chart.renderer.createGroup({
        id: this.chart.element.id + "_StackLabelGroup"
      });
      this.chart.seriesElements.appendChild(stackLabelGroup);
      var positivePoints = {};
      var negativePoints = {};
      var groupingValues = [];
      var keys = [];
      var stackLabelIndex = 0;
      if (this.chart.visibleSeries && this.chart.visibleSeries.length > 0) {
        for (var i = 0; i < this.chart.visibleSeries.length; i++) {
          keys = Object.keys(groupingValues);
          var series = this.chart.visibleSeries[i];
          if (!groupingValues[series.stackingGroup]) {
            groupingValues[series.stackingGroup] = [];
            groupingValues[series.stackingGroup].push(series);
          } else if (groupingValues[series.stackingGroup] !== void 0) {
            groupingValues[series.stackingGroup].push(series);
          }
        }
        if (keys[0] !== "") {
          for (var groupIndex = 0; groupIndex < keys.length; groupIndex++) {
            positivePoints = {};
            negativePoints = {};
            var count = groupingValues[keys[groupIndex]][groupingValues[keys[groupIndex]].length - 1].index;
            for (var seriesIndex = count; seriesIndex >= 0; seriesIndex--) {
              var series = this.chart.visibleSeries[seriesIndex];
              if (series.animation.enable && this.chart.animateSeries) {
                stackLabelGroup.setAttribute("visibility", "hidden");
              }
              if (series.visible && series.points && series.points.length > 0) {
                for (var pointIndex = 0; pointIndex < series.points.length; pointIndex++) {
                  var point = series.points[pointIndex];
                  var pointXValueAsKey = String(point.x);
                  if (!positivePoints[pointXValueAsKey] && series.stackedValues.endValues[pointIndex] > 0 && point.visible) {
                    positivePoints[pointXValueAsKey] = point;
                  }
                  if (!negativePoints[pointXValueAsKey] && series.stackedValues.endValues[pointIndex] < 0 && point.visible) {
                    negativePoints[pointXValueAsKey] = point;
                  }
                }
              }
            }
            stackLabelIndex = this.calculateStackLabel(positivePoints, negativePoints, stackLabelGroup, stackLabelIndex);
          }
        } else {
          for (var seriesIndex = this.chart.visibleSeries.length - 1; seriesIndex >= 0; seriesIndex--) {
            var series = this.chart.visibleSeries[seriesIndex];
            if (series.animation.enable && this.chart.animateSeries) {
              stackLabelGroup.setAttribute("visibility", "hidden");
            }
            if (series.visible && series.points && series.points.length > 0) {
              for (var pointIndex = 0; pointIndex < series.points.length; pointIndex++) {
                var point = series.points[pointIndex];
                var pointXValueAsKey = String(point.x);
                if (!positivePoints[pointXValueAsKey] && series.stackedValues.endValues[pointIndex] > 0 && point.visible) {
                  positivePoints[pointXValueAsKey] = point;
                }
                if (!negativePoints[pointXValueAsKey] && series.stackedValues.endValues[pointIndex] < 0 && point.visible) {
                  negativePoints[pointXValueAsKey] = point;
                }
              }
            }
          }
          this.calculateStackLabel(positivePoints, negativePoints, stackLabelGroup, stackLabelIndex);
        }
      }
    };
    DataLabel3.prototype.calculateStackLabel = function(positivePoints, negativePoints, stackLabelGroup, stackLabelIndex) {
      var _this = this;
      [positivePoints, negativePoints].forEach(function(points, index) {
        if (points) {
          var totalValue_1 = 0;
          var currentPoint_1;
          Object.keys(points).forEach(function(pointXValueAsKey) {
            var positiveValue = points[pointXValueAsKey].series.stackedValues.endValues[points[pointXValueAsKey].index];
            var negativeValue = negativePoints[pointXValueAsKey] ? negativePoints[pointXValueAsKey].series.stackedValues.endValues[negativePoints[pointXValueAsKey].index] : 0;
            if (index === 0) {
              totalValue_1 = positiveValue + negativeValue;
              currentPoint_1 = points[pointXValueAsKey];
            } else if (!positivePoints[pointXValueAsKey]) {
              totalValue_1 = positiveValue;
              currentPoint_1 = points[pointXValueAsKey];
            }
            if (currentPoint_1 && currentPoint_1.symbolLocations[0]) {
              var series = currentPoint_1.series;
              var symbolLocation = currentPoint_1.symbolLocations[0];
              var labelFormat = _this.chart.stackLabels.format;
              var stackLabeltext = totalValue_1 % 1 === 0 ? totalValue_1.toFixed(0) : totalValue_1.toFixed(2).slice(-1) === "0" ? totalValue_1.toFixed(1) : totalValue_1.toFixed(2);
              if (labelFormat) {
                var customLabelFormat = labelFormat.match("{value}") !== null;
                stackLabeltext = customLabelFormat ? labelFormat.replace("{value}", stackLabeltext.toString()) : _this.chart.intl.getNumberFormat({
                  format: labelFormat,
                  useGrouping: _this.chart.useGroupingSeparator
                })(totalValue_1);
              }
              var textSize = measureText(stackLabeltext, _this.chart.stackLabels.font, _this.chart.themeStyle.datalabelFont);
              var padding = 10;
              if (_this.chartBackground === void 0) {
                _this.chartBackground = _this.chart.chartArea.background === "transparent" ? _this.chart.background || _this.chart.themeStyle.background : _this.chart.chartArea.background;
              }
              var backgroundColor = _this.chart.stackLabels.fill === "transparent" && _this.chartBackground === "transparent" ? _this.chart.theme.indexOf("Dark") > -1 || _this.chart.theme.indexOf("HighContrast") > -1 ? "black" : "white" : _this.chart.stackLabels.fill !== "transparent" ? _this.chart.stackLabels.fill : _this.chartBackground;
              var rgbValue = convertHexToColor(colorNameToHex(backgroundColor));
              var contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1e3);
              var alignmentValue = textSize.width + _this.chart.stackLabels.border.width + _this.chart.stackLabels.margin.left + _this.chart.stackLabels.margin.right - padding / 2;
              var yOffset = _this.chart.requireInvertedAxis ? padding / 2 : _this.chart.primaryYAxis.isInversed ? index === 0 ? textSize.height + padding / 2 : -padding : index === 0 ? -padding : textSize.height + padding / 2;
              var xOffset = _this.chart.requireInvertedAxis ? _this.chart.primaryYAxis.isInversed ? index === 0 ? -(padding + textSize.width / 2) : padding + textSize.width / 2 : index === 0 ? padding + textSize.width / 2 : -(padding + textSize.width / 2) : 0;
              xOffset += _this.chart.stackLabels.font.textAlignment === "Far" ? alignmentValue : _this.chart.stackLabels.font.textAlignment === "Near" ? -alignmentValue : 0;
              var xPosition = Math.max(series.clipRect.x + textSize.width, Math.min(xOffset + series.clipRect.x + symbolLocation.x, series.clipRect.x + series.clipRect.width - textSize.width));
              var yPosition = Math.max(series.clipRect.y + textSize.height, Math.min(yOffset + series.clipRect.y + symbolLocation.y - (_this.chart.stackLabels.angle > 0 && !_this.chart.requireInvertedAxis ? textSize.width / 2 : 0), series.clipRect.y + series.clipRect.height - textSize.height));
              var rect = new Rect(xPosition - textSize.width / 2 - _this.chart.stackLabels.margin.left, yPosition - textSize.height - _this.chart.stackLabels.margin.top, textSize.width + (_this.chart.stackLabels.margin.left + _this.chart.stackLabels.margin.right), textSize.height + padding / 2 + (_this.chart.stackLabels.margin.top + _this.chart.stackLabels.margin.bottom));
              var shapeRect = _this.chart.renderer.drawRectangle(new RectOption(_this.chart.element.id + "StackLabel_TextShape_" + stackLabelIndex, _this.chart.stackLabels.fill, _this.chart.stackLabels.border, null, rect, _this.chart.stackLabels.rx, _this.chart.stackLabels.ry, "", null), new Int32Array([symbolLocation.x, symbolLocation.y]));
              shapeRect.setAttribute("transform", "rotate(" + _this.chart.stackLabels.angle + ", " + xPosition + ", " + yPosition + ")");
              stackLabelGroup.appendChild(shapeRect);
              textElement2(_this.chart.renderer, new TextOption(_this.chart.element.id + "_StackLabel_" + stackLabelIndex, xPosition, yPosition, "middle", stackLabeltext, "rotate(" + _this.chart.stackLabels.angle + ", " + xPosition + ", " + yPosition + ")", "auto", _this.chart.stackLabels.angle), _this.chart.stackLabels.font, _this.chart.stackLabels.font.color || (_this.chart.theme === "Bootstrap5" ? "#212529" : _this.chart.theme === "Bootstrap5Dark" ? "#DEE2E6" : contrast >= 128 ? _this.chart.theme.indexOf("Tailwind3") > -1 ? "#111827" : "black" : _this.chart.theme.indexOf("Tailwind3") > -1 ? "#FFFFFF" : "white"), stackLabelGroup, null, _this.chart.redraw, true, null, _this.chart.duration, series.clipRect, null, null, _this.chart.enableCanvas, null, _this.chart.themeStyle.datalabelFont, null);
              if (series.type === "StackingLine" || series.type === "StackingArea") {
                document.querySelectorAll('[id^="' + _this.chart.element.id + "_Series_" + series.index + "_Point_" + currentPoint_1.index + '_Text_"], \n                                [id^="' + _this.chart.element.id + "_Series_" + series.index + "_Point_" + currentPoint_1.index + '_TextShape_"]').forEach(function(element) {
                  if (element.id) {
                    element.style.visibility = "hidden";
                    element.setAttribute("data-collide", "true");
                  }
                });
              }
              for (var dataLabelID in _this.dataLabelRectCollection) {
                if (Object.prototype.hasOwnProperty.call(_this.dataLabelRectCollection, dataLabelID)) {
                  var dataLabelRect = _this.dataLabelRectCollection[dataLabelID];
                  if (dataLabelRect) {
                    var isCollided = isCollide(rect, [dataLabelRect], {
                      x: 0,
                      y: 0,
                      height: 0,
                      width: 0
                    });
                    if (isCollided) {
                      var dataLabelElement = document.getElementById(dataLabelID);
                      if (dataLabelElement) {
                        dataLabelElement.style.visibility = "hidden";
                        dataLabelElement.setAttribute("data-collide", "true");
                      }
                    }
                  }
                }
              }
            }
            stackLabelIndex++;
          });
        }
      });
      return stackLabelIndex;
    };
    DataLabel3.prototype.getRectanglePoints = function(rect) {
      var loc1 = new ChartLocation(rect.x, rect.y);
      var loc2 = new ChartLocation(rect.x + rect.width, rect.y);
      var loc3 = new ChartLocation(rect.x + rect.width, rect.y + rect.height);
      var loc4 = new ChartLocation(rect.x, rect.y + rect.height);
      return [loc1, loc2, loc3, loc4];
    };
    DataLabel3.prototype.isDataLabelOverlapWithChartBound = function(rectCoordinates, chart, clip) {
      for (var index = 0; index < rectCoordinates.length; index++) {
        if (!withInBounds(rectCoordinates[index].x + clip.x, rectCoordinates[index].y + clip.y, chart.initialClipRect)) {
          return true;
        }
      }
      return false;
    };
    DataLabel3.prototype.createDataLabelTemplate = function(parentElement, series, dataLabel, point, data, labelIndex, redraw) {
      this.margin = {
        left: 0,
        right: 0,
        bottom: 0,
        top: 0
      };
      var clip = series.clipRect;
      var childElement = createTemplate(createElement("div", {
        id: this.chart.element.id + "_Series_" + (series.index === void 0 ? series.category : series.index) + "_DataLabel_" + point.index + (labelIndex ? "_" + labelIndex : ""),
        styles: "position: absolute;background-color:" + data.color + ";" + getFontStyle(dataLabel.font, this.chart.themeStyle.datalabelFont) + ";border:" + data.border.width + "px solid " + data.border.color + ";"
      }), point.index, this.chart.enableHtmlSanitizer ? this.chart.sanitize(data.template) : data.template, this.chart, point, series, this.chart.element.id + "_DataLabel", labelIndex);
      this.calculateTemplateLabelSize(parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw);
    };
    DataLabel3.prototype.calculateTemplateLabelSize = function(parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw, isReactCallback) {
      var elementRect = measureElementRect(childElement, redraw, isReactCallback);
      var rect = this.calculateTextPosition(point, series, {
        width: elementRect.width,
        height: elementRect.height
      }, dataLabel, labelIndex);
      var clipWidth = 0;
      var clipHeight = 0;
      var isOverlap2 = false;
      if (isReactCallback) {
        isOverlap2 = elementRect.width === 0 || elementRect.height === 0;
      }
      childElement.style.left = (this.chart.chartAreaType === "PolarRadar" ? 0 : series.clipRect.x) + rect.x - clipWidth + "px";
      childElement.style.top = (this.chart.chartAreaType === "PolarRadar" ? 0 : series.clipRect.y) + rect.y + clipHeight + "px";
      var vAxis = series.chart.requireInvertedAxis ? series.xAxis : series.yAxis;
      var hAxis = series.chart.requireInvertedAxis ? series.yAxis : series.xAxis;
      if (childElement.childElementCount && !isOverlap2 && (!isCollide(rect, this.chart.dataLabelCollections, clip) || dataLabel.labelIntersectAction === "None") && (series.seriesType !== "XY" || point.yValue === void 0 || withIn(point.yValue, series.yAxis.visibleRange) || series.type.indexOf("Stacking") > -1 || series.type.indexOf("100") > -1 && withIn(series.stackedValues.endValues[point.index], series.yAxis.visibleRange)) && withIn(point.xValue, series.xAxis.visibleRange) && parseFloat(childElement.style.top) >= vAxis.rect.y && parseFloat(childElement.style.left) >= hAxis.rect.x && parseFloat(childElement.style.top) <= vAxis.rect.y + vAxis.rect.height && parseFloat(childElement.style.left) <= hAxis.rect.x + hAxis.rect.width) {
        this.chart.dataLabelCollections.push(new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height));
        appendChildElement(this.chart.enableCanvas, parentElement, childElement, redraw, true, "left", "top");
        if (series.animation.enable && this.chart.animateSeries && !this.chart.enableCanvas) {
          this.doDataLabelAnimation(series, childElement);
        } else if (this.chart.enableCanvas) {
          parentElement.appendChild(childElement);
        }
      }
    };
    DataLabel3.prototype.calculateTextPosition = function(point, series, textSize, dataLabel, labelIndex) {
      var labelRegion = labelIndex > 1 ? series.type === "Candle" ? point.regions[1] : point.regions[0] : point.regions[0];
      if (labelIndex > 1 && series.type === "HiloOpenClose") {
        labelRegion = labelIndex === 2 ? point.regions[1] : point.regions[2];
      }
      var location;
      location = this.getLabelLocation(point, series, textSize, labelIndex);
      var padding = 5;
      var clipRect = series.clipRect;
      if (!this.chart.requireInvertedAxis || !this.isRectSeries(series) || series.type === "BoxAndWhisker") {
        this.locationX = location.x;
        var alignmentValue = textSize.height + this.borderWidth * 2 + this.markerHeight + this.margin.bottom + this.margin.top + padding;
        location.x = dataLabel.position === "Auto" ? location.x : this.calculateAlignment(alignmentValue, location.x, dataLabel.alignment, this.isRectSeries(series) ? point.yValue < 0 : false);
        location.y = !this.isRectSeries(series) || series.type === "BoxAndWhisker" ? this.calculatePathPosition(location.y, dataLabel.position, series, point, textSize, labelIndex) : this.calculateRectPosition(location.y, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);
        if (this.isRectSeries(series) && this.chart.chartAreaType === "PolarRadar") {
          location = this.calculatePolarRectPosition(location, dataLabel.position, series, point, textSize, labelIndex, dataLabel.alignment, alignmentValue);
        }
      } else {
        this.locationY = location.y;
        var alignmentValue = textSize.width + this.borderWidth + this.margin.left + this.margin.right - padding;
        location.x = dataLabel.position === "Auto" ? location.x : this.calculateAlignment(alignmentValue, location.x, dataLabel.alignment, point.yValue < 0);
        location.x = this.calculateRectPosition(location.x, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);
      }
      var rect = calculateRect(location, textSize, this.margin);
      if (!(dataLabel.enableRotation === true && dataLabel.angle !== 0) && !(rect.y > clipRect.y + clipRect.height || rect.x > clipRect.x + clipRect.width || rect.x + rect.width < 0 || rect.y + rect.height < 0)) {
        rect.x = rect.x < 0 ? series.type === "StackingColumn" && !this.inverted ? 0 : padding : rect.x;
        rect.y = rect.y < 0 && !this.chart.requireInvertedAxis && !(dataLabel.labelIntersectAction === "None") ? padding : rect.y;
        rect.x -= rect.x + rect.width > clipRect.x + clipRect.width ? rect.x + rect.width - (clipRect.x + clipRect.width) + padding : 0;
        rect.y -= rect.y + rect.height > clipRect.y + clipRect.height ? rect.y + rect.height - (clipRect.y + clipRect.height) + padding : 0;
        this.fontBackground = this.fontBackground === "transparent" ? this.chartBackground : this.fontBackground;
      }
      var dataLabelOutRegion;
      if (this.inverted && series.isRectSeries && rect.x + rect.width > labelRegion.x + labelRegion.width) {
        dataLabelOutRegion = true;
      }
      this.fontBackground = dataLabelOutRegion ? this.chartBackground : this.fontBackground;
      return rect;
    };
    DataLabel3.prototype.calculatePolarRectPosition = function(location, position, series, point, size, labelIndex, alignment, alignmentValue) {
      var padding = 5;
      var columnRadius;
      var chartWidth = this.chart.availableSize.width;
      var alignmentSign = alignment === "Center" ? 0 : alignment === "Far" ? 1 : -1;
      var angle = point.regionData.startAngle - 0.5 * Math.PI + (point.regionData.endAngle - point.regionData.startAngle) / 2;
      if (labelIndex === 0) {
        columnRadius = point.regionData.radius < point.regionData.innerRadius ? point.regionData.innerRadius : point.regionData.radius;
      } else {
        columnRadius = point.regionData.radius > point.regionData.innerRadius ? point.regionData.innerRadius : point.regionData.radius;
      }
      this.fontBackground = this.fontBackground === "transparent" ? this.chartBackground : this.fontBackground;
      if (series.drawType.indexOf("Stacking") > -1) {
        position = position === "Outer" ? "Top" : position;
      } else if (series.drawType.indexOf("Range") > -1) {
        position = position === "Outer" || position === "Top" ? position : "Auto";
      }
      if (position === "Outer") {
        columnRadius = labelIndex === 0 ? columnRadius + 2 * padding + this.markerHeight : columnRadius - 2 * padding - this.markerHeight;
      } else if (position === "Middle") {
        columnRadius = columnRadius / 2 + padding;
        if (series.drawType === "StackingColumn") {
          columnRadius = point.regionData.innerRadius + (point.regionData.radius - point.regionData.innerRadius) / 2 + padding - size.height / 2;
        }
      } else if (position === "Top") {
        columnRadius = labelIndex === 0 ? columnRadius - 2 * padding - this.markerHeight : columnRadius + 2 * padding + this.markerHeight;
      } else if (position === "Bottom") {
        columnRadius = 2 * padding;
        columnRadius += series.drawType === "StackingColumn" ? point.regionData.innerRadius + this.markerHeight : 0;
      } else {
        if (labelIndex === 0) {
          columnRadius = columnRadius >= series.chart.radius ? columnRadius - padding : series.drawType === "StackingColumn" ? columnRadius - 2 * padding : columnRadius + 2 * padding;
        } else {
          columnRadius = columnRadius >= series.chart.radius ? columnRadius + padding : columnRadius - 2 * padding;
        }
      }
      columnRadius += alignmentValue * alignmentSign;
      location.x = series.clipRect.width / 2 + series.clipRect.x + columnRadius * Math.cos(angle);
      if (series.drawType === "StackingColumn") {
        location.x = location.x < chartWidth / 2 ? location.x + size.width / 2 : location.x > chartWidth / 2 ? location.x - size.width / 2 : location.x;
      } else if (series.drawType === "Column") {
        location.x = location.x < chartWidth / 2 ? location.x - size.width / 2 : location.x > chartWidth / 2 ? location.x + size.width / 2 : location.x;
      }
      location.y = series.clipRect.height / 2 + series.clipRect.y + columnRadius * Math.sin(angle);
      return location;
    };
    DataLabel3.prototype.getLabelLocation = function(point, series, textSize, labelIndex) {
      var location = new ChartLocation(0, 0);
      var labelRegion = series.type === "Candle" && labelIndex > 1 ? point.regions[1] : point.regions[0];
      if (series.type === "HiloOpenClose") {
        labelRegion = labelIndex === 2 ? point.regions[1] : point.regions[2];
      }
      var xAxis = series.xAxis;
      var yAxis = series.yAxis;
      var isInverted = series.chart.requireInvertedAxis;
      if (series.type === "BoxAndWhisker") {
        this.markerHeight = 0;
        switch (labelIndex) {
          case 0:
            location = getPoint(point.xValue, point.median, xAxis, yAxis, isInverted);
            break;
          case 1:
            location = getPoint(point.xValue, point.maximum, xAxis, yAxis, isInverted);
            break;
          case 2:
            location = getPoint(point.xValue, point.minimum, xAxis, yAxis, isInverted);
            break;
          case 3:
            location = getPoint(point.xValue, point.upperQuartile, xAxis, yAxis, isInverted);
            break;
          case 4:
            location = getPoint(point.xValue, point.lowerQuartile, xAxis, yAxis, isInverted);
            break;
          default: {
            location = getPoint(point.xValue, point.outliers[labelIndex - 5], xAxis, yAxis, isInverted);
            this.markerHeight = series.marker.height / 2;
            break;
          }
        }
        if (isInverted) {
          location.y = point.regions[0].y + point.regions[0].height / 2;
        } else {
          location.x = point.regions[0].x + point.regions[0].width / 2;
        }
      } else if (isInverted && series.type.indexOf("Stacking") > -1 && point.yValue === 0) {
        location = {
          x: labelRegion.x + labelRegion.width,
          y: labelRegion.y + labelRegion.height / 2
        };
      } else if (labelIndex === 0 || labelIndex === 1) {
        location = new ChartLocation(point.symbolLocations[0].x, point.symbolLocations[0].y);
      } else if ((labelIndex === 2 || labelIndex === 3) && series.type === "Candle") {
        location = new ChartLocation(point.symbolLocations[1].x, point.symbolLocations[1].y);
      } else if (isInverted) {
        location = {
          x: labelRegion.x + labelRegion.width / 2,
          y: labelRegion.y
        };
      } else {
        location = {
          x: labelRegion.x + labelRegion.width,
          y: labelRegion.y + labelRegion.height / 2
        };
      }
      if (labelIndex > 1 && series.type === "HiloOpenClose") {
        if (series.chart.requireInvertedAxis) {
          var height = labelRegion.height;
          location.y = labelRegion.y + height / 2 + 2 * (labelIndex === 2 ? 1 : -1);
        } else {
          var width = labelRegion.width;
          location.x = labelRegion.x + width / 2 + 2 * (labelIndex === 2 ? 1 : -1);
        }
      }
      return location;
    };
    DataLabel3.prototype.calculateRectPosition = function(labelLocation, rect, isMinus, position, series, textSize, labelIndex, point) {
      if (series.chart.chartAreaType === "PolarRadar") {
        return null;
      }
      var padding = 5;
      var margin = this.margin;
      var textLength = series.marker.dataLabel.enableRotation ? textSize.width : !this.inverted ? textSize.height : textSize.width;
      if (position === "Bottom" && series.type === "StackingColumn" && !this.inverted && rect.height < textSize.height) {
        this.extraSpace = this.borderWidth + (Math.abs(rect.height - textSize.height / 2) < padding ? 0 : padding);
      } else {
        this.extraSpace = this.borderWidth + textLength / 2 + (position !== "Outer" && series.type.indexOf("Column") > -1 && Math.abs(rect.height - textSize.height) < padding ? 0 : padding);
      }
      if (series.type === "StackingColumn100" || series.type === "StackingBar100") {
        position = position === "Outer" ? "Top" : position;
      } else if (series.type.indexOf("Range") > -1) {
        position = position === "Outer" || position === "Top" ? position : "Auto";
      } else if (series.type === "Waterfall") {
        position = position === "Auto" ? "Middle" : position;
      }
      switch (position) {
        case "Bottom":
          labelLocation = !this.inverted ? isMinus ? labelLocation + (series.type === "Waterfall" ? -this.extraSpace - margin.top - this.markerHeight : -rect.height + this.extraSpace + margin.top) : labelLocation + rect.height - this.extraSpace - margin.bottom : isMinus ? labelLocation + (series.type === "Waterfall" ? +this.extraSpace + margin.left + this.markerHeight : +rect.width - this.extraSpace - margin.left) : labelLocation - rect.width + this.extraSpace + margin.right;
          break;
        case "Middle":
          labelLocation = labelLocation = !this.inverted ? isMinus ? labelLocation - rect.height / 2 : labelLocation + rect.height / 2 : isMinus ? labelLocation + rect.width / 2 : labelLocation - rect.width / 2;
          break;
        case "Auto":
          labelLocation = this.calculateRectActualPosition(labelLocation, rect, isMinus, series, textSize, labelIndex, point);
          break;
        default:
          this.extraSpace += this.errorHeight;
          labelLocation = this.calculateTopAndOuterPosition(labelLocation, rect, position, series, labelIndex, this.extraSpace, isMinus, point);
          break;
      }
      var check = !this.inverted ? labelLocation < rect.y || labelLocation > rect.y + rect.height : labelLocation < rect.x || labelLocation > rect.x + rect.width;
      this.fontBackground = check ? this.fontBackground === "transparent" ? this.chartBackground : this.fontBackground : this.fontBackground === "transparent" ? point.color || series.interior : this.fontBackground;
      var seriesLength = series.chart.series.length;
      if (position === "Outer" && series.type.indexOf("Stacking") > -1 && seriesLength - 1 > series.index) {
        var nextSeries = void 0;
        var nextSeriesPoint = void 0;
        for (var i = series.index + 1; i < seriesLength; i++) {
          nextSeries = series.chart.series[i];
          nextSeriesPoint = nextSeries.points[point.index];
          if (nextSeries.type.indexOf("Stacking") > -1 && nextSeries.type.indexOf("100") === -1) {
            this.fontBackground = nextSeriesPoint && (nextSeriesPoint.yValue < 0 && point.yValue < 0 || nextSeriesPoint.yValue > 0 && point.yValue > 0) ? nextSeriesPoint ? nextSeriesPoint.color : nextSeries.interior : this.fontBackground;
            break;
          }
        }
      }
      return labelLocation;
    };
    DataLabel3.prototype.calculatePathPosition = function(labelLocation, position, series, point, size, labelIndex) {
      var padding = 5;
      if (series.type.indexOf("Area") > -1 && series.type !== "RangeArea" && series.type !== "SplineRangeArea" && series.type !== "RangeStepArea" && this.yAxisInversed && series.marker.dataLabel.position !== "Auto") {
        position = position === "Top" ? "Bottom" : position === "Bottom" ? "Top" : position;
      }
      this.fontBackground = this.fontBackground === "transparent" ? this.chartBackground : this.fontBackground;
      switch (position) {
        case "Top":
        case "Outer":
          labelLocation = labelLocation - this.markerHeight - this.borderWidth - size.height / 2 - this.margin.bottom - padding - this.errorHeight;
          break;
        case "Bottom":
          labelLocation = labelLocation + this.markerHeight + this.borderWidth + size.height / 2 + this.margin.top + padding + this.errorHeight;
          break;
        case "Auto":
          labelLocation = this.calculatePathActualPosition(labelLocation, this.markerHeight, series, point, size, labelIndex);
          break;
      }
      return labelLocation;
    };
    DataLabel3.prototype.isDataLabelShape = function(style) {
      this.isShape = style.color !== "transparent" || style.border.width > 0;
      this.borderWidth = style.border.width;
      if (!this.isShape) {
        this.margin = {
          left: 0,
          right: 0,
          bottom: 0,
          top: 0
        };
      }
    };
    DataLabel3.prototype.calculateRectActualPosition = function(labelLocation, rect, isMinus, series, size, labelIndex, point) {
      var location;
      var labelRect;
      var isOverLap = true;
      var position = 0;
      var collection = this.chart.dataLabelCollections;
      var finalPosition = series.type.indexOf("Range") !== -1 || series.type === "Hilo" ? 2 : 4;
      while (isOverLap && position < finalPosition) {
        var actualPosition = this.getPosition(position);
        this.fontBackground = series.marker.dataLabel.fill;
        if (series.type.indexOf("Stacking") > -1 && actualPosition === "Outer") {
          actualPosition = "Top";
          position++;
        }
        location = this.calculateRectPosition(labelLocation, rect, isMinus, actualPosition, series, size, labelIndex, point);
        if (!this.inverted) {
          if (series.marker.dataLabel.enableRotation) {
            size.width = size.width - point.regions[0].width / 10;
          }
          labelRect = calculateRect(new ChartLocation(this.locationX, location), size, this.margin);
          isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect) || labelRect.y > series.clipRect.height;
          if (series.marker.dataLabel.template === null && isOverLap !== true) {
            isOverLap = labelRect.y / 2 + size.height + (actualPosition === "Outer" ? point.regions[0].height + this.extraSpace : point.regions[0].height - 2 * this.extraSpace) > series.clipRect.height;
          }
        } else {
          labelRect = calculateRect(new ChartLocation(location, this.locationY), size, this.margin);
          isOverLap = labelRect.x < 0 || isCollide(labelRect, collection, series.clipRect) || labelRect.x + labelRect.width > series.clipRect.width;
        }
        position++;
      }
      return location;
    };
    DataLabel3.prototype.calculateAlignment = function(value, labelLocation, alignment, isMinus) {
      switch (alignment) {
        case "Far":
          labelLocation = !this.inverted ? isMinus ? labelLocation + value : labelLocation - value : isMinus ? labelLocation - value : labelLocation + value;
          break;
        case "Near":
          labelLocation = !this.inverted ? isMinus ? labelLocation - value : labelLocation + value : isMinus ? labelLocation + value : labelLocation - value;
          break;
      }
      return labelLocation;
    };
    DataLabel3.prototype.calculateTopAndOuterPosition = function(location, rect, position, series, index, extraSpace, isMinus, point) {
      var margin = this.margin;
      var top;
      switch (series.type) {
        case "RangeColumn":
        case "RangeArea":
        case "RangeStepArea":
        case "SplineRangeArea":
        case "Hilo":
          top = index === 0 && !this.yAxisInversed || index === 1 && this.yAxisInversed;
          location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);
          break;
        case "Candle":
          top = (index === 0 || index === 2) && !this.yAxisInversed || (index === 1 || index === 3) && this.yAxisInversed;
          location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top, index > 1);
          break;
        case "HiloOpenClose":
          if (index <= 1) {
            top = index === 0 && !this.yAxisInversed || index === 1 && this.yAxisInversed;
            location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);
          } else {
            if (this.yAxisInversed) {
              location = !this.inverted ? location + extraSpace + margin.top : location - extraSpace - margin.right;
            } else {
              location = !this.inverted ? location - extraSpace - margin.bottom : location + extraSpace + margin.left;
            }
          }
          break;
        default:
          if (isMinus && position === "Top" || !isMinus && position === "Outer" || position === "Top" && series.visiblePoints[point.index].yValue === 0) {
            location = !this.inverted ? location + (isMinus && series.type === "Waterfall" ? -rect.height + extraSpace + margin.bottom : -extraSpace - margin.bottom - this.markerHeight) : location + (isMinus && series.type === "Waterfall" ? +rect.width - extraSpace - margin.left : +extraSpace + margin.left + this.markerHeight);
          } else {
            location = !this.inverted ? location + (isMinus && series.type === "Waterfall" ? -rect.height - extraSpace - margin.top : +extraSpace + margin.top + this.markerHeight) : location + (isMinus && series.type === "Waterfall" ? +rect.width + extraSpace + margin.top : -extraSpace - margin.right - this.markerHeight);
          }
          break;
      }
      return location;
    };
    DataLabel3.prototype.updateLabelLocation = function(position, location, extraSpace, margin, rect, top, inside2) {
      if (inside2 === void 0) {
        inside2 = false;
      }
      if (!this.inverted) {
        if (top) {
          location = position === "Outer" && !inside2 ? location - extraSpace - margin.bottom - this.markerHeight : location + extraSpace + margin.top + this.markerHeight;
        } else {
          location = position === "Outer" && !inside2 ? location + rect.height + extraSpace + margin.top + this.markerHeight : location + rect.height - extraSpace - margin.bottom - this.markerHeight;
        }
      } else {
        if (top) {
          location = position === "Outer" && !inside2 ? location + extraSpace + margin.left + this.markerHeight : location - extraSpace - margin.right - this.markerHeight;
        } else {
          location = position === "Outer" && !inside2 ? location - rect.width - extraSpace - margin.right - this.markerHeight : location - rect.width + extraSpace + margin.left + this.markerHeight;
        }
      }
      return location;
    };
    DataLabel3.prototype.calculatePathActualPosition = function(y, markerSize, series, point, size, labelIndex) {
      var points = series.points;
      var index = point.index;
      var yValue = points[index].yValue;
      var position;
      var nextPoint = points.length - 1 > index ? points[index + 1] : null;
      var previousPoint = index > 0 ? points[index - 1] : null;
      var yLocation;
      var isOverLap = true;
      var labelRect;
      var isBottom;
      var positionIndex;
      var collection = this.chart.dataLabelCollections;
      if (series.type === "Bubble") {
        position = "Top";
      } else if (series.type.indexOf("Step") > -1) {
        position = "Top";
        if (index) {
          position = !previousPoint || !previousPoint.visible || yValue > previousPoint.yValue !== this.yAxisInversed || yValue === previousPoint.yValue ? "Top" : "Bottom";
        }
      } else if (series.type === "BoxAndWhisker") {
        if (labelIndex === 1 || labelIndex === 3 || labelIndex > 4) {
          position = series.yAxis.isAxisInverse ? "Bottom" : "Top";
        } else if (labelIndex === 2 || labelIndex === 4) {
          position = series.yAxis.isAxisInverse ? "Top" : "Bottom";
        } else {
          isOverLap = false;
          position = "Middle";
          yLocation = this.calculatePathPosition(y, position, series, point, size, labelIndex);
        }
      } else {
        if (index === 0) {
          position = !nextPoint || !nextPoint.visible || yValue > nextPoint.yValue || yValue < nextPoint.yValue && this.yAxisInversed ? "Top" : "Bottom";
        } else if (index === points.length - 1) {
          position = !previousPoint || !previousPoint.visible || yValue > previousPoint.yValue || yValue < previousPoint.yValue && this.yAxisInversed ? "Top" : "Bottom";
        } else {
          if (!nextPoint.visible && !(previousPoint && previousPoint.visible)) {
            position = "Top";
          } else if (!nextPoint.visible || !previousPoint) {
            position = nextPoint.yValue > yValue || previousPoint && previousPoint.yValue > yValue ? "Bottom" : "Top";
          } else {
            var slope = (nextPoint.yValue - previousPoint.yValue) / 2;
            var intersectY = slope * index + (nextPoint.yValue - slope * (index + 1));
            position = !this.yAxisInversed ? intersectY < yValue ? "Top" : "Bottom" : intersectY < yValue ? "Bottom" : "Top";
          }
        }
      }
      isBottom = position === "Bottom";
      positionIndex = ["Outer", "Top", "Bottom", "Middle", "Auto"].indexOf(position);
      while (isOverLap && positionIndex < 4) {
        yLocation = this.calculatePathPosition(y, this.getPosition(positionIndex), series, point, size, labelIndex);
        labelRect = calculateRect(new ChartLocation(this.locationX, yLocation), size, this.margin);
        isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect) || labelRect.y + labelRect.height > series.clipRect.height;
        positionIndex = isBottom ? positionIndex - 1 : positionIndex + 1;
        isBottom = false;
      }
      return yLocation;
    };
    DataLabel3.prototype.doDataLabelAnimation = function(series, element) {
      var shapeElements = series.shapeElement.childNodes;
      var textNode = series.textElement.childNodes;
      var delay = series.animation.delay + series.animation.duration;
      var duration = series.chart.animated ? series.chart.duration : 200;
      var location;
      var length = element ? 1 : textNode.length;
      var tempElement;
      for (var i = 0; i < length; i++) {
        tempElement = textNode[i];
        if (element) {
          element.style.visibility = "hidden";
          templateAnimate(element, delay, duration, "ZoomIn");
        } else {
          location = new ChartLocation(+tempElement.getAttribute("x") + +tempElement.getAttribute("width") / 2, +tempElement.getAttribute("y") + +tempElement.getAttribute("height") / 2);
          markerAnimate(tempElement, delay, series.animation.duration, series, null, location, true);
          if (shapeElements[i]) {
            tempElement = shapeElements[i];
            location = new ChartLocation(+tempElement.getAttribute("x") + +tempElement.getAttribute("width") / 2, +tempElement.getAttribute("y") + +tempElement.getAttribute("height") / 2);
            markerAnimate(tempElement, delay, series.animation.duration, series, null, location, true);
          }
        }
      }
    };
    DataLabel3.prototype.getPosition = function(index) {
      return ["Outer", "Top", "Bottom", "Middle", "Auto"][index];
    };
    DataLabel3.prototype.getModuleName = function() {
      return "DataLabel";
    };
    DataLabel3.prototype.destroy = function() {
    };
    return DataLabel3;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/error-bar.js
var ErrorBar = (
  /** @class */
  function() {
    function ErrorBar2(chart) {
      this.chart = chart;
    }
    ErrorBar2.prototype.render = function(series) {
      if (this.chart.chartAreaType === "PolarRadar") {
        return null;
      }
      this.createElement(series, this.chart);
      this.renderErrorBar(series);
    };
    ErrorBar2.prototype.renderErrorBar = function(series) {
      var seriesIndex = series.index;
      var symbolId;
      var capId;
      var errorbar = series.errorBar;
      var errorBarCap = series.errorBar.errorBarCap;
      var errorDirection = ["", ""];
      var redraw = series.chart.redraw;
      for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
        var point = _a[_i];
        if (point.visible && point.symbolLocations[0]) {
          var errorX = 0;
          var errorY = 0;
          switch (errorbar.mode) {
            case "Vertical":
              errorY = point.verticalError;
              break;
            case "Horizontal":
              errorX = point.horizontalError;
              break;
            case "Both":
              errorX = point.horizontalError;
              errorY = point.verticalError;
              break;
          }
          errorDirection = this["calculate" + errorbar.type + "Value"](point, series, this.chart.requireInvertedAxis, errorX, errorY);
          symbolId = this.chart.element.id + "_Series__ErrorBarGroup_" + seriesIndex + "_Point_" + point.index;
          capId = this.chart.element.id + "_Series__ErrorBarCap_" + seriesIndex + "_Point_" + point.index;
          var shapeOption = new PathOption(symbolId, "", errorbar.width, errorbar.errorBarColorMapping ? point.errorBarColor : errorbar.color || this.chart.themeStyle.errorBar, null, "", errorDirection[0]);
          var element = getElement2(shapeOption.id);
          var previousDirection = element ? element.getAttribute("d") : null;
          if (series.errorBarElement) {
            series.errorBarElement.appendChild(this.chart.renderer.drawPath(shapeOption));
          }
          pathAnimation(element, errorDirection[0], redraw, previousDirection, this.chart.duration);
          var capOption = new PathOption(capId, "", errorBarCap.width, errorbar.errorBarCap.color ? errorBarCap.color : errorbar.errorBarColorMapping ? point.errorBarColor : errorbar.color || this.chart.themeStyle.errorBar, null, "", errorDirection[1]);
          element = getElement2(capOption.id);
          previousDirection = element ? element.getAttribute("d") : null;
          if (series.errorBarElement) {
            appendChildElement(this.chart.enableCanvas, series.errorBarElement, this.chart.renderer.drawPath(capOption), redraw);
          }
          pathAnimation(element, errorDirection[1], redraw, previousDirection, this.chart.duration);
        }
      }
    };
    ErrorBar2.prototype.findLocation = function(point, series, isInverted, x1, y1) {
      var errorbar = series.errorBar;
      var direction = errorbar.direction;
      var location = [];
      var yValue = series.type.indexOf("Stacking") > -1 ? series.stackedValues.endValues[point.index] : series.seriesType === "HighLow" || series.seriesType === "HighLowOpenClose" ? series.points[point.index].high : point.yValue;
      var startPoint = getPoint(point.xValue + (direction === "Plus" || direction === "Both" ? errorbar.type === "Custom" && (errorbar.mode === "Horizontal" || errorbar.mode === "Both") ? x1 = point.horizontalPositiveError : x1 : 0), yValue + (direction === "Plus" || direction === "Both" ? errorbar.type === "Custom" && (errorbar.mode === "Vertical" || errorbar.mode === "Both") ? y1 = point.verticalPositiveError : y1 : 0), series.xAxis, series.yAxis, isInverted);
      location.push(startPoint);
      if (series.isRectSeries) {
        var midPoint = point.symbolLocations[0];
        location.push(midPoint);
      } else {
        var midPoint = getPoint(point.xValue, point.yValue, series.xAxis, series.yAxis, isInverted);
        location.push(midPoint);
      }
      var endPoint = getPoint(point.xValue - (direction === "Minus" || direction === "Both" ? errorbar.type === "Custom" && (errorbar.mode === "Horizontal" || errorbar.mode === "Both") ? x1 = point.horizontalNegativeError : x1 : 0), yValue - (direction === "Minus" || direction === "Both" ? errorbar.type === "Custom" && (errorbar.mode === "Vertical" || errorbar.mode === "Both") ? y1 = point.verticalNegativeError : y1 : 0), series.xAxis, series.yAxis, isInverted);
      location.push(endPoint);
      point.error = errorbar.mode === "Vertical" ? errorbar.verticalError : errorbar.horizontalError;
      this.negativeHeight = errorbar.mode === "Vertical" || errorbar.mode === "Both" ? isInverted ? location[1].x - location[2].x : location[2].y - location[1].y : 0;
      this.positiveHeight = errorbar.mode === "Vertical" || errorbar.mode === "Both" ? isInverted ? location[0].x - location[1].x : location[1].y - location[0].y : 0;
      return this.getErrorDirection(location[0], location[1], location[2], series, isInverted);
    };
    ErrorBar2.prototype.calculateFixedValue = function(point, series, isInverted, errorX, errorY) {
      return this.findLocation(point, series, isInverted, errorX, errorY);
    };
    ErrorBar2.prototype.calculatePercentageValue = function(point, series, isInverted, errorX, errorY) {
      errorX = errorX / 100 * point.xValue;
      errorY = errorY / 100 * point.yValue;
      return this.findLocation(point, series, isInverted, errorX, errorY);
    };
    ErrorBar2.prototype.calculateStandardDeviationValue = function(point, series, isInverted, errorX, errorY) {
      var getMean = this.meanCalculation(series, series.errorBar.mode);
      errorX = errorX * (getMean.horizontalSquareRoot + getMean.horizontalMean);
      errorY = errorY * (getMean.verticalSquareRoot + getMean.verticalMean);
      return this.findLocation(point, series, isInverted, errorX, errorY);
    };
    ErrorBar2.prototype.calculateStandardErrorValue = function(point, series, isInverted, errorX, errorY) {
      var length = series.points.length;
      var getMean = this.meanCalculation(series, series.errorBar.mode);
      errorX = errorX * getMean.horizontalSquareRoot / Math.sqrt(length);
      errorY = errorY * getMean.verticalSquareRoot / Math.sqrt(length);
      return this.findLocation(point, series, isInverted, errorX, errorY);
    };
    ErrorBar2.prototype.calculateCustomValue = function(point, series, isInverted, errorX, errorY) {
      return this.findLocation(point, series, isInverted, errorX, errorY);
    };
    ErrorBar2.prototype.getHorizontalDirection = function(start, mid, end, direction, errorMode, capLength) {
      var path = "";
      var capDirection = "";
      path += "M " + start.x + " " + mid.y + " L " + end.x + " " + mid.y;
      capDirection += direction === "Plus" || direction === "Both" ? "M " + start.x + " " + (mid.y - capLength) + " L " + start.x + " " + (mid.y + capLength) : "";
      capDirection += direction === "Minus" || direction === "Both" ? "M " + end.x + " " + (mid.y - capLength) + " L " + end.x + " " + (mid.y + capLength) : " ";
      return [path, capDirection];
    };
    ErrorBar2.prototype.getVerticalDirection = function(start, mid, end, direction, errorMode, capLength) {
      var path = "";
      var capDirection = "";
      path += "M " + mid.x + " " + start.y + " L " + mid.x + " " + end.y;
      capDirection += direction === "Plus" || direction === "Both" ? "M " + (mid.x - capLength) + " " + start.y + " L " + (mid.x + capLength) + " " + start.y : "";
      capDirection += direction === "Minus" || direction === "Both" ? "M " + (mid.x - capLength) + " " + end.y + " L " + (mid.x + capLength) + " " + end.y : "";
      return [path, capDirection];
    };
    ErrorBar2.prototype.getBothDirection = function(start, mid, end, direction, errorMode, capLength) {
      var capDirection = "";
      var path = "";
      var pathH = this.getHorizontalDirection(start, mid, end, direction, errorMode, capLength);
      var pathV = this.getVerticalDirection(start, mid, end, direction, errorMode, capLength);
      path = pathH[0].concat(pathV[0]);
      capDirection = pathH[1].concat(pathV[1]);
      return [path, capDirection];
    };
    ErrorBar2.prototype.getErrorDirection = function(start, mid, end, series, isInverted) {
      var direction = series.errorBar.direction;
      var mode = series.errorBar.mode;
      var capLength = series.errorBar.errorBarCap.length;
      var paths;
      var errorMode = mode;
      switch (mode) {
        case "Both":
          errorMode = mode;
          break;
        case "Horizontal":
          errorMode = isInverted ? "Vertical" : mode;
          break;
        case "Vertical":
          errorMode = isInverted ? "Horizontal" : mode;
          break;
      }
      switch (errorMode) {
        case "Horizontal":
          paths = this.getHorizontalDirection(start, mid, end, direction, errorMode, capLength);
          break;
        case "Vertical":
          paths = this.getVerticalDirection(start, mid, end, direction, errorMode, capLength);
          break;
        case "Both":
          paths = this.getBothDirection(start, mid, end, direction, errorMode, capLength);
          break;
      }
      return [paths[0], paths[1]];
    };
    ErrorBar2.prototype.meanCalculation = function(series, mode) {
      var sumOfX = 0;
      var sumOfY = 0;
      var verticalMean = 0;
      var horizontalMean = 0;
      var length = series.points.length;
      switch (mode) {
        case "Vertical":
          sumOfY = sum(series.yData);
          verticalMean = sumOfY / length;
          break;
        case "Horizontal":
          sumOfX = sum(series.xData);
          horizontalMean = sumOfX / length;
          break;
        case "Both":
          sumOfY = sum(series.yData);
          verticalMean = sumOfY / length;
          sumOfX = sum(series.xData);
          horizontalMean = sumOfX / length;
      }
      for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
        var point = _a[_i];
        if (mode === "Vertical") {
          sumOfY = sumOfY + Math.pow(point.yValue - verticalMean, 2);
        } else if (mode === "Horizontal") {
          sumOfX = sumOfX + Math.pow(point.xValue - horizontalMean, 2);
        } else {
          sumOfY = sumOfY + Math.pow(point.yValue - verticalMean, 2);
          sumOfX = sumOfX + Math.pow(point.xValue - horizontalMean, 2);
        }
      }
      var verStandardMean = sumOfY / (length - 1);
      var verSquareRoot = Math.sqrt(sumOfY / (length - 1));
      var horStandardMean = sumOfX / (length - 1);
      var horSquareRoot = Math.sqrt(sumOfX / (length - 1));
      return new Mean(verStandardMean, verSquareRoot, horStandardMean, horSquareRoot, verticalMean, horizontalMean);
    };
    ErrorBar2.prototype.createElement = function(series, chart) {
      var transform = chart.chartAreaType === "Cartesian" ? "translate(" + series.clipRect.x + "," + series.clipRect.y + ")" : "";
      var markerHeight = series.marker.height / 2;
      var markerWidth = series.marker.width / 2;
      if (chart.chartAreaType === "Cartesian") {
        var options = new RectOption(chart.element.id + "_ChartErrorBarClipRect_" + series.index, "transparent", {
          width: 1,
          color: "Gray"
        }, 1, {
          x: -markerWidth,
          y: -markerHeight,
          width: series.clipRect.width + markerWidth * 2,
          height: series.clipRect.height + markerHeight * 2
        });
        series.errorBarElement = chart.renderer.createGroup({
          "id": chart.element.id + "ErrorBarGroup" + series.index,
          "transform": transform,
          "clip-path": "url(#" + chart.element.id + "_ChartErrorBarClipRect_" + series.index + ")"
        });
        if (series.errorBarElement) {
          series.errorBarElement.appendChild(appendClipElement(chart.redraw, options, chart.renderer));
        }
      }
    };
    ErrorBar2.prototype.doErrorBarAnimation = function(series) {
      var errorBarElements = series.errorBarElement.childNodes;
      if (!errorBarElements) {
        return null;
      }
      var delay = series.animation.delay + (series.animation.duration === 0 && animationMode === "Enable" ? 1e3 : series.animation.duration);
      var j = 1;
      while (j < errorBarElements.length) {
        for (var i = 0; i < series.points.length; i++) {
          if (!series.points[i].symbolLocations[0]) {
            continue;
          }
          errorBarElements[j].style.visibility = "hidden";
          templateAnimate(errorBarElements[j], delay, 350, series.chart.requireInvertedAxis ? "SlideLeftIn" : "SlideBottomIn", false);
        }
        j++;
      }
    };
    ErrorBar2.prototype.getModuleName = function() {
      return "ErrorBar";
    };
    ErrorBar2.prototype.destroy = function() {
    };
    return ErrorBar2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart/legend/legend.js
var __extends58 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Legend = (
  /** @class */
  function(_super) {
    __extends58(Legend2, _super);
    function Legend2(chart) {
      var _this = _super.call(this, chart) || this;
      _this.library = _this;
      _this.addEventListener();
      return _this;
    }
    Legend2.prototype.addEventListener = function() {
      if (this.chart.isDestroyed) {
        return;
      }
      this.chart.on(Browser.touchMoveEvent, this.mouseMove, this);
      this.chart.on("click", this.click, this);
      this.chart.on(Browser.touchEndEvent, this.mouseEnd, this);
    };
    Legend2.prototype.removeEventListener = function() {
      if (this.chart.isDestroyed) {
        return;
      }
      this.chart.off(Browser.touchMoveEvent, this.mouseMove);
      this.chart.off("click", this.click);
      this.chart.off(Browser.touchEndEvent, this.mouseEnd);
    };
    Legend2.prototype.mouseMove = function(e) {
      if (this.chart.legendSettings.visible && !this.chart.isTouch) {
        this.move(e);
        if (this.chart.highlightModule && (this.chart.highlightMode !== "None" || this.chart.legendSettings.enableHighlight)) {
          var legendItemsId = [this.legendID + "_text_", this.legendID + "_shape_marker_", this.legendID + "_shape_", this.legendID + "_g_"];
          var targetId = e.target.id;
          var index = void 0;
          for (var _i = 0, legendItemsId_1 = legendItemsId; _i < legendItemsId_1.length; _i++) {
            var id = legendItemsId_1[_i];
            if (targetId.indexOf(id) > -1) {
              index = parseInt(targetId.split(id)[1], 10);
              this.chart.highlightModule.legendSelection(this.chart, index, e.target, e.type);
              break;
            }
          }
        }
      }
    };
    Legend2.prototype.mouseEnd = function(e) {
      if (this.chart.legendSettings.visible && this.chart.isTouch) {
        this.move(e);
      }
    };
    Legend2.prototype.getLegendOptions = function(visibleSeriesCollection, chart) {
      this.legendCollections = [];
      var seriesType;
      var fill;
      var dashArray;
      var colors = [];
      this.isRtlEnable = chart.enableRtl;
      this.isReverse = !this.isRtlEnable && chart.legendSettings.reverse;
      if (visibleSeriesCollection.length > 1) {
        this.legend.mode = "Series";
      }
      for (var _i = 0, visibleSeriesCollection_1 = visibleSeriesCollection; _i < visibleSeriesCollection_1.length; _i++) {
        var series = visibleSeriesCollection_1[_i];
        if (this.legend.mode === "Series") {
          if (series.category !== "Indicator") {
            seriesType = chart.chartAreaType === "PolarRadar" ? series.drawType : series.type;
            dashArray = !series.marker.visible && seriesType.indexOf("Line") > -1 && seriesType.indexOf("Area") === -1 ? series.dashArray : "";
            fill = series.interior;
            this.legendCollections.push(new LegendOptions(series.name, fill, series.legendShape, series.category === "TrendLine" ? this.chart.series[series.sourceIndex].trendlines[series.index].visible : series.visible, seriesType, series.legendImageUrl ? series.legendImageUrl : series.type === "Scatter" && series.marker.shape === "Image" ? series.marker.imageUrl : "", series.marker.shape, series.marker.visible, null, null, dashArray));
          }
        } else if (this.legend.mode === "Point") {
          for (var _a = 0, _b = series.points; _a < _b.length; _a++) {
            var points = _b[_a];
            seriesType = chart.chartAreaType === "PolarRadar" ? series.drawType : series.type;
            fill = points.interior ? points.interior : series.interior;
            this.legendCollections.push(new LegendOptions(points.x.toString(), fill, series.legendShape, series.category === "TrendLine" ? this.chart.series[series.sourceIndex].trendlines[series.index].visible : points.visible, seriesType, series.type === "Scatter" && series.marker.shape === "Image" ? series.marker.imageUrl : "", series.marker.shape, series.marker.visible));
          }
        } else if (this.legend.mode === "Range") {
          for (var _c = 0, _d = series.points; _c < _d.length; _c++) {
            var points = _d[_c];
            seriesType = chart.chartAreaType === "PolarRadar" ? series.drawType : series.type;
            fill = points.interior ? points.interior : series.interior;
            var legendLabel = "Others";
            if (colors.indexOf(fill) < 0) {
              colors.push(fill);
              if (chart.rangeColorSettings.length >= 1 && chart.rangeColorSettings[0].colors.length === 1) {
                for (var _e = 0, _f = chart.rangeColorSettings; _e < _f.length; _e++) {
                  var rangeMap = _f[_e];
                  if (rangeMap.colors[0] === fill) {
                    legendLabel = rangeMap.label;
                  }
                }
                this.legendCollections.push(new LegendOptions(legendLabel, fill, series.legendShape, series.category === "TrendLine" ? this.chart.series[series.sourceIndex].trendlines[series.index].visible : points.visible, seriesType, series.type === "Scatter" && series.marker.shape === "Image" ? series.marker.imageUrl : "", series.marker.shape, series.marker.visible));
              }
            }
          }
        } else {
          if (this.legendCollections.length === 0 && chart.rangeColorSettings.length > 0) {
            var startLabel = chart.rangeColorSettings[0].start.toString();
            var endLabel = chart.rangeColorSettings[chart.rangeColorSettings.length - 1].end.toString();
            this.legendCollections.push(new LegendOptions(startLabel, series.interior, "Rectangle", true, seriesType, "", series.marker.shape, series.marker.visible));
            this.legendCollections.push(new LegendOptions(endLabel, series.interior, "Rectangle", true, seriesType, "", series.marker.shape, series.marker.visible));
          }
        }
      }
      if (this.isReverse && chart.legendSettings.mode !== "Gradient") {
        this.legendCollections.reverse();
      }
    };
    Legend2.prototype.getLegendBounds = function(availableSize, legendBounds, legend) {
      this.calculateLegendTitle(legend, legendBounds);
      this.isTitle = legend.title ? true : false;
      this.chartRowCount = 1;
      this.rowHeights = [];
      this.columnHeights = [];
      this.pageHeights = [];
      var padding = legend.padding;
      var titlePosition = legend.titlePosition;
      var extraHeight = 0;
      var legendOption;
      var extraWidth = 0;
      var arrowWidth = this.arrowWidth;
      var arrowHeight = this.arrowHeight;
      var verticalArrowSpace = this.isVertical && !legend.enablePages ? arrowHeight : 0;
      var titleSpace = this.isTitle && titlePosition === "Top" ? this.legendTitleSize.height + this.fivePixel : 0;
      titleSpace = this.isTitle && this.isVertical && titlePosition !== "Top" ? this.legendTitleSize.height + this.fivePixel : titleSpace;
      if (!this.isVertical) {
        extraHeight = !legend.height ? availableSize.height / 100 * 5 : 0;
      } else {
        extraWidth = !legend.width ? availableSize.width / 100 * 5 : 0;
      }
      legendBounds.height += extraHeight;
      legendBounds.width += extraWidth;
      var shapeWidth = legend.shapeWidth;
      var shapePadding = legend.shapePadding;
      var maximumWidth = 0;
      var rowWidth = 0;
      var legendWidth = 0;
      var columnHeight = 0;
      var columnCount = 0;
      var rowCount = 0;
      var titlePlusArrowSpace = 0;
      var legendEventArgs;
      var render = false;
      this.maxItemHeight = Math.max(measureText("MeasureText", legend.textStyle, this.chart.themeStyle.legendLabelFont).height, legend.shapeHeight);
      var maxColumn = legend.layout === "Auto" && legend.maximumColumns > 0;
      if (legend.fixedWidth) {
        for (var i = 0; i < this.legendCollections.length; i++) {
          var textWidth = shapeWidth + shapePadding + (!this.isVertical ? i === 0 ? padding : this.itemPadding : padding) + (legend.maximumLabelWidth ? legend.maximumLabelWidth : measureText(this.legendCollections[i].text, legend.textStyle, this.chart.themeStyle.legendLabelFont).width);
          this.maxWidth = Math.max(this.maxWidth, textWidth);
        }
      }
      for (var i = 0; i < this.legendCollections.length; i++) {
        legendOption = this.legendCollections[i];
        if (regSub.test(legendOption.text)) {
          legendOption.text = getUnicodeText(legendOption.text, regSub);
        }
        if (regSup.test(legendOption.text)) {
          legendOption.text = getUnicodeText(legendOption.text, regSup);
        }
        legendEventArgs = {
          fill: legendOption.fill,
          text: legendOption.text,
          shape: legendOption.shape,
          markerShape: legendOption.markerShape,
          name: legendRender,
          cancel: false
        };
        this.chart.trigger(legendRender, legendEventArgs);
        legendOption.render = !legendEventArgs.cancel;
        legendOption.text = legendEventArgs.text;
        legendOption.fill = legendEventArgs.fill;
        legendOption.shape = legendEventArgs.shape;
        legendOption.markerShape = legendEventArgs.markerShape;
        legendOption.textSize = measureText(legendOption.text, legend.textStyle, this.chart.themeStyle.legendLabelFont);
        shapeWidth = legendOption.text ? legend.shapeWidth : 0;
        shapePadding = legendOption.text ? legend.shapePadding : 0;
        if (legendOption.render && legendOption.text) {
          render = true;
          legendWidth = legend.fixedWidth ? this.maxWidth : shapeWidth + shapePadding + (legend.maximumLabelWidth ? legend.maximumLabelWidth : legendOption.textSize.width) + (!this.isVertical || legend.layout === "Horizontal" ? i === 0 || columnCount === 1 && rowCount > 0 && legend.layout === "Horizontal" ? padding : this.itemPadding : padding);
          rowWidth = rowWidth + legendWidth;
          if (!legend.enablePages && !this.isVertical) {
            titlePlusArrowSpace = this.isTitle && titlePosition !== "Top" ? this.legendTitleSize.width + this.fivePixel : 0;
            titlePlusArrowSpace += arrowWidth;
          }
          this.getLegendHeight(legendOption, legend, legendBounds, rowWidth, this.maxItemHeight, padding);
          if (maxColumn ? columnCount === legend.maximumColumns : legend.layout === "Vertical" || legendBounds.width < padding + rowWidth + titlePlusArrowSpace || this.isVertical && legend.layout === "Auto") {
            maximumWidth = Math.max(maximumWidth, rowWidth + padding + titlePlusArrowSpace - (this.isVertical && this.legend.layout === "Auto" ? 0 : legendWidth));
            if (rowCount === 0 && legendWidth !== rowWidth) {
              rowCount = 1;
            }
            rowWidth = this.isVertical && this.legend.layout === "Auto" ? 0 : legendWidth;
            rowCount++;
            columnCount = 0;
            columnHeight = verticalArrowSpace;
          }
          var len = rowCount > 0 ? rowCount - 1 : 0;
          this.rowHeights[len] = Math.max(this.rowHeights[len] ? this.rowHeights[len] : 0, Math.max(legendOption.textSize.height, legend.shapeHeight));
          this.columnHeights[columnCount] = (this.columnHeights[columnCount] ? this.columnHeights[columnCount] : 0) + Math.max(legendOption.textSize.height, legend.shapeHeight) + (this.isVertical || rowCount > 0 && this.legend.itemPadding ? i === 0 ? padding : this.itemPadding : padding);
          columnCount++;
        }
      }
      columnHeight = Math.max.apply(null, this.columnHeights) + padding + titleSpace;
      columnHeight = Math.max(columnHeight, this.maxItemHeight + padding + padding + titleSpace);
      if (legend.layout === "Horizontal") {
        columnHeight = this.maxItemHeight + padding * 2 + titleSpace + this.pageButtonSize + legend.border.width;
      }
      this.isPaging = (legendBounds.height < columnHeight || legend.layout === "Horizontal" && this.rowHeights.length > 1) && !maxColumn;
      if (this.isPaging && !legend.enablePages) {
        if (!this.isVertical) {
          columnHeight = this.maxItemHeight + padding + padding + (titlePosition === "Top" ? titleSpace : 0);
        }
      }
      this.totalPages = rowCount;
      if (maxColumn && this.maxWidth && legend.fixedWidth) {
        rowWidth = this.maxWidth * legend.maximumColumns;
        this.isPaging = false;
      }
      if ((!this.isPaging || this.legend.layout !== "Auto") && !this.isVertical) {
        rowWidth += this.isTitle && titlePosition !== "Top" ? this.fivePixel + this.legendTitleSize.width + this.fivePixel : 0;
      }
      if (render) {
        this.setBounds(Math.max(rowWidth + padding, maximumWidth), columnHeight, legend, legendBounds);
      } else {
        this.setBounds(0, 0, legend, legendBounds);
      }
    };
    Legend2.prototype.getLegendHeight = function(legendOption, legend, legendBounds, rowWidth, legendHeight, padding) {
      var legendWidth = legendOption.textSize.width;
      var textPadding = legend.shapePadding + padding * 2 + legend.shapeWidth;
      switch (legend.textWrap) {
        case "Wrap":
        case "AnyWhere":
          if (legendWidth > legend.maximumLabelWidth || legendWidth + rowWidth > legendBounds.width) {
            legendOption.textCollection = textWrap(legendOption.text, legend.maximumLabelWidth ? Math.min(legend.maximumLabelWidth, legendBounds.width - textPadding) : legendBounds.width - textPadding, legend.textStyle, this.chart.enableRtl, null, null, this.chart.themeStyle.legendLabelFont);
          } else {
            legendOption.textCollection.push(legendOption.text);
          }
          legendOption.textSize.height = legendHeight * legendOption.textCollection.length;
          break;
      }
    };
    Legend2.prototype.getRenderPoint = function(legendOption, start, textPadding, previousLegend, rect, count, firstLegend) {
      var padding = this.legend.padding;
      var textWidth = this.legend.fixedWidth ? this.maxWidth : textPadding + (this.legend.maximumLabelWidth ? this.legend.maximumLabelWidth : previousLegend.textSize.width);
      var previousBound = previousLegend.location.x + (!this.isRtlEnable ? textWidth : -textWidth);
      if (this.legend.layout === "Auto" && this.legend.maximumColumns > 0 ? count % this.legend.maximumColumns === 0 : this.legend.layout === "Vertical" || this.isWithinBounds(previousBound, (this.legend.maximumLabelWidth ? this.legend.maximumLabelWidth : legendOption.textSize.width) + textPadding - this.itemPadding, rect) || this.isVertical && this.legend.layout === "Auto") {
        legendOption.location.x = start.x;
        if (count !== firstLegend) {
          this.chartRowCount++;
        }
        legendOption.location.y = count === firstLegend ? previousLegend.location.y : previousLegend.location.y + (this.isVertical && this.legend.layout !== "Horizontal" && !(this.legend.maximumColumns > 0) ? Math.max(previousLegend.textSize.height, this.legend.shapeHeight) : this.rowHeights[this.chartRowCount - 2]) + (this.isVertical || this.chartRowCount > 1 && this.legend.itemPadding ? this.itemPadding : padding);
      } else {
        legendOption.location.x = count === firstLegend ? previousLegend.location.x : previousBound;
        legendOption.location.y = previousLegend.location.y;
      }
      var availwidth = !this.isRtlEnable ? this.legendBounds.x + this.legendBounds.width - (legendOption.location.x + textPadding - this.itemPadding - this.legend.shapeWidth / 2) : legendOption.location.x - textPadding + this.itemPadding + this.legend.shapeWidth / 2 - this.legendBounds.x;
      if (!this.isVertical && this.isPaging && !this.legend.enablePages) {
        availwidth = this.legendBounds.width - legendOption.location.x - this.fivePixel;
      }
      availwidth = this.legend.maximumLabelWidth ? Math.min(this.legend.maximumLabelWidth, availwidth) : availwidth;
      if (this.legend.textOverflow === "Ellipsis" && this.legend.textWrap === "Normal") {
        legendOption.text = textTrim(+availwidth.toFixed(4), legendOption.text, this.legend.textStyle, this.chart.enableRtl, this.chart.themeStyle.legendLabelFont);
      }
    };
    Legend2.prototype.isWithinBounds = function(previousBound, textWidth, rect) {
      if (!this.isRtlEnable) {
        return previousBound + textWidth > rect.x + rect.width + this.legend.shapeWidth / 2;
      } else {
        return previousBound - textWidth < rect.x - this.legend.shapeWidth / 2;
      }
    };
    Legend2.prototype.LegendClick = function(index, event2) {
      var chart = this.chart;
      var seriesIndex = chart.legendSettings.mode === "Series" ? index : 0;
      var legendIndex = !this.isReverse ? index : this.legendCollections.length - 1 - index;
      var series = chart.visibleSeries[seriesIndex];
      var legend = this.legendCollections[legendIndex];
      var changeDetection = "isProtectedOnChange";
      if (chart.legendSettings.mode === "Series") {
        var legendClickArgs = {
          legendText: legend.text,
          legendShape: legend.shape,
          chart: chart.isBlazor ? {} : chart,
          series,
          points: series.points,
          name: legendClick,
          cancel: false
        };
        this.chart.trigger(legendClick, legendClickArgs);
        series.legendShape = legendClickArgs.legendShape;
        if (!legendClickArgs.cancel) {
          if (series.fill !== null) {
            chart.visibleSeries[index].interior = series.fill;
          }
          if (chart.legendSettings.toggleVisibility) {
            series.chart[changeDetection] = true;
            if (series.category === "TrendLine") {
              if (!chart.series[series.sourceIndex].trendlines[series.index].visible && chart.series[series.sourceIndex].visible) {
                chart.series[series.sourceIndex].trendlines[series.index].visible = true;
              } else {
                chart.series[series.sourceIndex].trendlines[series.index].visible = false;
              }
            } else {
              this.changeSeriesVisiblity(series, series.visible);
            }
            legend.visible = series.category === "TrendLine" ? chart.series[series.sourceIndex].trendlines[series.index].visible : series.visible;
            this.refreshLegendToggle(chart, series);
            if (chart.highlightModule && chart.legendSettings.enableHighlight) {
              chart.highlightModule.legendSelection(chart, index, event2.target, "mousemove");
            }
          } else if (chart.highlightModule) {
            chart.highlightModule.legendSelection(chart, index, event2.target, event2.type);
          } else if (chart.selectionModule) {
            chart.selectionModule.legendSelection(chart, index, event2.target, event2.type);
          }
          series.chart[changeDetection] = false;
        }
      } else if (chart.legendSettings.mode === "Point") {
        var point = series.points[index];
        var legendClickArgs = {
          legendText: legend.text,
          legendShape: legend.shape,
          chart: chart.isBlazor ? {} : chart,
          series,
          points: [point],
          name: legendClick,
          cancel: false
        };
        this.chart.trigger(legendClick, legendClickArgs);
        if (chart.legendSettings.toggleVisibility && !legendClickArgs.cancel) {
          point.visible = !point.visible;
          var legendOption = this.legendCollections[index];
          legendOption.visible = point.visible;
          this.refreshLegendToggle(chart, series);
        }
      } else if (chart.legendSettings.mode === "Range") {
        var points = [];
        var legendOption = this.legendCollections[index];
        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
          var point = _a[_i];
          if (legendOption.fill === (point.interior || series.interior)) {
            points.push(point);
          }
        }
        var legendClickArgs = {
          legendText: legend.text,
          legendShape: legend.shape,
          chart: chart.isBlazor ? {} : chart,
          series,
          points,
          name: legendClick,
          cancel: false
        };
        this.chart.trigger(legendClick, legendClickArgs);
        if (chart.legendSettings.toggleVisibility && !legendClickArgs.cancel) {
          legendOption.visible = !legendOption.visible;
          for (var _b = 0, points_1 = points; _b < points_1.length; _b++) {
            var point = points_1[_b];
            point.visible = !point.visible;
          }
          this.refreshLegendToggle(chart, series);
        }
      }
    };
    Legend2.prototype.refreshLegendToggle = function(chart, series) {
      var selectedDataIndexes = [];
      if (chart.selectionModule) {
        selectedDataIndexes = extend([], chart.selectionModule.selectedDataIndexes, null, true);
      }
      if (chart.svgObject.childNodes.length > 0 && !chart.enableAnimation && !chart.enableCanvas) {
        while (chart.svgObject.lastChild) {
          chart.svgObject.removeChild(chart.svgObject.lastChild);
        }
        remove(chart.svgObject);
      }
      chart.animateSeries = false;
      chart.redraw = chart.enableAnimation;
      series.isLegendClicked = true;
      chart.rotatedDataLabelCollections = [];
      removeElement2(getElement(chart.element.id + "_Secondary_Element").querySelectorAll(".ejSVGTooltip")[0]);
      blazorTemplatesReset(chart);
      this.redrawSeriesElements(series, chart);
      chart.removeSvg();
      chart.refreshAxis();
      series.refreshAxisLabel();
      this.refreshSeries(chart.visibleSeries);
      for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
        var series_1 = _a[_i];
        if (!isNullOrUndefined(series_1)) {
          chart.markerRender.removeHighlightedMarker(series_1, null, true);
        }
      }
      chart.refreshBound();
      chart.trigger("loaded", {
        chart
      });
      if (selectedDataIndexes.length > 0) {
        chart.selectionModule.selectedDataIndexes = selectedDataIndexes;
        chart.selectionModule.redrawSelection(chart, chart.selectionMode);
      }
      if (!chart.enableCanvas && chart.highlightModule && (chart.highlightMode !== "None" || chart.legendSettings.enableHighlight)) {
        chart.highlightModule.redrawSelection(chart, chart.highlightMode);
      }
      chart.redraw = false;
      series.isLegendClicked = false;
    };
    Legend2.prototype.changeSeriesVisiblity = function(series, visibility) {
      series.visible = !visibility;
      if (this.isSecondaryAxis(series.xAxis)) {
        series.xAxis.internalVisibility = series.xAxis.series.some(function(value) {
          return value.visible;
        });
      }
      if (this.isSecondaryAxis(series.yAxis) || series.category === "Pareto" && series.type === "Line") {
        series.yAxis.internalVisibility = series.yAxis.series.some(function(value) {
          return value.visible;
        });
      }
      if (series.trendlines.length && series.visible) {
        series.trendlines.forEach(function(trendline) {
          trendline.visible = true;
        });
      }
    };
    Legend2.prototype.isSecondaryAxis = function(axis) {
      return this.chart.axes.indexOf(axis) > -1;
    };
    Legend2.prototype.redrawSeriesElements = function(series, chart) {
      if (!chart.redraw) {
        return null;
      }
      removeElement2(chart.element.id + "_Series_" + (series.index === void 0 ? series.category : series.index) + "_DataLabelCollections");
    };
    Legend2.prototype.refreshSeries = function(seriesCollection) {
      for (var _i = 0, seriesCollection_1 = seriesCollection; _i < seriesCollection_1.length; _i++) {
        var series = seriesCollection_1[_i];
        if (series.type.indexOf("Spline") > -1) {
          var isArea = series.type.indexOf("Area") > -1 || series.drawType.indexOf("Area") > -1;
          var isRange = series.type.indexOf("Range") > -1;
          this.chart["spline" + (isArea ? isRange ? "RangeArea" : "Area" : "") + "SeriesModule"].findSplinePoint(series);
        }
        if (series.visible) {
          series.position = void 0;
        }
      }
    };
    Legend2.prototype.click = function(event2) {
      var _this = this;
      if (!this.chart.legendSettings.visible) {
        return;
      }
      var pageX = this.chart.mouseX;
      var pageY = this.chart.mouseY;
      var legendRegion = [];
      var targetId = event2.target.id.indexOf("_chart_legend_g_") > -1 ? event2.target.firstChild["id"] : event2.target.id;
      var legendItemsId = [this.legendID + "_text_", this.legendID + "_shape_marker_", this.legendID + "_shape_"];
      var seriesIndex;
      for (var _i = 0, legendItemsId_2 = legendItemsId; _i < legendItemsId_2.length; _i++) {
        var id = legendItemsId_2[_i];
        if (targetId.indexOf(id) > -1) {
          seriesIndex = parseInt(targetId.split(id)[1], 10);
          this.LegendClick(seriesIndex, event2);
          break;
        }
      }
      if (targetId.indexOf(this.legendID + "_pageup") > -1) {
        this.changePage(event2, true);
      } else if (targetId.indexOf(this.legendID + "_pagedown") > -1) {
        this.changePage(event2, false);
      }
      if (this.chart.enableCanvas && this.pagingRegions.length) {
        this.checkWithinBounds(pageX, pageY);
      }
      legendRegion = this.legendRegions.filter(function(region) {
        return withInBounds(pageX, pageY + (_this.isPaging ? (_this.currentPageNumber - 1) * _this.translatePage(_this.chart.enableCanvas, null, 1, 2) : 0), region.rect);
      });
      if (legendRegion.length && this.chart.enableCanvas) {
        this.LegendClick(legendRegion[0].index, event2);
      }
    };
    Legend2.prototype.checkWithinBounds = function(pageX, pageY) {
      var cRender = this.chart.renderer;
      var bounds = this.legendBounds;
      var borderWidth = this.chart.legendSettings.border.width;
      var canvasRect = new Rect(bounds.x, bounds.y, bounds.width, bounds.height);
      canvasRect.x = canvasRect.x - borderWidth / 2;
      canvasRect.y = canvasRect.y - borderWidth / 2;
      canvasRect.width = canvasRect.width + borderWidth;
      canvasRect.height = canvasRect.height + borderWidth;
      if (withInBounds(pageX, pageY, this.pagingRegions[0])) {
        if (!this.isRtlEnable) {
          this.canvasPageDown(cRender, canvasRect, bounds);
        } else {
          this.canvasPageUp(cRender, canvasRect, bounds);
        }
        return null;
      }
      if (withInBounds(pageX, pageY, this.pagingRegions[1])) {
        if (!this.isRtlEnable) {
          this.canvasPageUp(cRender, canvasRect, bounds);
        } else {
          this.canvasPageDown(cRender, canvasRect, bounds);
        }
        return null;
      }
    };
    Legend2.prototype.canvasPageDown = function(cRender, canvasRect, bounds) {
      if (--this.currentPageNumber > 0) {
        this.legendRegions = [];
        cRender.clearRect(canvasRect);
        cRender.canvasClip(new RectOption("legendClipPath", "transparent", {
          width: 0,
          color: ""
        }, null, canvasRect));
        this.renderLegend(this.chart, this.legend, bounds);
        cRender.canvasRestore();
      } else {
        ++this.currentPageNumber;
      }
    };
    Legend2.prototype.canvasPageUp = function(cRender, canvasRect, bounds) {
      if (++this.currentPageNumber > 0 && this.currentPageNumber <= this.totalNoOfPages) {
        this.legendRegions = [];
        cRender.clearRect(canvasRect);
        cRender.canvasClip(new RectOption("legendClipPath", "transpaent", {
          width: 0,
          color: ""
        }, null, canvasRect));
        this.renderLegend(this.chart, this.legend, bounds);
        cRender.canvasRestore();
      } else {
        --this.currentPageNumber;
      }
    };
    Legend2.prototype.getModuleName = function() {
      return "Legend";
    };
    Legend2.prototype.destroy = function() {
      this.removeEventListener();
    };
    return Legend2;
  }(BaseLegend)
);

// node_modules/@syncfusion/ej2-charts/src/common/annotation/annotation.js
var AnnotationBase = (
  /** @class */
  function() {
    function AnnotationBase2(control) {
      this.control = control;
    }
    AnnotationBase2.prototype.render = function(annotation, index) {
      this.isChart = this.control.getModuleName() === "chart";
      this.annotation = annotation;
      var childElement = createTemplate(createElement("div", {
        id: this.control.element.id + "_Annotation_" + index,
        styles: "position: absolute; z-index: 1"
        //by default z-index set for annotation elements
      }), index, this.control.enableHtmlSanitizer ? this.control.sanitize(annotation.content) : annotation.content, this.control);
      return childElement;
    };
    AnnotationBase2.prototype.setAnnotationPixelValue = function(location) {
      var rect = this.annotation.region === "Chart" ? new Rect(0, 0, this.control.availableSize.width, this.control.availableSize.height) : this.isChart ? this.control.chartAxisLayoutPanel.seriesClipRect : this.control.series[0].accumulationBound;
      location.x = (typeof this.annotation.x !== "string" ? typeof this.annotation.x === "number" ? this.annotation.x : 0 : stringToNumber(this.annotation.x, rect.width)) + rect.x;
      location.y = (typeof this.annotation.y === "number" ? this.annotation.y : stringToNumber(this.annotation.y, rect.height)) + rect.y;
      return true;
    };
    AnnotationBase2.prototype.setAnnotationPointValue = function(location) {
      var symbolLocation = new ChartLocation(0, 0);
      if (this.isChart) {
        var chart = this.control;
        var annotation = this.annotation;
        var xAxisName = annotation.xAxisName;
        var yAxisName = annotation.yAxisName;
        var isInverted = chart.requireInvertedAxis;
        var stockChart = this.control.stockChart;
        var xAxis = void 0;
        var yAxis = void 0;
        var xValue = void 0;
        for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {
          var axis = _a[_i];
          if (xAxisName === axis.name || xAxisName == null && axis.name === "primaryXAxis") {
            xAxis = axis;
            if (xAxis.isIndexed) {
              xValue = Number(annotation.x);
            } else if (xAxis.valueType.indexOf("Category") > -1) {
              var xAnnotation = xAxis.valueType === "DateTimeCategory" ? annotation.x.getTime().toString() : annotation.x;
              if (typeof xAnnotation === "object") {
                for (var i = 0; i < xAxis.labels.length; i++) {
                  if (xAxis.labels[i].toString() === annotation.x.toString()) {
                    xValue = i;
                  }
                }
              }
              if (xAxis.labels.indexOf(xAnnotation) < 0) {
                return false;
              } else {
                xValue = xAxis.labels.indexOf(xAnnotation);
              }
            } else if (xAxis.valueType === "DateTime") {
              var option = {
                skeleton: "full",
                type: "dateTime"
              };
              xValue = typeof this.annotation.x === "object" || typeof new Date(this.annotation.x) === "object" ? Date.parse(chart.intl.getDateParser(option)(chart.intl.getDateFormat(option)(new Date(DataUtil.parse.parseJson({
                val: annotation.x
              }).val)))) : 0;
            } else {
              xValue = +annotation.x;
            }
          } else if (yAxisName === axis.name || yAxisName == null && axis.name === "primaryYAxis") {
            yAxis = axis;
          }
        }
        if (xAxis && yAxis && withIn(xAxis.valueType === "Logarithmic" ? logBase(xValue, xAxis.logBase) : xValue, xAxis.visibleRange) && withIn(yAxis.valueType === "Logarithmic" ? logBase(+annotation.y, yAxis.logBase) : +annotation.y, yAxis.visibleRange)) {
          symbolLocation = getPoint(xValue, +annotation.y, xAxis, yAxis, isInverted);
          location.x = symbolLocation.x + (isInverted ? yAxis.rect.x : xAxis.rect.x);
          location.y = symbolLocation.y + (isInverted ? xAxis.rect.y : yAxis.rect.y) + (stockChart && stockChart.enablePeriodSelector ? stockChart.toolbarHeight + stockChart.titleSize.height : 0);
        } else {
          return false;
        }
        return true;
      } else {
        return this.setAccumulationPointValue(location);
      }
    };
    AnnotationBase2.prototype.processAnnotation = function(annotation, index, parentElement) {
      var chart = this.control;
      var location = new ChartLocation(0, 0);
      var annotationElement = this.render(annotation, index);
      var annotationRendered = function() {
        annotationElement.style.transform = "translate(-50%, -50%)";
      };
      annotationRendered.bind(location, this);
      if (this["setAnnotation" + annotation.coordinateUnits + "Value"](location)) {
        this.setElementStyle(location, annotationElement, parentElement);
      } else if (this.control.redraw) {
        removeElement2(annotationElement.id);
      }
      updateBlazorTemplate((this.control.element.id + "Annotation" + index).replace(/[^a-zA-Z0-9]/g, ""), "ContentTemplate", chart.stockChart ? chart.stockChart.annotations[index] : this.control.annotations[index], void 0, annotationRendered);
    };
    AnnotationBase2.prototype.setAccumulationPointValue = function(location) {
      var accumulation = this.control;
      var point;
      for (var _i = 0, _a = accumulation.visibleSeries[0].points; _i < _a.length; _i++) {
        var accPoint = _a[_i];
        if (typeof accPoint.x === "object") {
          if (Date.parse(accPoint.x) === Date.parse(this.annotation.x) && accPoint.y === this.annotation.y) {
            point = accPoint;
            break;
          }
        } else {
          if (accPoint.x === this.annotation.x && accPoint.y === this.annotation.y) {
            point = accPoint;
            break;
          }
        }
      }
      if (point && point.visible) {
        location.x = point.symbolLocation.x;
        location.y = point.symbolLocation.y;
        return true;
      } else {
        return false;
      }
    };
    AnnotationBase2.prototype.setElementStyle = function(location, element, parentElement) {
      var elementRect = measureElementRect(element, this.control.redraw);
      var argsData = {
        cancel: false,
        name: annotationRender,
        content: element,
        location
      };
      var chart = this.control;
      this.control.trigger(annotationRender, argsData);
      if (!argsData.cancel) {
        argsData.content.style.left = this.setAlignmentValue(this.annotation.horizontalAlignment, elementRect.width, argsData.location.x) + "px";
        argsData.content.style.top = this.setAlignmentValue(this.annotation.verticalAlignment, elementRect.height, argsData.location.y) + "px";
        var annotation = chart.annotationModule.annotation;
        if (chart.getModuleName() === "chart" && annotation && annotation.accessibility) {
          argsData.content.setAttribute("aria-label", annotation.accessibility.accessibilityDescription ? annotation.accessibility.accessibilityDescription : "Annotation");
          argsData.content.setAttribute("role", annotation.accessibility.accessibilityRole ? annotation.accessibility.accessibilityRole : "img");
          argsData.content.setAttribute("tabindex", annotation.accessibility.focusable ? String(annotation.accessibility.tabIndex) : "-1");
          if (annotation.accessibility.focusable) {
            argsData.content.style.outline = "none";
          }
        } else {
          argsData.content.setAttribute("aria-label", this.annotation.description || "Annotation");
          argsData.content.setAttribute("role", "img");
        }
        appendElement(argsData.content, parentElement, this.control.redraw, true, "left", "top", this.control.duration);
      }
    };
    AnnotationBase2.prototype.setAlignmentValue = function(alignment, size, value) {
      switch (alignment) {
        case "Top":
        case "Near":
          value -= size;
          break;
        case "Bottom":
        case "Far":
          value += 0;
          break;
        case "Middle":
        case "Center":
          value -= size / 2;
          break;
      }
      return value;
    };
    return AnnotationBase2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart/annotation/annotation.js
var __extends59 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ChartAnnotation = (
  /** @class */
  function(_super) {
    __extends59(ChartAnnotation2, _super);
    function ChartAnnotation2(control, annotations) {
      var _this = _super.call(this, control) || this;
      _this.chart = control;
      _this.annotations = annotations;
      return _this;
    }
    ChartAnnotation2.prototype.renderAnnotations = function(element) {
      var _this = this;
      this.annotations = this.chart.annotations;
      this.parentElement = redrawElement(this.chart.redraw, this.chart.element.id + "_Annotation_Collections") || createElement("div", {
        id: this.chart.element.id + "_Annotation_Collections"
      });
      this.annotations.map(function(annotation, index2) {
        _this.processAnnotation(annotation, index2, _this.parentElement);
      });
      for (var index = 0; this.chart.getModuleName() === "chart" && !this.chart.enableCanvas && index < this.chart.visibleSeries.length; index++) {
        if (this.chart.visibleSeries[index].animation.enable && this.chart.animateSeries) {
          this.parentElement.style.visibility = "hidden";
          break;
        }
      }
      appendElement(this.parentElement, element, this.chart.redraw);
    };
    ChartAnnotation2.prototype.destroy = function() {
    };
    ChartAnnotation2.prototype.getModuleName = function() {
      return "Annotation";
    };
    return ChartAnnotation2;
  }(AnnotationBase)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/box-and-whisker-series.js
var __extends60 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var BoxAndWhiskerSeries = (
  /** @class */
  function(_super) {
    __extends60(BoxAndWhiskerSeries2, _super);
    function BoxAndWhiskerSeries2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    BoxAndWhiskerSeries2.prototype.render = function(series, xAxis, yAxis, isInverted) {
      this.sideBySideInfo = this.getSideBySideInfo(series);
      var argsData;
      for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
        var point = _a[_i];
        this.renderPoint(series, point, this.sideBySideInfo, argsData, xAxis, yAxis, isInverted);
      }
      if (series.marker.visible) {
        series.chart.markerRender.render(series);
      }
    };
    BoxAndWhiskerSeries2.prototype.updateTipRegion = function(series, point, sideBySideInfo) {
      var tipRegion = this.getRectangle(point.xValue + sideBySideInfo.median, point.maximum, point.xValue + sideBySideInfo.median, point.minimum, series);
      this.updateTipSize(series, point, tipRegion, series.chart.requireInvertedAxis);
    };
    BoxAndWhiskerSeries2.prototype.updateTipSize = function(series, point, region, isInverted) {
      var borderWidth = series.border.width || 1;
      if (!isInverted) {
        region.x -= borderWidth / 2;
        region.width = region.width || borderWidth;
      } else {
        region.y -= borderWidth / 2;
        region.height = region.height || borderWidth;
      }
      point.regions.push(region);
    };
    BoxAndWhiskerSeries2.prototype.renderPoint = function(series, point, sideBySideInfo, argsData, xAxis, yAxis, isInverted) {
      point.symbolLocations = [];
      point.regions = [];
      var centerRegion;
      if (point.visible && withInRange(series.points[point.index - 1], point, series.points[point.index + 1], series)) {
        this.findBoxPlotValues(point.y, point, series.boxPlotMode, series.showOutliers);
        this.updateTipRegion(series, point, sideBySideInfo);
        centerRegion = this.getRectangle(point.xValue + sideBySideInfo.start, point.upperQuartile, point.xValue + sideBySideInfo.end, point.lowerQuartile, series);
        point.regions.push(centerRegion);
        argsData = this.triggerEvent(series, point, series.interior, {
          color: !isNullOrUndefined(series.border.color) && series.border.color !== "transparent" ? series.border.color : getSaturationColor(series.interior, -0.6),
          width: series.border.width ? series.border.width : 1
        });
        if (!argsData.cancel) {
          this.renderBoxAndWhisker(series, point, argsData, this.getPathString(point, series, getPoint(point.xValue, point.median, xAxis, yAxis, isInverted), getPoint(point.xValue + sideBySideInfo.median, point.average, xAxis, yAxis, isInverted)), sideBySideInfo.median);
        }
      }
    };
    BoxAndWhiskerSeries2.prototype.updateDirection = function(series, point, isInverted) {
      var argsData;
      for (var i = 0; i < point.length; i++) {
        var visiblePoint = series.points[point[i]];
        this.renderPoint(series, visiblePoint, this.sideBySideInfo, argsData, series.xAxis, series.yAxis, isInverted);
        if (visiblePoint.symbolLocations && visiblePoint.symbolLocations.length && series.marker.visible) {
          series.chart.markerRender.renderMarker(series, visiblePoint, visiblePoint.symbolLocations[0], visiblePoint.symbolLocations.length - 1, true);
        }
        if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {
          series.chart.dataLabelCollections = [];
          series.chart.dataLabelModule.commonId = series.chart.element.id + "_Series_" + series.index + "_Point_";
          if (visiblePoint.outliers.length === 0) {
            var element = getElement2(series.chart.dataLabelModule.commonId + visiblePoint.index + "_Text_5");
            if (element) {
              element.remove();
            }
          }
          series.chart.dataLabelModule.renderDataLabel(series, visiblePoint, null, series.marker.dataLabel);
        }
      }
      var children = series.seriesElement.children;
      for (var i = children.length - 1; i >= 0; i--) {
        if (children[i].children.length === 0) {
          series.seriesElement.removeChild(children[i]);
        }
      }
    };
    BoxAndWhiskerSeries2.prototype.getPathString = function(point, series, median, average) {
      var topRect = point.regions[0];
      var midRect = point.regions[1];
      var direction = "";
      var center = series.chart.requireInvertedAxis ? topRect.y + topRect.height / 2 : topRect.x + topRect.width / 2;
      var midWidth = midRect.x + midRect.width;
      var midHeight = midRect.y + midRect.height;
      var topWidth = topRect.x + topRect.width;
      var topHeight = topRect.y + topRect.height;
      if (!series.chart.requireInvertedAxis) {
        this.updateTipSize(series, point, {
          x: midRect.x,
          y: topRect.y,
          width: midWidth - midRect.x,
          height: 0
        }, true);
        this.updateTipSize(series, point, {
          x: midRect.x,
          y: topHeight,
          width: midWidth - midRect.x,
          height: 0
        }, true);
        direction += "M " + midRect.x + " " + topRect.y + " L " + midWidth + " " + topRect.y;
        direction += " M " + center + " " + topRect.y + " L " + center + " " + midRect.y;
        direction += " M " + midRect.x + " " + midRect.y + " L " + midWidth + " " + midRect.y + " L " + midWidth + " " + midHeight + " L " + midRect.x + " " + midHeight + " Z";
        direction += " M " + center + " " + midHeight + " L " + center + " " + topHeight;
        direction += " M " + midRect.x + " " + topHeight + " L " + midWidth + " " + topHeight;
        direction += " M " + midRect.x + " " + median.y + " L " + midWidth + " " + median.y;
        direction += series.showMean ? " M " + (average.x - 5) + " " + (average.y - 5) + " L " + (average.x + 5) + " " + (average.y + 5) + " M " + (average.x + 5) + " " + (average.y - 5) + " L " + (average.x - 5) + " " + (average.y + 5) : "";
      } else {
        this.updateTipSize(series, point, {
          x: topRect.x,
          y: midRect.y,
          width: 0,
          height: midHeight - midRect.y
        }, false);
        this.updateTipSize(series, point, {
          x: topWidth,
          y: midRect.y,
          width: 0,
          height: midHeight - midRect.y
        }, true);
        direction += "M " + topRect.x + " " + midRect.y + " L " + topRect.x + " " + midHeight;
        direction += "M " + topRect.x + " " + center + " L " + midRect.x + " " + center;
        direction += " M " + midRect.x + " " + midRect.y + " L " + midWidth + " " + midRect.y + " L " + midWidth + " " + midHeight + " L " + midRect.x + " " + midHeight + " Z";
        direction += " M " + midWidth + " " + center + " L " + topWidth + " " + center;
        direction += " M " + topWidth + " " + midRect.y + " L " + topWidth + " " + midHeight;
        direction += " M " + median.x + " " + midRect.y + " L " + median.x + " " + midHeight;
        direction += series.showMean ? "M " + (average.x + 5) + " " + (average.y - 5) + " L " + (average.x - 5) + " " + (average.y + 5) + "M " + (average.x - 5) + " " + (average.y - 5) + " L " + (average.x + 5) + " " + (average.y + 5) : "";
      }
      return direction;
    };
    BoxAndWhiskerSeries2.prototype.renderBoxAndWhisker = function(series, point, argsData, direction, median) {
      var location;
      var size;
      var symbolId = series.chart.element.id + "_Series_" + series.index + "_Point_" + (series.removedPointIndex !== null && series.removedPointIndex <= point.index ? point.index + 1 : point.index);
      var previusDirection = getElement2(symbolId + "_BoxPath") ? getElement2(symbolId + "_BoxPath").getAttribute("d") : "";
      var element = series.chart.renderer.drawPath(new PathOption(symbolId + "_BoxPath", argsData.fill, argsData.border.width, argsData.border.color, series.opacity, series.border.dashArray, direction), new Int32Array([series.clipRect.x, series.clipRect.y]));
      element.setAttribute("role", "img");
      element.setAttribute("aria-label", series.accessibility.accessibilityDescriptionFormat ? series.formatAccessibilityDescription(point, series) : point.x.toString() + ":" + point.maximum.toString() + ":" + point.minimum.toString() + ":" + point.lowerQuartile.toString() + ":" + point.upperQuartile.toString());
      var parentElement = series.chart.renderer.createGroup({
        "id": symbolId
      });
      appendChildElement(series.chart.enableCanvas, parentElement, element, series.chart.redraw, true, null, null, null, previusDirection, null, null, null, series.chart.duration);
      if (series.removedPointIndex !== null && series.removedPointIndex <= point.index) {
        parentElement.id = series.chart.element.id + "_Series_" + series.index + "_Point_" + point.index;
        element.id = series.chart.element.id + "_Series_" + series.index + "_Point_" + point.index + "_BoxPath";
      }
      for (var i = 0; i < point.outliers.length; i++) {
        location = getPoint(point.xValue + median, point.outliers[i], series.xAxis, series.yAxis, series.chart.requireInvertedAxis);
        size = new Size(series.marker.width, series.marker.height);
        point.symbolLocations.push(location);
        this.updateTipSize(series, point, {
          x: location.x - size.width / 2,
          y: location.y - size.height / 2,
          width: size.width,
          height: size.height
        }, true);
      }
      appendChildElement(series.chart.enableCanvas, series.seriesElement, parentElement, series.chart.redraw, false, null, null, null, null, null, null, null, series.chart.duration, true);
    };
    BoxAndWhiskerSeries2.prototype.findBoxPlotValues = function(yValues, point, mode, showOutliers) {
      var yCount = yValues.length;
      var quartile = {
        average: sum(yValues) / yCount,
        lowerQuartile: 0,
        upperQuartile: 0,
        maximum: 0,
        minimum: 0,
        median: 0,
        outliers: []
      };
      if (mode === "Exclusive") {
        quartile.lowerQuartile = this.getExclusiveQuartileValue(yValues, yCount, 0.25);
        quartile.upperQuartile = this.getExclusiveQuartileValue(yValues, yCount, 0.75);
        quartile.median = this.getExclusiveQuartileValue(yValues, yCount, 0.5);
      } else if (mode === "Inclusive") {
        quartile.lowerQuartile = this.getInclusiveQuartileValue(yValues, yCount, 0.25);
        quartile.upperQuartile = this.getInclusiveQuartileValue(yValues, yCount, 0.75);
        quartile.median = this.getInclusiveQuartileValue(yValues, yCount, 0.5);
      } else {
        quartile.median = getMedian(yValues);
        this.getQuartileValues(yValues, yCount, quartile);
      }
      this.getMinMaxOutlier(yValues, yCount, quartile, showOutliers);
      point.minimum = quartile.minimum;
      point.maximum = quartile.maximum;
      point.lowerQuartile = quartile.lowerQuartile;
      point.upperQuartile = quartile.upperQuartile;
      point.median = quartile.median;
      point.outliers = quartile.outliers;
      point.average = quartile.average;
    };
    BoxAndWhiskerSeries2.prototype.getExclusiveQuartileValue = function(yValues, count, percentile) {
      if (count === 0) {
        return 0;
      } else if (count === 1) {
        return yValues[0];
      }
      var value = 0;
      var rank = percentile * (count + 1);
      var integerRank = Math.floor(Math.abs(rank));
      var fractionRank = rank - integerRank;
      if (integerRank === 0) {
        value = yValues[0];
      } else if (integerRank > count - 1) {
        value = yValues[count - 1];
      } else {
        value = fractionRank * (yValues[integerRank] - yValues[integerRank - 1]) + yValues[integerRank - 1];
      }
      return value;
    };
    BoxAndWhiskerSeries2.prototype.getInclusiveQuartileValue = function(yValues, count, percentile) {
      if (count === 0) {
        return 0;
      } else if (count === 1) {
        return yValues[0];
      }
      var value = 0;
      var rank = percentile * (count - 1);
      var integerRank = Math.floor(Math.abs(rank));
      var fractionRank = rank - integerRank;
      value = fractionRank * (yValues[integerRank + 1] - yValues[integerRank]) + yValues[integerRank];
      return value;
    };
    BoxAndWhiskerSeries2.prototype.getQuartileValues = function(yValues, count, quartile) {
      if (count === 1) {
        quartile.lowerQuartile = yValues[0];
        quartile.upperQuartile = yValues[0];
        return null;
      }
      var isEvenList = count % 2 === 0;
      var halfLength = count / 2;
      var lowerQuartileArray = yValues.slice(0, halfLength);
      var upperQuartileArray = yValues.slice(isEvenList ? halfLength : halfLength + 1, count);
      quartile.lowerQuartile = getMedian(lowerQuartileArray);
      quartile.upperQuartile = getMedian(upperQuartileArray);
    };
    BoxAndWhiskerSeries2.prototype.getMinMaxOutlier = function(yValues, count, quartile, showOutliers) {
      var interquartile = quartile.upperQuartile - quartile.lowerQuartile;
      var rangeIQR = 1.5 * interquartile;
      for (var i = 0; i < count; i++) {
        if (yValues[i] < quartile.lowerQuartile - rangeIQR && showOutliers) {
          quartile.outliers.push(yValues[i]);
        } else {
          quartile.minimum = yValues[i];
          break;
        }
      }
      for (var i = count - 1; i >= 0; i--) {
        if (yValues[i] > quartile.upperQuartile + rangeIQR && showOutliers) {
          quartile.outliers.push(yValues[i]);
        } else {
          quartile.maximum = yValues[i];
          break;
        }
      }
    };
    BoxAndWhiskerSeries2.prototype.doAnimation = function(series) {
      this.animate(series);
    };
    BoxAndWhiskerSeries2.prototype.getModuleName = function() {
      return "BoxAndWhiskerSeries";
    };
    BoxAndWhiskerSeries2.prototype.destroy = function() {
    };
    return BoxAndWhiskerSeries2;
  }(ColumnBase)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/multi-colored-area-series.js
var __extends61 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var MultiColoredAreaSeries = (
  /** @class */
  function(_super) {
    __extends61(MultiColoredAreaSeries2, _super);
    function MultiColoredAreaSeries2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MultiColoredAreaSeries2.prototype.render = function(series, xAxis, yAxis, isInverted, pointAnimate, pointUpdate) {
      var _this = this;
      var firstPoint;
      var startPoint = null;
      var direction = "";
      var origin = Math.max(series.yAxis.visibleRange.min, 0);
      var options = [];
      var startRegion;
      var previous;
      var rendered;
      var segments = this.sortSegments(series, series.segments);
      var emptyPointDirection = "";
      var visiblePoints = this.enableComplexProperty(series);
      visiblePoints.map(function(point, i, seriesPoints) {
        point.symbolLocations = [];
        point.regions = [];
        rendered = false;
        if (point.visible && withInRange(seriesPoints[i - 1], point, seriesPoints[i + 1], series)) {
          direction += _this.getAreaPathDirection(point.xValue, origin, series, isInverted, getPoint, startPoint, "M");
          startPoint = startPoint || new ChartLocation(point.xValue, origin);
          firstPoint = getPoint(point.xValue, point.yValue, xAxis, yAxis, isInverted);
          if (previous && _this.setPointColor(point, previous, series, series.segmentAxis === "X", segments)) {
            rendered = true;
            startRegion = getPoint(startPoint.x, origin, xAxis, yAxis, isInverted);
            direction += "L " + firstPoint.x + " " + firstPoint.y + " ";
            direction += "L " + firstPoint.x + " " + startRegion.y + " ";
            _this.generatePathOption(options, series, previous, direction, "_Point_" + previous.index);
            direction = "M " + firstPoint.x + " " + startRegion.y + " L " + firstPoint.x + " " + firstPoint.y + " ";
          } else {
            direction += "L " + firstPoint.x + " " + firstPoint.y + " ";
            _this.setPointColor(point, null, series, series.segmentAxis === "X", segments);
          }
          if (seriesPoints[i + 1] && !seriesPoints[i + 1].visible && series.emptyPointSettings.mode !== "Drop") {
            direction += _this.getAreaEmptyDirection({
              "x": point.xValue,
              "y": origin
            }, startPoint, series, isInverted, getPoint);
            startPoint = null;
          }
          previous = point;
          _this.storePointLocation(point, series, isInverted, getPoint);
        }
      });
      if (!isNullOrUndefined(rendered) && !rendered) {
        direction = series.points.length > 1 ? direction + this.getAreaPathDirection(previous.xValue, origin, series, isInverted, getPoint, null, "L") : "";
        this.generatePathOption(options, series, previous, direction, "");
      }
      if (series.border.width !== 0) {
        emptyPointDirection = this.removeEmptyPointsBorder(this.getBorderDirection(direction));
        this.generateBorderPathOption(options, series, previous, emptyPointDirection, "");
      }
      this.applySegmentAxis(series, options, segments, pointAnimate);
      if (!pointUpdate) {
        this.renderMarker(series);
      }
    };
    MultiColoredAreaSeries2.prototype.generatePathOption = function(options, series, point, direction, id) {
      options.push(new PathOption(series.chart.element.id + "_Series_" + series.index + id, series.setPointColor(point, series.interior), 0, "transparent", series.opacity, series.dashArray, direction));
    };
    MultiColoredAreaSeries2.prototype.generateBorderPathOption = function(options, series, point, emptyPointDirection, id) {
      options.push(new PathOption(series.chart.element.id + "_Series_border_" + series.index + id, "transparent", series.border.width, series.border.color ? series.border.color : series.interior, 1, series.border.dashArray, emptyPointDirection));
    };
    MultiColoredAreaSeries2.prototype.updateDirection = function(series, point) {
      this.render(series, series.xAxis, series.yAxis, series.chart.requireInvertedAxis, false, true);
      for (var i = 0; i < point.length; i++) {
        if (series.marker && series.marker.visible) {
          series.chart.markerRender.renderMarker(series, series.points[point[i]], series.points[point[i]].symbolLocations[0], null, true);
        }
        if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {
          series.chart.dataLabelModule.commonId = series.chart.element.id + "_Series_" + series.index + "_Point_";
          series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);
        }
      }
    };
    MultiColoredAreaSeries2.prototype.destroy = function() {
    };
    MultiColoredAreaSeries2.prototype.getModuleName = function() {
      return "MultiColoredAreaSeries";
    };
    MultiColoredAreaSeries2.prototype.doAnimation = function(series) {
      this.doLinearAnimation(series, series.animation);
    };
    return MultiColoredAreaSeries2;
  }(MultiColoredSeries)
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/multi-colored-line-series.js
var __extends62 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var MultiColoredLineSeries = (
  /** @class */
  function(_super) {
    __extends62(MultiColoredLineSeries2, _super);
    function MultiColoredLineSeries2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MultiColoredLineSeries2.prototype.render = function(series, xAxis, yAxis, isInverted, pointAnimate, pointUpdate) {
      var previous = null;
      var startPoint = "M";
      var visiblePoints = this.enableComplexProperty(series);
      var options = [];
      var direction = "";
      var lastPoint;
      var segmentPoint = null;
      var segments = this.sortSegments(series, series.segments);
      for (var _i = 0, visiblePoints_1 = visiblePoints; _i < visiblePoints_1.length; _i++) {
        var point = visiblePoints_1[_i];
        point.regions = [];
        if (point.visible && withInRange(visiblePoints[point.index - 1], point, visiblePoints[point.index + 1], series)) {
          lastPoint = point;
          direction += this.getLineDirection(previous, point, series, isInverted, getPoint, startPoint);
          if (previous != null) {
            if (this.setPointColor(point, previous, series, series.segmentAxis === "X", segments)) {
              options.push(new PathOption(series.chart.element.id + "_Series_" + series.index + "_Point_" + previous.index, "none", series.width, series.setPointColor(previous, series.interior), series.opacity, series.dashArray, direction));
              startPoint = "M";
              direction = "";
            } else {
              startPoint = "L";
            }
          } else {
            if (this.setPointColor(point, segmentPoint, series, series.segmentAxis === "X", segments) && direction !== "") {
              options.push(new PathOption(series.chart.element.id + "_Series_" + series.index + "_Point_" + segmentPoint.index, "none", series.width, series.setPointColor(segmentPoint, series.interior), series.opacity, series.dashArray, direction));
              startPoint = "M";
              direction = "";
            }
          }
          previous = point;
          segmentPoint = point;
          this.storePointLocation(point, series, isInverted, getPoint);
        } else {
          previous = series.emptyPointSettings.mode === "Drop" ? previous : null;
          startPoint = series.emptyPointSettings.mode === "Drop" ? startPoint : "M";
          point.symbolLocations = [];
        }
      }
      if (direction !== "") {
        options.push(new PathOption(series.chart.element.id + "_Series_" + series.index, "none", series.width, series.setPointColor(lastPoint, series.interior), series.opacity, series.dashArray, direction));
      }
      this.applySegmentAxis(series, options, segments, pointAnimate);
      if (!pointUpdate) {
        this.renderMarker(series);
      }
    };
    MultiColoredLineSeries2.prototype.updateDirection = function(series, point) {
      this.render(series, series.xAxis, series.yAxis, series.chart.requireInvertedAxis, false, true);
      for (var i = 0; i < point.length; i++) {
        if (series.marker && series.marker.visible) {
          series.chart.markerRender.renderMarker(series, series.points[point[i]], series.points[point[i]].symbolLocations[0], null, true);
        }
        if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {
          series.chart.dataLabelModule.commonId = series.chart.element.id + "_Series_" + series.index + "_Point_";
          series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);
        }
      }
    };
    MultiColoredLineSeries2.prototype.doAnimation = function(series) {
      this.doLinearAnimation(series, series.animation);
    };
    MultiColoredLineSeries2.prototype.getModuleName = function() {
      return "MultiColoredLineSeries";
    };
    MultiColoredLineSeries2.prototype.destroy = function() {
    };
    return MultiColoredLineSeries2;
  }(MultiColoredSeries)
);

// node_modules/@syncfusion/ej2-charts/src/chart/axis/multi-level-labels.js
var MultiLevelLabel = (
  /** @class */
  function() {
    function MultiLevelLabel2(chart) {
      this.xAxisPrevHeight = [];
      this.xAxisMultiLabelHeight = [];
      this.yAxisPrevHeight = [];
      this.yAxisMultiLabelHeight = [];
      this.multiLevelLabelRectXRegion = [];
      this.xLabelCollection = [];
      this.chart = chart;
      this.addEventListener();
    }
    MultiLevelLabel2.prototype.addEventListener = function() {
      if (this.chart.isDestroyed) {
        return;
      }
      this.chart.on("click", this.click, this);
    };
    MultiLevelLabel2.prototype.getMultilevelLabelsHeight = function(axis) {
      var _this = this;
      var value = 0;
      var multiLevelLabelsHeight = [];
      var prevHeight = [];
      var isVertical = axis.orientation === "Vertical";
      var axisValue = isVertical ? axis.rect.height : axis.rect.width;
      var labelSize;
      var height;
      var padding = 10;
      var gap;
      axis.multiLevelLabels.map(function(multiLevel, index) {
        multiLevel.categories.map(function(categoryLabel, i) {
          if (categoryLabel.text !== "" && categoryLabel.start !== null && categoryLabel.end !== null) {
            labelSize = measureText(categoryLabel.text, multiLevel.textStyle, _this.chart.themeStyle.axisLabelFont);
            height = isVertical ? labelSize.width : labelSize.height;
            height += 2 * multiLevel.border.width + (multiLevel.border.type === "CurlyBrace" ? padding : 0);
            gap = categoryLabel.maximumTextWidth !== null ? categoryLabel.maximumTextWidth : valueToCoefficient(typeof categoryLabel.end === "string" ? Number(new Date(categoryLabel.end)) : categoryLabel.end, axis) * axisValue - valueToCoefficient(typeof categoryLabel.start === "string" ? Number(new Date(categoryLabel.start)) : categoryLabel.start, axis) * axisValue;
            var len = axis.multiLevelLabels[index].categories.length;
            gap = (i === 0 || i === len - 1) && axis.labelPlacement === "OnTicks" && axis.edgeLabelPlacement === "Shift" ? gap / 2 : gap;
            if (labelSize.width > gap - padding && (_this.chart.enableRtl ? gap < 0 : gap > 0) && multiLevel.overflow === "Wrap" && !isVertical) {
              height = height * textWrap(categoryLabel.text, gap - padding, multiLevel.textStyle, _this.chart.enableRtl, null, null, _this.chart.themeStyle.axisLabelFont).length;
            }
            multiLevelLabelsHeight[index] = !multiLevelLabelsHeight[index] ? height : multiLevelLabelsHeight[index] < height ? height : multiLevelLabelsHeight[index];
          }
        });
        prevHeight[index] = value;
        value += multiLevelLabelsHeight[index] ? multiLevelLabelsHeight[index] + padding : 0;
      });
      axis.multiLevelLabelHeight = value + (axis.title !== "" || this.chart.legendModule && this.chart.legendSettings.visible ? padding / 2 : 0);
      if (isVertical) {
        this.yAxisMultiLabelHeight = multiLevelLabelsHeight;
        this.yAxisPrevHeight = prevHeight;
      } else {
        this.xAxisMultiLabelHeight = multiLevelLabelsHeight;
        this.xAxisPrevHeight = prevHeight;
      }
    };
    MultiLevelLabel2.prototype.renderXAxisMultiLevelLabels = function(axis, index, parent, axisRect) {
      var _this = this;
      var x;
      var y;
      var padding = 10;
      var startX;
      var pointIndex;
      var startY = (axis.labelPosition === axis.tickPosition ? axis.majorTickLines.height : 0) + axis.maxLabelSize.height + padding;
      var endX;
      var pathRect = "";
      var start;
      var end;
      var labelSize;
      var isOutside = axis.labelPosition === "Outside";
      var gap;
      var anchor;
      var isInversed = axis.isAxisInverse;
      var argsData;
      var opposedPosition = axis.isAxisOpposedPosition;
      var len;
      var scrollBarHeight = axis.scrollbarSettings.enable || isOutside && isNullOrUndefined(axis.crossesAt) ? axis.scrollBarHeight : 0;
      var clipY = opposedPosition && !isOutside || !opposedPosition && isOutside ? axisRect.y + startY - axis.majorTickLines.width : axisRect.y - startY - axis.multiLevelLabelHeight;
      this.createClipRect(axisRect.x - axis.majorTickLines.width, clipY + scrollBarHeight, axis.multiLevelLabelHeight + padding, axisRect.width + 2 * axis.majorTickLines.width, this.chart.element.id + "_XAxis_Clippath_" + index, this.chart.element.id + "XAxisMultiLevelLabel" + index);
      axis.multiLevelLabels.map(function(multiLevel, level) {
        pointIndex = 0;
        _this.labelElement = _this.chart.renderer.createGroup({
          id: _this.chart.element.id + index + "_MultiLevelLabel" + level
        });
        multiLevel.categories.map(function(categoryLabel, i) {
          len = multiLevel.categories.length;
          pathRect = "";
          start = typeof categoryLabel.start === "string" ? Number(new Date(categoryLabel.start)) : categoryLabel.start;
          end = typeof categoryLabel.end === "string" ? Number(new Date(categoryLabel.end)) : categoryLabel.end;
          var labelFontStyle = extend({}, getValue("properties", multiLevel.textStyle), null, true);
          argsData = _this.triggerMultiLabelRender(axis, categoryLabel.text, labelFontStyle, axis.multiLevelLabels[level].alignment, categoryLabel.customAttributes);
          if (!argsData.cancel) {
            startX = valueToCoefficient(start, axis) * axisRect.width;
            endX = valueToCoefficient(end, axis) * axisRect.width;
            endX = isInversed ? [startX, startX = endX][0] : endX;
            labelSize = measureText(argsData.text, argsData.textStyle, _this.chart.themeStyle.axisLabelFont);
            gap = (categoryLabel.maximumTextWidth === null ? endX - startX : categoryLabel.maximumTextWidth) - padding;
            x = startX + axisRect.x + padding;
            y = (opposedPosition && !isOutside || !opposedPosition && isOutside ? startY + axisRect.y + labelSize.height / 2 + padding + _this.xAxisPrevHeight[level] : axisRect.y - startY + labelSize.height / 2 - _this.xAxisMultiLabelHeight[level] - _this.xAxisPrevHeight[level]) + scrollBarHeight;
            if (argsData.alignment === "Center") {
              x += (endX - startX - padding) / 2;
              anchor = "middle";
            } else if (argsData.alignment === "Far") {
              x = x + (endX - startX - padding) - multiLevel.border.width / 2;
              if (axis.labelPlacement === "OnTicks" && (i === 0 || i === len - 1)) {
                x += (endX - startX - padding) / 2;
                x = x - labelSize.width / 2;
              }
              anchor = "end";
            } else {
              anchor = "start";
              x += multiLevel.border.width / 2;
            }
            y = multiLevel.border.type === "CurlyBrace" ? !opposedPosition && isOutside || opposedPosition && !isOutside ? y + padding : y - padding / 2 : y;
            var options = new TextOption(_this.chart.element.id + index + "_Axis_MultiLevelLabel_Level_" + level + "_Text_" + i, x, y, anchor, argsData.text);
            if (multiLevel.overflow !== "None") {
              if (axis.edgeLabelPlacement && axis.labelPlacement === "OnTicks") {
                switch (axis.edgeLabelPlacement) {
                  case "None":
                    break;
                  case "Shift":
                    if (i === 0 || isInversed && i === len - 1) {
                      if (argsData.alignment === "Center" && (options.x < axisRect.x + padding || options.x - labelSize.width / 2) < axis.rect.x) {
                        options.x += axisRect.x / 2;
                        if (options.x / 2 < axisRect.x) {
                          options.x = axisRect.x + padding / 2;
                          options.anchor = "start";
                        }
                      } else if (argsData.alignment === "Far" && (options.x < axisRect.x + padding || options.x > axisRect.x + padding)) {
                        options.x += labelSize.width / 2 - gap / 2;
                      } else if (argsData.alignment === "Near" && (options.x < axisRect.x + padding || options.x > axisRect.x + padding)) {
                        options.x = axisRect.x + padding;
                      }
                      gap = gap / 2;
                    } else if (i === len - 1 || isInversed && i === 0) {
                      if (argsData.alignment === "Center" && options.x > axisRect.x + axisRect.width) {
                        options.x -= padding;
                        if (options.x > axisRect.width) {
                          options.x = axisRect.width + axisRect.x;
                          options.anchor = "end";
                        }
                      } else if (argsData.alignment === "Far") {
                        options.x = axisRect.width + axisRect.x;
                      }
                      gap = gap / 2;
                    }
                    break;
                }
              }
              options.text = multiLevel.overflow === "Wrap" ? textWrap(argsData.text, gap, argsData.textStyle, _this.chart.enableRtl, null, null, _this.chart.themeStyle.axisLabelFont) : textTrim(gap, argsData.text, argsData.textStyle, _this.chart.enableRtl, _this.chart.themeStyle.axisLabelFont);
              options.x = options.x - padding / 2;
            }
            textElement2(_this.chart.renderer, options, argsData.textStyle, argsData.textStyle.color || _this.chart.themeStyle.axisLabelFont.color, _this.labelElement, false, _this.chart.redraw, true, null, null, null, null, null, _this.chart.enableCanvas, null, _this.chart.themeStyle.axisLabelFont);
            if (_this.chart.enableCanvas) {
              var textSize = measureText(argsData.text, argsData.textStyle, _this.chart.themeStyle.axisLabelFont);
              _this.multiLevelLabelRectXRegion.push(new Rect(options.x, options.y, textSize.width, textSize.height));
              _this.xLabelCollection.push(options);
            }
            if (multiLevel.border.width > 0 && multiLevel.border.type !== "WithoutBorder") {
              pathRect = _this.renderXAxisLabelBorder(level, endX - startX - padding, axis, startX, startY, labelSize, options, axisRect, argsData.alignment, pathRect, isOutside, opposedPosition, pointIndex);
              if (pathRect !== "") {
                _this.createBorderElement(level, index, axis, pathRect, pointIndex);
                pointIndex++;
              }
            }
            if (!_this.chart.enableCanvas) {
              _this.multiElements.appendChild(_this.labelElement);
            }
          }
        });
      });
      if (!this.chart.enableCanvas) {
        parent.appendChild(this.multiElements);
      }
    };
    MultiLevelLabel2.prototype.renderXAxisLabelBorder = function(labelIndex, gap, axis, startX, startY, labelSize, textOptions, axisRect, alignment, path, isOutside, opposedPosition, categoryIndex) {
      var padding = 10;
      var padding1;
      var padding2;
      var value;
      var value1;
      var groupLabel = axis.multiLevelLabels[labelIndex];
      var categoryType = groupLabel.categories[categoryIndex].type;
      var width = gap + padding;
      var height = isNullOrUndefined(this.xAxisMultiLabelHeight[labelIndex]) ? 0 : this.xAxisMultiLabelHeight[labelIndex] + padding;
      var scrollBarHeight = axis.labelPosition === "Outside" ? axis.scrollBarHeight : 0;
      var x = startX + axisRect.x;
      var y = !opposedPosition && isOutside || opposedPosition && !isOutside ? startY + axisRect.y + this.xAxisPrevHeight[labelIndex] + scrollBarHeight : axisRect.y - startY - this.xAxisPrevHeight[labelIndex] - scrollBarHeight;
      var borderType = categoryType ? categoryType : groupLabel.border.type;
      switch (borderType) {
        case "WithoutTopandBottomBorder":
        case "Rectangle":
        case "WithoutTopBorder": {
          var len = axis.multiLevelLabels[labelIndex].categories.length;
          var lastX = categoryIndex === len - 1 && x + width > axisRect.width ? axisRect.width + axisRect.x : x + width;
          var initialX = categoryIndex === 0 && axis.multiLevelLabels[labelIndex].categories[0].start <= 0 ? axisRect.x : x;
          height = !opposedPosition && isOutside || opposedPosition && !isOutside ? height : -height;
          path += "M " + initialX + " " + y + " L " + initialX + " " + (y + height) + " M " + lastX + " " + y + " L " + lastX + " " + (y + height);
          path += borderType !== "WithoutTopandBottomBorder" ? " L " + initialX + " " + (y + height) + " " : " ";
          path += borderType === "Rectangle" ? "M " + initialX + " " + y + " L " + lastX + " " + y : " ";
          break;
        }
        case "Brace":
          if (alignment === "Near") {
            value = textOptions.x;
            value1 = textOptions.x + labelSize.width + 2;
          } else if (alignment === "Center") {
            value = textOptions.x - labelSize.width / 2 - 2;
            value1 = textOptions.x + labelSize.width / 2 + 2;
          } else {
            value = textOptions.x - labelSize.width - 2;
            value1 = textOptions.x;
          }
          height = !opposedPosition && isOutside || opposedPosition && !isOutside ? height : -height;
          path += "M " + x + " " + y + " L " + x + " " + (y + height / 2) + " M " + x + " " + (y + height / 2) + " L " + (value - 2) + " " + (y + height / 2) + " M " + value1 + " " + (y + height / 2) + " L " + (x + width) + " " + (y + height / 2) + " M " + (x + width) + " " + (y + height / 2) + " L " + (x + width) + " " + y;
          break;
        case "CurlyBrace":
          if (!opposedPosition && isOutside || opposedPosition && !isOutside) {
            padding = 10;
            padding1 = 15;
            padding2 = 5;
          } else {
            padding = -10;
            padding1 = -15;
            padding2 = -5;
          }
          if (alignment === "Center") {
            path += "M " + x + " " + y + " C " + x + " " + y + " " + (x + 5) + " " + (y + padding) + " " + (x + 10) + " " + (y + padding) + " L " + (x + width / 2 - 5) + " " + (y + padding) + " L " + (x + width / 2) + " " + (y + padding1) + " L " + (x + width / 2 + 5) + " " + (y + padding) + " L " + (x + width - 10) + " " + (y + padding) + " C " + (x + width - 10) + " " + (y + padding) + " " + (x + width) + " " + (y + padding2) + " " + (x + width) + " " + y;
          } else if (alignment === "Near") {
            path += "M " + x + " " + y + " C " + x + " " + y + " " + (x + 5) + " " + (y + padding) + " " + (x + 10) + " " + (y + padding) + " L " + (x + 15) + " " + (y + padding1) + " L " + (x + 20) + " " + (y + padding) + " L " + (x + width - 10) + " " + (y + padding) + " C " + (x + width - 10) + " " + (y + padding) + " " + (x + width) + " " + (y + padding2) + " " + (x + width) + " " + y;
          } else {
            path += "M " + x + " " + y + " C " + x + " " + y + " " + (x + 5) + " " + (y + padding) + " " + (x + 10) + " " + (y + padding) + " L " + (x + width - 20) + " " + (y + padding) + " L " + (x + width - 15) + " " + (y + padding1) + " L " + (x + width - 10) + " " + (y + padding) + " L " + (x + width - 10) + " " + (y + padding) + " C " + (x + width - 10) + " " + (y + padding) + " " + (x + width) + " " + (y + padding2) + " " + (x + width) + " " + y;
          }
          break;
      }
      return path;
    };
    MultiLevelLabel2.prototype.renderYAxisMultiLevelLabels = function(axis, index, parent, rect) {
      var _this = this;
      var labelSize;
      var isOutside = axis.labelPosition === "Outside";
      var x;
      var y;
      var padding = 10;
      var startX = (axis.tickPosition === axis.labelPosition ? axis.majorTickLines.height : 0) + axis.maxLabelSize.width + padding;
      var startY;
      var path = "";
      var endY;
      var argsData;
      var pointIndex;
      var isInversed = axis.isAxisInverse;
      var start;
      var end;
      var gap;
      var anchor = "middle";
      var opposedPosition = axis.isAxisOpposedPosition;
      var scrollBarHeight = isOutside && isNullOrUndefined(axis.crossesAt) ? axis.scrollBarHeight : 0;
      scrollBarHeight = scrollBarHeight * (opposedPosition ? 1 : -1);
      var clipX = opposedPosition && !isOutside || !opposedPosition && isOutside ? rect.x - axis.multiLevelLabelHeight - startX - padding : rect.x + startX;
      this.createClipRect(clipX + scrollBarHeight, rect.y - axis.majorTickLines.width, rect.height + 2 * axis.majorTickLines.width, axis.multiLevelLabelHeight + padding, this.chart.element.id + "_YAxis_Clippath_" + index, this.chart.element.id + "YAxisMultiLevelLabel" + index);
      axis.multiLevelLabels.map(function(multiLevel, level) {
        _this.labelElement = _this.chart.renderer.createGroup({
          id: _this.chart.element.id + index + "_MultiLevelLabel" + level
        });
        pointIndex = 0;
        multiLevel.categories.map(function(categoryLabel, i) {
          path = "";
          end = typeof categoryLabel.end === "string" ? Number(new Date(categoryLabel.end)) : categoryLabel.end;
          start = typeof categoryLabel.start === "string" ? Number(new Date(categoryLabel.start)) : categoryLabel.start;
          startY = valueToCoefficient(start, axis) * rect.height;
          endY = valueToCoefficient(end, axis) * rect.height;
          endY = isInversed ? [startY, startY = endY][0] : endY;
          var labelFontStyle = extend({}, getValue("properties", multiLevel.textStyle), null, true);
          argsData = _this.triggerMultiLabelRender(axis, categoryLabel.text, labelFontStyle, multiLevel.alignment, categoryLabel.customAttributes);
          if (!argsData.cancel) {
            var maximumWidth = categoryLabel.maximumTextWidth === null ? _this.yAxisMultiLabelHeight[level] / 2 : categoryLabel.maximumTextWidth / 2;
            labelSize = measureText(argsData.text, argsData.textStyle, _this.chart.themeStyle.axisLabelFont);
            gap = endY - startY;
            x = rect.x - startX - _this.yAxisPrevHeight[level] - maximumWidth - padding / 2;
            y = rect.height + rect.y - startY - gap / 2;
            if (opposedPosition) {
              x = isOutside ? rect.x + startX + padding / 2 + maximumWidth + _this.yAxisPrevHeight[level] + scrollBarHeight : rect.x - startX - maximumWidth - _this.yAxisPrevHeight[level] - padding / 2;
            } else {
              x = isOutside ? x + scrollBarHeight : rect.x + startX + padding / 2 + maximumWidth + _this.yAxisPrevHeight[level];
            }
            if (argsData.alignment === "Center") {
              y += labelSize.height / 4;
            } else if (argsData.alignment === "Far") {
              y += gap / 2 - labelSize.height / 2;
            } else {
              y = y - gap / 2 + labelSize.height;
            }
            x = multiLevel.border.type === "CurlyBrace" ? !opposedPosition && isOutside || opposedPosition && !isOutside ? x - padding : x + padding : x;
            var options = new TextOption(_this.chart.element.id + index + "_Axis_MultiLevelLabel_Level_" + level + "_Text_" + i, x, y, anchor, argsData.text);
            options.text = multiLevel.overflow === "Trim" ? textTrim(categoryLabel.maximumTextWidth === null ? _this.yAxisMultiLabelHeight[level] : categoryLabel.maximumTextWidth, argsData.text, argsData.textStyle, _this.chart.enableRtl, _this.chart.themeStyle.axisLabelFont) : options.text;
            options.text = multiLevel.overflow === "Wrap" ? textWrap(argsData.text, categoryLabel.maximumTextWidth === null ? _this.yAxisMultiLabelHeight[level] : categoryLabel.maximumTextWidth, argsData.textStyle, _this.chart.enableRtl, null, null, _this.chart.themeStyle.axisLabelFont) : options.text;
            if (typeof options.text !== "string" && options.text.length > 1) {
              options.y -= padding * options.text.length / 2;
            }
            textElement2(_this.chart.renderer, options, argsData.textStyle, argsData.textStyle.color || _this.chart.themeStyle.axisLabelFont.color, _this.labelElement, _this.chart.redraw, true, null, null, null, null, null, null, _this.chart.enableCanvas, null, _this.chart.themeStyle.axisLabelFont);
            if (multiLevel.border.width > 0 && multiLevel.border.type !== "WithoutBorder") {
              path = _this.renderYAxisLabelBorder(level, gap, axis, endY, startX, startY, labelSize, options, rect, argsData.alignment, path, isOutside, opposedPosition, pointIndex);
              if (path !== "") {
                _this.createBorderElement(level, index, axis, path, pointIndex);
                pointIndex++;
              }
            }
            if (!_this.chart.enableCanvas) {
              _this.multiElements.appendChild(_this.labelElement);
            }
          }
        });
      });
      if (!this.chart.enableCanvas) {
        parent.appendChild(this.multiElements);
      }
    };
    MultiLevelLabel2.prototype.renderYAxisLabelBorder = function(labelIndex, gap, axis, endY, startX, startY, labelSize, textOptions, rect, alignment, path, isOutside, opposedPosition, categoryIndex) {
      var height = endY - startY;
      var padding = 10;
      var padding1;
      var padding2;
      var groupLabel = axis.multiLevelLabels[labelIndex];
      var categoryType = groupLabel.categories[categoryIndex].type;
      var y = rect.y + rect.height - endY;
      var scrollBarHeight = isOutside && isNullOrUndefined(axis.crossesAt) ? axis.scrollBarHeight : 0;
      scrollBarHeight = scrollBarHeight * (opposedPosition ? 1 : -1);
      var width = (groupLabel.categories[categoryIndex].maximumTextWidth === null ? this.yAxisMultiLabelHeight[labelIndex] : groupLabel.categories[categoryIndex].maximumTextWidth) + padding;
      var x = (!opposedPosition && isOutside || opposedPosition && !isOutside ? rect.x - startX - this.yAxisPrevHeight[labelIndex] : rect.x + startX + this.yAxisPrevHeight[labelIndex]) + scrollBarHeight;
      var borderType = categoryType ? categoryType : groupLabel.border.type;
      switch (borderType) {
        case "WithoutTopandBottomBorder":
        case "Rectangle":
        case "WithoutTopBorder":
          width = !opposedPosition && isOutside || opposedPosition && !isOutside ? -width : width;
          path += "M " + x + " " + y + " L " + (x + width) + " " + y + " M " + x + " " + (y + height) + " L " + (x + width) + " " + (y + height);
          path += borderType !== "WithoutTopandBottomBorder" ? " L " + (x + width) + " " + y + " " : " ";
          path += borderType === "Rectangle" ? "M " + x + " " + (y + height) + "L " + x + " " + y + " " : " ";
          break;
        case "Brace":
          width = !opposedPosition && isOutside || opposedPosition && !isOutside ? width : -width;
          path += "M " + x + " " + y + " L " + (x - width / 2) + " " + y + " L " + (x - width / 2) + " " + (textOptions.y - labelSize.height / 2 - 4) + " M " + (x - width / 2) + " " + (textOptions.y + labelSize.height / 4 + 2) + " L " + (x - width / 2) + " " + (y + height) + " L " + x + " " + (y + height);
          break;
        case "CurlyBrace":
          if (!opposedPosition && isOutside || opposedPosition && !isOutside) {
            padding = -10;
            padding1 = -15;
            padding2 = -5;
          } else {
            padding = 10;
            padding1 = 15;
            padding2 = 5;
          }
          if (alignment === "Center") {
            path += "M " + x + " " + y + " C " + x + " " + y + " " + (x + padding) + " " + y + " " + (x + padding) + " " + (y + 10) + " L " + (x + padding) + " " + (y + (height - 10) / 2) + " L " + (x + padding1) + " " + (y + (height - 10) / 2 + 5) + " L " + (x + padding) + " " + (y + (height - 10) / 2 + 10) + " L " + (x + padding) + " " + (y + (height - 10)) + " C " + (x + padding) + " " + (y + (height - 10)) + " " + (x + padding2) + " " + (y + height) + " " + x + " " + (y + height);
          } else if (alignment === "Far") {
            path += "M " + x + " " + y + " C " + x + " " + y + " " + (x + padding) + " " + y + " " + (x + padding) + " " + (y + 10) + " L " + (x + padding) + " " + (y + height - 20) + "  L " + (x + padding1) + " " + (y + (height - 15)) + " L " + (x + padding) + " " + (y + (height - 10)) + " L " + (x + padding) + " " + (y + (height - 10)) + " C " + (x + padding) + " " + (y + (height - 10)) + " " + (x + padding) + " " + (y + height) + " " + x + " " + (y + height);
          } else {
            path += "M " + x + " " + y + " C " + x + " " + y + " " + (x + padding) + " " + y + " " + (x + padding) + " " + (y + 10) + " L " + (x + padding1) + " " + (y + 15) + " L " + (x + padding) + " " + (y + 20) + " L " + (x + padding) + " " + (y + (height - 10)) + " C " + (x + padding) + " " + (y + (height - 10)) + " " + (x + padding2) + " " + (y + height) + " " + x + " " + (y + height);
          }
          break;
      }
      return path;
    };
    MultiLevelLabel2.prototype.createClipRect = function(x, y, height, width, clipId, axisId) {
      this.multiElements = this.chart.renderer.createGroup({
        "id": axisId,
        "clip-path": "url(#" + clipId + ")"
      });
      if (!this.chart.enableCanvas) {
        this.multiElements.appendChild(appendClipElement(this.chart.redraw, {
          "id": clipId,
          "x": x,
          "y": y,
          "width": width,
          "height": height,
          "fill": "white",
          "stroke-width": 1,
          "stroke": "Gray"
        }, this.chart.renderer));
      }
    };
    MultiLevelLabel2.prototype.createBorderElement = function(borderIndex, axisIndex, axis, path, pointIndex) {
      var direction = path;
      var borderElement = this.chart.renderer.drawPath(new PathOption(this.chart.element.id + axisIndex + "_Axis_MultiLevelLabel_Rect_" + borderIndex + "_" + pointIndex, "Transparent", axis.multiLevelLabels[borderIndex].border.width, axis.multiLevelLabels[borderIndex].border.color || this.chart.themeStyle.axisLine, 1, "", path));
      borderElement.style.pointerEvents = "none";
      appendChildElement(this.chart.enableCanvas, this.labelElement, borderElement, this.chart.redraw, true, "x", "y", null, direction);
    };
    MultiLevelLabel2.prototype.triggerMultiLabelRender = function(axis, text, textStyle, textAlignment, customAttributes) {
      var argsData = {
        cancel: false,
        name: axisMultiLabelRender,
        axis,
        text,
        textStyle,
        alignment: textAlignment,
        customAttributes
      };
      this.chart.trigger(axisMultiLabelRender, argsData);
      return argsData;
    };
    MultiLevelLabel2.prototype.MultiLevelLabelClick = function(labelIndex, axisIndex) {
      var level = parseInt(labelIndex.substr(0, 1), 10);
      var textElement3 = parseInt(labelIndex.substr(7), 10);
      var chart = this.chart;
      var axis = chart.axisCollections[axisIndex];
      var categories = axis.multiLevelLabels[level].categories;
      var text = categories[textElement3].text;
      var start = categories[textElement3].start;
      var end = categories[textElement3].end;
      var customAttributes = categories[textElement3].customAttributes;
      var multilevelclickArgs = {
        axis,
        level,
        text,
        customAttributes,
        start,
        end,
        name: multiLevelLabelClick,
        cancel: false
      };
      this.chart.trigger(multiLevelLabelClick, multilevelclickArgs);
      return multilevelclickArgs;
    };
    MultiLevelLabel2.prototype.click = function(event2) {
      var targetId = event2.target.id;
      var multiLevelID = "_Axis_MultiLevelLabel_Level_";
      var textId;
      var elementId;
      var axisIndex;
      if (this.chart.enableCanvas) {
        for (var i = 0; i < this.multiLevelLabelRectXRegion.length; i++) {
          if (withInBounds(event2["x"], event2["y"], this.multiLevelLabelRectXRegion[i], this.multiLevelLabelRectXRegion[i].width, this.multiLevelLabelRectXRegion[i].height)) {
            targetId = this.xLabelCollection[i].id;
          }
        }
      }
      if (targetId.indexOf(multiLevelID) > -1) {
        textId = targetId.split(multiLevelID)[1];
        elementId = targetId.split(multiLevelID)[0];
        axisIndex = parseInt(elementId.charAt(elementId.length - 1), 10);
        this.MultiLevelLabelClick(textId, axisIndex);
      }
    };
    MultiLevelLabel2.prototype.getModuleName = function() {
      return "MultiLevelLabel";
    };
    MultiLevelLabel2.prototype.destroy = function() {
    };
    return MultiLevelLabel2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart/series/pareto-series.js
var __extends63 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ParetoSeries = (
  /** @class */
  function(_super) {
    __extends63(ParetoSeries2, _super);
    function ParetoSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.paretoAxes = [];
      return _this;
    }
    ParetoSeries2.prototype.initSeries = function(targetSeries, chart) {
      var series = new Series(chart, "series", targetSeries.properties, true);
      var colors = chart.palettes.length ? chart.palettes : getSeriesColor(chart.theme);
      var count = colors.length;
      series.name = "Pareto";
      series.yAxisName = targetSeries.yAxisName + "_CumulativeAxis";
      series.category = "Pareto";
      targetSeries.category = "Pareto";
      series.index = targetSeries.index + chart.series.length;
      series.type = "Line";
      series.interior = series.fill = series.paretoOptions.fill ? series.paretoOptions.fill : colors[series.index % count];
      series.width = series.paretoOptions.width;
      series.dashArray = series.paretoOptions.dashArray;
      series.marker = series.paretoOptions.marker;
      if (series.marker && series.marker.visible) {
        series.marker.shape = series.marker.shape ? series.marker.shape : markerShapes[chart.markerIndex % 10];
        chart.markerIndex++;
      }
      chart.visibleSeries.push(series);
      this.initAxis(targetSeries, series, chart);
    };
    ParetoSeries2.prototype.initAxis = function(paretoSeries, targetSeries, chart) {
      var isExist = this.paretoAxes.some(function(currentAxis) {
        return currentAxis.name === targetSeries.yAxisName;
      });
      if (!isExist) {
        var secondaryAxis = paretoSeries.yAxisName && chart.axes.length ? chart.axes.filter(function(axis) {
          return axis.name === paretoSeries.yAxisName;
        })[0] : chart.primaryYAxis;
        var newAxis = new Axis(chart, "axes", {
          name: targetSeries.yAxisName,
          majorGridLines: {
            width: 0
          },
          majorTickLines: secondaryAxis.majorTickLines,
          lineStyle: secondaryAxis.lineStyle,
          minimum: 0,
          maximum: 100,
          interval: 20,
          rowIndex: secondaryAxis.rowIndex,
          opposedPosition: true,
          labelFormat: "{value}%"
        });
        this.paretoAxes.push(newAxis);
      }
    };
    ParetoSeries2.prototype.render = function(series) {
      series.chart.columnSeriesModule.render(series);
    };
    ParetoSeries2.prototype.performCumulativeCalculation = function(json, series) {
      var data = json;
      var sum2 = 0;
      var count = 0;
      var length = data.length;
      for (var i = 0; i < length; i++) {
        sum2 += data[i][series.yName];
      }
      for (var i = 0; i < length; i++) {
        count = count + data[i][series.yName];
        data[i][series.yName] = Number((count / sum2 * 100).toFixed(2));
      }
      return data;
    };
    ParetoSeries2.prototype.doAnimation = function(series) {
      this.animate(series);
    };
    ParetoSeries2.prototype.getModuleName = function() {
      return "ParetoSeries";
    };
    ParetoSeries2.prototype.destroy = function() {
    };
    return ParetoSeries2;
  }(ColumnBase)
);

// node_modules/@syncfusion/ej2-charts/src/common/utils/export.js
var ExportUtils = (
  /** @class */
  function() {
    function ExportUtils3(control) {
      this.control = control;
    }
    ExportUtils3.prototype.export = function(type, fileName, orientation, controls, width, height, isVertical, header, footer, exportToMultiplePage) {
      var _this = this;
      var controlValue = this.getControlsValue(controls, isVertical, exportToMultiplePage && type === "PDF", type);
      var canvasElements = [];
      var controlWidth = [];
      var controlHeight = [];
      var isDownload = !(Browser.userAgent.toString().indexOf("HeadlessChrome") > -1);
      orientation = isNullOrUndefined(orientation) ? PdfPageOrientation.Landscape : orientation;
      var _loop_1 = function(i2) {
        controlWidth.push(width ? width : controlValue[i2].width);
        controlHeight.push(height ? height : controlValue[i2].height);
        var element = controls[i2].svgObject;
        var isCanvas = controls[i2].enableCanvas;
        var image = void 0;
        if (!isCanvas) {
          element = createElement("canvas", {
            id: "ej2-canvas",
            attrs: {
              "width": controlWidth[i2].toString(),
              "height": controlHeight[i2].toString()
            }
          });
        }
        var svgData = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">' + controlValue[i2].svg.outerHTML + "</svg>";
        var url = window.URL.createObjectURL(new Blob(type === "SVG" ? [svgData] : [new XMLSerializer().serializeToString(controlValue[i2].svg)], {
          type: "image/svg+xml"
        }));
        if (type === "SVG") {
          if (Browser.info.name === "msie") {
            var svg = new Blob([new XMLSerializer().serializeToString(controlValue[i2].svg)], {
              type: "application/octet-stream"
            });
            window.navigator.msSaveOrOpenBlob(svg, fileName + "." + type.toLocaleLowerCase());
          } else {
            this_1.triggerDownload(fileName, type, url, isDownload);
          }
        } else if (Browser.info.name === "msie") {
          var canvas = element;
          if (!isCanvas) {
            canvas = this_1.createCanvas();
          }
          image = canvas.toDataURL();
          canvasElements.push(element);
          if (type === "PDF") {
            if (canvasElements.length === controlValue.length) {
              this_1.exportPdf(canvasElements, orientation, controlWidth, controlHeight, isDownload, fileName, header, footer);
            }
          } else {
            this_1.doexport(type, image, fileName);
          }
        } else {
          var image_1 = new Image();
          var ctx_1 = element.getContext("2d");
          image_1.onload = function() {
            ctx_1.drawImage(image_1, 0, 0);
            window.URL.revokeObjectURL(url);
            canvasElements.push(element);
            if (type === "PDF") {
              if (canvasElements.length === controlValue.length) {
                _this.exportPdf(canvasElements, orientation, controlWidth, controlHeight, isDownload, fileName, header, footer);
              }
            } else {
              if (window.navigator.msSaveOrOpenBlob) {
                window.navigator.msSaveOrOpenBlob(element.toBlob(null), fileName + "." + type.toLocaleLowerCase());
              } else {
                _this.triggerDownload(fileName, type, element.toDataURL("image/" + type.toLowerCase()), isDownload);
              }
            }
          };
          image_1.src = url;
        }
        if (!isCanvas) {
          removeElement2(document.getElementById(controls[i2].element.id + "_canvas"));
        }
      };
      var this_1 = this;
      for (var i = 0; i < controlValue.length; i++) {
        _loop_1(i);
      }
    };
    ExportUtils3.prototype.getDataUrl = function(chart) {
      var controlValue = this.getControlsValue([chart]);
      var element = this.control.svgObject;
      var isCanvas = this.control.enableCanvas;
      if (!isCanvas) {
        element = createElement("canvas", {
          id: "ej2-canvas",
          attrs: {
            "width": controlValue[0].width.toString(),
            "height": controlValue[0].height.toString()
          }
        });
      }
      var url = window.URL.createObjectURL(new Blob([new XMLSerializer().serializeToString(controlValue[0].svg)], {
        type: "image/svg+xml"
      }));
      if (Browser.info.name === "msie") {
        var canvas = element;
        if (!isCanvas) {
          canvas = this.createCanvas();
        }
        var argsData = {
          name: afterExport,
          cancel: false,
          dataUrl: element.toDataURL("image/png")
        };
        chart.trigger(afterExport, argsData);
        return {
          element: canvas,
          dataUrl: canvas.toDataURL()
        };
      } else {
        var image_2 = new Image();
        var ctx_2 = element.getContext("2d");
        image_2.onload = function() {
          ctx_2.drawImage(image_2, 0, 0);
          window.URL.revokeObjectURL(url);
          var argsData2 = {
            name: afterExport,
            cancel: false,
            dataUrl: element.toDataURL("image/png")
          };
          chart.trigger(afterExport, argsData2);
          return argsData2.dataUrl;
        };
        image_2.src = url;
        return {
          element,
          blobUrl: url
        };
      }
    };
    ExportUtils3.prototype.triggerDownload = function(fileName, type, url, isDownload) {
      createElement("a", {
        attrs: {
          "download": fileName + "." + type.toLocaleLowerCase(),
          "href": url
        }
      }).dispatchEvent(new MouseEvent(isDownload ? "click" : "move", {
        view: window,
        bubbles: false,
        cancelable: true
      }));
    };
    ExportUtils3.prototype.getControlsValue = function(controls, isVertical, isMultiPages, type) {
      var width = 0;
      var height = 0;
      var svgObject = new SvgRenderer("").createSvg({
        id: "Svg_Export_Element",
        width: 200,
        height: 200
      });
      var controlValues = [];
      var backgroundColor;
      for (var i = 0; i < controls.length; i++) {
        var control = controls[i];
        if (control.enableRtl) {
          svgObject.setAttribute("direction", "rtl");
        }
        var isCanvas = control.enableCanvas;
        var svg = control.svgObject.cloneNode(true);
        var groupEle = control.renderer.createGroup({
          style: isNullOrUndefined(isVertical) || isVertical ? "transform: translateY(" + height + "px)" : "transform: translateX(" + width + "px)"
        });
        backgroundColor = svg.childNodes[0] ? svg.childNodes[0].getAttribute("fill") : "transparent";
        if (backgroundColor === "transparent") {
          if (control.theme.indexOf("Dark") > -1 || control.theme.indexOf("HighContrast") > -1) {
            backgroundColor = "rgba(0, 0, 0, 1)";
          } else {
            backgroundColor = "rgba(255, 255, 255, 1)";
          }
        }
        if (!isCanvas) {
          if (control.getModuleName() === "stockChart") {
            svg.childNodes[0].firstChild.setAttribute("fill", backgroundColor);
            for (var index = 1; index < svg.childNodes.length; index++) {
              svg.childNodes[index].childNodes[0].setAttribute("fill", backgroundColor);
            }
          } else if (type === "SVG") {
            svg.childNodes[0].setAttribute("fill", backgroundColor);
          }
          groupEle.appendChild(svg);
        }
        var top_1 = 0;
        var left = 0;
        if (control.stockLegendModule && control.legendSettings.visible) {
          if (control.legendSettings.position === "Bottom" || control.legendSettings.position === "Top" || control.legendSettings.position === "Auto") {
            top_1 += control.stockLegendModule.legendBounds.height;
          } else if (control.legendSettings.position === "Left" || control.legendSettings.position === "Right") {
            left += control.stockLegendModule.legendBounds.width;
          }
        }
        width = isNullOrUndefined(isVertical) || isVertical ? Math.max(control.availableSize.width + left, width) : width + control.availableSize.width + left;
        height = isNullOrUndefined(isVertical) || isVertical ? height + control.availableSize.height + top_1 : Math.max(control.availableSize.height + top_1, height);
        if (!isCanvas) {
          svgObject.appendChild(groupEle);
        }
        if (isMultiPages || i === controls.length - 1) {
          if (!isMultiPages && !this.control.enableCanvas || isMultiPages && !isCanvas) {
            svgObject.setAttribute("width", width + "");
            svgObject.setAttribute("height", height + "");
            svgObject.style.backgroundColor = backgroundColor;
          }
          controlValues.push({
            "width": width,
            "height": height,
            "svg": svgObject
          });
        }
        if (isMultiPages && i < controls.length) {
          width = 0;
          height = 0;
          svgObject = new SvgRenderer("").createSvg({
            id: "Svg_Export_Element",
            width: 200,
            height: 200
          });
        }
      }
      return controlValues;
    };
    ExportUtils3.prototype.createCanvas = function() {
      var chart = this.control;
      this.canvasRender(true, chart);
      var canvas = chart.svgObject;
      this.canvasRender(false, chart);
      return canvas;
    };
    ExportUtils3.prototype.canvasRender = function(enableCanvas, chart) {
      chart.enableCanvas = enableCanvas;
      chart["preRender"]();
      chart["render"]();
    };
    ExportUtils3.prototype.exportPdf = function(element, orientation, width, height, isDownload, fileName, header, footer) {
      var document2 = new PdfDocument();
      var margin = document2.pageSettings.margins;
      var pdfDefaultWidth = document2.pageSettings.width;
      var pdfDefaultHeight = document2.pageSettings.height;
      for (var i = 0; element.length > i; i++) {
        var imageString = element[i].toDataURL("image/jpeg").replace("image/jpeg", "image/octet-stream");
        document2.pageSettings.orientation = orientation;
        var exactWidth = pdfDefaultWidth < width[i] ? width[i] + margin.left + margin.right : pdfDefaultWidth;
        var exactHeight = orientation === 0 && pdfDefaultHeight > height[i] ? width[i] + margin.left + margin.right : pdfDefaultHeight < height[i] ? height[i] + margin.top + margin.bottom : pdfDefaultHeight;
        if (header !== void 0) {
          var font = new PdfStandardFont(1, header.fontSize || 15);
          var pdfHeader = new PdfPageTemplateElement(exactWidth, 30);
          pdfHeader.graphics.drawString(header.content + "", font, null, new PdfSolidBrush(new PdfColor(0, 0, 0)), header.x, header.y, null);
          document2.template.top = pdfHeader;
        }
        if (footer !== void 0) {
          var font = new PdfStandardFont(1, footer.fontSize || 15);
          var pdfFooter = new PdfPageTemplateElement(exactWidth, 30);
          pdfFooter.graphics.drawString(footer.content + "", font, null, new PdfSolidBrush(new PdfColor(0, 0, 0)), footer.x, footer.y, null);
          document2.template.bottom = pdfFooter;
        }
        document2.pageSettings.size = new SizeF(exactWidth, exactHeight);
        imageString = imageString.slice(imageString.indexOf(",") + 1);
        document2.pages.add().graphics.drawImage(new PdfBitmap(imageString), 0, 0, width[i], height[i]);
      }
      if (isDownload) {
        document2.save(fileName + ".pdf");
        document2.destroy();
      }
    };
    ExportUtils3.prototype.doexport = function(type, image, fileName) {
      var images = [];
      var fileType = type || "JPG";
      images = [image];
      this.exportImage(images, fileName, fileType, image);
    };
    ExportUtils3.prototype.exportImage = function(images, fileName, fileType, image) {
      var buffers = [];
      var length = !(images instanceof HTMLElement) ? images.length : 0;
      for (var g = 0; g < length; g++) {
        image = images[g];
        image = image.replace(/^data:[a-z]*;,/, "");
        var image1 = image.split(",");
        var byteString = atob(image1[1]);
        var buffer = new ArrayBuffer(byteString.length);
        var intArray = new Uint8Array(buffer);
        for (var i = 0; i < byteString.length; i++) {
          intArray[i] = byteString.charCodeAt(i);
        }
        buffers.push(buffer);
      }
      for (var j = 0; j < buffers.length; j++) {
        var b = new Blob([buffers[j]], {
          type: "application/octet-stream"
        });
        if (Browser.info.name === "msie") {
          window.navigator.msSaveOrOpenBlob(b, fileName + "." + fileType.toLocaleLowerCase());
        }
      }
    };
    return ExportUtils3;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart/print-export/export.js
var Export = (
  /** @class */
  function() {
    function Export2(chart) {
      this.actualRowCount = 0;
      this.series = [];
      this.axisCollection = [];
      this.requiredValuesLength = 0;
      this.histogramSeriesCount = 0;
      this.chart = chart;
    }
    Export2.prototype.export = function(type, fileName, orientation, controls, width, height, isVertical, header, footer, exportToMultiplePage) {
      var exportChart = new ExportUtils(this.chart);
      controls = controls ? controls : [this.chart];
      if (type === "CSV" || type === "XLSX") {
        this.excelExport(controls, fileName, type, width, height);
      } else {
        var argsData = {
          cancel: false,
          name: beforeExport,
          width,
          height,
          excelProperties: {
            rows: void 0,
            columns: void 0
          }
        };
        this.chart.trigger(beforeExport, argsData);
        if (!argsData.cancel) {
          exportChart.export(type, fileName, orientation, controls, width = argsData.width, height = argsData.height, isVertical, header, footer, exportToMultiplePage);
        }
      }
    };
    Export2.prototype.excelExport = function(controls, fileName, type, width, height) {
      this.rows = [];
      this.actualRowCount = 1;
      var workSheets = [];
      var requiredValues = [];
      var headerStyle = {
        bold: true,
        hAlign: "Center",
        vAlign: "Center",
        wrapText: true
      };
      var xValues = [];
      for (var i = 0; i < controls.length; i++) {
        var isRangeNavigator = controls[i].getModuleName() === "rangeNavigator";
        var isAccumulation = controls[i].getModuleName() === "accumulationchart";
        this.series = isRangeNavigator ? controls[i].series : controls[i].visibleSeries;
        if (isRangeNavigator && this.series.length === 0) {
          if (controls[i].dataSource) {
            this.createRangeNavigatorExcelSheet(controls[i], headerStyle, type);
          }
        } else {
          this.histogramSeriesCount = 0;
          this.requiredValuesLength = 0;
          this.axisCollection = [];
          if (isAccumulation || isRangeNavigator) {
            this.axisCollection.push(null);
          } else {
            this.axisCollection = controls[i].getModuleName() === "stockChart" ? controls[i].chart.horizontalAxes : controls[i].horizontalAxes;
          }
          requiredValues = this.getRequiredValues(isRangeNavigator);
          if (this.requiredValuesLength === 0 && this.series.length === this.histogramSeriesCount) {
            return;
          }
          xValues = this.getXValue(requiredValues, controls[i], isRangeNavigator, isAccumulation);
          this.getTitle(requiredValues, headerStyle, controls[i], isRangeNavigator, isAccumulation, type, xValues[0].length);
          this.createExcelSheet(isRangeNavigator, isAccumulation, xValues, type, requiredValues, headerStyle, controls[i]);
        }
      }
      var columns = [];
      this.requiredValuesLength = this.requiredValuesLength === 0 ? 1 : this.requiredValuesLength;
      for (var columnCount = 0; columnCount < this.requiredValuesLength; columnCount++) {
        columns.push({
          index: columnCount + 1,
          width: 100
        });
      }
      var argsData = {
        cancel: false,
        name: beforeExport,
        width,
        height,
        excelProperties: {
          rows: this.rows,
          columns
        }
      };
      controls[0].trigger(beforeExport, argsData);
      if (!argsData.cancel) {
        workSheets.push({
          columns: argsData.excelProperties.columns,
          rows: argsData.excelProperties.rows
        });
        var book = new Workbook({
          worksheets: workSheets
        }, type === "XLSX" ? "xlsx" : "csv");
        fileName = fileName ? fileName : type === "XLSX" ? "XLSX" : "CSV";
        book.save(fileName + (type === "XLSX" ? ".xlsx" : ".csv"));
      }
    };
    Export2.prototype.createRangeNavigatorExcelSheet = function(controls, headerStyle, type) {
      var xName = controls.xName;
      var yName = controls.yName;
      this.rows.push({
        index: this.actualRowCount,
        cells: [{
          index: 1,
          value: controls.valueType.indexOf("DateTime") > -1 ? controls.valueType : "Category",
          colSpan: 1,
          rowSpan: 1,
          style: headerStyle
        }, {
          index: 2,
          value: yName,
          colSpan: 1,
          rowSpan: 1,
          style: headerStyle
        }]
      });
      this.actualRowCount++;
      var dataSource = controls.dataSource;
      for (var dataCount = 0; dataCount < dataSource.length; dataCount++) {
        this.rows.push({
          index: this.actualRowCount,
          cells: [{
            index: 1,
            value: type === "CSV" && dataSource[dataCount][xName] === null ? "" : dataSource[dataCount][xName],
            colSpan: 1,
            rowSpan: 1,
            style: headerStyle
          }, {
            index: 2,
            value: type === "CSV" && dataSource[dataCount][yName] === null ? "" : dataSource[dataCount][yName],
            colSpan: 1,
            rowSpan: 1,
            style: {}
          }]
        });
        this.actualRowCount++;
      }
      this.requiredValuesLength = 2;
    };
    Export2.prototype.getRequiredValues = function(isRangeNavigator) {
      var requiredValues = [];
      var _loop_1 = function(seriesCount2) {
        var seriesType = this_1.series[seriesCount2].type;
        if (!isRangeNavigator && !this_1.series[seriesCount2].visible || this_1.series[seriesCount2].category === "TrendLine") {
          requiredValues.push([]);
          return "continue";
        }
        if (seriesType === "Histogram") {
          requiredValues.push([]);
          this_1.histogramSeriesCount++;
        } else if (this_1.series[seriesCount2].category === "Pareto") {
          requiredValues.push([this_1.series[seriesCount2]["xName"], "y"]);
        } else if (seriesType.indexOf("Range") !== -1 || seriesType === "Hilo") {
          requiredValues.push([this_1.series[seriesCount2]["xName"], this_1.series[seriesCount2]["high"], this_1.series[seriesCount2]["low"]]);
        } else if (seriesType === "HiloOpenClose" || seriesType === "Candle") {
          requiredValues.push([this_1.series[seriesCount2]["xName"], this_1.series[seriesCount2]["high"], this_1.series[seriesCount2]["low"], this_1.series[seriesCount2]["open"], this_1.series[seriesCount2]["close"]]);
          if (seriesType === "Candle" && this_1.series[seriesCount2]["volume"] !== "") {
            requiredValues[seriesCount2].push(this_1.series[seriesCount2]["volume"]);
          }
        } else if (seriesType === "BoxAndWhisker") {
          requiredValues.push([this_1.series[seriesCount2]["xName"], "maximum", "upperQuartile", "median", "lowerQuartile", "minimum", "outliers"]);
        } else if (seriesType === "Bubble") {
          requiredValues.push([this_1.series[seriesCount2]["xName"], this_1.series[seriesCount2]["yName"]]);
          if (this_1.series[seriesCount2]["size"] !== "") {
            requiredValues[seriesCount2].push(this_1.series[seriesCount2]["size"]);
          }
        } else if (seriesType === "Pie") {
          requiredValues.push([this_1.series[seriesCount2]["xName"], this_1.series[seriesCount2]["yName"]]);
          if (this_1.series[seriesCount2]["radius"].match(/[a-zA-Z]/)) {
            requiredValues[seriesCount2].push(this_1.series[seriesCount2]["radius"]);
          }
        } else {
          requiredValues.push([this_1.series[seriesCount2]["xName"], this_1.series[seriesCount2]["yName"]]);
        }
        if (this_1.series[seriesCount2].errorBar && this_1.series[seriesCount2].errorBar.visible) {
          var errorBar_1 = this_1.series[seriesCount2].errorBar;
          var errorTypes = ["verticalError", "horizontalError", "verticalNegativeError", "horizontalNegativeError", "verticalPositiveError", "horizontalPositiveError"];
          errorTypes.forEach(function(errorType) {
            if (typeof errorBar_1[errorType] === "string") {
              requiredValues[seriesCount2].push(errorBar_1[errorType]);
            }
          });
        }
        this_1.requiredValuesLength += requiredValues[seriesCount2].length;
      };
      var this_1 = this;
      for (var seriesCount = 0; seriesCount < this.series.length; seriesCount++) {
        _loop_1(seriesCount);
      }
      return requiredValues;
    };
    Export2.prototype.getTitle = function(requiredValues, headerStyle, control, isRangeNavigator, isAccumulation, type, xValueLength) {
      var cells = [];
      var additionalCells = [];
      var index = 1;
      var isTitle = false;
      var titlePushRowIndex;
      if (!isRangeNavigator && type === "XLSX" && control.title) {
        this.rows.push({});
        titlePushRowIndex = this.rows.length > 0 ? this.rows.length - 1 : -1;
        this.actualRowCount++;
        isTitle = true;
      }
      for (var axisCount = 0; axisCount < this.axisCollection.length; axisCount++) {
        if (isAccumulation && xValueLength === 0) {
          break;
        }
        var isYName = false;
        var valueType = "";
        var currentIndex = index;
        var isXValue = false;
        for (var seriesCount = 0; seriesCount < this.series.length; seriesCount++) {
          var axisName = this.axisCollection[axisCount] !== null ? this.axisCollection[axisCount].name === "primaryXAxis" || this.axisCollection[axisCount].name === "primaryYAxis" && this.series[seriesCount].type.indexOf("Bar") > -1 ? null : this.axisCollection[axisCount].name : "";
          if (!isRangeNavigator && (!isAccumulation && axisName !== this.series[seriesCount].xAxisName || !this.series[seriesCount].visible || this.series[seriesCount].category === "TrendLine" || this.series[seriesCount].type === "Histogram")) {
            continue;
          }
          if (!isXValue) {
            cells.push({});
            index++;
          }
          isXValue = true;
          var seriesName = this.series[seriesCount].name;
          var requiredValuesLength = this.series[seriesCount].type === "BoxAndWhisker" ? requiredValues[seriesCount].length - 1 : requiredValues[seriesCount].length;
          if (requiredValues[seriesCount][1] === this.series[seriesCount].yName) {
            for (var requiredValuesCount = 1; requiredValuesCount < requiredValuesLength; requiredValuesCount++) {
              cells.push({
                index,
                value: requiredValuesCount === 1 ? seriesName ? seriesName : "Series-" + (seriesCount + 1) : requiredValues[seriesCount][requiredValuesCount],
                colSpan: 1,
                rowSpan: 1,
                style: headerStyle
              });
              index++;
            }
          } else {
            cells.push({
              index,
              value: seriesName ? seriesName : "Series-" + (seriesCount + 1),
              colSpan: requiredValuesLength - 1,
              rowSpan: 1,
              style: headerStyle
            });
            var localIndex = index;
            for (var requiredValuesCount = 1; requiredValuesCount < requiredValuesLength; requiredValuesCount++) {
              additionalCells.push({
                index: localIndex,
                value: requiredValues[seriesCount][requiredValuesCount],
                colSpan: 1,
                rowSpan: 1,
                style: headerStyle
              });
              localIndex++;
            }
            if (this.series[seriesCount].type === "BoxAndWhisker") {
              cells.push({
                index: localIndex,
                value: requiredValues[seriesCount][requiredValuesLength],
                colSpan: 1,
                rowSpan: 2,
                style: headerStyle
              });
              localIndex++;
            }
            index = localIndex;
            isYName = true;
          }
          valueType = isAccumulation ? requiredValues[0][0] : isRangeNavigator ? control.valueType : this.axisCollection[axisCount].valueType;
          valueType = isAccumulation || valueType.indexOf("DateTime") > -1 ? valueType : "Category";
        }
        if (isXValue) {
          cells[currentIndex - 1] = {
            index: currentIndex,
            value: valueType,
            colSpan: 1,
            rowSpan: isYName ? 2 : 1,
            style: headerStyle
          };
        }
      }
      if (cells.length) {
        this.rows.push({
          index: this.actualRowCount,
          cells
        });
        this.actualRowCount++;
      }
      if (additionalCells.length) {
        this.rows.push({
          index: this.actualRowCount,
          cells: additionalCells
        });
        this.actualRowCount++;
      }
      if (isTitle) {
        cells = [];
        cells.push({
          index: 1,
          value: control.title,
          colSpan: index === 1 ? index : index - 1,
          rowSpan: 1,
          style: headerStyle
        });
        this.rows[titlePushRowIndex] = {
          index: titlePushRowIndex + 1,
          cells
        };
      }
      this.requiredValuesLength = index - 1;
    };
    Export2.prototype.getXValue = function(requiredValues, control, isRangeNavigator, isAccumulation) {
      var xValues = [];
      for (var axisCount = 0; axisCount < this.axisCollection.length; axisCount++) {
        var xValue = [];
        var valueType = isAccumulation ? "" : isRangeNavigator ? control.valueType : this.axisCollection[axisCount].valueType;
        for (var seriesCount = 0; seriesCount < this.series.length; seriesCount++) {
          var axisName = this.axisCollection[axisCount] !== null ? this.axisCollection[axisCount].name === "primaryXAxis" || this.axisCollection[axisCount].name === "primaryYAxis" && this.series[seriesCount].type.indexOf("Bar") > -1 ? null : this.axisCollection[axisCount].name : "";
          if (!isRangeNavigator && (!isAccumulation && axisName !== this.series[seriesCount].xAxisName || !this.series[seriesCount].visible) || this.series[seriesCount].category === "TrendLine" || this.series[seriesCount].type === "Histogram") {
            continue;
          }
          for (var dataCount = 0; dataCount < this.series[seriesCount].dataSource.length; dataCount++) {
            if (isAccumulation && !this.series[seriesCount].points[dataCount].visible) {
              continue;
            }
            xValue.push(valueType.indexOf("DateTime") > -1 ? new Date(this.series[seriesCount].dataSource[dataCount][requiredValues[seriesCount][0]]).getTime() : this.series[seriesCount].dataSource[dataCount][requiredValues[seriesCount][0]]);
          }
        }
        xValues.push(xValue);
      }
      var _loop_2 = function(xValuesLength2) {
        xValues[xValuesLength2] = xValues[xValuesLength2].filter(function(item, index) {
          return xValues[xValuesLength2].indexOf(item) === index;
        });
      };
      for (var xValuesLength = 0; xValuesLength < xValues.length; xValuesLength++) {
        _loop_2(xValuesLength);
      }
      return xValues;
    };
    Export2.prototype.createExcelSheet = function(isRangeNavigator, isAccumulation, xValues, type, requiredValues, headerStyle, controls) {
      var startIndex = 0;
      var index = 0;
      for (var axisCount = 0; axisCount < this.axisCollection.length; axisCount++) {
        var valueType = isAccumulation ? "" : isRangeNavigator ? controls[0].valueType : this.axisCollection[axisCount].valueType;
        for (var xValueLength = 0; xValueLength < xValues[axisCount].length; xValueLength++) {
          index = startIndex ? startIndex : 1;
          var cells = [];
          var isXValue = true;
          for (var seriesCount = 0; seriesCount < this.series.length; seriesCount++) {
            var axisName = this.axisCollection[axisCount] !== null ? this.axisCollection[axisCount].name === "primaryXAxis" || this.axisCollection[axisCount].name === "primaryYAxis" && this.series[seriesCount].type.indexOf("Bar") > -1 ? null : this.axisCollection[axisCount].name : "";
            if (!isRangeNavigator && (!isAccumulation && this.series[seriesCount].xAxisName !== axisName || !this.series[seriesCount].visible) || this.series[seriesCount].category === "TrendLine" || this.series[seriesCount].type === "Histogram") {
              continue;
            }
            var isExist = false;
            var dataSource = this.series[seriesCount].dataSource;
            for (var dataCount = 0; dataCount < dataSource.length; dataCount++) {
              var xValue = valueType.indexOf("DateTime") > -1 ? this.series[seriesCount].category === "Pareto" ? new Date(this.series[seriesCount].points[dataCount][requiredValues[seriesCount][0]]).getTime() : new Date(dataSource[dataCount][requiredValues[seriesCount][0]]).getTime() : this.series[seriesCount].category === "Pareto" ? this.series[seriesCount].points[dataCount][requiredValues[seriesCount][0]] : dataSource[dataCount][requiredValues[seriesCount][0]];
              if (xValues[axisCount][xValueLength] === xValue) {
                var usedValueCount = isXValue ? 0 : 1;
                var usedValueLength = this.series[seriesCount].type === "BoxAndWhisker" ? requiredValues[seriesCount].length - 1 : requiredValues[seriesCount].length;
                for (; usedValueCount < usedValueLength; usedValueCount++) {
                  var cellValue = this.series[seriesCount].enableComplexProperty ? getValue(requiredValues[seriesCount][usedValueCount], dataSource[dataCount]) : dataSource[dataCount][requiredValues[seriesCount][usedValueCount]];
                  var value = usedValueCount !== 0 && (this.series[seriesCount].type === "BoxAndWhisker" || this.series[seriesCount].category === "Pareto") ? this.series[seriesCount].points[dataCount][requiredValues[seriesCount][usedValueCount]] : cellValue;
                  if (value === null && type === "CSV") {
                    value = "";
                  }
                  cells.push({
                    index: usedValueCount === 0 ? startIndex === 0 ? 1 : startIndex : index,
                    value,
                    colSpan: 1,
                    rowSpan: 1,
                    style: usedValueCount === 0 ? headerStyle : {}
                  });
                  index++;
                }
                if (this.series[seriesCount].type === "BoxAndWhisker") {
                  cells.push({
                    index,
                    value: this.series[seriesCount].points[dataCount]["outliers"][0],
                    colSpan: 1,
                    rowSpan: 1,
                    style: {}
                  });
                  index++;
                }
                isXValue = false;
                isExist = true;
                break;
              }
            }
            if (!isExist) {
              index += requiredValues[seriesCount].length - 1;
            }
          }
          this.rows.push({
            index: this.actualRowCount,
            cells
          });
          this.actualRowCount++;
        }
        startIndex = index;
      }
    };
    Export2.prototype.getDataUrl = function(chart) {
      var exportUtil = new ExportUtils(chart);
      return exportUtil.getDataUrl(chart);
    };
    Export2.prototype.getModuleName = function() {
      return "Export";
    };
    Export2.prototype.destroy = function() {
    };
    return Export2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/common/scrollbar/scrollbar-elements.js
function createScrollSvg(scrollbar, renderer) {
  var rect = scrollbar.axis.rect;
  var isHorizontalAxis = scrollbar.axis.orientation === "Horizontal";
  var enablePadding = false;
  var markerHeight = 0;
  var yMin;
  for (var _i = 0, _a = scrollbar.axis.series; _i < _a.length; _i++) {
    var tempSeries = _a[_i];
    if (tempSeries.marker.visible && tempSeries.marker.height > markerHeight) {
      markerHeight = tempSeries.marker.height;
    }
  }
  for (var _b = 0, _c = scrollbar.axis.series; _b < _c.length; _b++) {
    var tempSeries = _c[_b];
    if (tempSeries.visible) {
      yMin = tempSeries.yMin.toString();
      enablePadding = tempSeries.yData.some(function(yData) {
        return yData === yMin;
      });
    }
    if (enablePadding) {
      break;
    }
  }
  var topOffset = (scrollbar.axis.isAxisOpposedPosition && isHorizontalAxis ? -16 : enablePadding ? markerHeight : 0) + rect.y + Math.max(0.5, scrollbar.axis.lineStyle.width / 2);
  var leftOffset = (scrollbar.axis.isAxisOpposedPosition && !isHorizontalAxis ? 16 : 0) + rect.x - (scrollbar.isVertical ? scrollbar.height : 0);
  if (!isHorizontalAxis && (scrollbar.axis.scrollbarSettings.position === "Left" || scrollbar.axis.scrollbarSettings.position === "Right")) {
    leftOffset = calculateScrollbarOffset(scrollbar, isHorizontalAxis);
  } else if (isHorizontalAxis && (scrollbar.axis.scrollbarSettings.position === "Top" || scrollbar.axis.scrollbarSettings.position === "Bottom")) {
    topOffset = calculateScrollbarOffset(scrollbar, isHorizontalAxis);
  }
  scrollbar.svgObject = renderer.createSvg({
    id: scrollbar.component.element.id + "_scrollBar_svg" + scrollbar.axis.name,
    width: scrollbar.isVertical ? scrollbar.height : scrollbar.width,
    height: scrollbar.isVertical ? scrollbar.width : scrollbar.height,
    style: "position: absolute;top: " + topOffset + "px;left: " + leftOffset + "px;cursor:auto;"
  });
  scrollbar.elements.push(scrollbar.svgObject);
}
var ScrollElements = (
  /** @class */
  function() {
    function ScrollElements2(chart) {
      this.chartId = chart.element.id + "_";
    }
    ScrollElements2.prototype.renderElements = function(scroll, renderer) {
      var isInverse = scroll.axis.isAxisInverse;
      var scrollBar = scroll.axis.scrollbarSettings;
      var scrollGroup = renderer.createGroup({
        id: this.chartId + "scrollBar_" + scroll.axis.name,
        transform: "translate(" + (scroll.isVertical && isInverse ? scroll.height : isInverse ? scroll.width : "0") + "," + (scroll.isVertical && isInverse ? "0" : isInverse ? scroll.height : scroll.isVertical ? scroll.width : "0") + ") rotate(" + (scroll.isVertical && isInverse ? "90" : scroll.isVertical ? "270" : isInverse ? "180" : "0") + ")"
      });
      var backRectGroup = renderer.createGroup({
        id: this.chartId + "scrollBar_backRect_" + scroll.axis.name
      });
      var thumbGroup = renderer.createGroup({
        id: this.chartId + "scrollBar_thumb_" + scroll.axis.name,
        transform: "translate(0,0)"
      });
      this.backRect(scroll, renderer, backRectGroup, scrollBar);
      this.thumb(scroll, renderer, thumbGroup, scrollBar);
      this.renderCircle(scroll, renderer, thumbGroup, scrollBar);
      this.arrows(scroll, renderer, thumbGroup, scrollBar);
      this.thumbGrip(scroll, renderer, thumbGroup, scrollBar);
      scrollGroup.appendChild(backRectGroup);
      scrollGroup.appendChild(thumbGroup);
      return scrollGroup;
    };
    ScrollElements2.prototype.backRect = function(scroll, renderer, parent, scrollBar) {
      var style = scroll.scrollbarThemeStyle;
      var backRectEle = renderer.drawRectangle(new RectOption(this.chartId + "scrollBarBackRect_" + scroll.axis.name, scrollBar.trackColor || style.backRect, {
        width: 1,
        color: scrollBar.trackColor || style.backRect
      }, 1, new Rect(0, 0, scroll.width, scroll.height), scrollBar.trackRadius, scrollBar.trackRadius));
      parent.appendChild(backRectEle);
    };
    ScrollElements2.prototype.arrows = function(scroll, renderer, parent, scrollBar) {
      var style = scroll.scrollbarThemeStyle;
      var option = new PathOption(this.chartId + "scrollBar_leftArrow_" + scroll.axis.name, style.arrow, 1, style.arrow, 1, "", "");
      this.leftArrowEle = renderer.drawPath(option);
      option.id = this.chartId + "scrollBar_rightArrow_" + scroll.axis.name;
      this.rightArrowEle = renderer.drawPath(option);
      this.setArrowDirection(this.thumbRectX, this.thumbRectWidth, scroll.height);
      if (scrollBar.enableZoom) {
        parent.appendChild(this.leftArrowEle);
        parent.appendChild(this.rightArrowEle);
      }
    };
    ScrollElements2.prototype.setArrowDirection = function(thumbRectX, thumbRectWidth, height) {
      var circleRadius = height / 2;
      var leftDirection = "M " + (thumbRectX - circleRadius / 2) + " " + height / 2 + " L " + (thumbRectX - circleRadius / 2 + (height / 2 - circleRadius / 4)) + " " + (height - circleRadius / 2) + " L " + (thumbRectX - circleRadius / 2 + (height / 2 - circleRadius / 4)) + " " + circleRadius / 2 + " Z";
      var rightDirection = "M " + (thumbRectX + thumbRectWidth + circleRadius / 2) + " " + height / 2 + " L " + (thumbRectX + thumbRectWidth + circleRadius / 2 - (height / 2 - circleRadius / 4)) + " " + (height - circleRadius / 2) + " L " + (thumbRectX + thumbRectWidth + circleRadius / 2 - (height / 2 - circleRadius / 4)) + " " + circleRadius / 2 + " Z";
      this.leftArrowEle.setAttribute("d", leftDirection);
      this.rightArrowEle.setAttribute("d", rightDirection);
    };
    ScrollElements2.prototype.thumb = function(scroll, renderer, parent, scrollBar) {
      scroll.startX = this.thumbRectX;
      var style = scroll.scrollbarThemeStyle;
      this.slider = renderer.drawRectangle(new RectOption(this.chartId + "scrollBarThumb_" + scroll.axis.name, scrollBar.scrollbarColor || style.thumb, {
        width: 1,
        color: scrollBar.scrollbarColor || style.thumb
      }, 1, new Rect(scrollBar.enableZoom ? this.thumbRectX : this.thumbRectX - scroll.height / 2, 0, scrollBar.enableZoom ? this.thumbRectWidth : this.thumbRectWidth + scroll.height / 2, scroll.height), scrollBar.scrollbarRadius, scrollBar.scrollbarRadius));
      parent.appendChild(this.slider);
    };
    ScrollElements2.prototype.renderCircle = function(scroll, renderer, parent, scrollBar) {
      var style = scroll.scrollbarThemeStyle;
      var option = new CircleOption(this.chartId + "scrollBar_leftCircle_" + scroll.axis.name, style.circle, {
        width: 1,
        color: style.circle
      }, 1, this.thumbRectX, scroll.height / 2, scroll.height / 2);
      var scrollShadowEle = '<filter x="-25.0%" y="-20.0%" width="150.0%" height="150.0%" filterUnits="objectBoundingBox"id="scrollbar_shadow"><feOffset dx="0" dy="1" in="SourceAlpha" result="shadowOffsetOuter1"></feOffset><feGaussianBlur stdDeviation="1.5" in="shadowOffsetOuter1" result="shadowBlurOuter1"></feGaussianBlur><feComposite in="shadowBlurOuter1" in2="SourceAlpha" operator="out" result="shadowBlurOuter1"></feComposite><feColorMatrix values="0 0 0 0 0   0 0 0 0 0   0 0 0 0 0  0 0 0 0.16 0" type="matrix" in="shadowBlurOuter1"></feColorMatrix></filter>';
      var defElement = renderer.createDefs();
      var shadowGroup = renderer.createGroup({
        id: this.chartId + scroll.axis.name + "_thumb_shadow"
      });
      defElement.innerText = scrollShadowEle;
      shadowGroup.innerText = '<use fill="black" fill-opacity="1" filter="url(#scrollbar_shadow)" xlink:href="#' + this.chartId + "scrollBar_leftCircle_" + scroll.axis.name + '"></use><use fill="black" fill-opacity="1" filter="url(#scrollbar_shadow)" xlink:href="#' + this.chartId + "scrollBar_rightCircle_" + scroll.axis.name + '"></use>';
      this.leftCircleEle = renderer.drawCircle(option);
      option.id = this.chartId + "scrollBar_rightCircle_" + scroll.axis.name;
      option.cx = this.thumbRectX + this.thumbRectWidth;
      this.rightCircleEle = renderer.drawCircle(option);
      parent.appendChild(defElement);
      if (scrollBar.enableZoom) {
        parent.appendChild(this.leftCircleEle);
        parent.appendChild(this.rightCircleEle);
      }
      parent.appendChild(shadowGroup);
    };
    ScrollElements2.prototype.thumbGrip = function(scroll, renderer, parent, scrollBar) {
      var sidePadding = scroll.component.theme.indexOf("Fluent2") > -1 || scroll.component.theme.indexOf("Bootstrap5") > -1 || scroll.component.theme.indexOf("Tailwind3") > -1 ? -5 : 0;
      var topPadding = 0;
      var gripWidth = 14;
      var gripCircleDiameter = 2;
      var padding = gripWidth / 2 - gripCircleDiameter;
      var style = scroll.scrollbarThemeStyle;
      var option = new CircleOption(this.chartId + "scrollBar_gripCircle0_" + scroll.axis.name, scrollBar.gripColor || style.grip, {
        width: 1,
        color: scrollBar.gripColor || style.grip
      }, 1, 0, 0, 1);
      this.gripCircle = renderer.createGroup({
        id: this.chartId + "scrollBar_gripCircle_" + scroll.axis.name,
        transform: "translate(" + (!scrollBar.enableZoom ? this.thumbRectX + this.thumbRectWidth / 2 + (scroll.isVertical ? 2 : 0) * padding - scrollBar.height / 2 : this.thumbRectX + this.thumbRectWidth / 2 + (scroll.isVertical ? 1 : -1) * padding) + "," + (scroll.isVertical ? scroll.height / 2 + padding / 2 - 0.5 : scroll.height / 2 - padding / 2 - 0.5) + ") rotate(" + (scroll.isVertical ? "180" : "0") + ")"
      });
      for (var i = 1; i <= (scroll.component.theme.indexOf("Fluent2") > -1 || scroll.component.theme.indexOf("Bootstrap5") > -1 || scroll.component.theme.indexOf("Tailwind3") > -1 ? 10 : 6); i++) {
        option.id = this.chartId + "scrollBar_gripCircle" + i + "_" + scroll.axis.name;
        option.cx = sidePadding;
        option.cy = topPadding;
        this.gripCircle.appendChild(renderer.drawCircle(option));
        sidePadding = i === (scroll.component.theme.indexOf("Fluent2") > -1 || scroll.component.theme.indexOf("Bootstrap5") > -1 || scroll.component.theme.indexOf("Tailwind3") > -1 ? 5 : 3) ? scroll.component.theme.indexOf("Fluent2") > -1 || scroll.component.theme.indexOf("Bootstrap5") > -1 || scroll.component.theme.indexOf("Tailwind3") > -1 ? -5 : 0 : sidePadding + 5;
        topPadding = i >= (scroll.component.theme.indexOf("Fluent2") > -1 || scroll.component.theme.indexOf("Bootstrap5") > -1 || scroll.component.theme.indexOf("Tailwind3") > -1 ? 5 : 3) ? 5 : 0;
      }
      if (scrollBar.height >= 12) {
        parent.appendChild(this.gripCircle);
      }
    };
    return ScrollElements2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/common/scrollbar/scrollbar.js
var ScrollBar = (
  /** @class */
  function() {
    function ScrollBar2(component, axis) {
      this.scrollRange = {
        max: null,
        min: null,
        interval: null,
        delta: null
      };
      this.component = component;
      this.elements = [];
      this.scrollElements = new ScrollElements(component);
      this.axis = axis;
      this.mouseMoveListener = this.scrollMouseMove.bind(this);
      this.mouseUpListener = this.scrollMouseUp.bind(this);
      this.animateDuration = 500;
      this.isPointer = Browser.isPointer;
      this.browserName = Browser.info.name;
    }
    ScrollBar2.prototype.getMouseXY = function(e) {
      var pageX;
      var pageY;
      var touchArg;
      if (e.type.indexOf("touch") > -1) {
        touchArg = e;
        pageX = touchArg.changedTouches[0].clientX;
        pageY = touchArg.changedTouches[0].clientY;
      } else {
        pageX = e.clientX;
        pageY = e.clientY;
      }
      var svgRect = getElement2(this.component.element.id + "_scrollBar_svg" + this.axis.name).getBoundingClientRect();
      this.mouseX = pageX - Math.max(svgRect.left, 0);
      this.mouseY = pageY - Math.max(svgRect.top, 0);
    };
    ScrollBar2.prototype.wireEvents = function(element) {
      EventHandler.add(element, Browser.touchStartEvent, this.scrollMouseDown, this);
      EventHandler.add(element, Browser.touchMoveEvent, this.scrollMouseMove, this);
      EventHandler.add(element, Browser.touchEndEvent, this.scrollMouseUp, this);
      EventHandler.add(element, "mousewheel", this.scrollMouseWheel, this);
      window.addEventListener("mousemove", this.mouseMoveListener, false);
      window.addEventListener("mouseup", this.mouseUpListener, false);
    };
    ScrollBar2.prototype.unWireEvents = function(element) {
      EventHandler.remove(element, Browser.touchStartEvent, this.scrollMouseDown);
      EventHandler.remove(element, Browser.touchMoveEvent, this.scrollMouseMove);
      EventHandler.remove(element, Browser.touchEndEvent, this.scrollMouseUp);
      EventHandler.remove(element, "mousewheel", this.scrollMouseWheel);
      window.removeEventListener("mousemove", this.mouseMoveListener, false);
      window.removeEventListener("mouseup", this.mouseUpListener, false);
    };
    ScrollBar2.prototype.scrollMouseDown = function(e) {
      var id = e.target.id;
      var elem = this.scrollElements;
      var isInverse = this.axis.isAxisInverse;
      this.getMouseXY(e);
      this.isResizeLeft = this.isExist(id, "_leftCircle_") || this.isExist(id, "_leftArrow_");
      this.isResizeRight = this.isExist(id, "_rightCircle_") || this.isExist(id, "_rightArrow_");
      this.previousXY = this.isVertical && isInverse ? this.mouseY : this.isVertical ? this.width - this.mouseY : isInverse ? this.width - this.mouseX : this.mouseX;
      this.previousWidth = elem.thumbRectWidth;
      this.previousRectX = elem.thumbRectX;
      this.startZoomPosition = this.axis.zoomPosition;
      this.startZoomFactor = this.axis.zoomFactor;
      this.startRange = this.axis.visibleRange;
      this.scrollStarted = true;
      this.component.trigger(scrollStart, this.getArgs(scrollStart));
      if (this.isExist(id, "scrollBarThumb_") || this.isExist(id, "gripCircle")) {
        this.isThumbDrag = true;
        if (this.axis.scrollbarSettings.height >= 12) {
          this.svgObject.style.cursor = "-webkit-grabbing";
        }
      } else if (this.isExist(id, "scrollBarBackRect_")) {
        var currentX = this.moveLength(this.previousXY, this.previousRectX);
        elem.thumbRectX = this.isWithIn(currentX) ? currentX : elem.thumbRectX;
        this.positionThumb(elem.thumbRectX, elem.thumbRectWidth);
        this.setZoomFactorPosition(elem.thumbRectX, elem.thumbRectWidth);
        this.axis.zoomPosition = this.zoomPosition < 0 ? 0 : this.zoomPosition > 0.9 ? 1 : this.zoomPosition;
        if (this.isLazyLoad) {
          var thumbMove = elem.thumbRectX > this.previousRectX ? "RightMove" : "LeftMove";
          var args = this.calculateLazyRange(elem.thumbRectX, elem.thumbRectWidth, thumbMove);
          if (args) {
            this.component.trigger(scrollEnd, args);
          }
        }
      }
      if (this.component.element.style.height === "") {
        this.isCustomHeight = true;
        this.component.element.style.height = this.component.availableSize.height + "px";
      }
    };
    ScrollBar2.prototype.isExist = function(id, match) {
      return id.indexOf(match) > -1;
    };
    ScrollBar2.prototype.isWithIn = function(currentX) {
      var circleRadius = this.axis.scrollbarSettings.height / 2;
      return currentX - circleRadius >= 0 && currentX + this.scrollElements.thumbRectWidth + circleRadius <= this.width;
    };
    ScrollBar2.prototype.moveLength = function(mouseXY, thumbX, circleRadius) {
      if (circleRadius === void 0) {
        circleRadius = this.axis.scrollbarSettings.height / 2;
      }
      var moveLength = 10 / 100 * (this.width - circleRadius * 2);
      if (mouseXY < thumbX) {
        moveLength = thumbX - (thumbX - moveLength > circleRadius ? moveLength : circleRadius);
      } else {
        moveLength = thumbX + (thumbX + this.scrollElements.thumbRectWidth + moveLength < this.width - circleRadius ? moveLength : circleRadius);
      }
      return moveLength;
    };
    ScrollBar2.prototype.setZoomFactorPosition = function(currentX, currentWidth) {
      this.isScrollUI = true;
      var axis = this.axis;
      var circleRadius = this.axis.scrollbarSettings.height / 2;
      var circleWidth = 1;
      var currentScrollWidth = currentX + currentWidth + circleRadius + circleWidth;
      var currentZPWidth = circleRadius + circleWidth / 2;
      var axisSize = this.isVertical ? axis.rect.height : this.width;
      this.zoomFactor = (currentWidth + (currentScrollWidth >= this.width ? circleRadius + circleWidth : 0)) / axisSize;
      this.zoomPosition = currentScrollWidth > axisSize ? 1 - axis.zoomFactor : currentX < circleRadius + circleWidth ? 0 : (currentX - (currentX - currentZPWidth <= 0 ? currentZPWidth : 0)) / axisSize;
      this.zoomPosition = this.component.enableRtl && !this.isVertical && !axis.isInversed || axis.isInversed && !(this.component.enableRtl && !this.isVertical) ? 1 - (this.zoomPosition + axis.zoomFactor) : this.zoomPosition;
    };
    ScrollBar2.prototype.scrollMouseMove = function(e) {
      var target = e.target;
      var elem = this.scrollElements;
      var isInverse = this.axis.isAxisInverse;
      if (!getElement2(this.svgObject.id)) {
        return null;
      }
      this.getMouseXY(e);
      if (!isNullOrUndefined(target.id)) {
        this.setCursor(target);
        this.setTheme(target);
      }
      var mouseXY = this.isVertical && isInverse ? this.width - this.mouseY : this.isVertical ? this.mouseY : this.mouseX;
      var range = this.axis.visibleRange;
      var zoomPosition = this.zoomPosition;
      var zoomFactor = this.zoomFactor;
      var moveLength = this.previousRectX - elem.thumbRectX;
      var thumbMove = moveLength < 0 ? "RightMove" : "LeftMove";
      var args;
      if (this.isLazyLoad && (this.isThumbDrag || this.isResizeLeft || this.isResizeRight)) {
        args = this.calculateLazyRange(elem.thumbRectX, elem.thumbRectWidth, thumbMove);
      }
      var currentRange = args ? args.currentRange : null;
      if (this.isThumbDrag) {
        this.component.isScrolling = this.isThumbDrag;
        mouseXY = this.isVertical || isInverse ? this.width - mouseXY : mouseXY;
        var currentX = elem.thumbRectX + (mouseXY - this.previousXY);
        if (mouseXY >= currentX + elem.thumbRectWidth) {
          this.setCursor(target);
        } else {
          if (this.axis.scrollbarSettings.height >= 12) {
            this.svgObject.style.cursor = "-webkit-grabbing";
          }
        }
        if (mouseXY >= 0 && mouseXY <= currentX + elem.thumbRectWidth) {
          elem.thumbRectX = this.isWithIn(currentX) ? currentX : elem.thumbRectX;
          this.positionThumb(elem.thumbRectX, elem.thumbRectWidth);
          this.previousXY = mouseXY;
          this.setZoomFactorPosition(currentX, elem.thumbRectWidth);
          this.axis.zoomPosition = this.zoomPosition < 0 ? 0 : this.zoomPosition > 0.9 ? 1 : this.zoomPosition;
        }
        this.component.trigger(scrollChanged, this.getArgs(scrollChanged, range, zoomPosition, zoomFactor, currentRange));
      } else if (this.isResizeLeft || this.isResizeRight) {
        this.resizeThumb();
      }
    };
    ScrollBar2.prototype.scrollMouseWheel = function(e) {
      if (!this.axis.scrollbarSettings.enableZoom) {
        return null;
      }
      var svgRect = getElement2(this.component.element.id + "_scrollBar_svg" + this.axis.name).getBoundingClientRect();
      this.mouseX = e.clientX - Math.max(svgRect.left, 0);
      this.mouseY = e.clientY - Math.max(svgRect.top, 0);
      var origin = 0.5;
      var elem = this.scrollElements;
      var axis = this.axis;
      var direction = this.browserName === "mozilla" && !this.isPointer ? -e.detail / 3 > 0 ? 1 : -1 : e["wheelDelta"] / 120 > 0 ? 1 : -1;
      var cumulative = Math.max(Math.max(1 / minMax(axis.zoomFactor, 0, 1), 1) + 0.25 * direction, 1);
      var range = this.axis.visibleRange;
      var zoomPosition = this.zoomPosition;
      var zoomFactor = this.zoomFactor;
      var args;
      if (cumulative >= 1) {
        origin = axis.orientation === "Horizontal" ? this.mouseX / axis.rect.width : 1 - this.mouseY / axis.rect.height;
        origin = origin > 1 ? 1 : origin < 0 ? 0 : origin;
        this.zoomFactor = cumulative === 1 ? 1 : minMax(1 / cumulative, 0, 1);
        this.zoomPosition = cumulative === 1 ? 0 : axis.zoomPosition + (axis.zoomFactor - this.zoomFactor) * origin;
      }
      elem.thumbRectX = this.isWithIn(this.zoomPosition * this.width) ? this.zoomPosition * this.width : elem.thumbRectX;
      this.isScrollUI = true;
      this.positionThumb(elem.thumbRectX, elem.thumbRectWidth);
      if (this.isLazyLoad) {
        this.setZoomFactorPosition(elem.thumbRectX, elem.thumbRectWidth);
        this.axis.zoomFactor = this.zoomFactor;
        this.axis.zoomPosition = this.zoomPosition < 0 ? 0 : this.zoomPosition > 0.9 ? 1 : this.zoomPosition;
      }
      axis.zoomFactor = this.zoomFactor;
      axis.zoomPosition = this.zoomPosition;
      if (this.isLazyLoad) {
        args = this.calculateMouseWheelRange(elem.thumbRectX, elem.thumbRectWidth);
        if (args) {
          if (args.currentRange.minimum !== args.previousAxisRange.minimum && args.currentRange.maximum !== args.previousAxisRange.maximum) {
            this.component.trigger(scrollEnd, args);
            this.isScrollEnd = false;
          }
        }
      }
      if (!this.isLazyLoad) {
        this.component.trigger(scrollChanged, this.getArgs(scrollChanged, range, zoomPosition, zoomFactor));
      }
    };
    ScrollBar2.prototype.scrollMouseUp = function() {
      var args;
      this.startX = this.scrollElements.thumbRectX;
      var circleRadius = this.axis.scrollbarSettings.height / 2;
      var circleWidth = 1;
      var currentScrollWidth = this.startX + this.scrollElements.thumbRectWidth + circleRadius + circleWidth;
      var currentZPWidth = circleRadius + circleWidth / 2;
      if ((this.isResizeLeft || this.isResizeRight) && !this.isLazyLoad) {
        this.axis.zoomFactor = currentScrollWidth >= this.width - 1 && this.startX - currentZPWidth <= 0 ? 1 : this.zoomFactor;
      }
      if (this.isLazyLoad) {
        var moveLength = this.previousRectX - this.startX;
        if ((moveLength > 0 || moveLength < 0) && this.isThumbDrag) {
          var thumbMove = moveLength < 0 ? "RightMove" : "LeftMove";
          if (thumbMove === "RightMove") {
            this.startX = this.startX + Math.abs(moveLength) < this.width - circleRadius ? this.startX : this.width - circleRadius - this.scrollElements.thumbRectWidth;
          } else {
            this.startX = this.startX + this.scrollElements.thumbRectWidth - Math.abs(moveLength) > circleRadius ? this.startX : circleRadius;
          }
          args = this.calculateLazyRange(this.startX, this.scrollElements.thumbRectWidth, thumbMove);
          if (args) {
            this.component.trigger(scrollEnd, args);
            this.scrollStarted = false;
          }
        }
        if (this.isResizeLeft || this.isResizeRight) {
          args = this.calculateLazyRange(this.startX, this.scrollElements.thumbRectWidth);
          if (args) {
            this.component.trigger(scrollEnd, args);
            this.scrollStarted = false;
          }
        }
      }
      this.isThumbDrag = false;
      this.isResizeLeft = false;
      this.isResizeRight = false;
      this.isScrollEnd = false;
      this.component.isScrolling = false;
      if (this.scrollStarted && !this.isLazyLoad) {
        this.component.trigger(scrollEnd, this.getArgs(scrollChanged, this.startRange, this.startZoomPosition, this.startZoomFactor));
        this.scrollStarted = false;
      }
      if (this.isCustomHeight) {
        this.component.element.style.height = null;
      }
    };
    ScrollBar2.prototype.calculateMouseWheelRange = function(scrollThumbX, scrollThumbWidth) {
      var zoomFactor;
      var zoomPosition;
      var args;
      var range = this.scrollRange;
      var previousRange = this.getStartEnd(this.previousStart, this.previousEnd, false);
      var circleRadius = this.axis.scrollbarSettings.height / 2;
      if (scrollThumbX + scrollThumbWidth + circleRadius <= this.width) {
        zoomPosition = (scrollThumbX - circleRadius) / this.width;
        zoomFactor = scrollThumbWidth / this.width;
      }
      var currentStart = range.min + zoomPosition * range.delta;
      var currentEnd = currentStart + zoomFactor * range.delta;
      if (currentEnd) {
        args = {
          axis: this.axis,
          currentRange: this.getStartEnd(currentStart, currentEnd, true),
          previousAxisRange: previousRange
        };
      }
      return args;
    };
    ScrollBar2.prototype.calculateLazyRange = function(scrollThumbX, scrollThumbWidth, thumbMove) {
      var currentScrollWidth = scrollThumbWidth;
      var zoomFactor;
      var zoomPosition;
      var currentStart;
      var currentEnd;
      var args;
      var range = this.scrollRange;
      var previousRange = this.getStartEnd(this.previousStart, this.previousEnd, false);
      var circleRadius = this.axis.scrollbarSettings.height / 2;
      var circleWidth = 16;
      if (this.isResizeRight || thumbMove === "RightMove") {
        currentScrollWidth = this.isResizeRight ? currentScrollWidth + circleWidth : currentScrollWidth;
        zoomFactor = currentScrollWidth / this.width;
        zoomPosition = thumbMove === "RightMove" ? (scrollThumbX + circleRadius) / this.width : this.axis.zoomPosition;
        currentStart = thumbMove === "RightMove" ? range.min + zoomPosition * range.delta : this.previousStart;
        currentEnd = currentStart + zoomFactor * range.delta;
      } else if (this.isResizeLeft || thumbMove === "LeftMove") {
        zoomPosition = (scrollThumbX - circleRadius) / this.width;
        zoomFactor = currentScrollWidth / this.width;
        currentStart = range.min + zoomPosition * range.delta;
        currentStart = currentStart >= range.min ? currentStart : range.min;
        currentEnd = thumbMove === "LeftMove" ? currentStart + zoomFactor * range.delta : this.previousEnd;
      } else if (this.isThumbDrag) {
        zoomPosition = thumbMove === "RightMove" ? (scrollThumbX + circleRadius) / this.width : (scrollThumbX - circleRadius) / this.width;
        zoomFactor = this.scrollElements.thumbRectWidth / this.width;
        currentStart = range.min + zoomPosition * range.delta;
        currentStart = currentStart >= range.min ? currentStart : range.min;
        currentEnd = currentStart + zoomFactor * range.delta;
      }
      if (currentEnd) {
        args = {
          axis: this.component.isBlazor ? {} : this.axis,
          currentRange: this.getStartEnd(currentStart, currentEnd, true),
          previousAxisRange: previousRange
        };
      }
      return args;
    };
    ScrollBar2.prototype.getStartEnd = function(start, end, isCurrentStartEnd) {
      var valueType = this.valueType;
      if ((valueType === "DateTime" || valueType === "DateTimeCategory") && isCurrentStartEnd) {
        this.previousStart = start;
        this.previousEnd = end;
      } else if (isCurrentStartEnd) {
        var currentStart = Math.round(start);
        var currentEnd = Math.ceil(end);
        if (this.axis.valueType === "Category") {
          currentEnd -= !this.axis.scrollbarSettings.enableZoom && currentEnd - currentStart > this.previousEnd - this.previousStart ? currentEnd - currentStart - (this.previousEnd - this.previousStart) : 0;
        }
        this.previousStart = start = currentStart;
        this.previousEnd = end = currentEnd;
      }
      switch (valueType) {
        case "Double":
        case "Category":
        case "Logarithmic":
          start = Math.round(start);
          end = Math.ceil(end);
          break;
        case "DateTime":
        case "DateTimeCategory":
          start = new Date(start);
          end = new Date(end);
          break;
      }
      return {
        minimum: start,
        maximum: end
      };
    };
    ScrollBar2.prototype.render = function(isScrollExist) {
      if (this.component.zoomModule || isScrollExist && this.axis.scrollbarSettings.enable) {
        this.getDefaults();
      }
      this.getTheme();
      this.removeScrollSvg();
      createScrollSvg(this, this.component.svgRenderer);
      this.wireEvents(this.svgObject);
      this.svgObject.appendChild(this.scrollElements.renderElements(this, this.component.svgRenderer));
      return this.svgObject;
    };
    ScrollBar2.prototype.getTheme = function() {
      this.scrollbarThemeStyle = getScrollbarThemeColor(this.component.theme);
    };
    ScrollBar2.prototype.removeScrollSvg = function() {
      if (document.getElementById(this.component.element.id + "_scrollBar_svg" + this.axis.name)) {
        remove(document.getElementById(this.component.element.id + "_scrollBar_svg" + this.axis.name));
      }
    };
    ScrollBar2.prototype.setCursor = function(target) {
      var id = target.id;
      this.svgObject.style.cursor = (id.indexOf("scrollBarThumb_") > -1 || id.indexOf("_gripCircle") > -1) && this.axis.scrollbarSettings.height >= 12 ? "-webkit-grab" : id.indexOf("Circle_") > -1 || id.indexOf("Arrow_") > -1 ? this.isVertical ? "ns-resize" : "ew-resize" : "auto";
    };
    ScrollBar2.prototype.setTheme = function(target) {
      var id = target.id;
      var isLeftHover = id.indexOf("_leftCircle_") > -1 || id.indexOf("_leftArrow_") > -1;
      var isRightHover = id.indexOf("_rightCircle_") > -1 || id.indexOf("_rightArrow_") > -1;
      var style = this.scrollbarThemeStyle;
      var leftArrowEle = this.scrollElements.leftArrowEle;
      var rightArrowEle = this.scrollElements.rightArrowEle;
      var leftCircleEle = this.scrollElements.leftCircleEle;
      var rightCircleEle = this.scrollElements.rightCircleEle;
      var isAxis = this.isCurrentAxis(target, leftArrowEle);
      leftCircleEle.style.fill = isLeftHover && isAxis ? style.circleHover : style.circle;
      rightCircleEle.style.fill = isRightHover && isAxis ? style.circleHover : style.circle;
      leftCircleEle.style.stroke = isLeftHover && isAxis ? style.circleHover : style.circle;
      rightCircleEle.style.stroke = isRightHover && isAxis ? style.circleHover : style.circle;
      if (this.component.theme === "HighContrastLight") {
        leftArrowEle.style.fill = isLeftHover && isAxis ? style.arrowHover : style.arrow;
        leftArrowEle.style.stroke = isLeftHover && isAxis ? style.arrowHover : style.arrow;
        rightArrowEle.style.fill = isRightHover && isAxis ? style.arrowHover : style.arrow;
        rightArrowEle.style.stroke = isRightHover && isAxis ? style.arrowHover : style.arrow;
        leftCircleEle.style.stroke = isLeftHover && isAxis ? style.circleHover : style.circle;
        rightCircleEle.style.stroke = isRightHover && isAxis ? style.circleHover : style.circle;
      }
    };
    ScrollBar2.prototype.isCurrentAxis = function(target, ele) {
      return target.id.split("_")[2] === ele.id.split("_")[2];
    };
    ScrollBar2.prototype.resizeThumb = function() {
      var currentWidth;
      var circleRadius = this.axis.scrollbarSettings.height / 2;
      var padding = 5;
      var gripWidth = 14;
      var minThumbWidth = circleRadius * 2 + padding * 2 + gripWidth;
      var thumbX = this.previousRectX;
      var isInverse = this.axis.isAxisInverse;
      var mouseXY = this.isVertical && isInverse ? this.mouseY : this.isVertical ? this.width - this.mouseY : isInverse ? this.width - this.mouseX : this.mouseX;
      var diff = Math.abs(this.previousXY - mouseXY);
      if (this.isResizeLeft && mouseXY >= 0) {
        var currentX = thumbX + (mouseXY > this.previousXY ? diff : -diff);
        currentWidth = currentX - circleRadius >= 0 ? this.previousWidth + (mouseXY > this.previousXY ? -diff : diff) : this.previousWidth;
        currentX = currentX - circleRadius >= 0 ? currentX : thumbX;
        if (currentWidth >= minThumbWidth && mouseXY < currentX + currentWidth) {
          this.scrollElements.thumbRectX = this.previousRectX = currentX;
          this.scrollElements.thumbRectWidth = this.previousWidth = currentWidth;
          this.previousXY = mouseXY;
          this.setZoomFactorPosition(currentX, currentWidth);
          var argsData = {
            axis: this.component.isBlazor ? {} : this.axis,
            name: scrollChanged,
            range: this.axis.visibleRange,
            zoomFactor: this.zoomFactor,
            zoomPosition: this.zoomPosition,
            previousRange: this.axis.visibleRange,
            previousZoomFactor: this.axis.zoomFactor,
            previousZoomPosition: this.axis.zoomPosition,
            currentRange: null,
            cancel: false
          };
          this.component.trigger(scrollChanged, argsData);
          if (!argsData.cancel) {
            this.positionThumb(currentX, currentWidth);
            this.axis.zoomFactor = argsData.zoomFactor;
            this.axis.zoomPosition = argsData.zoomPosition;
          } else {
            this.zoomFactor = argsData.previousZoomFactor;
            this.zoomPosition = argsData.previousZoomPosition;
          }
        }
      } else if (this.isResizeRight) {
        currentWidth = mouseXY >= minThumbWidth + this.scrollElements.thumbRectX && mouseXY <= this.width - circleRadius ? mouseXY - this.scrollElements.thumbRectX : this.previousWidth;
        this.scrollElements.thumbRectWidth = this.previousWidth = currentWidth;
        this.previousXY = mouseXY;
        this.setZoomFactorPosition(this.startX, currentWidth);
        if (!this.isLazyLoad) {
          this.setZoomFactorPosition(this.startX, currentWidth);
        }
        var argsData = {
          axis: this.component.isBlazor ? {} : this.axis,
          name: scrollChanged,
          range: this.axis.visibleRange,
          zoomFactor: this.zoomFactor,
          zoomPosition: this.zoomPosition,
          previousRange: this.axis.visibleRange,
          previousZoomFactor: this.axis.zoomFactor,
          previousZoomPosition: this.axis.zoomPosition,
          currentRange: null,
          cancel: false
        };
        this.component.trigger(scrollChanged, argsData);
        if (!argsData.cancel) {
          this.positionThumb(this.startX, currentWidth);
          this.axis.zoomFactor = argsData.zoomFactor;
          this.axis.zoomPosition = argsData.zoomPosition;
        } else {
          this.zoomFactor = argsData.previousZoomFactor;
          this.zoomPosition = argsData.previousZoomPosition;
        }
      }
    };
    ScrollBar2.prototype.positionThumb = function(currentX, currentWidth) {
      var elem = this.scrollElements;
      var gripWidth = 14;
      var gripCircleDiameter = 2;
      var padding = gripWidth / 2 - gripCircleDiameter;
      elem.slider.setAttribute("x", this.axis.scrollbarSettings.enableZoom ? currentX.toString() : (currentX - this.axis.scrollbarSettings.height / 2).toString());
      elem.slider.setAttribute("width", this.axis.scrollbarSettings.enableZoom ? currentWidth.toString() : (currentWidth + this.axis.scrollbarSettings.height).toString());
      elem.leftCircleEle.setAttribute("cx", currentX.toString());
      elem.rightCircleEle.setAttribute("cx", (currentX + currentWidth).toString());
      elem.setArrowDirection(currentX, currentWidth, this.height);
      elem.gripCircle.setAttribute("transform", "translate(" + (currentX + currentWidth / 2 + (this.isVertical ? 1 : -1) * padding) + "," + (this.isVertical ? this.axis.scrollbarSettings.height / 2 + padding / 2 - 0.5 : this.axis.scrollbarSettings.height / 2 - padding / 2 - 0.5) + ") rotate(" + (this.isVertical ? "180" : "0") + ")");
    };
    ScrollBar2.prototype.getDefaults = function() {
      var axis = this.axis;
      var circleRadius = this.axis.scrollbarSettings.height / 2;
      var padding = 5;
      var gripWidth = 14;
      var minThumbWidth = circleRadius * 2 + padding * 2 + gripWidth;
      if (this.axis.scrollbarSettings.enable) {
        this.isLazyLoad = true;
        this.getLazyDefaults(axis);
      }
      this.isVertical = axis.orientation === "Vertical";
      var isRtlEnabled = this.component.enableRtl && !this.isVertical && !axis.isInversed || axis.isInversed && !(this.component.enableRtl && !this.isVertical);
      this.zoomFactor = this.isLazyLoad ? this.zoomFactor : axis.zoomFactor;
      this.zoomPosition = this.isLazyLoad ? isRtlEnabled ? 1 - (this.zoomPosition + this.zoomFactor) : this.zoomPosition : isRtlEnabled ? 1 - (axis.zoomPosition + axis.zoomFactor) : axis.zoomPosition;
      var currentWidth = this.zoomFactor * (this.isVertical ? axis.rect.height : axis.rect.width);
      currentWidth = this.isLazyLoad && !this.axis.scrollbarSettings.enableZoom || currentWidth > minThumbWidth ? currentWidth : minThumbWidth;
      this.scrollX = axis.rect.x;
      this.scrollY = axis.rect.y;
      this.width = this.isVertical ? axis.rect.height : axis.rect.width;
      this.height = this.axis.scrollbarSettings.height;
      var currentX = this.zoomPosition * (this.isVertical ? axis.rect.height : this.width);
      var minThumbX = this.width - minThumbWidth - circleRadius;
      this.scrollElements.thumbRectX = currentX > minThumbX ? minThumbX : currentX < circleRadius ? circleRadius : currentX;
      this.scrollElements.thumbRectWidth = this.isThumbDrag ? this.scrollElements.thumbRectWidth : currentWidth + this.scrollElements.thumbRectX < this.width - circleRadius * 2 ? currentWidth : this.width - this.scrollElements.thumbRectX - circleRadius;
    };
    ScrollBar2.prototype.getLazyDefaults = function(axis) {
      var start;
      var end;
      var valueType = axis.valueType;
      var scrollbarSettings = axis.scrollbarSettings;
      var range = axis.scrollbarSettings.range;
      var visibleRange = axis.visibleRange;
      var pointsLength = axis.scrollbarSettings.pointsLength;
      this.valueType = valueType = (!scrollbarSettings.range.minimum || !scrollbarSettings.range.maximum) && scrollbarSettings.pointsLength ? "Double" : valueType;
      var option = {
        skeleton: "full",
        type: "dateTime"
      };
      var dateParser = this.component.intl.getDateParser(option);
      var dateFormatter = this.component.intl.getDateFormat(option);
      switch (valueType) {
        case "Double":
        case "Category":
        case "Logarithmic":
          start = range.minimum ? range.minimum : pointsLength ? 0 : visibleRange.min;
          end = range.maximum ? range.maximum : pointsLength ? pointsLength - 1 : visibleRange.max;
          break;
        case "DateTime":
        case "DateTimeCategory":
          start = range.minimum ? Date.parse(dateParser(dateFormatter(range.minimum))) : visibleRange.min;
          end = range.maximum ? Date.parse(dateParser(dateFormatter(range.maximum))) : visibleRange.max;
          break;
      }
      start = Math.min(start, visibleRange.min);
      end = Math.max(end, visibleRange.max);
      var zoomFactor = (visibleRange.max - visibleRange.min) / (end - start);
      var zoomPosition = (visibleRange.min - start) / (end - start);
      this.zoomFactor = range.minimum || range.maximum ? zoomFactor : this.axis.maxPointLength / axis.scrollbarSettings.pointsLength;
      this.zoomPosition = range.minimum || range.maximum ? zoomPosition : axis.zoomPosition;
      this.zoomPosition = this.component.enableRtl && axis.orientation === "Horizontal" && !axis.isInversed || axis.isInversed && !(this.component.enableRtl && axis.orientation === "Horizontal") ? 1 - (this.zoomPosition + this.zoomFactor) : this.zoomPosition;
      this.scrollRange.min = start;
      this.scrollRange.max = end;
      this.scrollRange.delta = end - start;
      this.previousStart = visibleRange.min;
      this.previousEnd = visibleRange.max;
    };
    ScrollBar2.prototype.getLogRange = function(axis) {
      var range = axis.scrollbarSettings.range;
      var start = logBase(range.minimum, axis.logBase);
      var end = logBase(range.maximum, axis.logBase);
      start = isFinite(start) ? start : range.minimum;
      end = isFinite(start) ? end : range.maximum;
      return {
        minimum: Math.floor(start / 1),
        maximum: Math.ceil(end / 1)
      };
    };
    ScrollBar2.prototype.injectTo = function(axis, component) {
      axis.zoomingScrollBar = new ScrollBar2(component, axis);
    };
    ScrollBar2.prototype.destroy = function() {
      var _this = this;
      if (this.axes) {
        this.axes.map(function(axis) {
          axis.zoomingScrollBar.destroy();
        });
      } else {
        this.elements.map(function(element) {
          _this.unWireEvents(element);
          remove(element.firstChild);
        });
        this.elements = [];
      }
    };
    ScrollBar2.prototype.getModuleName = function() {
      return "ScrollBar";
    };
    ScrollBar2.prototype.getArgs = function(eventName, range, zoomPosition, zoomFactor, currentRanges) {
      var scrollArgs = {
        axis: this.component.isBlazor ? {} : this.axis,
        name: eventName,
        range: this.axis.visibleRange,
        zoomFactor: this.axis.zoomFactor,
        zoomPosition: this.axis.zoomPosition,
        previousRange: range,
        previousZoomFactor: zoomFactor,
        previousZoomPosition: zoomPosition,
        currentRange: currentRanges
      };
      return scrollArgs;
    };
    return ScrollBar2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/accumulation-chart/model/acc-base.js
var __extends64 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate8 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AccumulationAnnotationSettings = (
  /** @class */
  function(_super) {
    __extends64(AccumulationAnnotationSettings2, _super);
    function AccumulationAnnotationSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([Property(null)], AccumulationAnnotationSettings2.prototype, "content", void 0);
    __decorate8([Property("0")], AccumulationAnnotationSettings2.prototype, "x", void 0);
    __decorate8([Property("0")], AccumulationAnnotationSettings2.prototype, "y", void 0);
    __decorate8([Property("Pixel")], AccumulationAnnotationSettings2.prototype, "coordinateUnits", void 0);
    __decorate8([Property("Chart")], AccumulationAnnotationSettings2.prototype, "region", void 0);
    __decorate8([Property("Middle")], AccumulationAnnotationSettings2.prototype, "verticalAlignment", void 0);
    __decorate8([Property("Center")], AccumulationAnnotationSettings2.prototype, "horizontalAlignment", void 0);
    __decorate8([Property(null)], AccumulationAnnotationSettings2.prototype, "description", void 0);
    return AccumulationAnnotationSettings2;
  }(ChildProperty)
);
var AccumulationDataLabelSettings = (
  /** @class */
  function(_super) {
    __extends64(AccumulationDataLabelSettings2, _super);
    function AccumulationDataLabelSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([Property(false)], AccumulationDataLabelSettings2.prototype, "visible", void 0);
    __decorate8([Property(true)], AccumulationDataLabelSettings2.prototype, "showZero", void 0);
    __decorate8([Property(null)], AccumulationDataLabelSettings2.prototype, "name", void 0);
    __decorate8([Property("transparent")], AccumulationDataLabelSettings2.prototype, "fill", void 0);
    __decorate8([Property("Inside")], AccumulationDataLabelSettings2.prototype, "position", void 0);
    __decorate8([Property(5)], AccumulationDataLabelSettings2.prototype, "rx", void 0);
    __decorate8([Property(5)], AccumulationDataLabelSettings2.prototype, "ry", void 0);
    __decorate8([Property(0)], AccumulationDataLabelSettings2.prototype, "angle", void 0);
    __decorate8([Property(false)], AccumulationDataLabelSettings2.prototype, "enableRotation", void 0);
    __decorate8([Complex({
      width: null,
      color: null
    }, Border)], AccumulationDataLabelSettings2.prototype, "border", void 0);
    __decorate8([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, Font)], AccumulationDataLabelSettings2.prototype, "font", void 0);
    __decorate8([Complex({}, Connector)], AccumulationDataLabelSettings2.prototype, "connectorStyle", void 0);
    __decorate8([Property(null)], AccumulationDataLabelSettings2.prototype, "template", void 0);
    __decorate8([Property("")], AccumulationDataLabelSettings2.prototype, "format", void 0);
    __decorate8([Property(null)], AccumulationDataLabelSettings2.prototype, "maxWidth", void 0);
    __decorate8([Property("Ellipsis")], AccumulationDataLabelSettings2.prototype, "textOverflow", void 0);
    __decorate8([Property("Normal")], AccumulationDataLabelSettings2.prototype, "textWrap", void 0);
    return AccumulationDataLabelSettings2;
  }(ChildProperty)
);
var PieCenter = (
  /** @class */
  function(_super) {
    __extends64(PieCenter2, _super);
    function PieCenter2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([Property("50%")], PieCenter2.prototype, "x", void 0);
    __decorate8([Property("50%")], PieCenter2.prototype, "y", void 0);
    return PieCenter2;
  }(ChildProperty)
);
var AccPoints = (
  /** @class */
  /* @__PURE__ */ function() {
    function AccPoints2() {
      this.visible = true;
      this.symbolLocation = null;
      this.region = null;
      this.labelRegion = null;
      this.labelVisible = true;
      this.regions = null;
      this.isExplode = false;
      this.isClubbed = false;
      this.isSliced = false;
      this.argsData = null;
      this.isLabelUpdated = null;
      this.initialLabelRegion = null;
    }
    return AccPoints2;
  }()
);
var AccumulationSeries = (
  /** @class */
  function(_super) {
    __extends64(AccumulationSeries2, _super);
    function AccumulationSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.points = [];
      _this.clubbedPoints = [];
      _this.sumOfPoints = 0;
      _this.isRectSeries = true;
      _this.clipRect = new Rect(0, 0, 0, 0);
      _this.category = "Series";
      _this.rightSidePoints = [];
      _this.leftSidePoints = [];
      return _this;
    }
    AccumulationSeries2.prototype.refreshDataManager = function(accumulation, render) {
      var _this = this;
      this.accumulation = accumulation;
      this.radius = this.radius ? this.radius : Browser.isDevice && this.dataLabel.position === "Outside" ? "40%" : "80%";
      var dateSource = this.dataSource || accumulation.dataSource;
      if (!(dateSource instanceof DataManager) && isNullOrUndefined(this.query)) {
        this.dataManagerSuccess({
          result: dateSource,
          count: dateSource.length
        }, accumulation, render);
        return;
      }
      var dataManager = this.dataModule.getData(this.dataModule.generateQuery().requiresCount());
      dataManager.then(function(e) {
        return _this.dataManagerSuccess(e, accumulation);
      });
    };
    AccumulationSeries2.prototype.dataManagerSuccess = function(e, accumulation, render) {
      if (render === void 0) {
        render = true;
      }
      var argsData = {
        name: seriesRender,
        series: this,
        data: e.result
      };
      accumulation.allowServerDataBinding = false;
      accumulation.trigger(seriesRender, argsData);
      this.resultData = e.result !== "" ? e.result : [];
      if (!accumulation.isBlazor && !render) {
        this.getPoints(this.resultData, accumulation);
      }
      if (++accumulation.seriesCounts === accumulation.visibleSeries.length && render || window["Blazor"] && !render && accumulation.seriesCounts === 1) {
        this.getPoints(this.resultData, accumulation);
        accumulation.refreshChart();
      }
    };
    AccumulationSeries2.prototype.getPoints = function(result, accumulation) {
      var length = Object.keys(result).length;
      this.sumOfPoints = 0;
      if (length === 0) {
        this.points = [];
        return null;
      }
      this.findSumOfPoints(result);
      this.points = [];
      this.clubbedPoints = [];
      this.sumOfClub = 0;
      var point;
      var colors = this.palettes.length ? this.palettes : getSeriesColor(accumulation.theme);
      var clubValue = stringToNumber(this.groupTo, this.sumOfPoints);
      for (var i = 0; i < length; i++) {
        point = this.setPoints(result, i, colors, accumulation);
        if (!this.isClub(point, clubValue, i)) {
          if (isNullOrUndefined(point.y)) {
            point.visible = false;
          }
          this.pushPoints(point, colors);
        } else {
          point.index = this.clubbedPoints.length;
          point.isExplode = true;
          this.clubbedPoints.push(point);
          point.isSliced = true;
        }
      }
      this.lastGroupTo = this.groupTo;
      if (this.sumOfClub > 0) {
        var clubPoint_1 = this.generateClubPoint();
        this.pushPoints(clubPoint_1, colors);
        var pointsLength_1 = this.points.length - 1;
        this.clubbedPoints.map(function(point2) {
          point2.index += pointsLength_1;
          point2.color = clubPoint_1.color;
        });
      }
      if (this.clubbedPoints.length && this.explode && this.type === "Pie" && (this.explodeAll || this.points[this.points.length - 1].index === this.explodeIndex)) {
        this.points.splice(this.points.length - 1, 1);
        this.points = this.points.concat(this.clubbedPoints);
      }
    };
    AccumulationSeries2.prototype.generateClubPoint = function() {
      var clubPoint = new AccPoints();
      clubPoint.isClubbed = true;
      clubPoint.x = "Others";
      clubPoint.y = this.sumOfClub;
      clubPoint.text = clubPoint.originalText = clubPoint.x + ": " + this.sumOfClub;
      clubPoint.sliceRadius = "80%";
      return clubPoint;
    };
    AccumulationSeries2.prototype.pushPoints = function(point, colors) {
      point.index = this.points.length;
      point.isExplode = this.explodeAll || point.index === this.explodeIndex;
      point.color = point.color || colors[point.index % colors.length];
      this.points.push(point);
    };
    AccumulationSeries2.prototype.isClub = function(point, clubValue, index) {
      if (!isNullOrUndefined(clubValue)) {
        if (this.groupMode === "Value" && Math.abs(point.y) <= clubValue) {
          this.sumOfClub += Math.abs(point.y);
          return true;
        } else if (this.groupMode === "Point" && index >= clubValue) {
          this.sumOfClub += Math.abs(point.y);
          return true;
        }
      }
      return false;
    };
    AccumulationSeries2.prototype.findSumOfPoints = function(result) {
      var length = Object.keys(result).length;
      for (var i = 0; i < length; i++) {
        if (!isNullOrUndefined(result[i]) && !isNullOrUndefined(result[i][this.yName]) && !isNaN(result[i][this.yName])) {
          this.sumOfPoints += Math.abs(result[i][this.yName]);
        }
      }
    };
    AccumulationSeries2.prototype.setPoints = function(data, i, colors, accumulation) {
      var point = new AccPoints();
      point.x = getValue(this.xName, data[i]);
      point.y = getValue(this.yName, data[i]);
      point.legendImageUrl = getValue(this.legendImageUrl, data[i]);
      point.color = getValue(this.pointColorMapping, data[i]);
      point.text = point.originalText = getValue(this.dataLabel.name || "", data[i]);
      point.tooltip = getValue(this.tooltipMappingName || "", data[i]);
      point.sliceRadius = getValue(this.radius, data[i]);
      point.sliceRadius = isNullOrUndefined(point.sliceRadius) ? "80%" : point.sliceRadius;
      point.separatorY = accumulation.intl.formatNumber(point.y, {
        useGrouping: accumulation.useGroupingSeparator
      });
      this.setAccEmptyPoint(point, i, data);
      return point;
    };
    AccumulationSeries2.prototype.renderSeries = function(accumulation, redraw) {
      var seriesGroup = redraw ? getElement2(accumulation.element.id + "_Series_" + this.index) : accumulation.renderer.createGroup({
        id: accumulation.element.id + "_Series_" + this.index
      });
      this.renderPoints(accumulation, seriesGroup, redraw);
      var datalabelGroup;
      if (accumulation.accumulationDataLabelModule && this.dataLabel.visible) {
        datalabelGroup = accumulation.renderer.createGroup({
          id: accumulation.element.id + "_datalabel_Series_" + this.index
        });
        datalabelGroup.style.visibility = (this.animation.enable && animationMode !== "Disable" || animationMode === "Enable") && accumulation.animateSeries && this.type === "Pie" ? "hidden" : "visible";
        this.renderDataLabel(accumulation, datalabelGroup, redraw);
      }
      if (this.type === "Pie") {
        if (!accumulation.redraw) {
          this.findMaxBounds(this.labelBound, this.accumulationBound);
        }
        accumulation.pieSeriesModule.animateSeries(accumulation, this.animation, this, seriesGroup, this.borderRadius, this.points);
      }
      if (!accumulation.redraw && accumulation.accumulationLegendModule) {
        this.labelBound.x -= accumulation.explodeDistance;
        this.labelBound.y -= accumulation.explodeDistance;
        this.labelBound.height += accumulation.explodeDistance - this.labelBound.y;
        this.labelBound.width += accumulation.explodeDistance - this.labelBound.x;
      }
    };
    AccumulationSeries2.prototype.renderPoints = function(accumulation, seriesGroup, redraw, previouRadius, previousCenter, pointAnimation) {
      var pointId = accumulation.element.id + "_Series_" + this.index + "_Point_";
      var option;
      var patternFill;
      var options = [];
      var visiblePoints = [];
      var patterns = ["Chessboard", "Dots", "DiagonalForward", "Crosshatch", "Pacman", "DiagonalBackward", "Grid", "Turquoise", "Star", "Triangle", "Circle", "Tile", "HorizontalDash", "VerticalDash", "Rectangle", "Box", "VerticalStripe", "HorizontalStripe", "Bubble"];
      for (var _i = 0, _a = this.points; _i < _a.length; _i++) {
        var point = _a[_i];
        point.percentage = +(point.y / this.sumOfPoints * 100).toFixed(2);
        var argsData = {
          cancel: false,
          name: pointRender,
          series: this,
          point,
          fill: point.color,
          border: this.isEmpty(point) ? {
            width: this.emptyPointSettings.border.width,
            color: this.emptyPointSettings.border.color
          } : {
            width: this.border.width,
            color: this.border.color
          },
          pattern: this.applyPattern ? patterns[point.index % patterns.length] : "None"
        };
        accumulation.trigger(pointRender, argsData);
        point.color = argsData.fill;
        patternFill = point.color;
        if (this.applyPattern) {
          var selection = new BaseSelection(accumulation);
          patternFill = selection.pattern(accumulation, point.color, point.index, argsData.pattern, this.opacity);
        }
        option = new PathOption(pointId + point.index, patternFill, argsData.border.width || 1, argsData.border.color || point.color, this.opacity, argsData.series.dashArray, "");
        if (this.funnelMode === "Trapezoidal" && this.type === "Funnel") {
          options.push(option);
          if (point.visible) {
            visiblePoints.push(point);
          }
        } else {
          accumulation[firstToLowerCase(this.type) + "SeriesModule"].renderPoint(point, this, accumulation, option, seriesGroup, redraw, previouRadius, previousCenter, pointAnimation);
        }
      }
      if (this.funnelMode === "Trapezoidal" && this.type === "Funnel") {
        accumulation[firstToLowerCase(this.type) + "SeriesModule"].renderTrapezoidalFunnel(this, visiblePoints, accumulation, options, seriesGroup, redraw);
      } else {
        appendChildElement(false, accumulation.getSeriesElement(), seriesGroup, redraw);
      }
    };
    AccumulationSeries2.prototype.renderDataLabel = function(accumulation, datalabelGroup, redraw) {
      accumulation.accumulationDataLabelModule.findAreaRect();
      var element = createElement("div", {
        id: accumulation.element.id + "_Series_0_DataLabelCollections"
      });
      this.leftSidePoints = [];
      this.rightSidePoints = [];
      var firstQuarter = [];
      var secondQuarter = [];
      for (var _i = 0, _a = this.points; _i < _a.length; _i++) {
        var point = _a[_i];
        if (point.visible) {
          if (this.dataLabel.showZero || !this.dataLabel.showZero && (point.y !== 0 || point.y === 0 && this.emptyPointSettings.mode === "Zero")) {
            accumulation.accumulationDataLabelModule.renderDataLabel(point, this.dataLabel, datalabelGroup, this.points, this.index, element, redraw);
          }
        }
        if (point.midAngle >= 90 && point.midAngle <= 270) {
          this.leftSidePoints.push(point);
        } else {
          if (point.midAngle >= 0 && point.midAngle <= 90) {
            secondQuarter.push(point);
          } else {
            firstQuarter.push(point);
          }
        }
      }
      firstQuarter.sort(function(a, b) {
        return a.midAngle - b.midAngle;
      });
      secondQuarter.sort(function(a, b) {
        return a.midAngle - b.midAngle;
      });
      this.leftSidePoints.sort(function(a, b) {
        return a.midAngle - b.midAngle;
      });
      this.rightSidePoints = firstQuarter.concat(secondQuarter);
      accumulation.accumulationDataLabelModule.drawDataLabels(this, this.dataLabel, datalabelGroup, element, redraw);
      if (this.dataLabel.template !== null && element.childElementCount) {
        var dataLabelCallBack = accumulation.accumulationDataLabelModule.drawDataLabels.bind(accumulation.accumulationDataLabelModule, this, this.dataLabel, datalabelGroup, element, redraw);
        if (accumulation.isReact) {
          accumulation.renderReactTemplates(dataLabelCallBack);
        }
        appendChildElement(false, getElement2(accumulation.element.id + "_Secondary_Element"), element, redraw);
      }
      appendChildElement(false, accumulation.getSeriesElement(), datalabelGroup, redraw);
    };
    AccumulationSeries2.prototype.findMaxBounds = function(totalbound, bound) {
      totalbound.x = bound.x < totalbound.x ? bound.x : totalbound.x;
      totalbound.y = bound.y < totalbound.y ? bound.y : totalbound.y;
      totalbound.height = bound.y + bound.height > totalbound.height ? bound.y + bound.height : totalbound.height;
      totalbound.width = bound.x + bound.width > totalbound.width ? bound.x + bound.width : totalbound.width;
    };
    AccumulationSeries2.prototype.findMaxLabelWidth = function() {
      var max;
      for (var i = 0; i < this.points.length; i++) {
        max = this.points[0].textSize.width;
        if (max < this.points[i].textSize.width) {
          max = this.points[i].textSize.width;
        }
      }
      return max;
    };
    AccumulationSeries2.prototype.setAccEmptyPoint = function(point, i, data) {
      if (!(isNullOrUndefined(point.y) || isNaN(point.y))) {
        return null;
      }
      point.color = this.emptyPointSettings.fill || point.color;
      switch (this.emptyPointSettings.mode) {
        case "Zero":
          point.y = 0;
          point.visible = true;
          break;
        case "Average": {
          var previous = data[i - 1] ? data[i - 1][this.yName] || 0 : 0;
          var next = data[i + 1] ? data[i + 1][this.yName] || 0 : 0;
          point.y = (Math.abs(previous) + Math.abs(next)) / 2;
          this.sumOfPoints += point.y;
          point.visible = true;
          break;
        }
        default:
          point.visible = false;
          break;
      }
    };
    AccumulationSeries2.prototype.setData = function(data, duration) {
      if (!data) {
        return null;
      }
      var samePoints = false;
      if (this.dataSource.length === data.length) {
        samePoints = true;
        for (var i = 0; i < data.length; i++) {
          if (this.dataSource[i][this.xName] === data[i][this.xName]) {
            var point = this.points[i];
            var existingPoint = this.dataSource[i];
            if (existingPoint[this.yName] !== data[i][this.yName]) {
              point.y = data[i][this.yName];
              this.dataSource[i] = data[i];
            }
          } else {
            samePoints = false;
            break;
          }
        }
      }
      if (!samePoints) {
        this.dataSource = data;
      } else {
        this.sumOfPoints = 0;
        var visiblePoints = [];
        for (var i = 0; i < this.resultData.length; i++) {
          if (this.points[i] && this.points[i].visible) {
            visiblePoints.push(this.resultData[i]);
          }
        }
        this.findSumOfPoints(visiblePoints);
        this.accumulation.redraw = this.borderRadius ? false : this.accumulation.enableAnimation;
        this.accumulation.animateSeries = false;
        var chartDuration = this.accumulation.duration;
        this.accumulation.duration = isNullOrUndefined(duration) ? 500 : duration;
        this.accumulation[firstToLowerCase(this.type) + "SeriesModule"].initProperties(this.accumulation, this);
        this.renderPoints(this.accumulation, getElement2(this.accumulation.element.id + "_Series_" + this.index), this.accumulation.redraw, null, null, true);
        if (this.accumulation.centerLabel.text) {
          this.accumulation.renderCenterLabel(true, true);
        }
        if (this.accumulation.annotationModule) {
          this.accumulation.annotationModule.renderAnnotations(getElement2(this.accumulation.element.id + "_Secondary_Element"));
        }
        if (this.accumulation.accumulationDataLabelModule && this.dataLabel.visible) {
          this.renderDataLabel(this.accumulation, getElement2(this.accumulation.element.id + "_datalabel_Series_" + this.index), this.accumulation.redraw);
        }
        this.accumulation.redraw = false;
        this.accumulation.duration = chartDuration;
      }
    };
    AccumulationSeries2.prototype.addPoint = function(dataPoint, duration) {
      var maxWidth;
      if (this.accumulation.series[0].dataLabel.visible) {
        maxWidth = this.findMaxLabelWidth();
      }
      this.dataSource.push(dataPoint);
      this.resultData = this.dataSource;
      this.sumOfPoints = 0;
      var visiblepoints = [];
      for (var i = 0; i < this.resultData.length; i++) {
        if (this.points[i] && this.points[i].visible) {
          visiblepoints.push(this.resultData[i]);
        } else if (i === this.resultData.length - 1) {
          visiblepoints.push(this.resultData[i]);
        }
      }
      this.findSumOfPoints(visiblepoints);
      var pointIndex = this.points.length === 0 ? 0 : this.points[this.points.length - 1].index + 1;
      var colors = this.palettes.length ? this.palettes : getSeriesColor(this.accumulation.theme);
      var point = this.setPoints(this.dataSource, pointIndex, colors, this.accumulation);
      this.pushPoints(point, colors);
      this.accumulation.redraw = this.borderRadius ? false : this.accumulation.enableAnimation;
      var chartDuration = this.accumulation.duration;
      this.accumulation.duration = isNullOrUndefined(duration) ? 500 : duration;
      this.updateSeries(getElement2(this.accumulation.element.id + "_Series_" + this.index), maxWidth, "addPoint");
      this.accumulation.redraw = false;
      this.accumulation.duration = chartDuration;
    };
    AccumulationSeries2.prototype.removePoint = function(index, duration) {
      var dataSource = extend([], this.dataSource, null, true);
      var chartDuration = this.accumulation.duration;
      if (dataSource.length > 0 && index >= 0 && index < dataSource.length) {
        this.sumOfPoints = 0;
        var removepoints = [];
        for (var i = 0; i < this.dataSource.length; i++) {
          if (i !== index && this.points[i] && this.points[i].visible) {
            removepoints.push(this.dataSource[i]);
          }
        }
        dataSource.splice(index, 1);
        this.dataSource.splice(index, 1);
        this.findSumOfPoints(removepoints);
        this.accumulation.redraw = this.borderRadius ? false : this.accumulation.enableAnimation;
        this.accumulation.duration = isNullOrUndefined(duration) ? 500 : duration;
        this.points.splice(index, 1);
        for (var i = index; i < this.points.length; i++) {
          var point = this.points[i];
          point.index = i;
          point.y = this.points[i].y;
        }
        var element = getElement2(this.accumulation.element.id + "_Series_0_Point_" + this.points.length);
        if (element) {
          element.parentNode.removeChild(element);
        }
        this.updateSeries(getElement2(this.accumulation.element.id + "_Series_" + this.index), void 0, "removePoint", index);
        this.accumulation.redraw = false;
        this.accumulation.duration = chartDuration;
      }
    };
    AccumulationSeries2.prototype.updateSeries = function(seriesGroup, maxLabelWidth, updatePoint, index) {
      var previousRadius = this.accumulation[firstToLowerCase(this.type) + "SeriesModule"].radius;
      var previousCenter = this.accumulation[firstToLowerCase(this.type) + "SeriesModule"].center;
      var previousLegendBounds;
      if (this.accumulation.legendSettings.visible) {
        if (updatePoint === "addPoint") {
          this.accumulation.accumulationLegendModule.legendCollections.push(new LegendOptions(this.points[this.points.length - 1].x.toString(), this.points[this.points.length - 1].color, this.legendShape, this.points[this.points.length - 1].visible, this.type, this.points[this.points.length - 1].legendImageUrl, null, null, this.points[this.points.length - 1].index, this.index));
        } else {
          this.accumulation.accumulationLegendModule.legendCollections.splice(index, 1);
          for (var i = index; i < this.accumulation.accumulationLegendModule.legendCollections.length; i++) {
            this.accumulation.accumulationLegendModule.legendCollections[i].pointIndex = i;
          }
        }
        if (this.accumulation.accumulationLegendModule.legendCollections.length >= 1) {
          previousLegendBounds = this.accumulation.accumulationLegendModule.legendBounds;
          this.accumulation.accumulationLegendModule.calculateLegendBounds(this.accumulation.initialClipRect, this.accumulation.availableSize, null, previousLegendBounds, true);
          if (this.dataLabel && this.dataLabel.position === "Outside" && (this.accumulation.legendSettings.position === "Bottom" || this.accumulation.legendSettings.position === "Top") ? previousLegendBounds.height !== this.accumulation.accumulationLegendModule.legendBounds.height : previousLegendBounds.width !== this.accumulation.accumulationLegendModule.legendBounds.width) {
            var titleHeight = this.accumulation.title ? measureText(this.accumulation.title, this.accumulation.titleStyle, this.accumulation.themeStyle.chartTitleFont).height * this.accumulation.titleCollection.length : 0;
            var subTitleHeight = this.accumulation.subTitle ? measureText(this.accumulation.subTitle, this.accumulation.subTitleStyle, this.accumulation.themeStyle.chartSubTitleFont).height * this.accumulation.subTitleCollection.length : 0;
            this.accumulation.initialClipRect = new Rect(this.accumulation.margin.left, this.accumulation.margin.top, this.accumulation.availableSize.width, this.accumulation.availableSize.height);
            subtractRect(this.accumulation.initialClipRect, new Rect(0, subTitleHeight + titleHeight, this.accumulation.margin.right + this.accumulation.margin.left, this.accumulation.margin.bottom + this.accumulation.margin.top));
            this.accumulation.accumulationLegendModule.calculateLegendBounds(this.accumulation.initialClipRect, this.accumulation.availableSize, null);
          }
        }
      }
      this.accumulation[firstToLowerCase(this.type) + "SeriesModule"].initProperties(this.accumulation, this);
      this.renderPoints(this.accumulation, seriesGroup, this.accumulation.redraw, previousRadius, previousCenter, true);
      if (previousLegendBounds && (this.accumulation.legendSettings.position === "Bottom" || this.accumulation.legendSettings.position === "Top" ? previousLegendBounds.height !== this.accumulation.accumulationLegendModule.legendBounds.height : previousLegendBounds.width !== this.accumulation.accumulationLegendModule.legendBounds.width) && this.accumulation.centerLabel.text) {
        this.accumulation.renderCenterLabel(true, true);
      }
      if (this.accumulation.annotationModule) {
        this.accumulation.annotationModule.renderAnnotations(getElement2(this.accumulation.element.id + "_Secondary_Element"));
      }
      if (this.accumulation.accumulationDataLabelModule && this.dataLabel.visible) {
        var datalabelGroup = this.accumulation.renderer.createGroup({
          id: this.accumulation.element.id + "_datalabel_Series_" + this.index
        });
        this.renderDataLabel(this.accumulation, datalabelGroup, this.accumulation.redraw);
      }
      if (this.accumulation.legendSettings.visible) {
        if (this.type === "Pie") {
          if (this.dataLabel.visible && this.points[this.points.length - 1] && this.points[this.points.length - 1].textSize.width > maxLabelWidth && this.accumulation.legendSettings.position !== "Top" && this.accumulation.legendSettings.position !== "Bottom") {
            this.accumulation.visibleSeries[0].findMaxBounds(this.accumulation.visibleSeries[0].labelBound, this.points[this.points.length - 1].labelRegion);
            this.findMaxBounds(this.labelBound, this.accumulationBound);
            this.labelBound.x -= this.accumulation.explodeDistance;
            this.labelBound.y -= this.accumulation.explodeDistance;
            this.labelBound.height += this.accumulation.explodeDistance - this.labelBound.y;
            this.labelBound.width += this.accumulation.explodeDistance - this.labelBound.x;
          }
          this.accumulation.accumulationLegendModule.getSmartLegendLocation(this.accumulation.visibleSeries[0].labelBound, this.accumulation.accumulationLegendModule.legendBounds, this.accumulation.margin);
        }
        this.accumulation.accumulationLegendModule.renderLegend(this.accumulation, this.accumulation.legendSettings, this.accumulation.accumulationLegendModule.legendBounds, this.accumulation.redraw, true);
      }
    };
    AccumulationSeries2.prototype.isEmpty = function(point) {
      return point.color === this.emptyPointSettings.fill;
    };
    __decorate8([Property("")], AccumulationSeries2.prototype, "dataSource", void 0);
    __decorate8([Property()], AccumulationSeries2.prototype, "query", void 0);
    __decorate8([Property("")], AccumulationSeries2.prototype, "xName", void 0);
    __decorate8([Property("")], AccumulationSeries2.prototype, "name", void 0);
    __decorate8([Property("")], AccumulationSeries2.prototype, "tooltipMappingName", void 0);
    __decorate8([Property("")], AccumulationSeries2.prototype, "yName", void 0);
    __decorate8([Property(true)], AccumulationSeries2.prototype, "visible", void 0);
    __decorate8([Complex({
      color: null,
      width: 0
    }, Border)], AccumulationSeries2.prototype, "border", void 0);
    __decorate8([Complex(null, Animation2)], AccumulationSeries2.prototype, "animation", void 0);
    __decorate8([Property("SeriesType")], AccumulationSeries2.prototype, "legendShape", void 0);
    __decorate8([Property("")], AccumulationSeries2.prototype, "legendImageUrl", void 0);
    __decorate8([Property("")], AccumulationSeries2.prototype, "pointColorMapping", void 0);
    __decorate8([Property(false)], AccumulationSeries2.prototype, "applyPattern", void 0);
    __decorate8([Property(null)], AccumulationSeries2.prototype, "selectionStyle", void 0);
    __decorate8([Property(null)], AccumulationSeries2.prototype, "groupTo", void 0);
    __decorate8([Property("Value")], AccumulationSeries2.prototype, "groupMode", void 0);
    __decorate8([Complex({}, AccumulationDataLabelSettings)], AccumulationSeries2.prototype, "dataLabel", void 0);
    __decorate8([Property([])], AccumulationSeries2.prototype, "palettes", void 0);
    __decorate8([Property(0)], AccumulationSeries2.prototype, "startAngle", void 0);
    __decorate8([Property(null)], AccumulationSeries2.prototype, "endAngle", void 0);
    __decorate8([Property(null)], AccumulationSeries2.prototype, "radius", void 0);
    __decorate8([Property("0")], AccumulationSeries2.prototype, "innerRadius", void 0);
    __decorate8([Property("Pie")], AccumulationSeries2.prototype, "type", void 0);
    __decorate8([Property(true)], AccumulationSeries2.prototype, "enableTooltip", void 0);
    __decorate8([Property(false)], AccumulationSeries2.prototype, "explode", void 0);
    __decorate8([Property("30%")], AccumulationSeries2.prototype, "explodeOffset", void 0);
    __decorate8([Property(false)], AccumulationSeries2.prototype, "explodeAll", void 0);
    __decorate8([Property(null)], AccumulationSeries2.prototype, "explodeIndex", void 0);
    __decorate8([Complex({
      mode: "Drop"
    }, EmptyPointSettings)], AccumulationSeries2.prototype, "emptyPointSettings", void 0);
    __decorate8([Property(0)], AccumulationSeries2.prototype, "gapRatio", void 0);
    __decorate8([Property("80%")], AccumulationSeries2.prototype, "width", void 0);
    __decorate8([Property("80%")], AccumulationSeries2.prototype, "height", void 0);
    __decorate8([Property("20%")], AccumulationSeries2.prototype, "neckWidth", void 0);
    __decorate8([Property("20%")], AccumulationSeries2.prototype, "neckHeight", void 0);
    __decorate8([Property("Linear")], AccumulationSeries2.prototype, "pyramidMode", void 0);
    __decorate8([Property("Standard")], AccumulationSeries2.prototype, "funnelMode", void 0);
    __decorate8([Property(1)], AccumulationSeries2.prototype, "opacity", void 0);
    __decorate8([Property("0")], AccumulationSeries2.prototype, "dashArray", void 0);
    __decorate8([Complex({}, Accessibility)], AccumulationSeries2.prototype, "accessibility", void 0);
    __decorate8([Property(0)], AccumulationSeries2.prototype, "borderRadius", void 0);
    return AccumulationSeries2;
  }(ChildProperty)
);
function getSeriesFromIndex(index, visibleSeries) {
  for (var _i = 0, visibleSeries_1 = visibleSeries; _i < visibleSeries_1.length; _i++) {
    var series = visibleSeries_1[_i];
    if (index === series.index) {
      return series;
    }
  }
  return visibleSeries[0];
}
function pointByIndex(index, points) {
  for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
    var point = points_1[_i];
    if (point.index === index) {
      return point;
    }
  }
  return null;
}

// node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/accumulation-base.js
var AccumulationBase = (
  /** @class */
  function() {
    function AccumulationBase2(accumulation) {
      this.accumulation = accumulation;
    }
    Object.defineProperty(AccumulationBase2.prototype, "center", {
      /**
       * Gets the center of the pie.
       *
       * @private
       * @returns {ChartLocation} - The center of the pie.
       */
      get: function() {
        return this.pieCenter || (this.accumulation.visibleSeries[0].type === "Pie" ? this.accumulation.pieSeriesModule.pieBaseCenter : null);
      },
      /**
       * Sets the center of the pie.
       *
       * @private
       * @param {ChartLocation} value - The center point to set.
       */
      set: function(value) {
        this.pieCenter = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AccumulationBase2.prototype, "radius", {
      /**
       * Gets the radius of the pie.
       *
       * @private
       * @returns {number} - The radius of the pie.
       */
      get: function() {
        return this.pieRadius !== void 0 ? this.pieRadius : this.accumulation.pieSeriesModule.pieBaseRadius;
      },
      /**
       * Sets the radius of the pie.
       *
       * @private
       * @param {number} value - The radius value to set.
       */
      set: function(value) {
        this.pieRadius = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AccumulationBase2.prototype, "labelRadius", {
      /**
       * Gets the label radius of the pie.
       *
       * @private
       * @returns {number} - The label radius of the pie.
       */
      get: function() {
        return this.pieLabelRadius !== void 0 ? this.pieLabelRadius : this.accumulation.pieSeriesModule.pieBaseLabelRadius;
      },
      /**
       * Sets the label radius of the pie.
       *
       * @private
       * @param {number} value - The label radius value to set.
       */
      set: function(value) {
        this.pieLabelRadius = value;
      },
      enumerable: true,
      configurable: true
    });
    AccumulationBase2.prototype.isCircular = function() {
      return this.accumulation.type === "Pie";
    };
    AccumulationBase2.prototype.isVariousRadius = function() {
      return this.accumulation.pieSeriesModule.isRadiusMapped;
    };
    AccumulationBase2.prototype.processExplode = function(event2) {
      if (event2.target.id.indexOf("_Series_") > -1 || event2.target.id.indexOf("_datalabel_") > -1) {
        var pointIndex = indexFinder(event2.target.id).point;
        if (isNaN(pointIndex) || event2.target.id.indexOf("_datalabel_") > -1 && this.accumulation.visibleSeries[0].points[pointIndex].labelPosition === "Outside") {
          return null;
        }
        this.explodePoints(pointIndex, this.accumulation);
        this.deExplodeAll(pointIndex, this.accumulation.enableAnimation ? 300 : 0);
      }
    };
    AccumulationBase2.prototype.invokeExplode = function() {
      var series = this.accumulation.visibleSeries[0];
      var duration = this.accumulation.enableAnimation ? 300 : 0;
      for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
        var point = _a[_i];
        if (point.isExplode && point.y !== 0) {
          this.pointExplode(point.index, point, duration);
        }
      }
      if (this.accumulation.accumulationSelectionModule && this.accumulation.selectionMode !== "None" && this.accumulation.accumulationSelectionModule.selectedDataIndexes.length) {
        for (var _b = 0, _c = this.accumulation.accumulationSelectionModule.selectedDataIndexes; _b < _c.length; _b++) {
          var index = _c[_b];
          this.explodePoints(index.point, this.accumulation, true);
          this.deExplodeAll(index.point, duration);
        }
      }
    };
    AccumulationBase2.prototype.deExplodeAll = function(index, animationDuration) {
      var pointId = this.accumulation.element.id + "_Series_0_Point_";
      var points = this.accumulation.visibleSeries[0].points;
      for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
        var currentPoint = points_1[_i];
        if (index !== currentPoint.index && !currentPoint.isSliced || currentPoint.isClubbed) {
          currentPoint.isExplode = false;
          this.deExplodeSlice(currentPoint.index, pointId, animationDuration);
        }
      }
    };
    AccumulationBase2.prototype.explodePoints = function(index, chart, explode, pointAnimation) {
      if (explode === void 0) {
        explode = false;
      }
      var series = chart.visibleSeries[0];
      var points = series.points;
      var point = pointByIndex(index, points);
      var explodePoints = true;
      var duration = this.accumulation.enableAnimation ? 300 : 0;
      if (isNullOrUndefined(point)) {
        return null;
      }
      var clubPointsExploded = !explode && (point.isSliced || series.clubbedPoints.length && points[points.length - 1].index === series.clubbedPoints[series.clubbedPoints.length - 1].index);
      if (series.type === "Pie" && (clubPointsExploded || point.isClubbed)) {
        explodePoints = this.clubPointExplode(index, point, series, points, chart, duration, clubPointsExploded);
      }
      if (explodePoints && point.y !== 0) {
        this.pointExplode(index, point, duration, explode, pointAnimation);
      }
    };
    AccumulationBase2.prototype.getSum = function(points) {
      var total = 0;
      points.map(function(point) {
        total += point.visible ? point.y : 0;
      });
      return total;
    };
    AccumulationBase2.prototype.clubPointExplode = function(index, point, series, points, chart, duration, clubPointsExploded) {
      if (clubPointsExploded === void 0) {
        clubPointsExploded = false;
      }
      if (point.isClubbed) {
        chart.animateSeries = false;
        points.splice(points.length - 1, 1);
        series.clubbedPoints.map(function(point2) {
          point2.visible = true;
          point2.isExplode = true;
        });
        chart.visibleSeries[0].points = points.concat(series.clubbedPoints);
        this.deExplodeAll(index, duration);
        series.sumOfPoints = this.getSum(chart.visibleSeries[0].points);
        chart.refreshChart();
        return false;
      } else if (clubPointsExploded || point.isSliced) {
        chart.animateSeries = false;
        points.splice(points.length - series.clubbedPoints.length, series.clubbedPoints.length);
        var clubPoint = series.generateClubPoint();
        clubPoint.index = points.length;
        clubPoint.color = series.clubbedPoints[0].color;
        points.push(clubPoint);
        series.sumOfPoints = this.getSum(points);
        this.deExplodeAll(index, duration);
        clubPoint.isExplode = false;
        chart.visibleSeries[0].points = points;
        chart.refreshChart();
        this.pointExplode(clubPoint.index, points[clubPoint.index], 0, true);
        clubPoint.isExplode = false;
        this.deExplodeSlice(clubPoint.index, chart.element.id + "_Series_0_Point_", duration);
        if (point.isSliced) {
          return false;
        }
      }
      return true;
    };
    AccumulationBase2.prototype.pointExplode = function(index, point, duration, explode, pointAnimation) {
      var translate;
      var pointId = this.accumulation.element.id + "_Series_0_Point_";
      var chart = this.accumulation;
      if (!this.isCircular()) {
        translate = {
          x: point.labelRegion && point.labelRegion.x < point.region.x ? -chart.explodeDistance : chart.explodeDistance,
          y: 0
        };
      } else {
        translate = degreeToLocation(point.midAngle, chart.explodeDistance, this.center);
      }
      if (this.isExplode(pointId + index) || explode) {
        point.isExplode = true;
        this.explodeSlice(index, translate, pointId, this.center || {
          x: 0,
          y: 0
        }, duration, pointAnimation);
      } else {
        point.isExplode = false;
        this.deExplodeSlice(index, pointId, duration);
      }
    };
    AccumulationBase2.prototype.isExplode = function(id) {
      var element = getElement2(id);
      var transform = element ? element.getAttribute("transform") : null;
      return element && (transform === "translate(0, 0)" || transform === null || transform === "translate(0)");
    };
    AccumulationBase2.prototype.deExplodeSlice = function(index, sliceId, animationDuration) {
      var element = getElement2(sliceId + index);
      var transform = element ? element.getAttribute("transform") : null;
      if (this.accumulation.enableAnimation && element && transform && transform !== "translate(0, 0)" && transform !== "translate(0)") {
        var result = transform.split("(")[1].split(")")[0].split(",");
        this.performAnimation(index, sliceId, 0, 0, +result[0], +result[1] || 0, animationDuration, true);
      } else {
        this.performAnimation(index, sliceId, 0, 0, 0, 0, animationDuration, true);
      }
    };
    AccumulationBase2.prototype.setTranslate = function(index, sliceId, position, transform) {
      this.setElementTransform(sliceId + index, position);
      this.setElementTransform(sliceId + index + "_polygon", position);
      if (this.accumulation.visibleSeries[0].dataLabel.visible) {
        sliceId = this.accumulation.element.id + "_datalabel_Series_0_";
        this.setElementTransform(sliceId + "shape_" + index, position);
        this.setElementTransform(sliceId + "text_" + index, position + transform);
        this.setElementTransform(sliceId + "connector_" + index, position);
      }
    };
    AccumulationBase2.prototype.setElementTransform = function(id, position) {
      var element = getElement2(id);
      if (element) {
        element.setAttribute("transform", position);
      }
    };
    AccumulationBase2.prototype.explodeSlice = function(index, translate, sliceId, center, animationDuration, pointAnimation) {
      if (pointAnimation && getElement2(this.accumulation.element.id + "_Series_0_Point_" + index).getAttribute("transform")) {
        this.setElementTransform(sliceId + index, "translate(" + (translate.x - center.x) + ", " + (translate.y - center.y) + ")");
      } else {
        this.performAnimation(index, sliceId, 0, 0, translate.x - center.x, translate.y - center.y, animationDuration);
      }
    };
    AccumulationBase2.prototype.performAnimation = function(index, sliceId, startX, startY, endX, endY, duration, isReverse) {
      var _this = this;
      var chart = this.accumulation;
      var values = sliceId.split("_");
      var seriesIndex = parseInt(sliceId.split("_")[values.length - 3], 10);
      var point = chart.visibleSeries[seriesIndex].points[index];
      if (duration <= 0) {
        this.setTranslate(index, sliceId, "translate(" + endX + ", " + endY + ")", point.transform);
        return null;
      }
      var xValue;
      var yValue;
      var delay = this.accumulation.series[seriesIndex].type === "Pie" && this.accumulation.animateSeries && this.accumulation.series[0].animation.enable ? this.accumulation.series[0].animation.duration : 0;
      new Animation({}).animate(createElement("div"), {
        duration,
        delay,
        progress: function(args) {
          xValue = linear(args.timeStamp, startX, endX, args.duration);
          yValue = linear(args.timeStamp, startY, endY, args.duration);
          _this.setTranslate(index, sliceId, "translate(" + (isReverse ? endX - xValue : xValue) + ", " + (isReverse ? endY - yValue : yValue) + ")", point.transform);
        },
        end: function() {
          _this.setTranslate(index, sliceId, "translate(" + (isReverse ? startX : endX) + ", " + (isReverse ? startX : endY) + ")", point.transform);
        }
      });
    };
    return AccumulationBase2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/pie-base.js
var __extends65 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PieBase = (
  /** @class */
  function(_super) {
    __extends65(PieBase2, _super);
    function PieBase2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PieBase2.prototype.initProperties = function(chart, series) {
      this.accumulation = chart;
      this.size = Math.min(chart.initialClipRect.width, chart.initialClipRect.height);
      this.initAngles(series);
      var pieCoefficient = 0.8;
      var r = parseInt(series.radius, 10);
      if ((series.radius.indexOf("%") !== -1 || typeof r === "number") && !isNaN(r)) {
        this.isRadiusMapped = false;
        this.pieBaseRadius = stringToNumber(series.radius, series.border.width > 20 ? 0.5 * pieCoefficient * this.size : this.size / 2);
        this.innerRadius = stringToNumber(series.innerRadius, this.pieBaseRadius);
        this.pieBaseLabelRadius = series.dataLabel.position === "Inside" ? (this.pieBaseRadius - this.innerRadius) / 2 + this.innerRadius : this.pieBaseRadius + stringToNumber(series.dataLabel.connectorStyle.length || "4%", this.size / 2);
      } else {
        var radiusCollection = [];
        this.isRadiusMapped = true;
        for (var i = 0; i < Object.keys(series.points).length; i++) {
          if (series.points[i].sliceRadius.indexOf("%") !== -1) {
            radiusCollection[i] = stringToNumber(series.points[i].sliceRadius, this.size / 2);
          } else {
            radiusCollection[i] = parseInt(series.points[i].sliceRadius, 10);
          }
        }
        var minRadius = Math.min.apply(null, radiusCollection);
        var maxRadius = Math.max.apply(null, radiusCollection);
        this.pieBaseRadius = this.seriesRadius = maxRadius;
        this.innerRadius = stringToNumber(series.innerRadius, this.seriesRadius);
        this.innerRadius = this.innerRadius > minRadius ? this.innerRadius / 2 : this.innerRadius;
      }
      this.radius = this.pieBaseRadius;
      this.labelRadius = this.pieBaseLabelRadius;
      chart.explodeDistance = series.explode ? stringToNumber(series.explodeOffset, this.pieBaseRadius) : 0;
      this.findCenter(chart, series);
      this.center = this.pieBaseCenter;
      if (!chart.redraw) {
        this.defaultLabelBound(series, series.dataLabel.visible, series.dataLabel.position);
      }
      this.totalAngle -= 1e-3;
    };
    PieBase2.prototype.getLabelRadius = function(series, point) {
      return series.dataLabel.position === "Inside" ? (stringToNumber(point.sliceRadius, this.pieBaseRadius) - this.innerRadius) / 2 + this.innerRadius : stringToNumber(point.sliceRadius, this.size / 2) + stringToNumber(series.dataLabel.connectorStyle.length || "4%", this.size / 2);
    };
    PieBase2.prototype.findCenter = function(accumulation, series) {
      this.accumulation = accumulation;
      this.pieBaseCenter = {
        x: stringToNumber(accumulation.center.x, accumulation.initialClipRect.width) + accumulation.initialClipRect.x,
        y: stringToNumber(accumulation.center.y, accumulation.initialClipRect.height) + accumulation.initialClipRect.y
      };
      var accumulationRect = this.getSeriesBound(series);
      var accumulationRectCenter = new ChartLocation(accumulationRect.x + accumulationRect.width / 2, accumulationRect.y + accumulationRect.height / 2);
      this.pieBaseCenter.x += this.pieBaseCenter.x - accumulationRectCenter.x;
      this.pieBaseCenter.y += this.pieBaseCenter.y - accumulationRectCenter.y;
      this.accumulation.origin = this.pieBaseCenter;
    };
    PieBase2.prototype.initAngles = function(series) {
      var endAngle = isNullOrUndefined(series.endAngle) ? series.startAngle : series.endAngle;
      this.totalAngle = (endAngle - series.startAngle) % 360;
      this.startAngle = series.startAngle - 90;
      this.totalAngle = this.totalAngle <= 0 ? 360 + this.totalAngle : this.totalAngle;
      this.startAngle = (this.startAngle < 0 ? this.startAngle + 360 : this.startAngle) % 360;
    };
    PieBase2.prototype.defaultLabelBound = function(series, visible, position) {
      var accumulationBound = this.getSeriesBound(series);
      series.accumulationBound = accumulationBound;
      series.labelBound = new Rect(accumulationBound.x, accumulationBound.y, accumulationBound.width + accumulationBound.x, accumulationBound.height + accumulationBound.y);
      if (visible && position === "Outside") {
        series.labelBound = new Rect(Infinity, Infinity, -Infinity, -Infinity);
      }
    };
    PieBase2.prototype.getSeriesBound = function(series) {
      var rect = new Rect(Infinity, Infinity, -Infinity, -Infinity);
      this.initAngles(series);
      var start = this.startAngle;
      var total = this.totalAngle;
      var end = (this.startAngle + total) % 360;
      end = end === 0 ? 360 : end;
      series.findMaxBounds(rect, this.getRectFromAngle(start));
      series.findMaxBounds(rect, this.getRectFromAngle(end));
      series.findMaxBounds(rect, new Rect(this.pieBaseCenter.x, this.pieBaseCenter.y, 0, 0));
      var nextQuandrant = (Math.floor(start / 90) * 90 + 90) % 360;
      var lastQuadrant = Math.floor(end / 90) * 90 % 360;
      lastQuadrant = lastQuadrant === 0 ? 360 : lastQuadrant;
      if (total >= 90 || lastQuadrant === nextQuandrant) {
        series.findMaxBounds(rect, this.getRectFromAngle(nextQuandrant));
        series.findMaxBounds(rect, this.getRectFromAngle(lastQuadrant));
      }
      if (start === 0 || start + total >= 360) {
        series.findMaxBounds(rect, this.getRectFromAngle(0));
      }
      var length = nextQuandrant === lastQuadrant ? 0 : Math.floor(total / 90);
      for (var i = 1; i < length; i++) {
        nextQuandrant = nextQuandrant + 90;
        if (nextQuandrant < lastQuadrant || end < start || total === 360) {
          series.findMaxBounds(rect, this.getRectFromAngle(nextQuandrant));
        }
      }
      rect.width -= rect.x;
      rect.height -= rect.y;
      return rect;
    };
    PieBase2.prototype.getRectFromAngle = function(angle) {
      var location = degreeToLocation(angle, this.pieBaseRadius, this.pieBaseCenter);
      return new Rect(location.x, location.y, 0, 0);
    };
    PieBase2.prototype.getPathArc = function(center, start, end, radius, innerRadius, borderRadius, isBorder, seriesPoints) {
      var degree = end - start;
      degree = degree < 0 ? degree + 360 : degree;
      var flag = degree < 180 ? 0 : 1;
      if (!innerRadius && innerRadius === 0) {
        return this.getPiePath(center, degreeToLocation(start, radius, center), degreeToLocation(end, radius, center), radius, flag, borderRadius, seriesPoints);
      } else {
        return this.getDoughnutPath(center, degreeToLocation(start, radius, center), degreeToLocation(end, radius, center), radius, degreeToLocation(start, innerRadius, center), degreeToLocation(end, innerRadius, center), innerRadius, flag, borderRadius, isBorder, seriesPoints);
      }
    };
    PieBase2.prototype.getPiePath = function(center, start, end, radius, clockWise, cornerRadius, seriesPoints) {
      var sliceCount = this.sliceCheck(seriesPoints);
      cornerRadius = sliceCount === 1 ? 0 : cornerRadius;
      var startAngle = Math.atan2(start.y - center.y, start.x - center.x);
      var endAngle = Math.atan2(end.y - center.y, end.x - center.x);
      cornerRadius = this.adjustCornerRadius(startAngle, endAngle, radius, cornerRadius);
      var x1 = start.x - cornerRadius * Math.cos(startAngle);
      var y1 = start.y - cornerRadius * Math.sin(startAngle);
      var x2 = end.x - cornerRadius * Math.cos(Math.PI / 2 + endAngle);
      var y2 = end.y - cornerRadius * Math.sin(Math.PI / 2 + endAngle);
      var cx2 = end.x - cornerRadius * Math.cos(endAngle);
      var cy2 = end.y - cornerRadius * Math.sin(endAngle);
      var cx1 = start.x + cornerRadius * Math.cos(Math.PI / 2 + startAngle);
      var cy1 = start.y + cornerRadius * Math.sin(Math.PI / 2 + startAngle);
      return "M " + center.x + " " + center.y + " L " + x1 + " " + y1 + " A " + cornerRadius + " " + cornerRadius + " 0 0 1 " + cx1 + " " + cy1 + " A " + radius + " " + radius + " 0 " + clockWise + " 1 " + x2 + " " + y2 + " A " + cornerRadius + " " + cornerRadius + " 0 0 1 " + cx2 + " " + cy2 + " Z";
    };
    PieBase2.prototype.getDoughnutPath = function(center, start, end, radius, innerStart, innerEnd, innerRadius, clockWise, cornerRadius, isBorder, seriesPoints) {
      var sliceCount = this.sliceCheck(seriesPoints);
      cornerRadius = sliceCount === 1 ? 0 : cornerRadius;
      var startAngle = Math.atan2(start.y - innerStart.y, start.x - innerStart.x);
      var endAngle = Math.atan2(end.y - innerEnd.y, end.x - innerEnd.x);
      cornerRadius = this.adjustCornerRadius(startAngle, endAngle, innerRadius, cornerRadius);
      cornerRadius = isBorder && this.innerRadius === 0 ? cornerRadius * -1 : cornerRadius;
      var x1 = start.x - cornerRadius * Math.cos(startAngle);
      var y1 = start.y - cornerRadius * Math.sin(startAngle);
      var x2 = end.x - cornerRadius * Math.cos(Math.PI / 2 + endAngle);
      var y2 = end.y - cornerRadius * Math.sin(Math.PI / 2 + endAngle);
      var x3 = innerEnd.x + cornerRadius * Math.cos(endAngle);
      var y3 = innerEnd.y + cornerRadius * Math.sin(endAngle);
      var x4 = innerStart.x + cornerRadius * Math.cos(Math.PI / 2 + startAngle);
      var y4 = innerStart.y + cornerRadius * Math.sin(Math.PI / 2 + startAngle);
      var cx1 = start.x + cornerRadius * Math.cos(Math.PI / 2 + startAngle);
      var cy1 = start.y + cornerRadius * Math.sin(Math.PI / 2 + startAngle);
      var cx2 = end.x - cornerRadius * Math.cos(endAngle);
      var cy2 = end.y - cornerRadius * Math.sin(endAngle);
      var cx3 = innerEnd.x - cornerRadius * Math.cos(Math.PI / 2 + endAngle);
      var cy3 = innerEnd.y - cornerRadius * Math.sin(Math.PI / 2 + endAngle);
      var cx4 = innerStart.x + cornerRadius * Math.cos(startAngle);
      var cy4 = innerStart.y + cornerRadius * Math.sin(startAngle);
      if (isBorder) {
        return "M " + cx1 + " " + cy1 + " A " + radius + " " + radius + " 0 " + clockWise + " 1 " + x2 + " " + y2 + " L " + cx3 + " " + cy3 + " A " + innerRadius + " " + innerRadius + " 0 " + clockWise + " 0 " + x4 + " " + y4 + " Z";
      } else {
        return "M " + x1 + " " + y1 + " A " + cornerRadius + " " + cornerRadius + " 0 0 1 " + cx1 + " " + cy1 + " A " + radius + " " + radius + " 0 " + clockWise + " 1 " + x2 + " " + y2 + " A " + cornerRadius + " " + cornerRadius + " 0 0 1 " + cx2 + " " + cy2 + " L " + x3 + " " + y3 + " A " + cornerRadius + " " + cornerRadius + " 0 0 1 " + cx3 + " " + cy3 + " A " + innerRadius + " " + innerRadius + " 0 " + clockWise + " 0 " + x4 + " " + y4 + " A " + cornerRadius + " " + cornerRadius + " 0 0 1 " + cx4 + " " + cy4 + " Z";
      }
    };
    PieBase2.prototype.adjustCornerRadius = function(startAngle, endAngle, radius, cornerRadius) {
      var anglePerSlice = Math.abs(endAngle - startAngle);
      if (anglePerSlice > Math.PI) {
        anglePerSlice = 2 * Math.PI - anglePerSlice;
      }
      var angleFactor = anglePerSlice / (2 * Math.PI);
      var adjustedCornerRadius = radius * angleFactor;
      return Math.min(cornerRadius, adjustedCornerRadius);
    };
    PieBase2.prototype.sliceCheck = function(seriesPoints) {
      var isOneSlice = 0;
      for (var index = 0; index < seriesPoints.length; index++) {
        var point = seriesPoints[index];
        if (point.visible) {
          isOneSlice++;
        }
      }
      return isOneSlice;
    };
    PieBase2.prototype.doAnimation = function(slice, series, groupElement, borderRadius, seriesPoints) {
      var _this = this;
      var startAngle = series.startAngle - 90;
      var duration = this.accumulation.duration ? this.accumulation.duration : series.animation.duration;
      var value;
      this.pieBaseCenter.x += 1;
      var radius = Math.max(this.accumulation.availableSize.height, this.accumulation.availableSize.width) * 0.75;
      radius += radius * 0.414;
      var effect = getAnimationFunction("Linear");
      new Animation({}).animate(slice, {
        duration: duration === 0 && animationMode === "Enable" ? 1e3 : duration,
        delay: series.animation.delay,
        progress: function(args) {
          value = effect(args.timeStamp, startAngle, _this.totalAngle, args.duration);
          slice.setAttribute("d", _this.getPathArc(_this.pieBaseCenter, startAngle, value, radius, 0, borderRadius, false, seriesPoints));
        },
        end: function() {
          _this.pieBaseCenter.x -= 1;
          slice.setAttribute("d", _this.getPathArc(_this.pieBaseCenter, 0, 359.99999, radius, 0, borderRadius, false, seriesPoints));
          _this.accumulation.trigger(animationComplete, _this.accumulation.isBlazor ? {} : {
            series,
            accumulation: _this.accumulation,
            chart: _this.accumulation
          });
          var datalabelGroup = getElement2(_this.accumulation.element.id + "_datalabel_Series_" + series.index);
          if (datalabelGroup) {
            markerAnimate(datalabelGroup, series.animation.delay, series.animation.duration, series, null, null, false);
          }
          groupElement.style.cssText = "";
          var annotationElement = getElement2(_this.accumulation.element.id + "_Annotation_Collections");
          if (annotationElement) {
            annotationElement.style.visibility = "visible";
          }
        }
      });
    };
    return PieBase2;
  }(AccumulationBase)
);

// node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/pie-series.js
var __extends66 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PieSeries = (
  /** @class */
  function(_super) {
    __extends66(PieSeries2, _super);
    function PieSeries2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PieSeries2.prototype.renderPoint = function(point, series, chart, option, seriesGroup, redraw, previousRadius, previousCenter, pointAnimation) {
      var sum2 = series.sumOfPoints;
      var seriesPoints = this.accumulation.visibleSeries[0].points;
      var borderRadius = series.borderRadius;
      point.startAngle = this.startAngle;
      var yValue = point.visible ? point.y : 0;
      var degree = sum2 ? Math.abs(yValue) / sum2 * this.totalAngle : null;
      var start = Math.PI / 180 * (90 - (360 - this.startAngle) - 90);
      this.radius = this.isRadiusMapped ? stringToNumber(point.sliceRadius, this.seriesRadius) : this.radius;
      option.d = this.getPathOption(point, degree, this.startAngle % 360, borderRadius, seriesPoints);
      point.midAngle = (this.startAngle - degree / 2) % 360;
      point.endAngle = this.startAngle % 360;
      point.symbolLocation = degreeToLocation(point.midAngle, (this.radius + this.innerRadius) / 2, this.center);
      if (!redraw) {
        var element = chart.renderer.drawPath(option);
        element.setAttribute("role", series.accessibility.accessibilityRole ? series.accessibility.accessibilityRole : "img");
        element.setAttribute("tabindex", point.index === 0 && series.accessibility.focusable ? String(series.accessibility.tabIndex) : "-1");
        element.style.outline = "none";
        element.setAttribute("stroke-linejoin", "round");
        element.setAttribute("aria-label", series.accessibility.accessibilityDescription ? series.accessibility.accessibilityDescription : point.x + ": " + point.y + "%. " + series.name);
        seriesGroup.appendChild(element);
        point.degree = degree;
        point.start = start;
      } else {
        var element = chart.renderer.drawPath(option);
        if (!point.isExplode && pointAnimation) {
          element.setAttribute("transform", "translate(0, 0)");
        }
        element.setAttribute("role", series.accessibility.accessibilityRole ? series.accessibility.accessibilityRole : "img");
        element.setAttribute("tabindex", point.index === 0 && series.accessibility.focusable ? String(series.accessibility.tabIndex) : "-1");
        element.style.outline = "none";
        element.setAttribute("stroke-linejoin", "round");
        element.setAttribute("aria-label", series.accessibility.accessibilityDescription ? series.accessibility.accessibilityDescription : point.x + ": " + point.y + "%. " + series.name);
        if (point.degree === void 0) {
          point.degree = degree;
          point.start = start;
        }
        seriesGroup.appendChild(element);
        this.refresh(point, degree, start, chart, option, borderRadius, seriesPoints, previousRadius, previousCenter, pointAnimation);
      }
    };
    PieSeries2.prototype.findSeries = function(e, borderRadius) {
      var borderGap = 3;
      var width = 2;
      var radius = this.innerRadius === 0 ? this.radius + borderGap : this.innerRadius - borderGap;
      var innerRadius = this.innerRadius === 0 ? radius + width : radius - width;
      this.toggleInnerPoint(e, radius, innerRadius, borderRadius);
    };
    PieSeries2.prototype.toggleInnerPoint = function(event2, radius, innerRadius, borderRadius) {
      var target = event2.target;
      var id = indexFinder(target.id, true);
      var accumulationId = event2.target.id.substring(0, event2.target.id.indexOf("Series") - 1);
      var borderElement = document.getElementById(this.accumulation.element.id + "PointHover_Border");
      var createBorderEle;
      var seriesPoints = this.accumulation.visibleSeries[0].points;
      var seriesIndex = id.series;
      var pointIndex = id.point;
      var srcElem = getElement2(accumulationId + "_Series_" + seriesIndex + "_Point_" + pointIndex);
      if (!isNaN(id.series) && srcElem) {
        if (!isNullOrUndefined(seriesIndex) && !isNaN(seriesIndex) && !isNullOrUndefined(pointIndex) && !isNaN(pointIndex)) {
          var point = this.accumulation.visibleSeries[0].points[pointIndex];
          var opacity = srcElem.getAttribute("class") === accumulationId + "_ej2_deselected" ? this.accumulation.tooltip.enable ? 0.5 : 0.3 : this.accumulation.tooltip.enable ? 0.5 : 1;
          var innerPie = this.getPathArc(this.accumulation.pieSeriesModule.center, point.startAngle % 360, (point.startAngle + point.degree) % 360, radius, innerRadius, borderRadius, true, seriesPoints);
          if (borderElement && accumulationId === this.accumulation.element.id && (borderElement.getAttribute("d") !== innerPie || point.isExplode)) {
            borderElement.parentNode.removeChild(borderElement);
            borderElement = null;
          }
          var seriousGroup = getElement2(accumulationId + "_Series_" + seriesIndex);
          if (!borderElement && (!point.isExplode || point.isExplode && event2.type !== "click")) {
            var path = new PathOption(accumulationId + "PointHover_Border", point.color, 1, point.color, opacity, "", innerPie);
            createBorderEle = this.accumulation.renderer.drawPath(path);
            createBorderEle.removeAttribute("transform");
            if (this.accumulation.selectionMode !== "None" && event2.target.hasAttribute("class")) {
              this.accumulation.accumulationSelectionModule.addSvgClass(createBorderEle, event2.target.getAttribute("class"));
            }
            seriousGroup.appendChild(createBorderEle);
            if (point.isExplode && createBorderEle) {
              var borderExplode = srcElem.getAttribute("transform");
              if (borderExplode) {
                createBorderEle.setAttribute("transform", borderExplode);
              }
            }
          }
        }
      } else if (borderElement) {
        this.removeBorder(borderElement, 1e3);
        borderElement = null;
      }
    };
    PieSeries2.prototype.removeBorder = function(borderElement, duration) {
      if (borderElement) {
        setTimeout(function() {
          if (borderElement.parentNode) {
            borderElement.parentNode.removeChild(borderElement);
          }
        }, duration);
      }
    };
    PieSeries2.prototype.refresh = function(point, degree, start, chart, option, borderRadius, seriesPoints, previousRadius, previouCenter, pointAnimation) {
      var _this = this;
      var seriesElement = getElement2(option.id);
      var duration = chart.duration ? chart.duration : 300;
      new Animation({}).animate(createElement("div"), {
        duration,
        delay: 0,
        progress: function(args) {
          var curentDegree = linear(args.timeStamp, point.degree, degree - point.degree, args.duration);
          var currentStartAngle = linear(args.timeStamp, point.start, start - point.start, args.duration);
          currentStartAngle = (currentStartAngle / (Math.PI / 180) + 360) % 360;
          if (previousRadius && previouCenter) {
            var currentRadius = linear(args.timeStamp, previousRadius, _this.radius - previousRadius, args.duration);
            var previouCenterx = linear(args.timeStamp, previouCenter.x, _this.center.x - previouCenter.x, args.duration);
            var previouCentery = linear(args.timeStamp, previouCenter.y, _this.center.y - previouCenter.y, args.duration);
            seriesElement.setAttribute("d", _this.getPathOption(point, curentDegree, currentStartAngle, borderRadius, seriesPoints, currentRadius, previouCenterx, previouCentery));
          } else {
            seriesElement.setAttribute("d", _this.getPathOption(point, curentDegree, currentStartAngle, borderRadius, seriesPoints));
          }
          if (point.isExplode) {
            chart.accBaseModule.explodePoints(point.index, chart, true, pointAnimation);
          }
          seriesElement.style.visibility = "visible";
        },
        end: function() {
          seriesElement.style.visibility = point.visible ? "visible" : "hidden";
          seriesElement.setAttribute("d", option.d);
          point.degree = degree;
          point.start = start;
        }
      });
    };
    PieSeries2.prototype.getPathOption = function(point, degree, startAngle, borderRadius, seriesPoints, previouRadius, previousCenterX, previousCenterY) {
      if (!degree) {
        return "";
      }
      var path = this.getPathArc(previousCenterX ? {
        x: previousCenterX,
        y: previousCenterY
      } : this.center, startAngle % 360, (startAngle + degree) % 360, this.isRadiusMapped ? stringToNumber(point.sliceRadius, this.size / 2) : previouRadius ? previouRadius : this.radius, this.innerRadius, borderRadius, false, seriesPoints);
      this.startAngle += degree;
      return path;
    };
    PieSeries2.prototype.animateSeries = function(accumulation, option, series, slice, borderRadius, seriesPoints) {
      var groupId = accumulation.element.id + "SeriesGroup" + series.index;
      if ((series.animation.enable && animationMode !== "Disable" || animationMode === "Enable") && accumulation.animateSeries) {
        var clippath = accumulation.renderer.createClipPath({
          id: groupId + "_clipPath"
        });
        var path = new PathOption(groupId + "_slice", "transparent", 1, "transparent", 1, "", "");
        var clipslice = accumulation.renderer.drawPath(path);
        clippath.appendChild(clipslice);
        accumulation.svgObject.appendChild(clippath);
        slice.style.cssText = "clip-path:url(#" + clippath.id + "); -webkit-clip-path:url(#" + clippath.id + ");";
        this.doAnimation(clipslice, series, slice, borderRadius, seriesPoints);
      }
    };
    PieSeries2.prototype.getModuleName = function() {
      return "PieSeries";
    };
    PieSeries2.prototype.destroy = function() {
    };
    return PieSeries2;
  }(PieBase)
);

// node_modules/@syncfusion/ej2-charts/src/accumulation-chart/accumulation.js
var __extends67 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate9 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AccumulationChart = (
  /** @class */
  function(_super) {
    __extends67(AccumulationChart2, _super);
    function AccumulationChart2(options, element) {
      var _this = _super.call(this, options, element) || this;
      _this.animateselected = false;
      _this.explodeDistance = 0;
      _this.currentLegendIndex = 0;
      _this.currentPointIndex = 0;
      _this.previousTargetId = "";
      _this.isLegendClicked = false;
      _this.chartid = 57724;
      return _this;
    }
    AccumulationChart2.prototype.animate = function(duration) {
      this.duration = duration === 0 && animationMode === "Enable" ? 700 : duration;
      this.animateselected = true;
      this.animateSeries = false;
      var temIndex = 0;
      var tempcolor = [];
      var tempindex = [];
      var tempindex1 = [];
      var currentSeries = this.visibleSeries[0];
      var datasource = [];
      datasource = currentSeries.dataSource;
      currentSeries.sumOfPoints = 0;
      if (currentSeries.points.length < Object.keys(currentSeries.dataSource).length) {
        this.refresh();
      } else if (currentSeries.points.length > Object.keys(currentSeries.dataSource).length) {
        var currentSeries_1 = this.visibleSeries[0];
        currentSeries_1.points = currentSeries_1.points.filter(function(entry1) {
          entry1.visible = false;
          tempindex.push(entry1.index);
          tempcolor.push(entry1.color);
          return datasource.some(function(entry2) {
            var accPoint = entry2;
            if (entry1.x === accPoint.x) {
              entry1.visible = true;
              tempindex1.push(entry1.index);
              entry1.index = temIndex;
              temIndex++;
            }
            return entry1.x === accPoint.x;
          });
        });
        var missing = tempindex.filter(function(item) {
          return tempindex1.indexOf(item) < 0;
        });
        var interval = tempindex.length - missing.length;
        for (var i = tempindex.length - 1; i >= interval; i--) {
          removeElement2("container_Series_0_Point_" + tempindex[i]);
        }
        for (var i = 0; i < currentSeries_1.points.length; i++) {
          currentSeries_1.points[i].y = currentSeries_1.dataSource[i].y;
          currentSeries_1.points[i].color = tempcolor[i];
          currentSeries_1.sumOfPoints += currentSeries_1.dataSource[i].y;
        }
        this.redraw = this.enableAnimation;
        this.animateSeries = false;
        this.calculateBounds();
        this.renderElements();
      } else {
        for (var i = 0; i < currentSeries.points.length; i++) {
          currentSeries.points[i].y = currentSeries.dataSource[i][currentSeries.yName];
          currentSeries.points[i].color = currentSeries.dataSource[i][currentSeries.pointColorMapping] != null ? currentSeries.dataSource[i][currentSeries.pointColorMapping] : currentSeries.points[i].color;
          currentSeries.sumOfPoints += currentSeries.dataSource[i][currentSeries.yName];
        }
        this.redraw = this.enableAnimation;
        this.animateSeries = false;
        this.removeSvg();
        this.refreshPoints(currentSeries.points);
        this.renderElements();
      }
    };
    Object.defineProperty(AccumulationChart2.prototype, "type", {
      /**
       * Gets the type of accumulation chart.
       *
       * @returns {AccumulationType} - The type of accumulation chart.
       * @private
       * */
      get: function() {
        if (this.series && this.series.length) {
          return this.series[0].type;
        }
        return "Pie";
      },
      enumerable: true,
      configurable: true
    });
    AccumulationChart2.prototype.preRender = function() {
      var blazor = "Blazor";
      this.isBlazor = window[blazor];
      this.allowServerDataBinding = false;
      this.unWireEvents();
      this.setCulture();
      this.animateSeries = true;
      if (this.element.id === "") {
        var collection = document.getElementsByClassName("e-accumulationchart").length;
        this.element.id = "acc_chart_" + this.chartid + "_" + collection;
      }
      this.wireEvents();
      this.element.setAttribute("dir", this.enableRtl ? "rtl" : "ltr");
      this.element.style.outline = "none";
    };
    AccumulationChart2.prototype.setTheme = function() {
      this.themeStyle = getThemeColor(this.theme, false, this);
    };
    AccumulationChart2.prototype.render = function() {
      var _this = this;
      if (this.element.className.indexOf("e-accumulationchart") === -1) {
        this.element.classList.add("e-accumulationchart");
      }
      this.element.setAttribute("role", this.accessibility.accessibilityRole ? this.accessibility.accessibilityRole : "region");
      this.element.setAttribute("tabindex", this.accessibility.focusable ? String(this.accessibility.tabIndex) : "-1");
      this.element.setAttribute("aria-label", this.accessibility.accessibilityDescription ? this.accessibility.accessibilityDescription : this.title + ". Syncfusion interactive chart.");
      this.element.setAttribute("class", this.element.getAttribute("class") + " e-accumulationchart-focused");
      var loadEventData = {
        chart: this.isBlazor ? {} : this,
        accumulation: this.isBlazor ? {} : this,
        theme: this.theme,
        name: load,
        cancel: false
      };
      this.trigger(load, loadEventData, function() {
        _this.theme = _this.isBlazor ? loadEventData.theme : _this.theme;
        _this.setTheme();
        _this.accBaseModule = new AccumulationBase(_this);
        _this.pieSeriesModule = new PieSeries(_this);
        _this.calculateVisibleSeries();
        _this.processData();
        _this.renderComplete();
        _this.allowServerDataBinding = true;
      });
    };
    AccumulationChart2.prototype.unWireEvents = function() {
      var isIE11Pointer = Browser.isPointer;
      var start = Browser.touchStartEvent;
      var move = Browser.touchMoveEvent;
      var stop = Browser.touchEndEvent;
      var cancel = isIE11Pointer ? "pointerleave" : "mouseleave";
      EventHandler.remove(this.element, move, this.accumulationMouseMove);
      EventHandler.remove(this.element, stop, this.accumulationMouseEnd);
      EventHandler.remove(this.element, start, this.accumulationMouseStart);
      EventHandler.remove(this.element, "click", this.accumulationOnMouseClick);
      EventHandler.remove(this.element, "dblclick", this.accumulationOnDoubleClick);
      EventHandler.remove(this.element, "contextmenu", this.accumulationRightClick);
      EventHandler.remove(this.element, cancel, this.accumulationMouseLeave);
      EventHandler.remove(this.element, "keydown", this.accumulationChartKeyDown);
      EventHandler.remove(document.body, "keydown", this.documentKeyHandler);
      EventHandler.remove(this.element, "keyup", this.accumulationChartKeyUp);
      window.removeEventListener(Browser.isTouch && "orientation" in window && "onorientationchange" in window ? "orientationchange" : "resize", this.accumulationResizeBound);
    };
    AccumulationChart2.prototype.wireEvents = function() {
      if (!this.element) {
        return;
      }
      var isIE11Pointer = Browser.isPointer;
      var start = Browser.touchStartEvent;
      var stop = Browser.touchEndEvent;
      var move = Browser.touchMoveEvent;
      var cancel = isIE11Pointer ? "pointerleave" : "mouseleave";
      EventHandler.add(this.element, move, this.accumulationMouseMove, this);
      EventHandler.add(this.element, stop, this.accumulationMouseEnd, this);
      EventHandler.add(this.element, start, this.accumulationMouseStart, this);
      EventHandler.add(this.element, "click", this.accumulationOnMouseClick, this);
      EventHandler.add(this.element, "dblclick", this.accumulationOnDoubleClick, this);
      EventHandler.add(this.element, "contextmenu", this.accumulationRightClick, this);
      EventHandler.add(this.element, cancel, this.accumulationMouseLeave, this);
      EventHandler.add(this.element, "keydown", this.accumulationChartKeyDown, this);
      EventHandler.add(document.body, "keydown", this.documentKeyHandler, this);
      EventHandler.add(this.element, "keyup", this.accumulationChartKeyUp, this);
      this.accumulationResizeBound = this.accumulationResize.bind(this);
      window.addEventListener(Browser.isTouch && "orientation" in window && "onorientationchange" in window ? "orientationchange" : "resize", this.accumulationResizeBound);
      new Touch(this.element);
      this.setStyle(this.element);
    };
    AccumulationChart2.prototype.setMouseXY = function(e) {
      var pageX;
      var pageY;
      var svgRectElement = getElement2(this.element.id + "_svg");
      if (svgRectElement && this.element) {
        var svgRect = svgRectElement.getBoundingClientRect();
        var rect = this.element.getBoundingClientRect();
        if (e.type.indexOf("touch") > -1) {
          this.isTouch = true;
          var touchArg = e;
          pageY = touchArg.changedTouches[0].clientY;
          pageX = touchArg.changedTouches[0].clientX;
        } else {
          this.isTouch = e.pointerType === "touch" || e.pointerType === "2";
          pageX = e.clientX;
          pageY = e.clientY;
        }
        this.mouseY = pageY - rect.top - Math.max(svgRect.top - rect.top, 0);
        this.mouseX = pageX - rect.left - Math.max(svgRect.left - rect.left, 0);
      }
    };
    AccumulationChart2.prototype.accumulationMouseEnd = function(e) {
      this.setMouseXY(e);
      this.trigger(chartMouseUp, {
        target: e.target.id,
        x: this.mouseX,
        y: this.mouseY
      });
      if (this.isTouch) {
        this.titleTooltip(e, this.mouseX, this.mouseY, this.isTouch);
        if (this.accumulationDataLabelModule && this.visibleSeries[0].dataLabel.visible) {
          this.accumulationDataLabelModule.move(e, this.mouseX, this.mouseY, this.isTouch);
        }
        if (this.accumulationLegendModule && this.legendSettings.visible) {
          this.accumulationLegendModule.move(e);
        }
      }
      if (this.centerLabel.hoverTextFormat) {
        this.updateCenterLabel(e);
      }
      this.notify(Browser.touchEndEvent, e);
      return false;
    };
    AccumulationChart2.prototype.accumulationMouseStart = function(e) {
      this.setMouseXY(e);
      this.trigger(chartMouseDown, {
        target: e.target.id,
        x: this.mouseX,
        y: this.mouseY
      });
      return false;
    };
    AccumulationChart2.prototype.accumulationResize = function() {
      var _this = this;
      this.animateSeries = false;
      var args = {
        accumulation: this.isBlazor ? {} : this,
        previousSize: new Size(this.availableSize.width, this.availableSize.height),
        name: resized,
        currentSize: new Size(0, 0),
        chart: this.isBlazor ? {} : this
      };
      var beforeResizeArgs = {
        name: "beforeResize",
        cancelResizedEvent: false
      };
      if (this.resizeTo) {
        clearTimeout(this.resizeTo);
      }
      this.trigger(beforeResize, beforeResizeArgs);
      if (!beforeResizeArgs.cancelResizedEvent) {
        this.resizeTo = +setTimeout(function() {
          if (_this.isDestroyed) {
            clearTimeout(_this.resizeTo);
            return;
          }
          calculateSize(_this);
          args.currentSize = _this.availableSize;
          _this.trigger(resized, args);
          _this.refreshSeries();
          _this.refreshChart();
        }, 500);
      }
      return false;
    };
    AccumulationChart2.prototype.print = function(id) {
      var clippath = document.getElementById(this.element.id + "_Series_0").style.clipPath;
      document.getElementById(this.element.id + "_Series_0").style.clipPath = "";
      var exportChart = new PrintUtils(this);
      exportChart.print(id);
      document.getElementById(this.element.id + "_Series_0").style.clipPath = clippath;
    };
    AccumulationChart2.prototype.export = function(type, fileName) {
      if (this.exportModule) {
        this.exportModule.export(type, fileName);
        if (this.afterExport) {
          this.exportModule.getDataUrl(this);
        }
      }
    };
    AccumulationChart2.prototype.setStyle = function(element) {
      element.style.touchAction = "element";
      element.style.msTouchAction = "element";
      element.style.msContentZooming = "none";
      element.style.msUserSelect = "none";
      element.style.webkitUserSelect = "none";
      element.style.position = "relative";
      element.style.display = "block";
      element.style.height = element.style.height || this.height && this.height.indexOf("%") === -1 ? element.style.height : "inherit";
      var tabColor = "";
      switch (this.theme) {
        case "HighContrastLight":
        case "HighContrast":
          tabColor = "#969696";
          break;
        case "MaterialDark":
        case "FabricDark":
        case "Bootstrap":
        case "Bootstrap4":
          tabColor = "#66afe9";
          break;
        case "Tailwind":
        case "TailwindDark":
          tabColor = "#4f46e5";
          break;
        case "Bootstrap5":
        case "Bootstrap5Dark":
          tabColor = "#0d6efd";
          break;
        case "Fluent":
        case "FluentDark":
          tabColor = "#9e9e9e";
          break;
        case "Fluent2":
        case "Fluent2Dark":
        case "Fluent2HighContrast":
          tabColor = "#0078D4";
          break;
        default:
          tabColor = "#9e9e9e";
          break;
      }
    };
    AccumulationChart2.prototype.setAnnotationValue = function(annotationIndex, content) {
      var annotation = this.annotations[annotationIndex];
      var element;
      var parentNode = getElement2(this.element.id + "_Annotation_Collections");
      if (content) {
        annotation.content = content;
        if (parentNode) {
          element = this.createElement("div");
          removeElement2(this.element.id + "_Annotation_" + annotationIndex);
          this.annotationModule.processAnnotation(annotation, annotationIndex, element);
          parentNode.appendChild(element.children[0]);
        } else {
          this.annotationModule.renderAnnotations(getElement2(this.element.id + "_Secondary_Element"));
        }
      }
    };
    AccumulationChart2.prototype.accumulationMouseMove = function(e) {
      if (!getElement2(this.element.id + "_svg")) {
        return false;
      }
      this.setMouseXY(e);
      this.trigger(chartMouseMove, {
        target: e.target.id,
        x: this.mouseX,
        y: this.mouseY
      });
      if (this.pointMove) {
        this.triggerPointEvent(pointMove, e.target, e);
      }
      if (this.accumulationLegendModule && this.legendSettings.visible) {
        this.accumulationLegendModule.move(e);
      }
      if (this.accumulationDataLabelModule && this.visibleSeries[0] && this.visibleSeries[0].dataLabel.visible) {
        this.accumulationDataLabelModule.move(e, this.mouseX, this.mouseY);
      }
      if (this.centerLabel.hoverTextFormat) {
        this.updateCenterLabel(e);
      }
      if (!this.isTouch) {
        this.titleTooltip(e, this.mouseX, this.mouseY);
      }
      if (this.enableBorderOnMouseMove && this.type === "Pie" && this.pieSeriesModule && withInBounds(this.mouseX, this.mouseY, this.initialClipRect)) {
        this.pieSeriesModule.findSeries(e, this.series[0].borderRadius);
      }
      this.notify(Browser.touchMoveEvent, e);
      return false;
    };
    AccumulationChart2.prototype.titleTooltip = function(event2, x, y, isTouch) {
      var targetId = event2.target.id;
      var id = targetId === this.element.id + "_title" || targetId === this.element.id + "_subTitle" || targetId === this.element.id + "_chart_legend_title";
      if (event2.target.textContent.indexOf("...") > -1 && id) {
        var title = targetId === this.element.id + "_title" ? this.title : targetId === this.element.id + "_subTitle" ? this.subTitle : this.legendSettings.title;
        showTooltip(title, x, y, this.element.offsetWidth, this.element.id + "_EJ2_Title_Tooltip", getElement2(this.element.id + "_Secondary_Element"), isTouch);
      } else {
        removeElement2(this.element.id + "_EJ2_Title_Tooltip");
      }
    };
    AccumulationChart2.prototype.accumulationChartKeyDown = function(e) {
      var actionKey = "";
      if (this.tooltip.enable && (e.code === "Tab" && this.previousTargetId.indexOf("Series") > -1 || e.code === "Escape")) {
        actionKey = "ESC";
      }
      if (e.code.indexOf("Arrow") > -1) {
        e.preventDefault();
      }
      if (e.ctrlKey && e.key === "p") {
        e.preventDefault();
        actionKey = "CtrlP";
      }
      if (actionKey !== "") {
        this.chartKeyboardNavigations(e, e.target.id, actionKey);
      }
      if (e.code === "Tab") {
        this.removeNavigationStyle();
      }
      return false;
    };
    AccumulationChart2.prototype.accumulationChartKeyUp = function(e) {
      var actionKey = "";
      var targetId = e.target["id"];
      var legendElement = getElement2(this.element.id + "_chart_legend_translate_g");
      var pagingElement = getElement2(this.element.id + "_chart_legend_pageup");
      if (legendElement) {
        var firstChild = legendElement.firstElementChild;
        var className = firstChild.getAttribute("class");
        if (className && className.indexOf("e-accumulationchart-focused") === -1) {
          className = className + " e-accumulationchart-focused";
        } else if (!className) {
          className = "e-accumulationchart-focused";
        }
        firstChild.setAttribute("class", className);
      }
      if (pagingElement) {
        pagingElement.setAttribute("class", "e-accumulationchart-focused");
      }
      this.removeNavigationStyle();
      if (e.code === "Tab") {
        if (this.previousTargetId !== "") {
          if (this.previousTargetId.indexOf("_Point_") > -1 && targetId.indexOf("_Point_") === -1) {
            var groupElement = document.getElementById(this.previousTargetId).parentElement;
            this.setTabIndex(groupElement.children[this.currentPointIndex], groupElement.firstElementChild);
            this.currentPointIndex = 0;
          } else if (this.previousTargetId.indexOf("_chart_legend_page") > -1 && targetId.indexOf("_chart_legend_page") === -1 && targetId.indexOf("_chart_legend_g_") === -1) {
            this.setTabIndex(e.target, pagingElement);
          } else if (this.previousTargetId.indexOf("_chart_legend_g_") > -1 && targetId.indexOf("chart_legend_g_") === -1 && legendElement) {
            this.setTabIndex(legendElement.children[this.currentLegendIndex], legendElement.firstElementChild);
          }
        }
        this.previousTargetId = targetId;
        if (targetId.indexOf("_chart_legend_g_") > -1 && this.highlightMode !== "None") {
          targetId = e.target["lastElementChild"].id;
          actionKey = "Tab";
        } else if (targetId.indexOf("_Point_") > -1 && (this.highlightMode !== "None" || this.tooltip.enable)) {
          actionKey = "Tab";
        }
      } else if (e.code.indexOf("Arrow") > -1) {
        e.preventDefault();
        if (targetId.indexOf("_chart_legend_page") > -1) {
          e.target.removeAttribute("tabindex");
          this.previousTargetId = targetId = this.element.id + "_chart_legend_page" + (e.code === "ArrowRight" ? "up" : "down");
          this.focusTarget(getElement2(targetId));
        } else if (targetId.indexOf("_chart_legend_") > -1 && legendElement) {
          e.target.removeAttribute("tabindex");
          this.currentLegendIndex += e.code === "ArrowUp" || e.code === "ArrowRight" ? 1 : -1;
          this.currentLegendIndex = this.getActualIndex(this.currentLegendIndex, legendElement.children.length);
          var currentLegend = legendElement.children[this.currentLegendIndex];
          this.focusTarget(currentLegend);
          this.removeNavigationStyle();
          this.setNavigationStyle(currentLegend.id);
          this.previousTargetId = targetId = currentLegend.lastElementChild.id;
          actionKey = this.highlightMode !== "None" ? "ArrowMove" : "";
        } else if (targetId.indexOf("_Point_") > -1) {
          e.target.setAttribute("tabindex", "-1");
          this.currentPointIndex += e.code === "ArrowUp" || e.code === "ArrowRight" ? 1 : -1;
          var totalLength = 0;
          for (var i = 0; i < e.target["parentElement"].children.length; i++) {
            totalLength = e.target["parentElement"].children[i].id.indexOf("_Point_") > -1 ? totalLength + 1 : totalLength;
          }
          this.currentPointIndex = this.getActualIndex(this.currentPointIndex, totalLength);
          targetId = this.element.id + "_Series_0_Point_" + this.currentPointIndex;
          this.focusTarget(getElement2(targetId));
          this.removeNavigationStyle();
          this.setNavigationStyle(targetId);
          actionKey = this.tooltip.enable ? "ArrowMove" : "";
        }
      } else if ((e.code === "Enter" || e.code === "Space") && (targetId.indexOf("_chart_legend_") > -1 || targetId.indexOf("_Point_") > -1)) {
        targetId = targetId.indexOf("_chart_legend_g") > -1 ? e.target["lastElementChild"].id : targetId;
        actionKey = "Enter";
      }
      if (actionKey !== "") {
        this.chartKeyboardNavigations(e, targetId, actionKey);
      }
      if (e.code === "Tab") {
        this.setNavigationStyle(targetId);
      }
      return false;
    };
    AccumulationChart2.prototype.setTabIndex = function(previousElement, currentElement) {
      if (previousElement) {
        previousElement.removeAttribute("tabindex");
      }
      if (currentElement) {
        currentElement.setAttribute("tabindex", "0");
      }
    };
    AccumulationChart2.prototype.getActualIndex = function(index, totalLength) {
      return index > totalLength - 1 ? 0 : index < 0 ? totalLength - 1 : index;
    };
    AccumulationChart2.prototype.focusTarget = function(element) {
      var className = element.getAttribute("class");
      element.setAttribute("tabindex", "0");
      if (className && className.indexOf("e-accumulationchart-focused") === -1) {
        className = className + " e-accumulationchart-focused";
      } else if (!className) {
        className = "e-accumulationchart-focused";
      }
      element.setAttribute("tabindex", "0");
      element.setAttribute("class", className);
      element.focus();
      return element.id;
    };
    AccumulationChart2.prototype.documentKeyHandler = function(e) {
      if (e.altKey && e.keyCode === 74 && !isNullOrUndefined(this.element)) {
        this.element.focus();
      }
    };
    AccumulationChart2.prototype.setNavigationStyle = function(target) {
      var currentElement = document.getElementById(target);
      if (currentElement) {
        currentElement.style.setProperty("outline", this.focusBorderWidth + "px solid " + (this.focusBorderColor || this.themeStyle.tabColor));
        currentElement.style.setProperty("margin", this.focusBorderMargin + "px");
      }
    };
    AccumulationChart2.prototype.removeNavigationStyle = function() {
      var currentElement = document.querySelectorAll("path[id*=_Series_0_Point_], [id*=" + this.element.id + "], [id*=_ChartBorder], text[id*=_title],g[id*=_chart_legend]");
      if (currentElement) {
        currentElement.forEach(function(element) {
          if (element instanceof HTMLElement || element instanceof SVGElement) {
            element.style.setProperty("outline", "none");
            element.style.setProperty("margin", "");
          }
        });
      }
    };
    AccumulationChart2.prototype.chartKeyboardNavigations = function(e, targetId, actionKey) {
      this.isLegendClicked = false;
      switch (actionKey) {
        case "Tab":
        case "ArrowMove":
          if (this.accumulationHighlightModule) {
          }
          if (targetId.indexOf("_Point_") > -1) {
            var seriesIndex = +targetId.split("_Series_")[1].split("_Point_")[0];
            var pointIndex = +targetId.split("_Series_")[1].replace("_Symbol", "").split("_Point_")[1];
            var pointRegion = this.visibleSeries[seriesIndex].points[pointIndex].symbolLocation;
            this.mouseX = pointRegion.x + this.initialClipRect.x;
            this.mouseY = pointRegion.y + this.initialClipRect.y;
            if (this.accumulationHighlightModule) {
              var targetElement = getElement2(targetId);
              if (!isNullOrUndefined(targetElement)) {
                if (targetElement.id.indexOf("text") > 1) {
                  targetElement = getElement2(targetElement.id.replace("text", "shape"));
                }
                if (targetElement.hasAttribute("class") && targetElement.getAttribute("class").indexOf("highlight") > -1) {
                  return;
                }
                this.accumulationHighlightModule.calculateSelectedElements(this, targetElement, "mousemove");
                return;
              }
            }
            if (this.accumulationTooltipModule) {
              var series = this.visibleSeries[seriesIndex];
              var data = void 0;
              if (series.enableTooltip) {
                data = new AccPointData(series.points[pointIndex], series);
              }
              this.accumulationTooltipModule.renderSeriesTooltip(this, data);
            }
          }
          if (this.accumulationHighlightModule && this.highlightMode !== "None") {
            targetId = targetId.indexOf("_chart_legend_g_") > -1 ? document.getElementById(targetId).firstChild["id"] : targetId;
            var legendID = this.element.id + "_chart_legend";
            var legendItemsId = [legendID + "_text_", legendID + "_shape_marker_", legendID + "_shape_"];
            for (var i = 0; i < legendItemsId.length; i++) {
              var id = legendItemsId[i];
              if (targetId.indexOf(id) > -1) {
                document.getElementById(targetId).setAttribute("class", "");
                this.accumulationHighlightModule.legendSelection(this, 0, parseInt(targetId.split(id)[1], 10), getElement2(targetId), "mousemove");
                break;
              }
            }
          }
          break;
        case "Enter":
        case "Space":
          if (targetId.indexOf("_chart_legend_") > -1 && this.accumulationLegendModule) {
            this.isLegendClicked = true;
            this.accumulationLegendModule.click(e);
            this.focusChild(document.getElementById(targetId).parentElement);
            this.setNavigationStyle(document.getElementById(targetId).parentElement.id);
          } else {
            if (this.accumulationSelectionModule) {
              this.accumulationSelectionModule.calculateSelectedElements(this, document.getElementById(targetId), "click");
            }
            this.setNavigationStyle(targetId);
          }
          break;
        case "CtrlP":
          this.print();
          break;
        case "ESC":
          if (this.accumulationTooltipModule) {
            this.accumulationTooltipModule.removeTooltip(1);
          }
          break;
      }
    };
    AccumulationChart2.prototype.focusChild = function(element) {
      element.setAttribute("tabindex", "0");
      var className = element.getAttribute("class");
      element.setAttribute("tabindex", "0");
      if (className && className.indexOf("e-accumulationchart-focused") === -1) {
        className = "e-accumulationchart-focused " + className;
      } else if (!className) {
        className = "e-accumulationchart-focused";
      }
      element.setAttribute("class", className);
      element.focus();
      return element.id;
    };
    AccumulationChart2.prototype.accumulationOnDoubleClick = function(e) {
      this.trigger(chartDoubleClick, {
        target: e.target.id,
        x: this.mouseX,
        y: this.mouseY
      });
      return false;
    };
    AccumulationChart2.prototype.accumulationOnMouseClick = function(e) {
      this.setMouseXY(e);
      if (this.accumulationLegendModule && this.legendSettings.visible) {
        this.accumulationLegendModule.click(e);
      }
      if (this.selectionMode !== "None" && this.accumulationSelectionModule) {
        this.accumulationSelectionModule.calculateSelectedElements(this, e.target, e.type);
      }
      if (this.visibleSeries[0].explode) {
        this.accBaseModule.processExplode(e);
      }
      if (this.enableBorderOnMouseMove && this.pieSeriesModule && this.type === "Pie") {
        this.pieSeriesModule.findSeries(e, this.series[0].borderRadius);
      }
      this.trigger(chartMouseClick, {
        target: e.target.id,
        x: this.mouseX,
        y: this.mouseY
      });
      if (this.pointClick) {
        this.triggerPointEvent(pointClick, e.target, e);
      }
      this.removeNavigationStyle();
      return false;
    };
    AccumulationChart2.prototype.triggerPointEvent = function(event2, element, e) {
      var evt = e;
      var indexes = indexFinder(element.id, true);
      if (indexes.series >= 0 && indexes.point >= 0) {
        this.trigger(event2, {
          series: this.isBlazor ? {} : this.series[indexes.series],
          point: this.series[indexes.series].points[indexes.point],
          seriesIndex: indexes.series,
          pointIndex: indexes.point,
          x: this.mouseX,
          y: this.mouseY,
          pageX: evt.pageX,
          pageY: evt.pageY
        });
      }
    };
    AccumulationChart2.prototype.accumulationRightClick = function(event2) {
      if (event2.buttons === 2 && event2.pointerType === "touch") {
        event2.preventDefault();
        event2.stopPropagation();
        return false;
      }
      return true;
    };
    AccumulationChart2.prototype.accumulationMouseLeave = function(e) {
      this.setMouseXY(e);
      this.trigger(chartMouseLeave, {
        target: e.target.id,
        x: this.mouseX,
        y: this.mouseY
      });
      this.notify(Browser.isPointer ? "pointerleave" : "mouseleave", e);
      var borderElement = document.getElementById(this.element.id + "PointHover_Border");
      if (borderElement) {
        this.pieSeriesModule.removeBorder(borderElement, 1e3);
        borderElement = null;
      }
      return false;
    };
    AccumulationChart2.prototype.setCulture = function() {
      this.intl = new Internationalization();
    };
    AccumulationChart2.prototype.createPieSvg = function() {
      this.removeSvg();
      createSvg(this);
    };
    AccumulationChart2.prototype.removeSvg = function() {
      if (this.redraw) {
        return null;
      }
      blazorTemplatesReset(this);
      removeElement2(this.element.id + "_Secondary_Element");
      if (this.svgObject) {
        while (this.svgObject.childNodes.length > 0) {
          this.svgObject.removeChild(this.svgObject.firstChild);
        }
        if (!this.svgObject.hasChildNodes() && this.svgObject.parentNode) {
          remove(this.svgObject);
        }
      }
      removeElement2("EJ2_legend_tooltip");
      removeElement2("EJ2_datalabel_tooltip");
      removeElement2(this.element.id + "PointHover_Border");
    };
    AccumulationChart2.prototype.createSecondaryElement = function() {
      var element = redrawElement(this.redraw, this.element.id + "_Secondary_Element") || this.createElement("div", {
        id: this.element.id + "_Secondary_Element",
        styles: "position: relative"
      });
      appendChildElement(false, this.element, element, this.redraw);
    };
    AccumulationChart2.prototype.calculateVisibleSeries = function() {
      this.visibleSeries = [];
      for (var i = 0, length_1 = this.series.length; i < length_1; i++) {
        this.series[i].index = i;
        if (this.series[i].type === this.type && this.visibleSeries.length === 0) {
          this.visibleSeries.push(this.series[i]);
          break;
        }
      }
    };
    AccumulationChart2.prototype.processData = function(render) {
      if (render === void 0) {
        render = true;
      }
      this.seriesCounts = 0;
      for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
        var series = _a[_i];
        series.dataModule = new Data(series.dataSource || this.dataSource, series.query);
        series.refreshDataManager(this, render);
      }
    };
    AccumulationChart2.prototype.refreshChart = function() {
      this.doGrouppingProcess();
      this.createPieSvg();
      this.calculateBounds();
      this.renderElements();
      removeElement2("chartmeasuretext");
    };
    AccumulationChart2.prototype.doGrouppingProcess = function() {
      var series = this.visibleSeries[0];
      if (!isNullOrUndefined(series.resultData) && !isNullOrUndefined(series.lastGroupTo) && series.lastGroupTo !== series.groupTo) {
        series.getPoints(series.resultData, this);
      }
    };
    AccumulationChart2.prototype.calculateBounds = function() {
      this.initialClipRect = new Rect(this.margin.left, this.margin.top, this.availableSize.width, this.availableSize.height);
      this.titleCollection = [];
      this.subTitleCollection = [];
      var titleHeight = 0;
      var subTitleHeight = 0;
      var maxWidth = 0;
      var titleWidth = 0;
      if (this.title) {
        this.titleCollection = getTitle(this.title, this.titleStyle, this.initialClipRect.width, this.enableRtl, this.themeStyle.chartTitleFont);
      }
      titleHeight = this.title ? measureText(this.title, this.titleStyle, this.themeStyle.chartTitleFont).height * this.titleCollection.length : titleHeight;
      if (this.subTitle) {
        for (var _i = 0, _a = this.titleCollection; _i < _a.length; _i++) {
          var titleText = _a[_i];
          titleWidth = measureText(titleText, this.titleStyle, this.themeStyle.chartSubTitleFont).width;
          maxWidth = titleWidth > maxWidth ? titleWidth : maxWidth;
        }
        this.subTitleCollection = getTitle(this.subTitle, this.subTitleStyle, this.initialClipRect.width, this.enableRtl, this.themeStyle.chartSubTitleFont);
        subTitleHeight = measureText(this.subTitle, this.subTitleStyle, this.themeStyle.chartSubTitleFont).height * this.subTitleCollection.length;
      }
      var left = this.margin.left + this.border.width;
      var width = this.availableSize.width - left - this.margin.right - this.border.width;
      var top = this.margin.top + this.border.width;
      var height = this.availableSize.height - top - this.border.width - this.margin.bottom;
      var marginTotal = subTitleHeight + titleHeight;
      switch (this.titleStyle.position) {
        case "Top":
          left = 0;
          top = subTitleHeight + titleHeight;
          width = this.margin.right + this.margin.left;
          height = this.margin.bottom + this.margin.top;
          break;
        case "Bottom":
          height -= marginTotal + this.margin.bottom * 2;
          break;
        case "Left":
          left += marginTotal;
          width -= marginTotal;
          break;
        case "Right":
          width -= marginTotal;
          break;
      }
      if (this.titleStyle.position !== "Top") {
        this.initialClipRect = new Rect(left, top, width, height);
      } else {
        this.initialClipRect = subtractRect(this.initialClipRect, new Rect(left, top, width, height));
      }
      this.calculateLegendBounds();
    };
    AccumulationChart2.prototype.calculateLegendBounds = function() {
      if (!this.accumulationLegendModule || !this.legendSettings.visible) {
        return null;
      }
      this.accumulationLegendModule.getLegendOptions(this, this.visibleSeries);
      this.accumulationLegendModule.calculateLegendBounds(this.initialClipRect, this.availableSize, null);
    };
    AccumulationChart2.prototype.renderElements = function() {
      this.renderBorder();
      this.createSecondaryElement();
      this.renderSeries();
      this.renderTitle();
      this.renderCenterLabel(true);
      this.renderLegend();
      appendChildElement(false, this.element, this.svgObject, this.redraw);
      this.processSelection();
      this.processExplode();
      this.renderAnnotation();
      this.setSecondaryElementPosition();
      updateBlazorTemplate(this.element.id + "_DataLabel", "Template", this.series[0].dataLabel);
      this.trigger("loaded", {
        accumulation: this.isBlazor ? {} : this,
        chart: this.isBlazor ? {} : this
      });
      this.animateSeries = false;
    };
    AccumulationChart2.prototype.setSecondaryElementPosition = function() {
      var tooltipParent = getElement2(this.element.id + "_Secondary_Element");
      if (!tooltipParent) {
        return;
      }
      var rect = this.element.getBoundingClientRect();
      var svgRect = getElement2(this.element.id + "_svg").getBoundingClientRect();
      tooltipParent.style.left = Math.max(svgRect.left - rect.left, 0) + "px";
      tooltipParent.style.top = Math.max(svgRect.top - rect.top, 0) + "px";
    };
    AccumulationChart2.prototype.renderAnnotation = function() {
      if (this.annotationModule) {
        this.annotationModule.renderAnnotations(getElement2(this.element.id + "_Secondary_Element"));
      }
    };
    AccumulationChart2.prototype.processExplode = function() {
      if (this.redraw) {
        return null;
      }
      if (!this.visibleSeries[0].explode) {
        return null;
      }
      this.accBaseModule.invokeExplode();
    };
    AccumulationChart2.prototype.renderSeries = function() {
      if (!this.redraw) {
        this.svgObject.appendChild(this.renderer.createGroup({
          id: this.element.id + "_SeriesCollection"
        }));
      }
      for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
        var series = _a[_i];
        if (series.visible && this[firstToLowerCase(series.type) + "SeriesModule"]) {
          this[firstToLowerCase(series.type) + "SeriesModule"].initProperties(this, series);
          series.renderSeries(this, this.redraw);
        }
      }
    };
    AccumulationChart2.prototype.renderBorder = function() {
      var padding = this.border.width;
      var rect = new RectOption(this.element.id + "_border", this.background || this.themeStyle.background, this.border, 1, new Rect(padding / 2, padding / 2, this.availableSize.width - padding, this.availableSize.height - padding), 0, 0, "", this.border.dashArray);
      var htmlObject = this.renderer.drawRectangle(rect);
      htmlObject.setAttribute("aria-hidden", "true");
      appendChildElement(false, this.svgObject, htmlObject, this.redraw);
      var backGroundImage = this.backgroundImage;
      if (backGroundImage) {
        var image = new ImageOption(this.availableSize.height - padding, this.availableSize.width - padding, backGroundImage, 0, 0, this.element.id + "_background", "visible", "none");
        appendChildElement(false, this.svgObject, this.renderer.drawImage(image), this.redraw);
      }
    };
    AccumulationChart2.prototype.renderLegend = function() {
      if (!this.accumulationLegendModule || !this.legendSettings.visible) {
        return null;
      }
      if (this.accumulationLegendModule.legendCollections.length) {
        if (this.visibleSeries[0].type === "Pie") {
          this.accumulationLegendModule.getSmartLegendLocation(this.visibleSeries[0].labelBound, this.accumulationLegendModule.legendBounds, this.margin);
        }
        this.accumulationLegendModule.renderLegend(this, this.legendSettings, this.accumulationLegendModule.legendBounds, this.redraw);
      }
    };
    AccumulationChart2.prototype.processSelection = function() {
      var selectedDataIndexes = [];
      if (this.accumulationSelectionModule && this.selectionMode !== "None") {
        selectedDataIndexes = extend([], this.accumulationSelectionModule.selectedDataIndexes, null, true);
        this.accumulationSelectionModule.invokeSelection(this);
      }
      if (this.accumulationHighlightModule && this.highlightMode !== "None") {
        this.accumulationHighlightModule.invokeHighlight(this);
      }
      if (selectedDataIndexes.length > 0) {
        this.accumulationSelectionModule.selectedDataIndexes = selectedDataIndexes;
        this.accumulationSelectionModule.redrawSelection(this);
      }
    };
    AccumulationChart2.prototype.renderTitle = function() {
      var margin = this.margin;
      if (!this.title) {
        return null;
      }
      var textAnchor = getTextAnchor(this.titleStyle.textAlignment, this.enableRtl);
      var titleSize = measureText(this.title, this.titleStyle, this.themeStyle.chartTitleFont);
      var padding = 20;
      var titleHeight = this.margin.top + titleSize.height * 3 / 4;
      var legendHeight = this.accumulationLegendModule === void 0 ? 0 : this.legendSettings.position === "Top" ? this.accumulationLegendModule.legendBounds.height : 0;
      var explode = this.explodeDistance === 0 ? 0 : this.explodeDistance;
      var expodeValue = legendHeight !== 0 ? 0 : explode / 2;
      var rect = new Rect(margin.left, 0, this.availableSize.width - margin.left - margin.right, 0);
      var positionY = this.margin.top + titleSize.height * 3 / 4;
      var positionX = titlePositionX(rect, this.titleStyle || this.themeStyle.chartTitleFont);
      var rotation;
      var alignment = this.titleStyle.textAlignment;
      var subtitleSize = measureText(this.subTitle, this.subTitleStyle, this.themeStyle.chartSubTitleFont);
      switch (this.titleStyle.position) {
        case "Top":
          positionX = titlePositionX(rect, this.titleStyle);
          positionY = titleHeight;
          break;
        case "Bottom":
          positionX += textAnchor === "start" ? this.border.width : textAnchor === "end" ? this.border.width : 0;
          positionY = this.availableSize.height - this.margin.bottom - subtitleSize.height - titleSize.height / 2;
          break;
        case "Left":
          positionX = this.margin.left + titleSize.height * 3 / 4;
          positionY = alignment === "Near" ? margin.bottom + this.border.width : alignment === "Far" ? this.availableSize.height - margin.bottom - this.border.width : this.availableSize.height / 2;
          textAnchor = alignment === "Near" ? "end" : alignment === "Far" ? "start" : "middle";
          textAnchor = this.enableRtl ? textAnchor === "end" ? "start" : textAnchor === "start" ? "end" : textAnchor : textAnchor;
          rotation = "rotate(-90," + positionX + "," + positionY + ")";
          break;
        case "Right":
          positionX = this.availableSize.width - this.margin.right - titleSize.height * 3 / 4;
          positionY = alignment === "Near" ? margin.bottom + this.border.width : alignment === "Far" ? this.availableSize.height - margin.bottom - this.border.width : this.availableSize.height / 2;
          textAnchor = alignment === "Near" ? "start" : alignment === "Far" ? "end" : "middle";
          textAnchor = this.enableRtl ? textAnchor === "end" ? "start" : textAnchor === "start" ? "end" : textAnchor : textAnchor;
          rotation = "rotate(90," + positionX + "," + positionY + ")";
          break;
        case "Custom":
          positionX = this.titleStyle.x;
          positionY = this.titleStyle.y;
          textAnchor = "middle";
          break;
      }
      var options = new TextOption(this.element.id + "_title", positionX, positionY, textAnchor, this.titleCollection, rotation, "auto");
      var space = this.series[0].type === "Pie" && this.visibleSeries[0].dataLabel.position === "Outside" && this.visibleSeries[0].dataLabel.connectorStyle.length ? stringToNumber(this.visibleSeries[0].dataLabel.connectorStyle.length, this.accBaseModule.radius) : 0;
      if (!this.subTitle && this.series[0].type !== "Funnel" && this.series[0].type !== "Pyramid") {
        options.y = parseInt(this.series[0].radius, 10) >= 80 ? options.y : this.accBaseModule.center.y - this.accBaseModule.radius - padding - titleHeight - legendHeight - expodeValue - space;
        if (this.series[0].type === "Pie" && (parseInt(this.series[0].radius, 10) < 80 || isNaN(parseInt(this.series[0].radius, 10)))) {
          options.y = options.y < this.initialClipRect.y - legendHeight ? this.initialClipRect.y - legendHeight : options.y;
        }
      }
      var element = textElement2(this.renderer, options, this.titleStyle, this.titleStyle.color || this.themeStyle.chartTitleFont.color, this.svgObject, false, this.redraw, null, null, null, null, null, null, null, null, this.themeStyle.chartTitleFont);
      if (element) {
        element.setAttribute("tabindex", "0");
        element.style.outline = "none";
        element.parentNode.insertBefore(element, this.svgObject.children && this.svgObject.children[1]);
      }
      if (this.subTitle) {
        this.renderSubTitle(options);
      }
    };
    AccumulationChart2.prototype.updateCenterLabel = function(event2) {
      var data = this.getPieData(event2);
      this.format = data.point == null ? "" : this.parseFormat(data.point, this.visibleSeries[0], this.centerLabel.hoverTextFormat);
      this.renderCenterLabel();
    };
    AccumulationChart2.prototype.getPieData = function(e) {
      var dataIndex = indexFinder(e.target.id, true);
      if (!isNaN(dataIndex.series)) {
        return new AccPointData(this.visibleSeries[0].points[dataIndex.point], this.visibleSeries[0]);
      }
      return new AccPointData(null, null);
    };
    AccumulationChart2.prototype.parseFormat = function(point, series, format) {
      var value;
      var textValue;
      var regExp = RegExp;
      for (var _i = 0, _a = Object.keys(point); _i < _a.length; _i++) {
        var dataValue = _a[_i];
        value = new regExp("${point." + dataValue + "}", "gm");
        format = format.replace(value.source, point[dataValue]);
      }
      for (var _b = 0, _c = Object.keys(Object.getPrototypeOf(series)); _b < _c.length; _b++) {
        var dataValue = _c[_b];
        value = new regExp("${series." + dataValue + "}", "gm");
        textValue = series[dataValue];
        format = format.replace(value.source, textValue);
      }
      return format;
    };
    AccumulationChart2.prototype.renderCenterLabel = function(isanimate, pointAnimation) {
      var _this = this;
      if (!this.centerLabel.text || this.type !== "Pie") {
        return null;
      }
      var initialPositions = [];
      if (pointAnimation) {
        var tspanElements_1 = getElement2(this.element.id + "_centerLabel").querySelectorAll("tspan");
        tspanElements_1.forEach(function(tspan) {
          initialPositions.push({
            x: tspan.getAttribute("x"),
            y: tspan.getAttribute("y")
          });
        });
      }
      var series = this.series[0];
      var ypos;
      var getAnchor = getTextAnchor(this.centerLabel.textStyle.textAlignment, this.enableRtl);
      var padding = 10;
      var maxwidth = this.pieSeriesModule.innerRadius ? 2 * this.pieSeriesModule.innerRadius * 0.7071067 : 2 * this.pieSeriesModule.radius * 0.7071067;
      var labelCollection = (this.format || this.centerLabel.text).split("<br>");
      var centerLabelSize = measureText(labelCollection[0], this.centerLabel.textStyle, this.themeStyle.chartTitleFont);
      var collectionLength = labelCollection.length;
      for (var i = 0; i < collectionLength; i++) {
        var labelSize = measureText(labelCollection[i], this.centerLabel.textStyle, this.themeStyle.chartTitleFont);
        if (labelSize.width > maxwidth) {
          labelCollection.splice.apply(labelCollection, [i, 1].concat(textWrap(labelCollection[i], maxwidth, this.centerLabel.textStyle, this.enableRtl, null, null, this.themeStyle.chartTitleFont)));
        }
      }
      if (centerLabelSize.height * labelCollection.length > maxwidth) {
        ypos = this.accBaseModule.center.y + (centerLabelSize.height + padding) / 2 - maxwidth / 2;
      } else if (series.startAngle && series.endAngle && Math.abs(series.endAngle - series.startAngle) === 180) {
        ypos = this.accBaseModule.center.y - centerLabelSize.height * labelCollection.length / 2 + (centerLabelSize.height + padding) / 2 - this.pieSeriesModule.innerRadius / 2 + (this.pieSeriesModule.innerRadius ? padding : 0);
        if (centerLabelSize.height * labelCollection.length + this.pieSeriesModule.innerRadius / 2 + padding > maxwidth) {
          ypos = this.accBaseModule.center.y + (centerLabelSize.height + padding) / 2 - maxwidth / 2;
        }
      } else {
        ypos = labelCollection.length > 1 ? this.accBaseModule.center.y - centerLabelSize.height * labelCollection.length / 2 + (centerLabelSize.height + padding) / 2 : this.accBaseModule.center.y + centerLabelSize.height / 4;
      }
      var options = new TextOption(this.element.id + "_centerLabel", (this.series[0].animation.enable && animationMode !== "Disable" || animationMode === "Enable") && isanimate ? this.pieSeriesModule.center.x - 1 : this.pieSeriesModule.center.x, ypos, getAnchor, "", "", "auto");
      var element = textElement2(this.renderer, options, this.centerLabel.textStyle, this.centerLabel.textStyle.color || this.themeStyle.chartTitleFont.color, this.svgObject, false, this.redraw, null, null, null, null, null, null, null, null, this.themeStyle.chartTitleFont);
      var tspanElements = [];
      for (var i = 0; i < labelCollection.length; i++) {
        var tspanOption = {
          x: options.x,
          y: options.y + i * centerLabelSize.height,
          fill: ""
        };
        var tspanElement = this.renderer.createTSpan(tspanOption, "");
        tspanElement.style.fontFamily = "inherit";
        tspanElement.style.fontStyle = "inherit";
        tspanElement.style.fontSize = "inherit";
        tspanElement.style.fontWeight = labelCollection[i].indexOf("<b>") > -1 || labelCollection[i].indexOf("</b>") > -1 ? "bold" : "inherit";
        tspanElement.textContent = labelCollection[i].replace(/<\/?b>/g, "");
        element.appendChild(tspanElement);
        tspanElements.push(tspanElement);
      }
      if (pointAnimation) {
        tspanElements.forEach(function(tspanElement2, index) {
          _this.animateTspan(tspanElement2, Number(initialPositions[index].x), Number(initialPositions[index].y), Number(tspanElement2.getAttribute("x")), Number(tspanElement2.getAttribute("y")), _this.duration);
        });
      }
      if (isanimate && (this.series[0].animation.enable && animationMode !== "Disable" || animationMode === "Enable") && this.animateSeries) {
        this.centerLabelDelay(element);
      }
    };
    AccumulationChart2.prototype.animateTspan = function(element, startx, starty, endx, endy, duration) {
      new Animation({}).animate(element, {
        duration,
        progress: function(args) {
          element.style.animation = "";
          var progress = args.timeStamp / args.duration;
          var currentX = startx + (endx - startx) * progress;
          var currentY = starty + (endy - starty) * progress;
          element.setAttribute("x", currentX.toString());
          element.setAttribute("y", currentY.toString());
        },
        end: function() {
          element.setAttribute("x", endx.toString());
          element.setAttribute("y", endy.toString());
        }
      });
    };
    AccumulationChart2.prototype.centerLabelDelay = function(element) {
      element.style.visibility = "hidden";
      var animation = new Animation({});
      animation.animate(element, {
        delay: this.duration ? this.duration : this.series[0].animation.duration,
        progress: function(args) {
          args.element.style.visibility = "visible";
        }
      });
    };
    AccumulationChart2.prototype.renderSubTitle = function(options) {
      var maxWidth = 0;
      var titleWidth = 0;
      var padding = 10;
      var alignment = this.titleStyle.textAlignment;
      var subTitleElementSize = measureText(this.subTitle, this.subTitleStyle, this.themeStyle.chartSubTitleFont);
      for (var _i = 0, _a = this.titleCollection; _i < _a.length; _i++) {
        var titleText = _a[_i];
        titleWidth = measureText(titleText, this.titleStyle, this.themeStyle.chartSubTitleFont).width;
        maxWidth = titleWidth > maxWidth ? titleWidth : maxWidth;
      }
      var rect = new Rect(alignment === "Center" ? options.x - maxWidth / 2 : alignment === "Far" ? options.x - maxWidth : options.x, 0, maxWidth, 0);
      if (this.titleStyle.position === "Left") {
        rect.x = alignment === "Center" ? options.x - maxWidth * 0.5 : alignment === "Far" ? this.margin.left + subTitleElementSize.height * 3 / 4 : options.x - maxWidth;
      }
      var subTitleOption = new TextOption(this.element.id + "_subTitle", titlePositionX(rect, this.subTitleStyle), options.y * options.text.length + subTitleElementSize.height * 3 / 4 + padding, getTextAnchor(this.subTitleStyle.textAlignment, this.enableRtl), this.subTitleCollection, options.transform, "auto");
      textElement2(this.renderer, subTitleOption, this.subTitleStyle, this.subTitleStyle.color || this.themeStyle.chartSubTitleFont.color, this.svgObject, false, this.redraw, null, null, null, null, null, null, null, null, this.themeStyle.chartSubTitleFont);
    };
    AccumulationChart2.prototype.getSeriesElement = function() {
      return this.svgObject.getElementsByTagName("g")[0];
    };
    AccumulationChart2.prototype.refreshSeries = function() {
      for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
        var series = _a[_i];
        this.refreshPoints(series.points);
      }
    };
    AccumulationChart2.prototype.refreshPoints = function(points) {
      for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
        var point = points_1[_i];
        point.labelPosition = null;
        point.labelRegion = null;
        point.labelVisible = true;
      }
    };
    AccumulationChart2.prototype.getModuleName = function() {
      return "accumulationchart";
    };
    AccumulationChart2.prototype.destroy = function() {
      if (this.element) {
        this.unWireEvents();
        _super.prototype.destroy.call(this);
        this.element.classList.remove("e-accumulationchart");
        this.element.classList.remove("e-accumulationchart-focused");
        var element = document.getElementById(this.element.id + "Keyboard_accumulationchart_focus");
        if (element) {
          element.remove();
        }
        removeElement2("chartmeasuretext");
        this.removeSvg();
        var highlightElement = document.getElementById(this.element.id + "_ej2_chart_highlight");
        if (highlightElement) {
          highlightElement.remove();
        }
        var selectionElement = document.getElementById(this.element.id + "_ej2_chart_selection");
        if (selectionElement) {
          selectionElement.remove();
        }
        this.svgObject = null;
      }
    };
    AccumulationChart2.prototype.requiredModules = function() {
      var modules = [];
      var enableAnnotation = false;
      modules.push({
        member: this.type + "Series",
        args: [this]
      });
      if (this.legendSettings.visible) {
        modules.push({
          member: "AccumulationLegend",
          args: [this]
        });
      }
      if (this.findDatalabelVisibility()) {
        modules.push({
          member: "AccumulationDataLabel",
          args: [this]
        });
      }
      if (this.tooltip.enable) {
        modules.push({
          member: "AccumulationTooltip",
          args: [this]
        });
      }
      if (this.selectionMode !== "None") {
        modules.push({
          member: "AccumulationSelection",
          args: [this]
        });
      }
      if (this.highlightMode !== "None") {
        modules.push({
          member: "AccumulationHighlight",
          args: [this]
        });
      }
      if (this.enableExport || this.allowExport) {
        modules.push({
          member: "Export",
          args: [this]
        });
      }
      enableAnnotation = this.annotations.some(function(value) {
        return value.content !== null;
      });
      if (enableAnnotation) {
        modules.push({
          member: "Annotation",
          args: [this]
        });
      }
      return modules;
    };
    AccumulationChart2.prototype.findDatalabelVisibility = function() {
      for (var _i = 0, _a = this.series; _i < _a.length; _i++) {
        var series = _a[_i];
        if (series.dataLabel.visible) {
          return true;
        }
      }
      return false;
    };
    AccumulationChart2.prototype.changeVisibleSeries = function(visibleSeries, index) {
      for (var _i = 0, visibleSeries_1 = visibleSeries; _i < visibleSeries_1.length; _i++) {
        var series = visibleSeries_1[_i];
        if (index === series.index) {
          return series;
        }
      }
      return null;
    };
    AccumulationChart2.prototype.getPersistData = function() {
      return "";
    };
    AccumulationChart2.prototype.sanitize = function(value) {
      if (this.enableHtmlSanitizer) {
        return SanitizeHtmlHelper.sanitize(value);
      }
      return value;
    };
    AccumulationChart2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var update = {
        refreshElements: false,
        refreshBounds: false
      };
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "theme":
            this.animateSeries = true;
            break;
          case "title":
          case "subTitle":
          case "height":
          case "width":
          case "margin":
            update.refreshBounds = true;
            break;
          case "titleStyle":
            if (newProp.titleStyle && (newProp.titleStyle.size || newProp.titleStyle.textOverflow)) {
              update.refreshBounds = true;
            } else {
              update.refreshElements = true;
            }
            break;
          case "subTitleStyle":
            if (newProp.subTitleStyle && (newProp.subTitleStyle.size || newProp.subTitleStyle.textOverflow)) {
              update.refreshBounds = true;
            } else {
              update.refreshElements = true;
            }
            break;
          case "legendSettings":
            update.refreshBounds = true;
            update.refreshElements = true;
            break;
          case "dataSource":
            this.processData(false);
            update.refreshBounds = true;
            break;
          case "series":
            if (!this.animateselected) {
              var len = this.series.length;
              var seriesRefresh = false;
              var series = void 0;
              var blazorProp = void 0;
              for (var i = 0; i < len; i++) {
                series = newProp.series[i];
                if ((series.startAngle || series.endAngle || series.explodeOffset || series.neckHeight || series.neckWidth || series.radius || series.innerRadius || series.groupMode || series.emptyPointSettings) && this.isBlazor) {
                  blazorProp = true;
                }
                if (newProp.series[i] && (newProp.series[i].dataSource || newProp.series[i].yName || newProp.series[i].xName || series.type || newProp.series[i].dataLabel || series.radius || series.innerRadius || series.startAngle || series.endAngle || series.gapRatio || series.neckWidth || series.explode || series.neckWidth || series.pyramidMode || series.explodeOffset || series.funnelMode || blazorProp)) {
                  extend(this.changeVisibleSeries(this.visibleSeries, i), series, null, true);
                  seriesRefresh = true;
                }
                if (newProp.series[i] && !isNullOrUndefined(newProp.series[i].explodeIndex) && newProp.series[i].explodeIndex >= 0 && newProp.series[i].explodeIndex !== oldProp.series[i].explodeIndex) {
                  this.accBaseModule.explodePoints(newProp.series[i].explodeIndex, this);
                  this.accBaseModule.deExplodeAll(newProp.series[i].explodeIndex, this.enableAnimation ? 300 : 0);
                } else if (newProp.series[i].explodeIndex < 0) {
                  this.accBaseModule.deExplodeAll(newProp.series[i].explodeIndex, this.enableAnimation ? 300 : 0);
                }
                if (!this.pieSeriesModule) {
                  this.pieSeriesModule = new PieSeries(this);
                }
              }
              if (seriesRefresh) {
                this.calculateVisibleSeries();
                this.processData(false);
                update.refreshBounds = true;
              }
            }
            this.animateselected = false;
            this.redraw = false;
            break;
          case "enableRtl":
          case "locale":
          case "currencyCode":
            _super.prototype.refresh.call(this);
            break;
          case "background":
          case "border":
          case "annotations":
          case "enableSmartLabels":
            update.refreshElements = true;
            break;
          case "isMultiSelect":
          case "selectedDataIndexes":
          case "selectionMode":
            if (this.accumulationSelectionModule) {
              if (isNullOrUndefined(this.accumulationSelectionModule.selectedDataIndexes)) {
                this.accumulationSelectionModule.invokeSelection(this);
              } else {
                this.accumulationSelectionModule.selectedDataIndexes = this.selectedDataIndexes;
                this.accumulationSelectionModule.redrawSelection(this);
              }
            }
            break;
          case "tooltip":
            if (this.accumulationTooltipModule) {
              this.accumulationTooltipModule.previousPoints = [];
              if (this.tooltip.template) {
                this.accumulationTooltipModule.template = this.tooltip.template;
              }
            }
            break;
          case "center":
            if (!isNullOrUndefined(newProp.center.x)) {
              this.center.x = newProp.center.x;
              update.refreshElements = true;
            }
            if (!isNullOrUndefined(newProp.center.y)) {
              this.center.y = newProp.center.y;
              update.refreshElements = true;
            }
            break;
        }
      }
      if (!update.refreshBounds && update.refreshElements) {
        this.createPieSvg();
        this.renderElements();
      } else if (update.refreshBounds) {
        this.refreshSeries();
        this.createPieSvg();
        this.calculateBounds();
        this.renderElements();
      }
    };
    __decorate9([Property(null)], AccumulationChart2.prototype, "width", void 0);
    __decorate9([Property(null)], AccumulationChart2.prototype, "height", void 0);
    __decorate9([Property(null)], AccumulationChart2.prototype, "title", void 0);
    __decorate9([Property(null)], AccumulationChart2.prototype, "backgroundImage", void 0);
    __decorate9([Complex({}, PieCenter)], AccumulationChart2.prototype, "center", void 0);
    __decorate9([Property("")], AccumulationChart2.prototype, "dataSource", void 0);
    __decorate9([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, TitleStyleSettings)], AccumulationChart2.prototype, "titleStyle", void 0);
    __decorate9([Property(null)], AccumulationChart2.prototype, "subTitle", void 0);
    __decorate9([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, TitleStyleSettings)], AccumulationChart2.prototype, "subTitleStyle", void 0);
    __decorate9([Complex({}, LegendSettings)], AccumulationChart2.prototype, "legendSettings", void 0);
    __decorate9([Complex({}, TooltipSettings)], AccumulationChart2.prototype, "tooltip", void 0);
    __decorate9([Complex({}, CenterLabel)], AccumulationChart2.prototype, "centerLabel", void 0);
    __decorate9([Property("None")], AccumulationChart2.prototype, "selectionMode", void 0);
    __decorate9([Property("")], AccumulationChart2.prototype, "highlightColor", void 0);
    __decorate9([Property("None")], AccumulationChart2.prototype, "highlightMode", void 0);
    __decorate9([Property("None")], AccumulationChart2.prototype, "selectionPattern", void 0);
    __decorate9([Property("None")], AccumulationChart2.prototype, "highlightPattern", void 0);
    __decorate9([Property(false)], AccumulationChart2.prototype, "enableHtmlSanitizer", void 0);
    __decorate9([Property(true)], AccumulationChart2.prototype, "enableBorderOnMouseMove", void 0);
    __decorate9([Property(false)], AccumulationChart2.prototype, "isMultiSelect", void 0);
    __decorate9([Property(true)], AccumulationChart2.prototype, "enableAnimation", void 0);
    __decorate9([Collection([], Indexes)], AccumulationChart2.prototype, "selectedDataIndexes", void 0);
    __decorate9([Complex({}, Margin)], AccumulationChart2.prototype, "margin", void 0);
    __decorate9([Property(true)], AccumulationChart2.prototype, "enableSmartLabels", void 0);
    __decorate9([Complex({
      color: "#DDDDDD",
      width: 0
    }, Border)], AccumulationChart2.prototype, "border", void 0);
    __decorate9([Property(null)], AccumulationChart2.prototype, "background", void 0);
    __decorate9([Collection([{}], AccumulationSeries)], AccumulationChart2.prototype, "series", void 0);
    __decorate9([Collection([{}], AccumulationAnnotationSettings)], AccumulationChart2.prototype, "annotations", void 0);
    __decorate9([Property("Material")], AccumulationChart2.prototype, "theme", void 0);
    __decorate9([Property(false)], AccumulationChart2.prototype, "useGroupingSeparator", void 0);
    __decorate9([Property(true)], AccumulationChart2.prototype, "enableExport", void 0);
    __decorate9([Property(false)], AccumulationChart2.prototype, "allowExport", void 0);
    __decorate9([Complex({}, Accessibility)], AccumulationChart2.prototype, "accessibility", void 0);
    __decorate9([Property(null)], AccumulationChart2.prototype, "focusBorderColor", void 0);
    __decorate9([Property(1.5)], AccumulationChart2.prototype, "focusBorderWidth", void 0);
    __decorate9([Property(0)], AccumulationChart2.prototype, "focusBorderMargin", void 0);
    __decorate9([Event()], AccumulationChart2.prototype, "loaded", void 0);
    __decorate9([Event()], AccumulationChart2.prototype, "legendClick", void 0);
    __decorate9([Event()], AccumulationChart2.prototype, "load", void 0);
    __decorate9([Event()], AccumulationChart2.prototype, "seriesRender", void 0);
    __decorate9([Event()], AccumulationChart2.prototype, "legendRender", void 0);
    __decorate9([Event()], AccumulationChart2.prototype, "textRender", void 0);
    __decorate9([Event()], AccumulationChart2.prototype, "tooltipRender", void 0);
    __decorate9([Event()], AccumulationChart2.prototype, "pointRender", void 0);
    __decorate9([Event()], AccumulationChart2.prototype, "annotationRender", void 0);
    __decorate9([Event()], AccumulationChart2.prototype, "beforePrint", void 0);
    __decorate9([Event()], AccumulationChart2.prototype, "chartMouseMove", void 0);
    __decorate9([Event()], AccumulationChart2.prototype, "chartMouseClick", void 0);
    __decorate9([Event()], AccumulationChart2.prototype, "chartDoubleClick", void 0);
    __decorate9([Event()], AccumulationChart2.prototype, "pointClick", void 0);
    __decorate9([Event()], AccumulationChart2.prototype, "pointMove", void 0);
    __decorate9([Event()], AccumulationChart2.prototype, "animationComplete", void 0);
    __decorate9([Event()], AccumulationChart2.prototype, "chartMouseDown", void 0);
    __decorate9([Event()], AccumulationChart2.prototype, "chartMouseLeave", void 0);
    __decorate9([Event()], AccumulationChart2.prototype, "chartMouseUp", void 0);
    __decorate9([Event()], AccumulationChart2.prototype, "beforeResize", void 0);
    __decorate9([Event()], AccumulationChart2.prototype, "resized", void 0);
    __decorate9([Event()], AccumulationChart2.prototype, "beforeExport", void 0);
    __decorate9([Event()], AccumulationChart2.prototype, "afterExport", void 0);
    __decorate9([Event()], AccumulationChart2.prototype, "selectionComplete", void 0);
    __decorate9([Property("USD")], AccumulationChart2.prototype, "currencyCode", void 0);
    AccumulationChart2 = __decorate9([NotifyPropertyChanges], AccumulationChart2);
    return AccumulationChart2;
  }(Component)
);

// node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/triangular-base.js
var __extends68 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TriangularBase = (
  /** @class */
  function(_super) {
    __extends68(TriangularBase2, _super);
    function TriangularBase2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    TriangularBase2.prototype.initProperties = function(chart, series) {
      var actualChartArea = chart.initialClipRect;
      series.triangleSize = new Size(stringToNumber(series.width, actualChartArea.width), stringToNumber(series.height, actualChartArea.height));
      series.neckSize = new Size(stringToNumber(series.neckWidth, actualChartArea.width), stringToNumber(series.neckHeight, actualChartArea.height));
      this.defaultLabelBound(series, series.dataLabel.visible, series.dataLabel.position, chart);
      if (series.explodeOffset === "30%") {
        series.explodeOffset = "25px";
      }
      chart.explodeDistance = stringToNumber(series.explodeOffset, actualChartArea.width);
      var points = series.points;
      this.initializeSizeRatio(points, series);
    };
    TriangularBase2.prototype.initializeSizeRatio = function(points, series, reverse) {
      if (reverse === void 0) {
        reverse = false;
      }
      var sumOfPoints = series.sumOfPoints;
      var gapRatio = Math.min(Math.max(series.gapRatio, 0), 1);
      var coEff = sumOfPoints !== 0 ? 1 / (sumOfPoints * (1 + gapRatio / (1 - gapRatio))) : 0;
      var spacing = gapRatio / (points.length - 1);
      var y = 0;
      for (var i = points.length - 1; i >= 0; i--) {
        var index = reverse ? points.length - 1 - i : i;
        if (points[index].visible) {
          var height = coEff * points[index].y;
          points[index].yRatio = y;
          points[index].heightRatio = height;
          y += height + spacing;
        }
      }
    };
    TriangularBase2.prototype.setLabelLocation = function(series, point, points) {
      var last = points.length - 1;
      var bottom = series.type === "Funnel" ? points.length - 2 : points.length - 1;
      var x = (points[0].x + points[bottom].x) / 2;
      var right = (points[1].x + points[bottom - 1].x) / 2;
      point.region = new Rect(x, points[0].y, right - x, points[bottom].y - points[0].y);
      point.symbolLocation = {
        x: point.region.x + point.region.width / 2,
        y: point.region.y + point.region.height / 2
      };
      point.labelOffset = {
        x: point.symbolLocation.x - (points[0].x + points[last].x) / 2,
        y: point.symbolLocation.y - (points[0].y + points[last].y) / 2
      };
    };
    TriangularBase2.prototype.getPath = function(locations, point, path, firstIndex, lastIndex, series) {
      var length = series.points.length;
      var borderRadius = series.borderRadius;
      var min = Math.min(point.region.width, point.region.height);
      var funnelMinimum = Math.min(series.neckSize.height, series.neckSize.width);
      if (funnelMinimum === 0) {
        funnelMinimum = series.neckSize.height === 0 && series.neckSize.width === 0 ? point.region.height : series.neckSize.width === 0 ? series.neckSize.height : series.neckSize.width;
      }
      borderRadius = borderRadius > min / 2 ? min / 2 : borderRadius;
      if (series.type === "Funnel") {
        borderRadius = borderRadius > funnelMinimum / 2 ? funnelMinimum / 2 : borderRadius;
      }
      var angle = Math.atan2(locations[1].x - locations[2].x, locations[1].y - locations[2].y);
      var temp = borderRadius;
      if (series.type === "Pyramid") {
        borderRadius = point.index === lastIndex && length !== 1 && firstIndex !== lastIndex ? 0 : borderRadius;
        path += locations[0].x - temp * Math.sin(-angle) + " " + (locations[0].y + -temp * Math.cos(angle)) + " Q" + locations[0].x + " " + locations[0].y + " " + (locations[0].x + borderRadius * Math.sin(-angle)) + " " + (locations[0].y + -borderRadius * Math.cos(-angle));
        path += " L" + (locations[1].x + borderRadius * Math.sin(-angle)) + " " + (locations[1].y + -borderRadius * Math.cos(angle));
        borderRadius = point.index === lastIndex ? temp : 0;
        path += " L" + (locations[2].x - temp * Math.sin(-angle)) + " " + (locations[2].y - -temp * Math.cos(angle)) + " Q" + locations[2].x + " " + locations[2].y + " " + (locations[2].x - borderRadius) + " " + locations[2].y;
        path += " L" + (locations[3].x + borderRadius) + " " + locations[3].y + " Q" + locations[3].x + " " + locations[3].y + " " + (locations[3].x + temp * Math.sin(-angle)) + " " + (locations[3].y - -temp * Math.cos(angle));
      }
      if (series.type === "Funnel") {
        borderRadius = point.index === firstIndex && length !== 1 && firstIndex !== lastIndex ? 0 : borderRadius;
        path += locations[0].x + -(borderRadius * Math.sin(-angle)) + " " + (locations[0].y + -borderRadius * Math.cos(angle)) + " Q" + locations[0].x + " " + locations[0].y + " " + (locations[0].x + borderRadius) + " " + locations[0].y;
        path += " L" + (locations[1].x - borderRadius) + " " + locations[1].y + " Q" + locations[1].x + " " + locations[1].y + " " + (locations[1].x - borderRadius * Math.sin(angle)) + " " + (locations[1].y + -borderRadius * Math.cos(angle));
        borderRadius = point.index === firstIndex ? temp : 0;
        if (series.neckWidth === "0%") {
          var middle = locations[5].x + (locations[3].x - locations[5].x) / 2;
          path += " L" + (locations[2].x + -borderRadius * Math.sin(-angle)) + " " + (locations[2].y - -borderRadius * Math.cos(angle)) + " Q" + middle + " " + locations[2].y + " " + (locations[5].x - -borderRadius * Math.sin(-angle)) + " " + (locations[2].y - -borderRadius * Math.cos(angle));
        } else {
          path = series.neckHeight !== "0%" && locations[2].y !== locations[3].y ? path += " L" + locations[2].x + " " + locations[2].y : path;
          var tempX = series.neckHeight === "0%" ? borderRadius * Math.sin(-angle) : 0;
          var tempY = series.neckHeight === "0%" ? -borderRadius * Math.cos(angle) : borderRadius;
          path += " L" + (locations[3].x - tempX) + " " + (locations[3].y - tempY) + " Q" + locations[3].x + " " + locations[3].y + " " + (locations[3].x - tempY) + " " + locations[3].y;
          path += " L" + (locations[4].x + tempY) + " " + locations[4].y + " Q" + locations[4].x + " " + locations[4].y + " " + (locations[4 + 1].x + tempX) + " " + (locations[4].y - tempY);
          path = series.neckHeight !== "0%" && locations[4].y !== locations[5].y ? path += " L" + locations[5].x + " " + locations[5].y : path;
        }
      }
      return path;
    };
    TriangularBase2.prototype.findPath = function(locations, point, series) {
      var path = "M ";
      var firstIndex = -1;
      var lastIndex = -1;
      for (var index = 0; index < series.points.length; index++) {
        if (series.points[index].visible) {
          if (firstIndex === -1) {
            firstIndex = index;
          }
          lastIndex = index;
        }
      }
      if (series.borderRadius && (point.index === lastIndex || point.index === firstIndex)) {
        path = this.getPath(locations, point, path, firstIndex, lastIndex, series);
      } else {
        for (var i = 0; i < locations.length; i++) {
          path += locations[i].x + " " + locations[i].y;
          if (i !== locations.length - 1) {
            path += " L ";
          }
        }
      }
      return path + " Z ";
    };
    TriangularBase2.prototype.defaultLabelBound = function(series, visible, position, chart) {
      var x = (chart.initialClipRect.width - series.triangleSize.width) / 2;
      var y = (chart.initialClipRect.height - series.triangleSize.height) / 2;
      var accumulationBound = new Rect(x, y, series.triangleSize.width, series.triangleSize.height);
      series.labelBound = new Rect(accumulationBound.x, accumulationBound.y, accumulationBound.width + accumulationBound.x, accumulationBound.height + accumulationBound.y);
      series.accumulationBound = accumulationBound;
      if (visible && position === "Outside") {
        series.labelBound = new Rect(Infinity, Infinity, -Infinity, -Infinity);
      }
    };
    return TriangularBase2;
  }(AccumulationBase)
);

// node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/funnel-series.js
var __extends69 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var FunnelSeries = (
  /** @class */
  function(_super) {
    __extends69(FunnelSeries2, _super);
    function FunnelSeries2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    FunnelSeries2.prototype.getSegmentData = function(point, series, chart) {
      var lineWidth;
      var topRadius;
      var bottomRadius;
      var endTop;
      var endBottom;
      var minRadius;
      var endMin;
      var bottomY;
      var area = series.triangleSize;
      var offset = 0;
      var extraSpace = (chart.initialClipRect.width - series.triangleSize.width) / 2;
      var emptySpaceAtLeft = extraSpace + chart.initialClipRect.x;
      var seriesTop = chart.initialClipRect.y + (chart.initialClipRect.height - area.height) / 2;
      var top = point.yRatio * area.height;
      var bottom = top + point.heightRatio * area.height;
      var neckSize = series.neckSize;
      lineWidth = neckSize.width + (area.width - neckSize.width) * ((area.height - neckSize.height - top) / (area.height - neckSize.height));
      topRadius = area.width / 2 - lineWidth / 2;
      endTop = topRadius + lineWidth;
      if (bottom > area.height - neckSize.height || area.height === neckSize.height) {
        lineWidth = neckSize.width;
      } else {
        lineWidth = neckSize.width + (area.width - neckSize.width) * ((area.height - neckSize.height - bottom) / (area.height - neckSize.height));
      }
      bottomRadius = area.width / 2 - lineWidth / 2;
      endBottom = bottomRadius + lineWidth;
      if (top >= area.height - neckSize.height) {
        topRadius = bottomRadius = minRadius = area.width / 2 - neckSize.width / 2;
        endTop = endBottom = endMin = area.width / 2 + neckSize.width / 2;
      } else if (bottom > area.height - neckSize.height) {
        minRadius = bottomRadius = area.width / 2 - lineWidth / 2;
        endMin = endBottom = minRadius + lineWidth;
        bottomY = area.height - neckSize.height;
      }
      top += seriesTop;
      bottom += seriesTop;
      bottomY += seriesTop;
      var line1 = {
        x: emptySpaceAtLeft + offset + topRadius,
        y: top
      };
      var line2 = {
        x: emptySpaceAtLeft + offset + endTop,
        y: top
      };
      var line4 = {
        x: emptySpaceAtLeft + offset + endBottom,
        y: bottom
      };
      var line5 = {
        x: emptySpaceAtLeft + offset + bottomRadius,
        y: bottom
      };
      var line3 = {
        x: emptySpaceAtLeft + offset + endBottom,
        y: bottom
      };
      var line6 = {
        x: emptySpaceAtLeft + offset + bottomRadius,
        y: bottom
      };
      if (bottomY) {
        line3 = {
          x: emptySpaceAtLeft + offset + endMin,
          y: bottomY
        };
        line6 = {
          x: emptySpaceAtLeft + offset + minRadius,
          y: bottomY
        };
      }
      var polygon = [line1, line2, line3, line4, line5, line6];
      this.setLabelLocation(series, point, polygon);
      var direction = this.findPath(polygon, point, series);
      return direction;
    };
    FunnelSeries2.prototype.renderPoint = function(point, series, chart, options, seriesGroup, redraw, previousRadius, previousCenter, pointAnimation) {
      if (!point.visible) {
        removeElement2(options.id);
        return null;
      }
      var previousDirection;
      var direction = this.getSegmentData(point, series, chart);
      point.midAngle = 0;
      options.d = direction;
      if (pointAnimation && document.getElementById(options.id)) {
        previousDirection = document.getElementById(options.id).getAttribute("d");
      }
      var element = chart.renderer.drawPath(options);
      element.setAttribute("role", series.accessibility.accessibilityRole ? series.accessibility.accessibilityRole : "img");
      element.setAttribute("tabindex", point.index === 0 && series.accessibility.focusable ? String(series.accessibility.tabIndex) : "-1");
      element.setAttribute("aria-label", series.accessibility.accessibilityDescription ? series.accessibility.accessibilityDescription : point.x + ":" + point.y + "%. " + series.name);
      appendChildElement(false, seriesGroup, element, redraw, pointAnimation ? pointAnimation : void 0, pointAnimation ? "x" : void 0, pointAnimation ? "y" : void 0, void 0, pointAnimation ? previousDirection : void 0, void 0, void 0, void 0, pointAnimation ? chart.duration : void 0);
      if (point.isExplode) {
        chart.accBaseModule.explodePoints(point.index, chart, true);
      }
    };
    FunnelSeries2.prototype.renderTrapezoidalFunnel = function(series, points, chart, options, seriesGroup, redraw) {
      var funnelWidth = series.triangleSize.width;
      var funnelHeight = series.triangleSize.height;
      var horizontalMargin = (chart.initialClipRect.width - funnelWidth) / 2;
      var leftMargin = horizontalMargin + chart.initialClipRect.x;
      var funnelTop = chart.initialClipRect.y + (chart.initialClipRect.height - funnelHeight) / 2;
      var maxPointValue = Math.max.apply(Math, points.map(function(d) {
        return d.y;
      }));
      var barPadding = 10;
      var currentVerticalOffset = 0;
      var polygonGroup = redraw ? getElement2(chart.element.id + "_Series_" + series.index + "_Polygon") : chart.renderer.createGroup({
        id: chart.element.id + "_Series_" + series.index + "_Polygon"
      });
      for (var i = 0; i < series.points.length; i++) {
        var point = series.points[i];
        var pathOption = options[point.index];
        if (!point.visible) {
          removeElement2(pathOption.id);
          removeElement2(pathOption.id + "_polygon");
          continue;
        }
        var availableHeight = funnelHeight - barPadding * (points.length - 1);
        var barHeight = availableHeight / points.length;
        var barWidth = funnelWidth * (point.y / maxPointValue);
        var visiblePointIndex = points.indexOf(point);
        var nextBarWidth = visiblePointIndex < points.length - 1 ? funnelWidth * (points[visiblePointIndex + 1].y / maxPointValue) : 0;
        var x = leftMargin + (funnelWidth - barWidth) / 2;
        var y = funnelTop + currentVerticalOffset;
        var cornerRadius = Math.min(series.borderRadius, barHeight / 2);
        var rectPath = "M" + (x + cornerRadius) + " " + y + " L" + (x + barWidth - cornerRadius) + " " + y + " A" + cornerRadius + " " + cornerRadius + " 0 0 1 " + (x + barWidth) + " " + (y + cornerRadius) + " L" + (x + barWidth) + " " + (y + barHeight - cornerRadius) + " A" + cornerRadius + " " + cornerRadius + " 0 0 1 " + (x + barWidth - cornerRadius) + " " + (y + barHeight) + " L" + (x + cornerRadius) + " " + (y + barHeight) + " A" + cornerRadius + " " + cornerRadius + " 0 0 1 " + x + " " + (y + barHeight - cornerRadius) + " L" + x + " " + (y + cornerRadius) + " A" + cornerRadius + " " + cornerRadius + " 0 0 1 " + (x + cornerRadius) + " " + y + " Z";
        point.midAngle = 0;
        pathOption.d = rectPath;
        var element = chart.renderer.drawPath(pathOption);
        element.setAttribute("role", series.accessibility.accessibilityRole ? series.accessibility.accessibilityRole : "img");
        element.setAttribute("tabindex", point.index === 0 && series.accessibility.focusable ? String(series.accessibility.tabIndex) : "-1");
        element.setAttribute("aria-label", series.accessibility.accessibilityDescription ? series.accessibility.accessibilityDescription : point.x + ":" + point.y + "%. " + series.name);
        appendChildElement(false, seriesGroup, element, redraw);
        if (visiblePointIndex < points.length - 1) {
          var polygonOption = new PathOption(pathOption.id + "_polygon", this.lightenColor(pathOption.fill), pathOption["stroke-width"] * 0.4, this.lightenColor(pathOption.stroke), pathOption.opacity, pathOption["stroke-dasharray"], "");
          var trapezoidPoints = [[(funnelWidth - barWidth) / 2 + leftMargin + cornerRadius, y + barHeight], [(funnelWidth + barWidth) / 2 + leftMargin - cornerRadius, y + barHeight], [(funnelWidth + nextBarWidth) / 2 + leftMargin, y + barHeight + barPadding], [(funnelWidth - nextBarWidth) / 2 + leftMargin, y + barHeight + barPadding]];
          var trapezoidPath = "M" + trapezoidPoints[0][0] + " " + trapezoidPoints[0][1] + " L" + trapezoidPoints[1][0] + " " + trapezoidPoints[1][1] + " L" + trapezoidPoints[2][0] + " " + trapezoidPoints[2][1] + " L" + trapezoidPoints[3][0] + " " + trapezoidPoints[3][1] + " Z";
          polygonOption.d = trapezoidPath;
          var polygon = chart.renderer.drawPath(polygonOption);
          appendChildElement(false, polygonGroup, polygon, redraw);
        } else {
          removeElement2(pathOption.id + "_polygon");
        }
        currentVerticalOffset += barHeight + barPadding;
        point.region = new Rect(x, y, barWidth, barHeight);
        point.symbolLocation = {
          x: point.region.x + point.region.width / 2,
          y: point.region.y + point.region.height / 2
        };
        point.labelOffset = {
          x: point.symbolLocation.x + point.region.width / 2,
          y: point.symbolLocation.y + point.region.height / 2
        };
        if (point.isExplode) {
          chart.accBaseModule.explodePoints(point.index, chart, true);
        }
      }
      appendChildElement(false, chart.getSeriesElement(), seriesGroup, redraw);
      appendChildElement(false, chart.getSeriesElement(), polygonGroup, redraw);
    };
    FunnelSeries2.prototype.lightenColor = function(color) {
      var rgbValue = convertHexToColor(colorNameToHex(color));
      return "rgb(" + rgbValue.r + "," + rgbValue.g + "," + rgbValue.b + "," + 0.4 + ")";
    };
    FunnelSeries2.prototype.getModuleName = function() {
      return "FunnelSeries";
    };
    FunnelSeries2.prototype.destroy = function() {
    };
    return FunnelSeries2;
  }(TriangularBase)
);

// node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/pyramid-series.js
var __extends70 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PyramidSeries = (
  /** @class */
  function(_super) {
    __extends70(PyramidSeries2, _super);
    function PyramidSeries2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PyramidSeries2.prototype.getSegmentData = function(point, series, chart) {
      var area = series.triangleSize;
      var seriesTop = chart.initialClipRect.y + (chart.initialClipRect.height - area.height) / 2;
      var offset = 0;
      var extraSpace = (chart.initialClipRect.width - series.triangleSize.width) / 2;
      var emptySpaceAtLeft = extraSpace + chart.initialClipRect.x;
      var top = point.yRatio;
      var bottom = point.yRatio + point.heightRatio;
      var topRadius = 0.5 * (1 - point.yRatio);
      var bottomRadius = 0.5 * (1 - bottom);
      top += seriesTop / area.height;
      bottom += seriesTop / area.height;
      var line1 = {
        x: emptySpaceAtLeft + offset + topRadius * area.width,
        y: top * area.height
      };
      var line2 = {
        x: emptySpaceAtLeft + offset + (1 - topRadius) * area.width,
        y: top * area.height
      };
      var line3 = {
        x: emptySpaceAtLeft + offset + (1 - bottomRadius) * area.width,
        y: bottom * area.height
      };
      var line4 = {
        x: emptySpaceAtLeft + offset + bottomRadius * area.width,
        y: bottom * area.height
      };
      var polygon = [line1, line2, line3, line4];
      this.setLabelLocation(series, point, polygon);
      var direction = this.findPath(polygon, point, series);
      return direction;
    };
    PyramidSeries2.prototype.initializeSizeRatio = function(points, series) {
      if (series.pyramidMode === "Linear") {
        _super.prototype.initializeSizeRatio.call(this, points, series, true);
      } else {
        this.calculateSurfaceSegments(series);
      }
    };
    PyramidSeries2.prototype.calculateSurfaceSegments = function(series) {
      var count = series.points.length;
      var sumOfValues = series.sumOfPoints;
      var y = [];
      var height = [];
      var gapRatio = Math.min(0, Math.max(series.gapRatio, 1));
      var gapHeight = series.points.length > 1 ? gapRatio / (count - 1) : 0;
      var preSum = this.getSurfaceHeight(0, sumOfValues);
      var currY = 0;
      for (var i = 0; i < count; i++) {
        if (series.points[i].visible) {
          y[i] = currY;
          height[i] = this.getSurfaceHeight(currY, Math.abs(series.points[i].y));
          currY += height[i] + gapHeight * preSum;
        }
      }
      var coef = 1 / (currY - gapHeight * preSum);
      for (var i = 0; i < count; i++) {
        if (series.points[i].visible) {
          series.points[i].yRatio = coef * y[i];
          series.points[i].heightRatio = coef * height[i];
        }
      }
    };
    PyramidSeries2.prototype.getSurfaceHeight = function(y, surface) {
      var result = this.solveQuadraticEquation(1, 2 * y, -surface);
      return result;
    };
    PyramidSeries2.prototype.solveQuadraticEquation = function(a, b, c) {
      var root1;
      var root2;
      var d = b * b - 4 * a * c;
      if (d >= 0) {
        var sd = Math.sqrt(d);
        root1 = (-b - sd) / (2 * a);
        root2 = (-b + sd) / (2 * a);
        return Math.max(root1, root2);
      }
      return 0;
    };
    PyramidSeries2.prototype.renderPoint = function(point, series, chart, options, seriesGroup, redraw, previousRadius, previousCenter, pointAnimation) {
      if (!point.visible) {
        removeElement(options.id);
        return null;
      }
      var previousDirection;
      options.d = this.getSegmentData(point, series, chart);
      if (pointAnimation && document.getElementById(options.id)) {
        previousDirection = document.getElementById(options.id).getAttribute("d");
      }
      point.midAngle = 0;
      var element = chart.renderer.drawPath(options);
      element.setAttribute("role", series.accessibility.accessibilityRole ? series.accessibility.accessibilityRole : "img");
      element.setAttribute("tabindex", point.index === 0 && series.accessibility.focusable ? String(series.accessibility.tabIndex) : "-1");
      element.setAttribute("aria-label", series.accessibility.accessibilityDescription ? series.accessibility.accessibilityDescription : point.x + ": " + point.y + "%. " + series.name);
      appendChildElement(false, seriesGroup, element, redraw, pointAnimation ? pointAnimation : void 0, pointAnimation ? "x" : void 0, pointAnimation ? "y" : void 0, void 0, pointAnimation ? previousDirection : void 0, void 0, void 0, void 0, pointAnimation ? chart.duration : void 0);
      if (point.isExplode) {
        chart.accBaseModule.explodePoints(point.index, chart, true);
      }
    };
    PyramidSeries2.prototype.getModuleName = function() {
      return "PyramidSeries";
    };
    PyramidSeries2.prototype.destroy = function() {
    };
    return PyramidSeries2;
  }(TriangularBase)
);

// node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/legend.js
var __extends71 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var AccumulationLegend = (
  /** @class */
  function(_super) {
    __extends71(AccumulationLegend2, _super);
    function AccumulationLegend2(chart) {
      var _this = _super.call(this, chart) || this;
      _this.library = _this;
      _this.titleRect = new Rect(0, chart.margin.top, 0, 0);
      _this.addEventListener();
      return _this;
    }
    AccumulationLegend2.prototype.addEventListener = function() {
      if (this.chart.isDestroyed) {
        return;
      }
      this.chart.on(Browser.touchMoveEvent, this.mouseMove, this);
      this.chart.on(Browser.touchEndEvent, this.mouseEnd, this);
      this.chart.on("click", this.click, this);
    };
    AccumulationLegend2.prototype.removeEventListener = function() {
      if (this.chart.isDestroyed) {
        return;
      }
      this.chart.off(Browser.touchMoveEvent, this.mouseMove);
      this.chart.off("click", this.click);
      this.chart.off(Browser.touchEndEvent, this.mouseEnd);
    };
    AccumulationLegend2.prototype.mouseMove = function(e) {
      if (this.chart.legendSettings.visible && !this.chart.isTouch) {
        if (this.chart.accumulationHighlightModule && this.chart.highlightMode !== "None") {
          if (!this.chart.legendSettings.toggleVisibility) {
            this.click(e);
          }
          var legendItemsId = [this.legendID + "_text_", this.legendID + "_shape_marker_", this.legendID + "_shape_", this.legendID + "_g_"];
          var targetId = e.target.id;
          var index = void 0;
          for (var _i = 0, legendItemsId_1 = legendItemsId; _i < legendItemsId_1.length; _i++) {
            var id = legendItemsId_1[_i];
            if (targetId.indexOf(id) > -1) {
              index = parseInt(targetId.split(id)[1], 10);
              this.chart.accumulationHighlightModule.legendSelection(this.chart, 0, index, e.target, e.type);
              break;
            }
          }
        }
      }
    };
    AccumulationLegend2.prototype.mouseEnd = function(e) {
      if (this.chart.legendSettings.visible && this.chart.isTouch) {
        this.move(e);
      }
    };
    AccumulationLegend2.prototype.getLegendOptions = function(chart, series) {
      this.legendCollections = [];
      this.isRtlEnable = chart.enableRtl;
      this.isReverse = !this.isRtlEnable && chart.legendSettings.reverse;
      for (var i = 0; i < 1; i++) {
        var seriesType = series[i].type;
        if (seriesType === "Pie" || seriesType === "Doughnut") {
          seriesType = series[i].innerRadius !== "0" && series[i].innerRadius !== "0%" ? "Doughnut" : "Pie";
        }
        for (var _i = 0, _a = series[i].points; _i < _a.length; _i++) {
          var point = _a[_i];
          if (!isNullOrUndefined(point.x) && !isNullOrUndefined(point.y)) {
            this.legendCollections.push(new LegendOptions(chart.useGroupingSeparator && typeof point.x === "number" ? chart.intl.formatNumber(point.x, {
              useGrouping: true
            }) : point.x.toString(), point.color, series[i].legendShape, point.visible, seriesType, point.legendImageUrl, null, null, point.index, series[i].index, null, point.x.toString()));
          }
        }
        if (this.isReverse) {
          this.legendCollections.reverse();
        }
      }
    };
    AccumulationLegend2.prototype.getLegendBounds = function(availableSize, legendBounds, legend) {
      this.calculateLegendTitle(legend, legendBounds);
      this.isTitle = legend.title ? true : false;
      var extraWidth = 0;
      var extraHeight = 0;
      var legendOption;
      this.chartRowCount = 1;
      this.rowHeights = [];
      this.columnHeights = [];
      this.pageHeights = [];
      var padding = legend.padding;
      var titlePosition = legend.titlePosition;
      var titlePlusArrowSpace = 0;
      var arrowWidth = this.arrowWidth;
      var arrowHeight = legend.enablePages ? 0 : this.arrowHeight;
      if (!this.isVertical) {
        extraHeight = !legend.height ? availableSize.height / 100 * 5 : 0;
      } else {
        extraWidth = !legend.width ? availableSize.width / 100 * 5 : 0;
      }
      legendBounds.width += extraWidth;
      legendBounds.height += extraHeight;
      var shapePadding = legend.shapePadding;
      var maximumWidth = legend.maximumLabelWidth ? legend.maximumLabelWidth : 0;
      var shapeWidth = legend.shapeWidth;
      var rowWidth = 0;
      var columnCount = 0;
      var rowCount = 0;
      var columnWidth = [];
      var pageWidth = [];
      var pageRowWidth = 0;
      var previousRowCount = 0;
      var columnHeight = 0;
      var legendWidth = 0;
      var titleHeight = 0;
      this.maxItemHeight = Math.max(measureText("MeasureText", legend.textStyle, this.chart.themeStyle.legendLabelFont).height, legend.shapeHeight);
      var legendEventArgs;
      var render = false;
      var maxColumn = legend.layout === "Auto" && legend.maximumColumns > 0;
      if (legend.fixedWidth) {
        for (var i = 0; i < this.legendCollections.length; i++) {
          var textWidth = shapeWidth + shapePadding + (!this.isVertical ? i === 0 ? padding : this.itemPadding : padding) + (legend.maximumLabelWidth ? legend.maximumLabelWidth : measureText(this.legendCollections[i].text, legend.textStyle, this.chart.themeStyle.legendLabelFont).width);
          this.maxColumnWidth = this.maxColumnWidth > textWidth ? this.maxColumnWidth : textWidth;
        }
      }
      for (var i = 0; i < this.legendCollections.length; i++) {
        legendOption = this.legendCollections[i];
        legendEventArgs = {
          fill: legendOption.fill,
          text: legendOption.text,
          shape: legendOption.shape,
          name: "legendRender",
          cancel: false
        };
        this.chart.trigger("legendRender", legendEventArgs);
        legendOption.render = !legendEventArgs.cancel;
        legendOption.text = legendOption.originalText = legendEventArgs.text.indexOf("&") > -1 ? this.convertHtmlEntities(legendEventArgs.text) : legendEventArgs.text;
        legendOption.fill = legendEventArgs.fill;
        legendOption.shape = legendEventArgs.shape;
        legendOption.textSize = measureText(legendOption.text, legend.textStyle, this.chart.themeStyle.legendLabelFont);
        if (legendOption.render && legendOption.text !== "") {
          render = true;
          legendWidth = legend.fixedWidth ? this.maxColumnWidth : shapeWidth + shapePadding + (legend.maximumLabelWidth ? legend.maximumLabelWidth : legendOption.textSize.width) + (!this.isVertical || legend.layout === "Horizontal" ? i === 0 || columnCount === 1 && rowCount > 0 && legend.layout === "Horizontal" ? padding : this.itemPadding : padding);
          this.getLegendHeight(legendOption, legend, legendBounds, rowWidth, this.maxItemHeight, padding);
          if (this.isVertical && legend.layout === "Auto" && !maxColumn) {
            columnHeight += Math.max(legendOption.textSize.height, legend.shapeHeight) + (i === 0 ? padding : this.itemPadding);
            if (columnHeight + this.itemPadding + arrowHeight / this.pageButtonSize > legendBounds.height) {
              rowWidth = rowWidth + maximumWidth;
              pageRowWidth = this.getPageWidth(pageWidth);
              this.totalPages = Math.max(rowCount, this.totalPages || 1);
              if (rowWidth - pageRowWidth + legendWidth > legendBounds.width) {
                pageWidth.push(rowWidth - pageRowWidth);
                rowCount = this.rowHeights.length;
                previousRowCount = rowCount;
              } else {
                rowCount = previousRowCount;
              }
              columnWidth.push(maximumWidth);
              maximumWidth = 0;
              columnHeight = Math.max(legendOption.textSize.height, legend.shapeHeight) + padding;
              columnCount++;
            }
            this.columnHeights[columnCount] = (this.columnHeights[columnCount] ? this.columnHeights[columnCount] : 0) + Math.max(legendOption.textSize.height, legend.shapeHeight) + (i === 0 ? padding : this.itemPadding);
            maximumWidth = Math.max(legendWidth, maximumWidth);
            this.rowHeights[rowCount] = Math.max(this.rowHeights[rowCount] ? this.rowHeights[rowCount] : 0, Math.max(legendOption.textSize.height, legend.shapeHeight));
            rowCount++;
          } else {
            if (!legend.enablePages) {
              titlePlusArrowSpace = this.isTitle && titlePosition !== "Top" ? this.legendTitleSize.width + this.fivePixel : 0;
              titlePlusArrowSpace += arrowWidth;
            }
            rowWidth = rowWidth + legendWidth;
            if (maxColumn ? legend.maximumColumns === columnCount : legendBounds.width < padding + rowWidth + titlePlusArrowSpace || this.legend.layout === "Vertical" && columnCount === 1) {
              maximumWidth = Math.max(maximumWidth, rowWidth + padding + titlePlusArrowSpace - legendWidth);
              if (rowCount === 0 && legendWidth !== rowWidth) {
                rowCount = 1;
              }
              rowWidth = legendWidth;
              rowCount++;
              columnCount = 0;
            }
            var len = rowCount ? rowCount - 1 : rowCount;
            this.rowHeights[len] = Math.max(this.rowHeights[len] ? this.rowHeights[len] : 0, Math.max(legendOption.textSize.height, legend.shapeHeight));
            this.columnHeights[columnCount] = (this.columnHeights[columnCount] ? this.columnHeights[columnCount] : 0) + Math.max(legendOption.textSize.height, legend.shapeHeight) + padding;
            if (maxColumn && this.columnHeights[columnCount] > legendBounds.height) {
              this.columnHeights[columnCount] -= Math.max(legendOption.textSize.height, legend.shapeHeight) + padding;
            }
            columnCount++;
          }
        }
      }
      titleHeight = titlePosition === "Top" ? this.legendTitleSize.height : 0;
      if (this.isVertical && legend.layout === "Auto" && !maxColumn) {
        rowWidth = rowWidth + maximumWidth;
        this.isPaging = legendBounds.width < rowWidth + padding;
        columnHeight = Math.max.apply(null, this.columnHeights) + padding + arrowHeight + titleHeight;
        columnHeight = Math.max(columnHeight, (this.totalPages || 1) * (this.maxItemHeight + padding) + padding + arrowHeight);
        this.isPaging = this.isPaging && this.totalPages > 1;
        columnWidth.push(maximumWidth);
      } else {
        this.totalPages = this.totalRowCount = rowCount;
        columnHeight = Math.max.apply(null, this.columnHeights) + padding + arrowHeight + titleHeight;
        this.isPaging = (legendBounds.height < columnHeight || legend.layout === "Horizontal" && this.rowHeights.length > 1) && !maxColumn;
        columnHeight = !legend.enablePages && this.isPaging && legend.layout !== "Vertical" ? this.maxItemHeight + padding + padding + titleHeight : columnHeight;
        columnHeight = Math.max(columnHeight, this.maxItemHeight + padding + padding + titleHeight);
        if (legend.layout === "Horizontal") {
          columnHeight = this.maxItemHeight + padding * 2 + titleHeight + this.pageButtonSize + legend.border.width;
        }
        if (!this.isPaging) {
          rowWidth += this.isTitle && titlePosition !== "Top" ? this.fivePixel + this.legendTitleSize.width + this.fivePixel : 0;
        }
      }
      this.maxColumns = 0;
      var width;
      if (maxColumn && this.maxColumnWidth && legend.fixedWidth) {
        width = this.maxColumnWidth * legend.maximumColumns + padding;
        this.isPaging = false;
      } else {
        width = this.isVertical && legend.layout === "Auto" && !maxColumn ? this.getMaxColumn(columnWidth, legendBounds.width, padding, rowWidth + padding) : Math.max(rowWidth + padding, maximumWidth);
      }
      if (render) {
        this.setBounds(width, columnHeight, legend, legendBounds);
      } else {
        this.setBounds(0, 0, legend, legendBounds);
      }
    };
    AccumulationLegend2.prototype.getPageWidth = function(pageWidth) {
      var sum2 = 0;
      for (var i = 0; i < pageWidth.length; i++) {
        sum2 += pageWidth[i];
      }
      return sum2;
    };
    AccumulationLegend2.prototype.getLegendHeight = function(option, legend, bounds, rowWidth, legendHeight, padding) {
      var legendWidth = option.textSize.width;
      var textPadding = legend.shapePadding + padding * 2 + legend.shapeWidth;
      switch (legend.textWrap) {
        case "Wrap":
        case "AnyWhere":
          if (legendWidth > legend.maximumLabelWidth || legendWidth + rowWidth > bounds.width) {
            option.textCollection = textWrap(option.text, legend.maximumLabelWidth ? Math.min(legend.maximumLabelWidth, bounds.width - textPadding) : bounds.width - textPadding, legend.textStyle, this.chart.enableRtl, legend.textWrap === "AnyWhere", null, this.chart.themeStyle.legendLabelFont);
          } else {
            option.textCollection.push(option.text);
          }
          option.textSize.height = legendHeight * option.textCollection.length;
          break;
      }
    };
    AccumulationLegend2.prototype.convertHtmlEntities = function(legendText) {
      var text = legendText.replace("&amp;", "&").replace("&lt;", "<").replace("&gt;", ">").replace("&quot;", '"').replace("&nbsp;", " ").replace("&cent;", "").replace("&pound;", "").replace("&yen;", "").replace("&euro;", "").replace("&copy;", "").replace("&reg;", "");
      text = text.replace("&#38;", "&").replace("&#60;", "<").replace("&#62;", ">").replace("&#34;", '"').replace("&#160;", " ").replace("&#162;", "").replace("&#163;", "").replace("&#165;", "").replace("&#8364;", "").replace("&#169;", "").replace("&#174;", "");
      return text;
    };
    AccumulationLegend2.prototype.getMaxColumn = function(columns, width, padding, rowWidth) {
      var maxPageColumn = padding;
      this.maxColumnWidth = Math.max.apply(null, columns);
      for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
        var column = columns_1[_i];
        maxPageColumn += this.maxColumnWidth;
        this.maxColumns++;
        if (maxPageColumn + padding > width) {
          maxPageColumn -= this.maxColumnWidth;
          this.maxColumns--;
          break;
        }
      }
      this.isPaging = maxPageColumn < rowWidth && this.totalPages > 1;
      if (maxPageColumn === padding) {
        maxPageColumn = width;
      }
      this.maxColumns = Math.max(1, this.maxColumns);
      this.maxWidth = maxPageColumn;
      var columnWidth = this.maxColumnWidth + padding;
      var prevPage = 0;
      var columnCount = this.columnHeights.length;
      if (this.isPaging && this.isVertical) {
        for (var i = 1; i < columnCount; i++) {
          columnWidth += this.maxColumnWidth + padding;
          if (columnWidth > width) {
            this.pageHeights.push(prevPage !== i - 1 ? Math.max.apply(null, this.columnHeights.slice(prevPage, i - 1)) : this.columnHeights[prevPage]);
            columnWidth = this.maxColumnWidth + padding;
            prevPage = i;
          }
        }
        this.pageHeights.push(prevPage !== columnCount - 1 ? Math.max.apply(null, this.columnHeights.slice(prevPage, columnCount - 1)) : this.columnHeights[prevPage]);
        this.totalPages = this.pageHeights.length;
      }
      return maxPageColumn;
    };
    AccumulationLegend2.prototype.getAvailWidth = function(tx, width) {
      if (this.isVertical && this.legend.layout === "Auto" && !(this.legend.maximumColumns > 0)) {
        width = this.maxWidth;
      } else if (!this.isVertical && this.legend.layout !== "Vertical" && !(this.legend.maximumColumns > 0) && this.isPaging && !this.legend.enablePages) {
        return width - tx - this.fivePixel;
      }
      return width - (this.legend.padding * 2 + this.legend.shapeWidth + this.legend.shapePadding);
    };
    AccumulationLegend2.prototype.getRenderPoint = function(legendOption, start, textPadding, prevLegend, rect, count, firstLegend) {
      var padding = this.legend.padding;
      var previousLocation = prevLegend.location.y + this.maxItemHeight / 4 + (prevLegend.textCollection.length > 0 ? (prevLegend.textCollection.length - 1) * this.maxItemHeight : 0);
      if (this.isVertical && this.legend.layout === "Auto" && !(this.legend.maximumColumns > 0)) {
        if (count === firstLegend || previousLocation + Math.max(legendOption.textSize.height, this.legend.shapeHeight) + padding > rect.y + rect.height) {
          legendOption.location.x = prevLegend.location.x + (count === firstLegend ? 0 : !this.isRtlEnable ? this.maxColumnWidth : -this.maxColumnWidth);
          legendOption.location.y = start.y;
          var textStartLoc = this.legend.shapeWidth / 2 + padding;
          this.pageXCollections.push(legendOption.location.x + (!this.isRtlEnable ? -textStartLoc : textStartLoc));
        } else {
          legendOption.location.x = prevLegend.location.x;
          legendOption.location.y = prevLegend.location.y + Math.max(prevLegend.textSize.height, this.legend.shapeHeight) + this.itemPadding;
        }
      } else {
        var textWidth = this.legend.fixedWidth ? this.maxColumnWidth : textPadding + (this.legend.maximumLabelWidth ? this.legend.maximumLabelWidth : prevLegend.textSize.width);
        var previousBound = prevLegend.location.x + (!this.isRtlEnable ? textWidth : -textWidth);
        if (this.legend.layout === "Auto" && this.legend.maximumColumns > 0 ? count % this.legend.maximumColumns === 0 : this.isWithinBounds(previousBound, (this.legend.maximumLabelWidth ? this.legend.maximumLabelWidth : legendOption.textSize.width) + textPadding - this.itemPadding, rect, this.legend.shapeWidth / 2) || this.legend.layout === "Vertical") {
          if (count !== firstLegend) {
            this.chartRowCount++;
          }
          legendOption.location.y = count === firstLegend ? prevLegend.location.y : prevLegend.location.y + this.rowHeights[this.chartRowCount - 2] + padding;
          legendOption.location.x = start.x;
        } else {
          legendOption.location.y = prevLegend.location.y;
          legendOption.location.x = count === firstLegend ? prevLegend.location.x : previousBound;
        }
      }
      var availablewidth = this.getAvailWidth(legendOption.location.x, this.legendBounds.width);
      availablewidth = this.legend.maximumLabelWidth ? Math.min(this.legend.maximumLabelWidth, availablewidth) : availablewidth;
      if (this.legend.textOverflow === "Ellipsis" && this.legend.textWrap === "Normal") {
        legendOption.text = textTrim(+availablewidth.toFixed(4), legendOption.text, this.legend.textStyle, this.chart.enableRtl, this.chart.themeStyle.legendLabelFont);
      }
    };
    AccumulationLegend2.prototype.isWithinBounds = function(previousBound, textWidth, legendBounds, shapeWidth) {
      if (!this.isRtlEnable) {
        return previousBound + textWidth > legendBounds.x + legendBounds.width + shapeWidth;
      } else {
        return previousBound - textWidth < legendBounds.x - shapeWidth;
      }
    };
    AccumulationLegend2.prototype.getSmartLegendLocation = function(labelBound, legendBound, margin) {
      var space;
      switch (this.position) {
        case "Left":
          space = (labelBound.x - legendBound.width - margin.left) / 2;
          legendBound.x = labelBound.x - legendBound.width < margin.left ? legendBound.x : labelBound.x - legendBound.width - space;
          break;
        case "Right":
          space = (this.chart.availableSize.width - margin.right - (labelBound.x + labelBound.width + legendBound.width)) / 2;
          legendBound.x = labelBound.x + labelBound.width + legendBound.width > this.chart.availableSize.width - margin.right ? legendBound.x : labelBound.x + labelBound.width + space;
          break;
        case "Top":
          this.getTitleRect(this.chart);
          space = (labelBound.y - legendBound.height - (this.titleRect.y + this.titleRect.height)) / 2;
          legendBound.y = labelBound.y - legendBound.height < margin.top ? legendBound.y : labelBound.y - legendBound.height - space;
          break;
        case "Bottom":
          space = (this.chart.availableSize.height - margin.bottom - (labelBound.y + labelBound.height + legendBound.height)) / 2;
          legendBound.y = labelBound.y + labelBound.height + legendBound.height > this.chart.availableSize.height - margin.bottom ? legendBound.y : labelBound.y + labelBound.height + space;
          break;
      }
    };
    AccumulationLegend2.prototype.getTitleRect = function(accumulation) {
      if (!accumulation.title) {
        return null;
      }
      var titleSize = measureText(accumulation.title, accumulation.titleStyle, this.chart.themeStyle.legendTitleFont);
      this.titleRect = new Rect(accumulation.availableSize.width / 2 - titleSize.width / 2, accumulation.margin.top, titleSize.width, titleSize.height);
    };
    AccumulationLegend2.prototype.legendByIndex = function(index, legendCollections) {
      for (var _i = 0, legendCollections_1 = legendCollections; _i < legendCollections_1.length; _i++) {
        var legend = legendCollections_1[_i];
        if (legend.pointIndex === index) {
          return legend;
        }
      }
      return null;
    };
    AccumulationLegend2.prototype.click = function(event2) {
      var targetId = event2.target.id.indexOf("_chart_legend_g_") > -1 ? event2.target.firstChild["id"] : event2.target.id;
      var chart = this.chart;
      var legendItemsId = [this.legendID + "_text_", this.legendID + "_shape_", this.legendID + "_shape_marker_"];
      this.chart.animateSeries = false;
      for (var _i = 0, legendItemsId_2 = legendItemsId; _i < legendItemsId_2.length; _i++) {
        var id = legendItemsId_2[_i];
        if (targetId.indexOf(id) > -1) {
          var pointIndex = parseInt(targetId.split(id)[1], 10);
          if (this.chart.legendSettings.toggleVisibility && !isNaN(pointIndex)) {
            var currentSeries = this.chart.visibleSeries[0];
            var point = pointByIndex(pointIndex, currentSeries.points);
            var legendOption = this.legendByIndex(pointIndex, this.legendCollections);
            var legendClickArgs = {
              legendText: legendOption.text,
              legendShape: legendOption.shape,
              chart: chart.isBlazor ? {} : chart,
              series: currentSeries,
              point,
              name: legendClick,
              cancel: false
            };
            this.chart.trigger(legendClick, legendClickArgs);
            if (!legendClickArgs.cancel) {
              point.visible = !point.visible;
              legendOption.visible = point.visible;
              currentSeries.sumOfPoints += point.visible ? point.y : -point.y;
              chart.redraw = chart.enableAnimation;
              this.sliceVisibility(pointIndex, point.visible);
              chart.removeSvg();
              blazorTemplatesReset(chart);
              this.chart.refreshPoints(currentSeries.points);
              this.chart.calculateBounds();
              var borderElement = document.getElementById(this.chart.element.id + "PointHover_Border");
              if (borderElement) {
                this.chart.pieSeriesModule.removeBorder(borderElement, 0);
              }
              if (this.chart.accumulationTooltipModule) {
                this.chart.accumulationTooltipModule.removeTooltip(0);
              }
              this.chart.renderElements();
            }
          } else if (this.chart.accumulationSelectionModule && !isNaN(pointIndex)) {
            this.chart.accumulationSelectionModule.legendSelection(this.chart, 0, pointIndex, event2.target, event2.type);
          } else if (this.chart.accumulationHighlightModule && !isNaN(pointIndex)) {
            this.chart.accumulationHighlightModule.legendSelection(this.chart, 0, pointIndex, event2.target, event2.type);
          }
        }
      }
      if (targetId.indexOf(this.legendID + "_pageup") > -1) {
        this.changePage(event2, true);
      } else if (targetId.indexOf(this.legendID + "_pagedown") > -1) {
        this.changePage(event2, false);
      }
      chart.redraw = false;
    };
    AccumulationLegend2.prototype.sliceVisibility = function(index, isVisible) {
      var sliceId = this.chart.element.id + "_Series_0_Point_";
      if (this.chart.visibleSeries[0].dataLabel.visible) {
        sliceId = this.chart.element.id + "_datalabel_Series_0_";
        this.sliceAnimate(getElement2(sliceId + "g_" + index), isVisible);
      }
    };
    AccumulationLegend2.prototype.sliceAnimate = function(element, isVisible) {
      if (!element) {
        return null;
      }
      new Animation({}).animate(element, {
        duration: 300,
        delay: 0,
        name: isVisible ? "FadeIn" : "FadeOut",
        end: function(args) {
          args.element.style.visibility = isVisible ? "visible" : "hidden";
        }
      });
    };
    AccumulationLegend2.prototype.getModuleName = function() {
      return "AccumulationLegend";
    };
    AccumulationLegend2.prototype.destroy = function() {
      this.removeEventListener();
    };
    return AccumulationLegend2;
  }(BaseLegend)
);

// node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/dataLabel.js
var __extends72 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var AccumulationDataLabel = (
  /** @class */
  function(_super) {
    __extends72(AccumulationDataLabel2, _super);
    function AccumulationDataLabel2(accumulation) {
      var _this = _super.call(this, accumulation) || this;
      _this.rightSideRenderingPoints = [];
      _this.leftSideRenderingPoints = [];
      _this.id = accumulation.element.id + "_datalabel_Series_";
      return _this;
    }
    AccumulationDataLabel2.prototype.getDataLabelPosition = function(point, dataLabel, textSize, points) {
      var radius = this.isCircular() ? !this.isVariousRadius() ? this.accumulation.pieSeriesModule.labelRadius : this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], point) : this.getLabelDistance(point, dataLabel);
      if (this.accumulation.title) {
        var titleSize = measureText(this.accumulation.title, this.accumulation.titleStyle, this.accumulation.themeStyle.datalabelFont);
        this.titleRect = new Rect(this.accumulation.availableSize.width / 2 - titleSize.width / 2, this.accumulation.margin.top, titleSize.width, titleSize.height);
      }
      this.getLabelRegion(point, dataLabel.position, textSize, radius, this.marginValue);
      point.labelAngle = point.midAngle;
      point.labelPosition = dataLabel.position;
      if (this.accumulation.enableSmartLabels) {
        this.getSmartLabel(point, dataLabel, textSize, points);
      }
    };
    AccumulationDataLabel2.prototype.getLabelRegion = function(point, position, textSize, labelRadius, margin, endAngle) {
      if (endAngle === void 0) {
        endAngle = 0;
      }
      var labelAngle = endAngle || point.midAngle;
      var space = 20;
      var location = degreeToLocation(labelAngle, labelRadius, this.isCircular() ? this.center : this.getLabelLocation(point, position));
      location.y = position === "Inside" ? location.y - textSize.height / 2 : location.y;
      location.x = position === "Inside" ? location.x - textSize.width / 2 : location.x;
      point.labelRegion = new Rect(location.x, location.y, textSize.width + margin * 2, textSize.height + margin * 2);
      if (position === "Outside") {
        point.labelRegion.y -= point.labelRegion.height / 2;
        if (labelAngle >= 90 && labelAngle <= 270) {
          point.labelRegion.x -= point.labelRegion.width + space;
        } else {
          point.labelRegion.x += space;
        }
      }
    };
    AccumulationDataLabel2.prototype.calculateLabelCollection = function(point, dataLabel) {
      if (point.argsData.template !== null) {
        return null;
      }
      var position = point.labelPosition || dataLabel.position;
      var labelRadius = this.isCircular() ? !this.isVariousRadius() ? this.accumulation.pieSeriesModule.labelRadius : this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], point) : this.getLabelDistance(point, dataLabel);
      var radius = !this.isVariousRadius() ? this.accumulation.pieSeriesModule.radius - this.accumulation.pieSeriesModule.innerRadius : this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], point);
      var location = degreeToLocation(point.midAngle, labelRadius, this.isCircular() ? this.center : this.getLabelLocation(point, position));
      var padding = 20;
      var maxWidth = dataLabel.maxWidth;
      if (!maxWidth) {
        if (position === "Outside") {
          maxWidth = this.isCircular() ? location.x >= this.center.x ? this.areaRect.x + this.areaRect.width - location.x : location.x - this.areaRect.x : location.x >= point.region.x ? this.areaRect.x + this.areaRect.width - location.x : location.x - this.areaRect.x;
        } else {
          maxWidth = this.isCircular() ? radius - padding : point.region.width;
        }
      }
      if (point.label.indexOf("<br>") !== -1) {
        point.labelCollection = point.label.split("<br>");
      } else if (dataLabel.textWrap === "Normal" && dataLabel.textOverflow === "Ellipsis") {
        point.labelCollection[0] = textTrim(maxWidth, point.label, point.argsData.font, this.accumulation.enableRtl, this.accumulation.themeStyle.datalabelFont);
      } else if (dataLabel.textWrap === "Wrap" || dataLabel.textWrap === "AnyWhere") {
        point.labelCollection = textWrap(point.label, maxWidth, point.argsData.font, this.accumulation.enableRtl, dataLabel.textWrap === "AnyWhere", dataLabel.textOverflow === "Clip", this.accumulation.themeStyle.datalabelFont);
      } else {
        point.labelCollection[0] = point.label;
      }
    };
    AccumulationDataLabel2.prototype.getTextSize = function(labelCollection, dataLabel) {
      var height = 0;
      var font = dataLabel.font;
      var width = dataLabel.maxWidth ? dataLabel.maxWidth : 0;
      var textSize;
      for (var i = 0; i < labelCollection.length; i++) {
        textSize = measureText(labelCollection[i], font, this.accumulation.themeStyle.datalabelFont);
        width = Math.max(textSize.width, width);
        height += textSize.height;
      }
      if (dataLabel.textOverflow === "Clip" && dataLabel.textWrap !== "Normal" && dataLabel.maxWidth) {
        width = dataLabel.maxWidth;
      }
      return new Size(width, height);
    };
    AccumulationDataLabel2.prototype.getSmartLabel = function(point, dataLabel, textSize, points) {
      var circular = this.isCircular();
      var labelRadius = circular ? this.radius : this.getLabelDistance(point, dataLabel);
      var connectorLength = circular ? dataLabel.connectorStyle.length || "4%" : "0px";
      labelRadius += stringToNumber(connectorLength, labelRadius);
      var previousPoint = this.findPreviousPoint(points, point.index, point.labelPosition);
      if (dataLabel.position === "Inside") {
        point.labelRegion.height -= 4;
        point.labelRegion.width -= 4;
        if (previousPoint && previousPoint.labelRegion && !dataLabel.enableRotation && (isOverlap(point.labelRegion, previousPoint.labelRegion) || this.isOverlapping(point, points)) || !circular && !containsRect(point.region, point.labelRegion)) {
          point.labelPosition = "Outside";
          if (!circular) {
            labelRadius = this.getLabelDistance(point, dataLabel);
          }
          this.calculateLabelCollection(point, dataLabel);
          textSize = this.getTextSize(point.labelCollection, dataLabel);
          textSize.height += 4;
          textSize.width += 4;
          point.textSize = textSize;
          this.getLabelRegion(point, point.labelPosition, textSize, labelRadius, this.marginValue);
          previousPoint = this.findPreviousPoint(points, point.index, point.labelPosition);
          if (previousPoint && (isOverlap(point.labelRegion, previousPoint.labelRegion) || this.isConnectorLineOverlapping(point, previousPoint))) {
            this.setOuterSmartLabel(previousPoint, point, dataLabel.border.width, labelRadius, textSize, this.marginValue);
          }
        }
      } else {
        if (previousPoint && previousPoint.labelRegion && (isOverlap(point.labelRegion, previousPoint.labelRegion) || this.isOverlapping(point, points) || this.isConnectorLineOverlapping(point, previousPoint))) {
          this.setOuterSmartLabel(previousPoint, point, dataLabel.border.width, labelRadius, textSize, this.marginValue);
        }
      }
      if (this.isOverlapping(point, points) && (this.accumulation.type === "Pyramid" || this.accumulation.type === "Funnel")) {
        var position = "OutsideLeft";
        var space = 20;
        var labelAngle = point.midAngle || 0;
        var labelRadius_1 = circular ? this.radius : this.getLabelDistance(point, dataLabel);
        var location_1 = degreeToLocation(labelAngle, -labelRadius_1, this.isCircular() ? this.center : this.getLabelLocation(point, position));
        point.labelRegion = new Rect(location_1.x, location_1.y, textSize.width + this.marginValue * 2, textSize.height + this.marginValue * 2);
        point.labelRegion.y -= point.labelRegion.height / 2;
        point.labelRegion.x = point.labelRegion.x - space - point.labelRegion.width;
        if (previousPoint && previousPoint.labelRegion && (isOverlap(point.labelRegion, previousPoint.labelRegion) || this.isOverlapping(point, points) || this.isConnectorLineOverlapping(point, previousPoint))) {
          this.setOuterSmartLabel(previousPoint, point, dataLabel.border.width, labelRadius_1, textSize, this.marginValue);
        }
      }
    };
    AccumulationDataLabel2.prototype.move = function(e, x, y, isTouch) {
      var _this = this;
      if (e.target.textContent.indexOf("...") > -1) {
        var targetId = e.target.id.split(this.id);
        if (targetId.length === 2) {
          var seriesIndex = parseInt(targetId[1].split("_text_")[0], 10);
          var pointIndex = parseInt(targetId[1].split("_text_")[1], 10);
          if (!isNaN(seriesIndex) && !isNaN(pointIndex)) {
            if (isTouch) {
              removeElement2(this.accumulation.element.id + "_EJ2_Datalabel_Tooltip");
            }
            var point = getSeriesFromIndex(seriesIndex, this.accumulation.visibleSeries).points[pointIndex];
            showTooltip(point.text || point.y.toString(), x, y, this.areaRect.width, this.accumulation.element.id + "_EJ2_Datalabel_Tooltip", getElement2(this.accumulation.element.id + "_Secondary_Element"), null, null, this.accumulation.initialClipRect);
          }
        }
      } else {
        removeElement2(this.accumulation.element.id + "_EJ2_Datalabel_Tooltip");
      }
      if (isTouch) {
        clearTimeout(this.clearTooltip);
        this.clearTooltip = +setTimeout(function() {
          removeElement2(_this.accumulation.element.id + "_EJ2_Datalabel_Tooltip");
        }, 1e3);
      }
    };
    AccumulationDataLabel2.prototype.findPreviousPoint = function(points, index, position) {
      var point = points[0];
      for (var i = index - 1; i >= 0; i--) {
        point = points[i];
        if (point.visible && point.labelVisible && point.labelRegion && point.labelPosition === position) {
          return point;
        }
      }
      return null;
    };
    AccumulationDataLabel2.prototype.isOverlapping = function(currentPoint, points) {
      for (var i = currentPoint.index - 1; i >= 0; i--) {
        if (points[i].visible && points[i].labelVisible && points[i].labelRegion && currentPoint.labelRegion && currentPoint.labelVisible && isOverlap(currentPoint.labelRegion, points[i].labelRegion)) {
          return true;
        }
      }
      return false;
    };
    AccumulationDataLabel2.prototype.textTrimming = function(point, rect, font, position, dataLabel) {
      if (isOverlap(point.labelRegion, rect)) {
        var size = point.labelRegion.width;
        if (position === "Right") {
          size = rect.x - point.labelRegion.x;
        } else if (position === "Left") {
          size = point.labelRegion.x - (rect.x + rect.width);
          if (size < 0) {
            size += point.labelRegion.width;
            point.labelRegion.x = rect.x + rect.width;
          }
        } else if (position === "InsideRight") {
          size = rect.x + rect.width - point.labelRegion.x;
        } else if (position === "InsideLeft") {
          size = point.labelRegion.x + point.labelRegion.width - rect.x;
          if (size < point.labelRegion.width) {
            point.labelRegion.x = rect.x;
          }
        } else if (this.accumulation.enableSmartLabels) {
          this.setPointVisibileFalse(point);
        }
        if (point.labelVisible && point.labelRegion) {
          if (point.label.indexOf("<br>") !== -1) {
            point.labelCollection = point.label.split("<br>");
          } else if (size < point.labelRegion.width) {
            if (dataLabel.textWrap === "Normal" && dataLabel.textOverflow === "Ellipsis") {
              point.labelCollection[0] = textTrim(size - this.marginValue * 2, point.label, font, this.accumulation.enableRtl, this.accumulation.themeStyle.datalabelFont);
            } else if (dataLabel.textWrap === "Wrap" || dataLabel.textWrap === "AnyWhere") {
              point.labelCollection = textWrap(point.label, size - this.marginValue * 2, font, this.accumulation.enableRtl, dataLabel.textWrap === "AnyWhere", dataLabel.textOverflow === "Clip", this.accumulation.themeStyle.datalabelFont);
            }
            point.labelRegion.width = size;
          }
          for (var i = 0; i < point.labelCollection.length; i++) {
            if (point.labelCollection[i].length === 3 && point.labelCollection[i].indexOf("...") > -1) {
              this.setPointVisibileFalse(point);
              break;
            }
          }
        }
      }
    };
    AccumulationDataLabel2.prototype.setPointVisibileFalse = function(point) {
      point.labelVisible = false;
      point.labelRegion = null;
    };
    AccumulationDataLabel2.prototype.setPointVisibleTrue = function(point) {
      point.labelVisible = true;
    };
    AccumulationDataLabel2.prototype.setOuterSmartLabel = function(previousPoint, point, border, labelRadius, textsize, margin) {
      if (!this.isCircular()) {
        this.setSmartLabelForSegments(point, previousPoint);
      } else {
        var labelAngle = this.getOverlappedAngle(previousPoint.labelRegion, point.labelRegion, point.midAngle, border * 2);
        this.getLabelRegion(point, "Outside", textsize, labelRadius, margin, labelAngle);
        if (labelAngle > point.endAngle) {
          labelAngle = point.midAngle;
        }
        point.labelAngle = labelAngle;
        while (point.labelVisible && (isOverlap(previousPoint.labelRegion, point.labelRegion) || labelAngle <= previousPoint.labelAngle || labelAngle <= point.midAngle * 0.9 || this.isConnectorLineOverlapping(point, previousPoint))) {
          if (labelAngle > point.endAngle) {
            break;
          }
          point.labelAngle = labelAngle;
          this.getLabelRegion(point, "Outside", textsize, labelRadius, margin, labelAngle);
          labelAngle += 0.1;
        }
      }
    };
    AccumulationDataLabel2.prototype.setSmartLabelForSegments = function(point, prevPoint) {
      var textRegion = point.labelRegion;
      var overlapHeight = this.accumulation.type === "Funnel" ? prevPoint.labelRegion.y - (textRegion.y + textRegion.height) : point.labelRegion.y - (prevPoint.labelRegion.y + prevPoint.labelRegion.height);
      if (overlapHeight < 0) {
        point.labelRegion.y += this.accumulation.type === "Funnel" ? overlapHeight : -overlapHeight;
      }
    };
    AccumulationDataLabel2.prototype.isConnectorLineOverlapping = function(point, previous) {
      var position;
      if (!this.isCircular() && point.labelRegion.x < point.region.x) {
        position = "outsideLeft";
      }
      var start = this.getLabelLocation(point, position);
      var end = new ChartLocation(0, 0);
      this.getEdgeOfLabel(point.labelRegion, point.labelAngle, end, 0, point);
      var previousstart = this.getLabelLocation(previous);
      var previousend = new ChartLocation(0, 0);
      this.getEdgeOfLabel(previous.labelRegion, previous.labelAngle, previousend, 0, point);
      return this.isLineRectangleIntersect(start, end, point.labelRegion) || this.isLineRectangleIntersect(start, end, previous.labelRegion) || this.isLineRectangleIntersect(previousstart, previousend, point.labelRegion);
    };
    AccumulationDataLabel2.prototype.isLineRectangleIntersect = function(line1, line2, rect) {
      var rectPoints = [new ChartLocation(Math.round(rect.x), Math.round(rect.y)), new ChartLocation(Math.round(rect.x + rect.width), Math.round(rect.y)), new ChartLocation(Math.round(rect.x + rect.width), Math.round(rect.y + rect.height)), new ChartLocation(Math.round(rect.x), Math.round(rect.y + rect.height))];
      line1.x = Math.round(line1.x);
      line1.y = Math.round(line1.y);
      line2.x = Math.round(line2.x);
      line2.y = Math.round(line2.y);
      for (var i = 0; i < rectPoints.length; i++) {
        if (this.isLinesIntersect(line1, line2, rectPoints[i], rectPoints[(i + 1) % rectPoints.length])) {
          return true;
        }
      }
      return false;
    };
    AccumulationDataLabel2.prototype.isLinesIntersect = function(point1, point2, point11, point12) {
      var a1 = point2.y - point1.y;
      var b1 = point1.x - point2.x;
      var c1 = a1 * point1.x + b1 * point1.y;
      var a2 = point12.y - point11.y;
      var b2 = point11.x - point12.x;
      var c2 = a2 * point11.x + b2 * point11.y;
      var delta = a1 * b2 - a2 * b1;
      if (delta !== 0) {
        var x = (b2 * c1 - b1 * c2) / delta;
        var y = (a1 * c2 - a2 * c1) / delta;
        var lies = Math.min(point1.x, point2.x) <= x && x <= Math.max(point1.x, point2.x);
        lies = lies && Math.min(point1.y, point2.y) <= y && y <= Math.max(point1.y, point2.y);
        lies = lies && Math.min(point11.x, point12.x) <= x && x <= Math.max(point11.x, point12.x);
        lies = lies && Math.min(point11.y, point12.y) <= y && y <= Math.max(point11.y, point12.y);
        return lies;
      }
      return false;
    };
    AccumulationDataLabel2.prototype.getOverlappedAngle = function(first, second, angle, padding) {
      var x = first.x;
      if (angle >= 90 && angle <= 270) {
        second.y = first.y - (padding + second.height / 2);
        x = first.x + first.width;
      } else {
        second.y = first.y + first.height + padding;
      }
      return getAngle(this.center, new ChartLocation(x, second.y));
    };
    AccumulationDataLabel2.prototype.getConnectorPath = function(label, point, dataLabel, end) {
      if (end === void 0) {
        end = 0;
      }
      var connector = dataLabel.connectorStyle;
      var labelRadius = this.isCircular() ? !this.isVariousRadius() ? this.labelRadius : this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], point) : this.getLabelDistance(point, dataLabel);
      var start = this.getConnectorStartPoint(point, connector);
      var labelAngle = this.accumulation.enableSmartLabels ? point.midAngle : end || point.midAngle;
      var middle = new ChartLocation(0, 0);
      var endPoint = this.getEdgeOfLabel(label, labelAngle, middle, connector.width, point);
      if (connector.type === "Curve") {
        if (this.isCircular()) {
          var r = labelRadius - (this.isVariousRadius() ? stringToNumber(point.sliceRadius, this.accumulation.pieSeriesModule.size / 2) : this.radius);
          if (point.isLabelUpdated) {
            middle = this.getPerpendicularDistance(start, point);
          } else {
            middle = degreeToLocation(labelAngle, labelRadius - r / 2, this.center);
            if (point.labelPosition === "Outside" && dataLabel.position === "Inside") {
              middle = degreeToLocation(labelAngle, labelRadius - r * 1.25, this.center);
            }
          }
          return "M " + start.x + " " + start.y + " Q " + middle.x + " " + middle.y + " " + endPoint.x + " " + endPoint.y;
        } else {
          return this.getPolyLinePath(start, endPoint);
        }
      } else {
        return "M " + start.x + " " + start.y + " L " + middle.x + " " + middle.y + " L " + endPoint.x + " " + endPoint.y;
      }
    };
    AccumulationDataLabel2.prototype.getPolyLinePath = function(start, end) {
      var controlPoints = [start, end];
      if (start.y === end.y) {
        return "M " + start.x + " " + start.y + " L " + end.x + " " + end.y;
      }
      var path = "M";
      for (var i = 0; i <= 16; i++) {
        var t = i / 16;
        var points = this.getBezierPoint(t, controlPoints, 0, 2);
        path += points.x + "," + points.y;
        if (i !== 16) {
          path += " L";
        }
      }
      return path;
    };
    AccumulationDataLabel2.prototype.getBezierPoint = function(t, controlPoints, index, count) {
      if (count === 1) {
        return controlPoints[index];
      }
      var p0 = this.getBezierPoint(t, controlPoints, index, count - 1);
      var p1 = this.getBezierPoint(t, controlPoints, index + 1, count - 1);
      var x = p0.x ? p0.x : p0.x;
      var y = p0.y ? p0.y : p0.y;
      var x1 = p1.x ? p1.x : p1.x;
      var y1 = p1.y ? p1.y : p1.y;
      var x2 = (1 - t) * x + t * x1;
      var y2 = (1 - t) * y + t * y1;
      if (p0.x) {
        return {
          x: x2,
          y: y2
        };
      } else {
        return {
          x: x2,
          y: y2
        };
      }
    };
    AccumulationDataLabel2.prototype.getEdgeOfLabel = function(labelshape, angle, middle, border, point) {
      if (border === void 0) {
        border = 1;
      }
      var edge = new ChartLocation(labelshape.x, labelshape.y);
      var space = 10;
      if (angle >= 90 && angle <= 270) {
        edge.x += labelshape.width + border / 2 + space;
        edge.y += labelshape.height / 2;
        middle.x = edge.x + 10;
        middle.y = edge.y;
      } else if (point && point.region && point.region.x > point.labelRegion.x) {
        edge.x += border * 2 + labelshape.width + space;
        edge.y += labelshape.height / 2;
        middle.x = edge.x + 10;
        middle.y = edge.y;
      } else {
        edge.x -= space - border / 2;
        edge.y += labelshape.height / 2;
        middle.x = edge.x - 10;
        middle.y = edge.y;
      }
      return edge;
    };
    AccumulationDataLabel2.prototype.getLabelDistance = function(point, dataLabel) {
      if (point.labelPosition && dataLabel.position !== point.labelPosition || dataLabel.connectorStyle.length && dataLabel.position === "Outside") {
        var length_1 = stringToNumber(dataLabel.connectorStyle.length || "70px", this.accumulation.initialClipRect.width);
        if (length_1 < this.accumulation.initialClipRect.width) {
          return length_1;
        }
      }
      var position = point.labelPosition || dataLabel.position;
      var series = this.accumulation.visibleSeries[0];
      var extraSpace = (this.accumulation.initialClipRect.width - series.triangleSize.width) / 2;
      var labelLocation;
      switch (position) {
        case "Inside":
          return 0;
        case "Outside":
          labelLocation = point.symbolLocation.x + point.labelOffset.x;
          return this.accumulation.initialClipRect.width - labelLocation - extraSpace;
      }
    };
    AccumulationDataLabel2.prototype.getLabelLocation = function(point, position) {
      if (position === void 0) {
        position = "Outside";
      }
      if (this.accumulation.type !== "Pie" && this.accumulation.series[0].funnelMode !== "Trapezoidal") {
        position = position === "OutsideLeft" ? "OutsideLeft" : point.labelPosition || position;
        var location_2 = {
          x: point.symbolLocation.x,
          y: point.symbolLocation.y - point.labelOffset.y
        };
        switch (position) {
          case "Inside":
            location_2.y = point.region.y + point.region.height / 2;
            break;
          case "Outside":
            location_2.x += point.labelOffset.x;
            break;
          case "OutsideLeft":
            location_2.x -= point.labelOffset.x;
        }
        return location_2;
      } else if (this.accumulation.series[0].funnelMode === "Trapezoidal" && this.accumulation.type === "Funnel") {
        var location_3 = {
          x: point.symbolLocation.x,
          y: point.symbolLocation.y
        };
        if (position === "Outside") {
          location_3.x = point.labelOffset.x;
        }
        return location_3;
      } else {
        return degreeToLocation(point.midAngle, this.isVariousRadius() ? stringToNumber(point.sliceRadius, this.accumulation.pieSeriesModule.seriesRadius) : this.radius, this.center);
      }
    };
    AccumulationDataLabel2.prototype.getConnectorStartPoint = function(point, connector) {
      var position;
      if (!this.isCircular() && point.region.x > point.labelRegion.x) {
        position = "OutsideLeft";
      }
      return this.isCircular() ? degreeToLocation(point.midAngle, (this.isVariousRadius() ? stringToNumber(point.sliceRadius, this.accumulation.pieSeriesModule.seriesRadius) : this.radius) - connector.width, this.center) : this.getLabelLocation(point, position);
    };
    AccumulationDataLabel2.prototype.findAreaRect = function() {
      this.areaRect = new Rect(0, 0, this.accumulation.availableSize.width, this.accumulation.availableSize.height);
      var margin = this.accumulation.margin;
      subtractThickness(this.areaRect, new Thickness(margin.left, margin.right, margin.top, margin.bottom));
    };
    AccumulationDataLabel2.prototype.renderDataLabel = function(point, dataLabel, parent, points, series, templateElement, redraw) {
      var id = this.accumulation.element.id + "_datalabel_Series_" + series + "_";
      var datalabelGroup = this.accumulation.renderer.createGroup({
        id: id + "g_" + point.index
      });
      var border = {
        width: dataLabel.border.width,
        color: dataLabel.border.color
      };
      var argsFont = extend({}, getValue("properties", dataLabel.font), null, true);
      point.label = this.getDatalabelText(dataLabel.format, this.accumulation, point.originalText || point.y.toString());
      var argsData = {
        cancel: false,
        name: textRender,
        series: this.accumulation.visibleSeries[0],
        point,
        text: point.label,
        border,
        color: dataLabel.fill,
        template: this.accumulation.enableHtmlSanitizer ? this.accumulation.sanitize(dataLabel.template) : dataLabel.template,
        font: argsFont
      };
      this.accumulation.trigger(textRender, argsData);
      point.argsData = argsData;
      var isTemplate = argsData.template !== null;
      point.labelVisible = !argsData.cancel;
      point.text = point.label = argsData.text;
      point.labelCollection = [];
      this.marginValue = argsData.border.width ? 5 + argsData.border.width : 1;
      var childElement = createElement("div", {
        id: this.accumulation.element.id + "_Series_0_DataLabel_" + point.index,
        styles: "position: absolute;background-color:" + argsData.color + ";" + getFontStyle(dataLabel.font, this.accumulation.themeStyle.datalabelFont) + ";border:" + argsData.border.width + "px solid " + argsData.border.color + ";"
      });
      this.calculateLabelSize(isTemplate, childElement, point, points, argsData, datalabelGroup, id, dataLabel, redraw);
    };
    AccumulationDataLabel2.prototype.getDatalabelText = function(labelFormat, chart, labelText) {
      if (Number(labelText)) {
        var customLabelFormat = labelFormat.match("{value}") !== null;
        var format = chart.intl.getNumberFormat({
          format: customLabelFormat ? "" : labelFormat,
          useGrouping: chart.useGroupingSeparator
        });
        labelText = customLabelFormat ? labelFormat.replace("{value}", format(parseFloat(labelText))) : format(parseFloat(labelText));
      }
      return labelText;
    };
    AccumulationDataLabel2.prototype.calculateLabelSize = function(isTemplate, childElement, point, points, argsData, datalabelGroup, id, dataLabel, redraw, clientRect, isReactCallback) {
      this.calculateLabelCollection(point, dataLabel);
      var textSize = isTemplate ? isReactCallback ? {
        width: clientRect.width,
        height: clientRect.height
      } : this.getTemplateSize(childElement, point, argsData, redraw, isTemplate, points, datalabelGroup, id, dataLabel) : this.getTextSize(point.labelCollection, dataLabel);
      textSize.height += 4;
      textSize.width += 4;
      point.textSize = textSize;
      point.templateElement = childElement;
      this.getDataLabelPosition(point, dataLabel, textSize, points);
      if (point.labelRegion) {
        this.correctLabelRegion(point.labelRegion, point.textSize);
      }
    };
    AccumulationDataLabel2.prototype.drawDataLabels = function(series, dataLabel, parent, templateElement, redraw) {
      var angle;
      var degree;
      var modifiedPoints = series.leftSidePoints.concat(series.rightSidePoints);
      modifiedPoints.sort(function(a, b) {
        return a.index - b.index;
      });
      if (series.type === "Pie" && this.accumulation.enableSmartLabels) {
        this.extendedLabelsCalculation();
      }
      for (var _i = 0, modifiedPoints_1 = modifiedPoints; _i < modifiedPoints_1.length; _i++) {
        var point = modifiedPoints_1[_i];
        if (!isNullOrUndefined(point.argsData) && !isNullOrUndefined(point.y)) {
          this.finalizeDatalabels(point, modifiedPoints, dataLabel);
          var pointElement = document.getElementById(this.accumulation.element.id + "_Series_0_Point_" + point.index);
          var id = this.accumulation.element.id + "_datalabel_Series_0_";
          var datalabelGroup = this.accumulation.renderer.createGroup({
            id: id + "g_" + point.index
          });
          datalabelGroup.setAttribute("aria-hidden", "true");
          var dataLabelElement = void 0;
          var location_4 = void 0;
          var element = void 0;
          if (point.visible && point.labelVisible) {
            angle = degree = dataLabel.angle;
            if (point.argsData.template) {
              this.setTemplateStyle(point.templateElement, point, templateElement, dataLabel.font.color, point.color, redraw);
            } else {
              location_4 = new ChartLocation(point.labelRegion.x + this.marginValue, point.labelRegion.y + point.textSize.height * 3 / (point.labelCollection.length * 4) + this.marginValue);
              element = getElement2(id + "shape_" + point.index);
              var startLocation = element ? new ChartLocation(+element.getAttribute("x"), +element.getAttribute("y")) : null;
              var textWidth = point.textSize.width;
              if (dataLabel.enableRotation) {
                if (angle === 0) {
                  if (point.labelPosition === "Outside") {
                    degree = 0;
                  } else if (point.midAngle >= 90 && point.midAngle <= 260) {
                    degree = point.midAngle + 180;
                  } else {
                    degree = point.midAngle;
                  }
                } else {
                  degree = angle > 360 ? angle - 360 : angle < -360 ? angle + 360 : angle;
                }
              } else {
                degree = 0;
              }
              var rotate = "rotate(" + degree + "," + (location_4.x + textWidth / 2) + "," + location_4.y + ")";
              point.transform = rotate;
              dataLabelElement = this.accumulation.renderer.drawRectangle(new RectOption(id + "shape_" + point.index, point.argsData.color, point.argsData.border, 1, point.labelRegion, dataLabel.rx, dataLabel.ry, rotate, series.dataLabel.border.dashArray));
              appendChildElement(false, datalabelGroup, dataLabelElement, redraw, true, "x", "y", startLocation, null, false, false, null, this.accumulation.duration);
              textElement2(this.accumulation.renderer, new TextOption(id + "text_" + point.index, location_4.x, location_4.y, this.accumulation.enableRtl ? "end" : "start", point.labelCollection, rotate, "auto", degree), point.argsData.font, point.argsData.font.color || this.getSaturatedColor(point, point.argsData.color), datalabelGroup, false, redraw, true, false, this.accumulation.duration, null, null, null, null, true, this.accumulation.themeStyle.datalabelFont);
              element = null;
            }
            if (pointElement && this.accumulation.highlightMode !== "None") {
              datalabelGroup.setAttribute("class", pointElement.getAttribute("class") ? pointElement.getAttribute("class") : "");
              for (var i = 0; i < datalabelGroup.children.length; i++) {
                var existing = document.getElementById(datalabelGroup.children[i].id);
                if (existing) {
                  datalabelGroup.children[i].style.opacity = existing.style.opacity;
                }
              }
            }
            if (this.accumulation.accumulationLegendModule && this.accumulation.legendSettings.visible && !this.accumulation.redraw && (dataLabel.position === "Outside" || this.accumulation.enableSmartLabels)) {
              this.accumulation.visibleSeries[0].findMaxBounds(this.accumulation.visibleSeries[0].labelBound, point.labelRegion);
            }
            if (point.labelPosition === "Outside") {
              var element_1 = getElement2(id + "connector_" + point.index);
              var previousDirection = element_1 ? element_1.getAttribute("d") : "";
              var pathElement = this.accumulation.renderer.drawPath(new PathOption(id + "connector_" + point.index, "transparent", dataLabel.connectorStyle.width, dataLabel.connectorStyle.color || point.color, 1, dataLabel.connectorStyle.dashArray, this.getConnectorPath(extend({}, point.labelRegion, null, true), point, dataLabel, point.labelAngle)));
              appendChildElement(false, datalabelGroup, pathElement, redraw, true, null, null, null, previousDirection, false, false, null, this.accumulation.duration);
            }
            appendChildElement(false, parent, datalabelGroup, redraw);
          } else if (getElement2(datalabelGroup.id)) {
            getElement2(datalabelGroup.id).parentNode.removeChild(getElement2(datalabelGroup.id));
          }
        }
      }
      if (this.accumulation.type === "Pie" && dataLabel.textWrap === "Normal" && dataLabel.textOverflow === "Clip") {
        this.dataLabelClipPath(dataLabel, parent);
      }
    };
    AccumulationDataLabel2.prototype.dataLabelClipPath = function(dataLabel, parent) {
      var id = this.accumulation.element.id + "_datalabel_Series_0_";
      var clippath = this.accumulation.renderer.createClipPath({
        id: id + "clipPath"
      });
      var clipRect;
      var radius = this.accumulation.pieSeriesModule.pieBaseRadius;
      if (dataLabel.position === "Inside") {
        clipRect = this.accumulation.renderer.drawCircle(new CircleOption(id + "clipPath_rect", "transparent", {
          width: 0
        }, 0, this.center.x, this.center.y, radius));
      } else if (dataLabel.maxWidth) {
        var x = this.center.x - radius - stringToNumber(dataLabel.connectorStyle.length || "4%", radius) - dataLabel.maxWidth;
        var y = this.center.y - radius - stringToNumber(dataLabel.connectorStyle.length || "4%", radius) - dataLabel.maxWidth;
        var height = (radius + stringToNumber(dataLabel.connectorStyle.length || "4%", radius) + dataLabel.maxWidth) * 2;
        var width = height;
        if (this.accumulation.legendSettings.visible) {
          var legendModule = this.accumulation.accumulationLegendModule;
          if (legendModule.position === "Left") {
            width = legendModule.legendBounds.x + legendModule.legendBounds.width - x > 0 ? width - (legendModule.legendBounds.width - x) : width;
            x = legendModule.legendBounds.x + legendModule.legendBounds.width < x ? x : legendModule.legendBounds.x + legendModule.legendBounds.width;
          } else if (legendModule.position === "Right") {
            width = x + width - legendModule.legendBounds.x > 0 ? width - (x + width - legendModule.legendBounds.x) : width;
          }
        }
        clipRect = this.accumulation.renderer.drawRectangle(new RectOption(id + "clipPath_rect", "transparent", {
          width: 0
        }, 0, new Rect(x, y, height, width), 0, 0));
      }
      if (dataLabel.position === "Inside" || dataLabel.maxWidth) {
        clippath.appendChild(clipRect);
        appendChildElement(false, this.accumulation.svgObject, clippath);
        parent.style.cssText = "clip-path:url(#" + clippath.id + ")";
      }
    };
    AccumulationDataLabel2.prototype.finalizeDatalabels = function(point, points, dataLabel) {
      if (this.isOverlapping(point, points) || this.titleRect && point.labelRegion && isOverlap(point.labelRegion, this.titleRect)) {
        if (this.isCircular() && point.labelPosition === "Outside" && this.accumulation.enableSmartLabels) {
          this.setPointVisibileFalse(point);
        }
      }
      if (this.accumulation.accumulationLegendModule && this.accumulation.legendSettings.visible && point.labelVisible && point.labelRegion && (!dataLabel.maxWidth ? dataLabel.textOverflow === "Clip" ? dataLabel.textWrap !== "Normal" : true : false)) {
        var rect = this.accumulation.accumulationLegendModule.legendBounds;
        if (this.accumulation.visibleSeries[0].type !== "Pie" && this.accumulation.legendSettings.position === "Left" && dataLabel.position === "Outside") {
          point.labelRegion.x = point.labelRegion.x + rect.width;
        }
        var padding = this.accumulation.legendSettings.border.width / 2;
        this.textTrimming(point, new Rect(rect.x - padding, rect.y - padding, rect.width + 2 * padding, rect.height + 2 * padding), dataLabel.font, this.accumulation.accumulationLegendModule.position, dataLabel);
      }
      if (point.labelVisible && point.labelRegion && (!dataLabel.maxWidth ? dataLabel.textOverflow === "Clip" ? dataLabel.textWrap !== "Normal" : true : false)) {
        var position = this.isCircular() ? point.labelRegion.x >= this.center.x ? "InsideRight" : "InsideLeft" : point.labelRegion.x >= point.region.x ? "InsideRight" : "InsideLeft";
        this.textTrimming(point, this.areaRect, dataLabel.font, position, dataLabel);
      }
      if (point.labelVisible && point.labelRegion && !dataLabel.maxWidth && dataLabel.textOverflow !== "Clip" && this.accumulation.enableSmartLabels && (point.labelRegion.y + point.labelRegion.height / 2 > this.areaRect.y + this.areaRect.height || point.labelRegion.y < this.areaRect.y || point.labelRegion.x < this.areaRect.x || point.labelRegion.x + point.labelRegion.width > this.areaRect.x + this.areaRect.width)) {
        this.setPointVisibileFalse(point);
      }
    };
    AccumulationDataLabel2.prototype.getTemplateSize = function(element, point, argsData, redraw, isTemplate, points, datalabelGroup, id, dataLabel) {
      element = createTemplate(element, point.index, argsData.template, this.accumulation, point, this.accumulation.visibleSeries[0], this.accumulation.element.id + "_DataLabel", 0, argsData, isTemplate, points, datalabelGroup, id, dataLabel, redraw);
      var clientRect = measureElementRect(element, redraw);
      return {
        width: clientRect.width,
        height: clientRect.height
      };
    };
    AccumulationDataLabel2.prototype.setTemplateStyle = function(childElement, point, parent, labelColor, fill, redraw) {
      childElement.style.left = point.labelRegion.x + "px";
      childElement.style.top = point.labelRegion.y + "px";
      childElement.style.color = labelColor || this.getSaturatedColor(point, point.labelPosition === "Inside" ? fill : this.getLabelBackground(point));
      if (this.accumulation.isBlazor) {
        var position = this.isCircular() ? point.labelRegion.x >= this.center.x ? "InsideRight" : "InsideLeft" : point.labelRegion.x >= point.region.x ? "InsideRight" : "InsideLeft";
        if (position === "InsideRight") {
          childElement.style.transform = "translate(0%, -50%)";
        } else {
          childElement.style.transform = "translate(-100%, -50%)";
        }
      }
      if (childElement.childElementCount) {
        appendChildElement(false, parent, childElement, redraw, true, "left", "top");
        this.doTemplateAnimation(this.accumulation, childElement);
      }
    };
    AccumulationDataLabel2.prototype.getSaturatedColor = function(point, color) {
      var saturatedColor;
      if (this.marginValue >= 1) {
        saturatedColor = color === "transparent" ? this.getLabelBackground(point) : color;
      } else {
        saturatedColor = this.getLabelBackground(point);
      }
      saturatedColor = saturatedColor === "transparent" ? this.accumulation.theme.indexOf("Dark") > -1 || this.accumulation.theme.indexOf("HighContrast") > -1 ? "black" : "white" : saturatedColor;
      var rgbValue = convertHexToColor(colorNameToHex(saturatedColor));
      var contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1e3);
      return this.accumulation.theme === "Bootstrap5" ? "#212529" : this.accumulation.theme === "Bootstrap5Dark" ? "#DEE2E6" : contrast >= 128 ? this.accumulation.theme.indexOf("Tailwind3") > -1 ? "#111827" : "black" : this.accumulation.theme.indexOf("Tailwind3") > -1 ? "#FFFFFF" : "white";
    };
    AccumulationDataLabel2.prototype.doTemplateAnimation = function(accumulation, element) {
      var series = accumulation.visibleSeries[0];
      var delay = series.animation.delay + series.animation.duration;
      if ((series.animation.enable && animationMode !== "Disable" || animationMode === "Enable") && accumulation.animateSeries) {
        element.style.visibility = "hidden";
        templateAnimate(element, delay, 200, "ZoomIn");
      }
    };
    AccumulationDataLabel2.prototype.getLabelBackground = function(point) {
      return point.labelPosition === "Outside" ? this.accumulation.background || this.accumulation.themeStyle.background : !point.y ? this.accumulation.theme.indexOf("dark") ? "white" : "black" : point.color;
    };
    AccumulationDataLabel2.prototype.correctLabelRegion = function(labelRegion, textSize, padding) {
      if (padding === void 0) {
        padding = 4;
      }
      labelRegion.height -= padding;
      labelRegion.width -= padding;
      labelRegion.x += padding / 2;
      labelRegion.y += padding / 2;
      textSize.height -= padding;
      textSize.width -= padding;
    };
    AccumulationDataLabel2.prototype.getModuleName = function() {
      return "AccumulationDataLabel";
    };
    AccumulationDataLabel2.prototype.destroy = function() {
    };
    AccumulationDataLabel2.prototype.extendedLabelsCalculation = function() {
      var _this = this;
      var series = this.accumulation.series[0];
      series.rightSidePoints.forEach(function(point, index, halfSidePoints) {
        point.initialLabelRegion = point.labelRegion;
        point.isLabelUpdated = 0;
        _this.skipPoints(point, halfSidePoints, index);
      });
      series.leftSidePoints.forEach(function(point, index, halfSidePoints) {
        point.initialLabelRegion = point.labelRegion;
        point.isLabelUpdated = 0;
        _this.skipPoints(point, halfSidePoints, index);
      });
      this.arrangeLeftSidePoints(series);
      this.isIncreaseAngle = false;
      this.arrangeRightSidePoints(series);
    };
    AccumulationDataLabel2.prototype.arrangeRightSidePoints = function(series) {
      var startFresh;
      var angleChanged;
      var rightSideRenderPoints = series.rightSidePoints.filter(function(point) {
        return point.labelVisible && point.labelPosition === "Outside";
      });
      this.rightSideRenderingPoints = rightSideRenderPoints;
      var checkAngle;
      var currentPoint;
      var lastPoint = rightSideRenderPoints[rightSideRenderPoints.length - 1];
      var nextPoint;
      if (lastPoint) {
        if (lastPoint.labelAngle > 90 && lastPoint.labelAngle < 270) {
          this.isIncreaseAngle = true;
          this.changeLabelAngle(lastPoint, 89);
        }
      }
      for (var i = rightSideRenderPoints.length - 1; i >= 0; i--) {
        currentPoint = rightSideRenderPoints[i];
        nextPoint = rightSideRenderPoints[i + 1];
        if (this.isOverlapWithNext(currentPoint, rightSideRenderPoints, i) && currentPoint.labelVisible || !(currentPoint.labelAngle <= 90 || currentPoint.labelAngle >= 270)) {
          checkAngle = lastPoint.labelAngle + 10;
          angleChanged = true;
          if (startFresh) {
            this.isIncreaseAngle = false;
          } else if (checkAngle > 90 && checkAngle < 270 && nextPoint.isLabelUpdated) {
            this.isIncreaseAngle = true;
          }
          if (!this.isIncreaseAngle) {
            for (var k = i + 1; k < rightSideRenderPoints.length; k++) {
              this.increaseAngle(rightSideRenderPoints[k - 1], rightSideRenderPoints[k], series, true);
            }
          } else {
            for (var k = i + 1; k > 0; k--) {
              this.decreaseAngle(rightSideRenderPoints[k], rightSideRenderPoints[k - 1], series, true);
            }
          }
        } else {
          if (angleChanged && nextPoint && !nextPoint.isLabelUpdated) {
            startFresh = true;
          }
        }
      }
    };
    AccumulationDataLabel2.prototype.arrangeLeftSidePoints = function(series) {
      var _this = this;
      var leftSideRenderPoints = series.leftSidePoints.filter(function(point) {
        return point.labelVisible && point.labelPosition === "Outside";
      });
      this.leftSideRenderingPoints = leftSideRenderPoints;
      var previousPoint;
      var currentPoint;
      var angleChanged;
      var startFresh;
      for (var i = 0; i < leftSideRenderPoints.length; i++) {
        currentPoint = leftSideRenderPoints[i];
        previousPoint = leftSideRenderPoints[i - 1];
        if (this.isOverlapWithPrevious(currentPoint, leftSideRenderPoints, i) && currentPoint.labelVisible || !(currentPoint.labelAngle < 270)) {
          angleChanged = true;
          if (startFresh) {
            this.isIncreaseAngle = false;
          }
          if (!this.isIncreaseAngle) {
            for (var k = i; k > 0; k--) {
              this.decreaseAngle(leftSideRenderPoints[k], leftSideRenderPoints[k - 1], series, false);
              leftSideRenderPoints.filter(function(point, index) {
                if (point.isLabelUpdated && leftSideRenderPoints[index].labelAngle - 10 < 100) {
                  _this.isIncreaseAngle = true;
                }
              });
            }
          } else {
            for (var k = i; k < leftSideRenderPoints.length; k++) {
              this.increaseAngle(leftSideRenderPoints[k - 1], leftSideRenderPoints[k], series, false);
            }
          }
        } else {
          if (angleChanged && previousPoint && previousPoint.isLabelUpdated) {
            startFresh = true;
          }
        }
      }
    };
    AccumulationDataLabel2.prototype.decreaseAngle = function(currentPoint, previousPoint, series, isRightSide) {
      if (isNullOrUndefined(currentPoint) || isNullOrUndefined(previousPoint)) {
        return null;
      }
      var count = 1;
      if (isRightSide) {
        while (isOverlap(currentPoint.labelRegion, previousPoint.labelRegion) || !this.isVariousRadius() && !(previousPoint.labelRegion.height + previousPoint.labelRegion.y < currentPoint.labelRegion.y)) {
          var newAngle = previousPoint.midAngle - count;
          if (newAngle < 0) {
            newAngle = 360 + newAngle;
          }
          if (newAngle <= 270 && newAngle >= 90) {
            newAngle = 270;
            this.isIncreaseAngle = true;
            break;
          }
          this.changeLabelAngle(previousPoint, newAngle);
          count++;
        }
      } else {
        if (currentPoint.labelAngle > 270) {
          this.changeLabelAngle(currentPoint, 270);
          previousPoint.labelAngle = 270;
        }
        while (isOverlap(currentPoint.labelRegion, previousPoint.labelRegion) || !this.isVariousRadius() && currentPoint.labelRegion.y + currentPoint.labelRegion.height > previousPoint.labelRegion.y) {
          var newAngle = previousPoint.midAngle - count;
          if (!(newAngle <= 270 && newAngle >= 90)) {
            newAngle = 90;
            this.isIncreaseAngle = true;
            break;
          }
          this.changeLabelAngle(previousPoint, newAngle);
          if (isOverlap(currentPoint.labelRegion, previousPoint.labelRegion) && !series.leftSidePoints.indexOf(previousPoint) && newAngle - 1 < 90 && newAngle - 1 > 270) {
            this.changeLabelAngle(currentPoint, currentPoint.labelAngle + 1);
            this.arrangeLeftSidePoints(series);
            break;
          }
          count++;
        }
      }
    };
    AccumulationDataLabel2.prototype.increaseAngle = function(currentPoint, nextPoint, series, isRightSide) {
      if (isNullOrUndefined(currentPoint) || isNullOrUndefined(nextPoint)) {
        return null;
      }
      var count = 1;
      if (isRightSide) {
        while (isOverlap(currentPoint.labelRegion, nextPoint.labelRegion) || !this.isVariousRadius() && !(currentPoint.labelRegion.y + currentPoint.labelRegion.height < nextPoint.labelRegion.y)) {
          var newAngle = nextPoint.midAngle + count;
          if (newAngle < 270 && newAngle > 90) {
            newAngle = 90;
            this.isIncreaseAngle = true;
            break;
          }
          this.changeLabelAngle(nextPoint, newAngle);
          if (isOverlap(currentPoint.labelRegion, nextPoint.labelRegion) && newAngle + 1 > 90 && newAngle + 1 < 270 && this.rightSideRenderingPoints.indexOf(nextPoint) === this.rightSideRenderingPoints.length - 1) {
            this.changeLabelAngle(currentPoint, currentPoint.labelAngle - 1);
            nextPoint.labelRegion = nextPoint.initialLabelRegion;
            this.arrangeRightSidePoints(series);
            break;
          }
          if (count > 360) {
            break;
          }
          count++;
        }
      } else {
        while (isOverlap(currentPoint.labelRegion, nextPoint.labelRegion) || !this.isVariousRadius() && currentPoint.labelRegion.y < nextPoint.labelRegion.y + nextPoint.labelRegion.height) {
          var newAngle = nextPoint.midAngle + count;
          if (!(newAngle < 270 && newAngle > 90)) {
            newAngle = 270;
            this.isIncreaseAngle = false;
            break;
          }
          this.changeLabelAngle(nextPoint, newAngle);
          if (count > 360) {
            break;
          }
          count++;
        }
      }
    };
    AccumulationDataLabel2.prototype.changeLabelAngle = function(currentPoint, newAngle) {
      var dataLabel = this.accumulation.series[0].dataLabel;
      var variableR;
      if (this.isVariousRadius()) {
        variableR = this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], currentPoint);
      }
      var labelRadius = currentPoint.labelPosition === "Outside" && this.accumulation.enableSmartLabels && dataLabel.position === "Inside" ? this.radius + stringToNumber(dataLabel.connectorStyle.length || "4%", this.accumulation.pieSeriesModule.size / 2) : !this.isVariousRadius() ? this.accumulation.pieSeriesModule.labelRadius + 10 : variableR;
      var radius = !this.isVariousRadius() ? labelRadius : variableR;
      this.getLabelRegion(currentPoint, "Outside", currentPoint.textSize, radius, this.marginValue, newAngle);
      currentPoint.isLabelUpdated = 1;
      currentPoint.labelAngle = newAngle;
    };
    AccumulationDataLabel2.prototype.isOverlapWithPrevious = function(currentPoint, points, currentPointIndex) {
      for (var i = 0; i < currentPointIndex; i++) {
        if (i !== points.indexOf(currentPoint) && points[i].visible && points[i].labelVisible && points[i].labelRegion && currentPoint.labelRegion && currentPoint.labelVisible && isOverlap(currentPoint.labelRegion, points[i].labelRegion)) {
          return true;
        }
      }
      return false;
    };
    AccumulationDataLabel2.prototype.isOverlapWithNext = function(point, points, pointIndex) {
      for (var i = pointIndex; i < points.length; i++) {
        if (i !== points.indexOf(point) && points[i].visible && points[i].labelVisible && points[i].labelRegion && point.labelRegion && point.labelVisible && isOverlap(point.labelRegion, points[i].labelRegion)) {
          return true;
        }
      }
      return false;
    };
    AccumulationDataLabel2.prototype.skipPoints = function(currentPoint, halfsidePoints, pointIndex) {
      if (pointIndex > 0 && (currentPoint.midAngle < 285 && currentPoint.midAngle > 255 || currentPoint.midAngle < 105 && currentPoint.midAngle > 75)) {
        var previousPoint = halfsidePoints[pointIndex - 1];
        var angleDiff = currentPoint.endAngle % 360 - currentPoint.startAngle % 360;
        var prevAngleDiff = previousPoint.endAngle % 360 - previousPoint.startAngle % 360;
        if (prevAngleDiff <= angleDiff && angleDiff < 5 && previousPoint.labelVisible) {
          this.setPointVisibleTrue(currentPoint);
        }
      } else if (pointIndex > 1 && (currentPoint.midAngle < 300 && currentPoint.midAngle > 240 || currentPoint.midAngle < 120 && currentPoint.midAngle > 60)) {
        var prevPoint = halfsidePoints[pointIndex - 1];
        var secondPrevPoint = halfsidePoints[pointIndex - 2];
        var angleDiff = currentPoint.endAngle % 360 - currentPoint.startAngle % 360;
        var prevAngleDiff = prevPoint.endAngle % 360 - prevPoint.startAngle % 360;
        var thirdAngleDiff = secondPrevPoint.endAngle % 360 - secondPrevPoint.startAngle % 360;
        if (angleDiff < 3 && prevAngleDiff < 3 && thirdAngleDiff < 3 && prevPoint.labelVisible && currentPoint.labelVisible) {
          this.setPointVisibleTrue(currentPoint);
        }
      }
    };
    AccumulationDataLabel2.prototype.getPerpendicularDistance = function(startPoint, point) {
      var increasedLocation;
      var add = 10;
      var height = add + 10 * Math.sin(point.midAngle * Math.PI / 360);
      if (point.midAngle > 270 && point.midAngle < 360) {
        increasedLocation = new ChartLocation(startPoint.x + height * Math.cos((360 - point.midAngle) * Math.PI / 180), startPoint.y - height * Math.sin((360 - point.midAngle) * Math.PI / 180));
      } else if (point.midAngle > 0 && point.midAngle < 90) {
        increasedLocation = new ChartLocation(startPoint.x + height * Math.cos(point.midAngle * Math.PI / 180), startPoint.y + height * Math.sin(point.midAngle * Math.PI / 180));
      } else if (point.midAngle > 0 && point.midAngle < 90) {
        increasedLocation = new ChartLocation(startPoint.x - height * Math.cos((point.midAngle - 90) * Math.PI / 180), startPoint.y + height * Math.sin((point.midAngle - 90) * Math.PI / 180));
      } else {
        increasedLocation = new ChartLocation(startPoint.x - height * Math.cos((point.midAngle - 180) * Math.PI / 180), startPoint.y - height * Math.sin((point.midAngle - 180) * Math.PI / 180));
      }
      return increasedLocation;
    };
    return AccumulationDataLabel2;
  }(AccumulationBase)
);

// node_modules/@syncfusion/ej2-charts/src/accumulation-chart/user-interaction/tooltip.js
var __extends73 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var AccumulationTooltip = (
  /** @class */
  function(_super) {
    __extends73(AccumulationTooltip2, _super);
    function AccumulationTooltip2(accumulation) {
      var _this = _super.call(this, accumulation) || this;
      _this.accumulation = accumulation;
      _this.addEventListener();
      _this.template = _this.accumulation.tooltip.template;
      return _this;
    }
    AccumulationTooltip2.prototype.addEventListener = function() {
      if (this.accumulation.isDestroyed) {
        return;
      }
      this.accumulation.on(Browser.isPointer ? "pointerleave" : "mouseleave", this.mouseLeaveHandler, this);
      this.accumulation.on(Browser.touchMoveEvent, this.mouseMoveHandler, this);
      this.accumulation.on(Browser.touchEndEvent, this.mouseUpHandler, this);
    };
    AccumulationTooltip2.prototype.mouseLeaveHandler = function() {
      this.removeTooltip(this.accumulation.tooltip.fadeOutDuration);
    };
    AccumulationTooltip2.prototype.mouseUpHandler = function(e) {
      var control = this.accumulation;
      if (control.tooltip.enable && control.isTouch && withInBounds(control.mouseX, control.mouseY, control.initialClipRect)) {
        this.tooltip(e);
        this.removeTooltip(2e3);
      }
    };
    AccumulationTooltip2.prototype.mouseMoveHandler = function(e) {
      var control = this.accumulation;
      if (control.tooltip.enable && withInBounds(control.mouseX, control.mouseY, control.initialClipRect)) {
        this.tooltip(e);
      }
    };
    AccumulationTooltip2.prototype.tooltip = function(event2) {
      this.renderSeriesTooltip(this.accumulation, this.getPieData(event2, this.accumulation));
    };
    AccumulationTooltip2.prototype.renderSeriesTooltip = function(chart, data) {
      var svgElement = this.getElement(this.element.id + "_tooltip_svg");
      var isTooltip = svgElement && parseInt(svgElement.getAttribute("opacity"), 10) > 0;
      var tooltipDiv = this.getTooltipElement(isTooltip);
      var isFirst = !isTooltip;
      this.currentPoints = [];
      if (data.point && (!this.previousPoints[0] || this.previousPoints[0].point !== data.point)) {
        if (this.previousPoints[0] && data.point.index === this.previousPoints[0].point.index && data.series.index === this.previousPoints[0].series.index) {
          return null;
        }
        if (this.pushData(data, isFirst, tooltipDiv, false)) {
          this.triggerTooltipRender(data, isFirst, this.getTooltipText(data, chart.tooltip), this.findHeader(data));
        }
      } else {
        if (!data.point && this.isRemove) {
          this.removeTooltip(this.accumulation.tooltip.fadeOutDuration);
          this.isRemove = false;
        }
      }
    };
    AccumulationTooltip2.prototype.triggerTooltipRender = function(point, isFirst, textCollection, headerText) {
      var _this = this;
      var tooltip = this.chart.tooltip;
      var argsData = {
        cancel: false,
        name: tooltipRender,
        text: textCollection,
        point: point.point,
        textStyle: this.textStyle,
        series: this.accumulation.isBlazor ? {} : point.series,
        headerText,
        data: {
          pointX: point.point.x,
          pointY: point.point.y,
          seriesIndex: point.series.index,
          pointIndex: point.point.index,
          pointText: point.point.text,
          seriesName: point.series.name
        }
      };
      var tooltipSuccess = function(argsData2) {
        if (!argsData2.cancel) {
          _this.formattedText = _this.formattedText.concat(argsData2.text);
          _this.text = _this.formattedText;
          _this.headerText = argsData2.headerText;
          _this.createTooltip(_this.chart, isFirst, {
            x: tooltip.location.x !== null ? tooltip.location.x : point.point.symbolLocation.x,
            y: tooltip.location.y !== null ? tooltip.location.y : point.point.symbolLocation.y
          }, point.series.clipRect, point.point, !tooltip.enableMarker ? [] : ["Circle"], 0, _this.chart.initialClipRect, false, null, point.point, _this.template ? _this.accumulation.enableHtmlSanitizer ? _this.accumulation.sanitize(_this.template) : argsData2.template : "");
        } else {
          _this.removeHighlight();
          remove(_this.getElement(_this.element.id + "_tooltip"));
        }
        _this.isRemove = true;
      };
      tooltipSuccess.bind(this, point);
      this.chart.trigger(tooltipRender, argsData, tooltipSuccess);
    };
    AccumulationTooltip2.prototype.getPieData = function(e, chart) {
      var target = e.target;
      var id = indexFinder(target.id, true);
      if (!isNaN(id.series)) {
        var seriesIndex = id.series;
        var pointIndex = id.point;
        if (!isNullOrUndefined(seriesIndex) && !isNaN(seriesIndex) && !isNullOrUndefined(pointIndex) && !isNaN(pointIndex)) {
          var series = this.getSeriesFromIndex(seriesIndex, chart.visibleSeries);
          if (series.enableTooltip) {
            return new AccPointData(series.points[pointIndex], series);
          }
        }
      }
      return new AccPointData(null, null);
    };
    AccumulationTooltip2.prototype.getSeriesFromIndex = function(index, visibleSeries) {
      return visibleSeries[0];
    };
    AccumulationTooltip2.prototype.getTooltipText = function(data, tooltip) {
      var series = data.series;
      var format = tooltip.format ? tooltip.format : this.accumulation.theme.indexOf("Tailwind3") > -1 ? "${point.x} : ${point.y}" : "${point.x} : <b>${point.y}</b>";
      format = this.accumulation.useGroupingSeparator ? format.replace("${point.y}", "${point.separatorY}") : format;
      return this.parseTemplate(data.point, series, format);
    };
    AccumulationTooltip2.prototype.findHeader = function(data) {
      if (this.header === "") {
        return "";
      }
      this.header = this.parseTemplate(data.point, data.series, this.header);
      if (this.header.replace(/<b>/g, "").replace(/<\/b>/g, "").trim() !== "") {
        return this.header;
      }
      return "";
    };
    AccumulationTooltip2.prototype.parseTemplate = function(point, series, format) {
      var value;
      var textValue;
      var regExp = RegExp;
      for (var _i = 0, _a = Object.keys(point); _i < _a.length; _i++) {
        var dataValue = _a[_i];
        value = new regExp("${point." + dataValue + "}", "gm");
        var pointValue = dataValue === "x" && this.accumulation.useGroupingSeparator && typeof point[dataValue] === "number" ? this.accumulation.intl.formatNumber(point.x, {
          useGrouping: true
        }) : point[dataValue];
        format = format.replace(value.source, pointValue);
      }
      for (var _b = 0, _c = Object.keys(Object.getPrototypeOf(series)); _b < _c.length; _b++) {
        var dataValue = _c[_b];
        value = new regExp("${series." + dataValue + "}", "gm");
        textValue = series[dataValue];
        format = format.replace(value.source, textValue);
      }
      return format;
    };
    AccumulationTooltip2.prototype.getModuleName = function() {
      return "AccumulationTooltip";
    };
    AccumulationTooltip2.prototype.destroy = function() {
    };
    return AccumulationTooltip2;
  }(BaseTooltip)
);

// node_modules/@syncfusion/ej2-charts/src/accumulation-chart/user-interaction/selection.js
var __extends74 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var AccumulationSelection = (
  /** @class */
  function(_super) {
    __extends74(AccumulationSelection2, _super);
    function AccumulationSelection2(accumulation) {
      var _this = _super.call(this, accumulation) || this;
      _this.accumulation = accumulation;
      _this.renderer = accumulation.renderer;
      _this.addEventListener();
      return _this;
    }
    AccumulationSelection2.prototype.addEventListener = function() {
      if (this.accumulation.isDestroyed) {
        return;
      }
      this.accumulation.on(Browser.touchMoveEvent, this.mouseMove, this);
      this.accumulation.on("click", this.mouseClick, this);
    };
    AccumulationSelection2.prototype.removeEventListener = function() {
      if (this.accumulation.isDestroyed) {
        return;
      }
      this.accumulation.off(Browser.touchMoveEvent, this.mouseMove);
      this.accumulation.off("click", this.mouseClick);
    };
    AccumulationSelection2.prototype.initPrivateVariables = function(accumulation) {
      this.styleId = accumulation.element.id + "_ej2_chart_selection";
      this.unselected = accumulation.element.id + "_ej2_deselected";
      this.selectedDataIndexes = [];
      this.rectPoints = null;
    };
    AccumulationSelection2.prototype.invokeSelection = function(accumulation) {
      this.initPrivateVariables(accumulation);
      this.series = extend({}, accumulation.visibleSeries, null, true);
      this.seriesStyles();
      this.currentMode = accumulation.selectionMode;
      this.selectDataIndex(this.concatIndexes(accumulation.selectedDataIndexes, this.selectedDataIndexes), accumulation);
    };
    AccumulationSelection2.prototype.generateStyle = function(series, point) {
      return series.selectionStyle || this.styleId + "_series_" + series.index + "_point_" + point;
    };
    AccumulationSelection2.prototype.findElements = function(accumulation, series, index) {
      return [this.getElementByIndex(index)];
    };
    AccumulationSelection2.prototype.getElementByIndex = function(index) {
      var elementId = this.control.element.id + "_Series_" + index.series + "_Point_" + index.point;
      return document.getElementById(elementId);
    };
    AccumulationSelection2.prototype.isAlreadySelected = function(targetElement, eventType) {
      if (eventType === "mousemove") {
        this.currentMode = this.accumulation.highlightMode;
        this.highlightDataIndexes = [];
        this.styleId = this.accumulation.element.id + "_ej2_chart_highlight";
      } else if (eventType === "click") {
        this.currentMode = this.accumulation.selectionMode;
        this.styleId = this.accumulation.element.id + "_ej2_chart_selection";
      }
      if (this.accumulation.highlightMode !== "None" && this.accumulation.selectionMode === "None") {
        if (eventType === "click") {
          return false;
        }
      }
      if (this.accumulation.highlightMode !== "None" && this.previousSelectedElement && this.previousSelectedElement[0]) {
        var parentNodeId = targetElement.parentNode.id;
        var isValidElement = void 0;
        if (targetElement.parentNode) {
          isValidElement = parentNodeId.indexOf("SeriesGroup") > 0 || parentNodeId.indexOf("SymbolGroup") > 0 ? true : false;
        }
        for (var i = 0; i < this.previousSelectedElement.length; i++) {
          if (this.previousSelectedElement[i].hasAttribute("class")) {
            if (this.previousSelectedElement[i].getAttribute("class").indexOf("highlight") > -1 && (isValidElement || eventType === "click")) {
              this.previousSelectedElement[i].removeAttribute("class");
              this.addOrRemoveIndex(this.highlightDataIndexes, indexFinder(this.previousSelectedElement[i].id));
            } else if (!isValidElement && this.previousSelectedElement[i].getAttribute("class").indexOf("highlight") > -1) {
              this.performSelection(indexFinder(this.previousSelectedElement[i].id), this.accumulation, this.previousSelectedElement[i]);
            }
          }
        }
      }
      return true;
    };
    AccumulationSelection2.prototype.mouseClick = function(accumulation, event2) {
      this.calculateSelectedElements(accumulation, event2.target, event2.type);
    };
    AccumulationSelection2.prototype.calculateSelectedElements = function(accumulation, targetEle, eventType) {
      if (isNullOrUndefined(targetEle)) {
        return;
      }
      if (accumulation.highlightMode === "None" && accumulation.selectionMode === "None" || targetEle.id.indexOf(accumulation.element.id + "_") === -1) {
        return;
      }
      if (eventType === "mousemove") {
        if (!isNullOrUndefined(targetEle.parentNode) && targetEle.parentNode.hasAttribute("class") && (targetEle.parentNode.getAttribute("class").indexOf("highlight") > 0 || targetEle.parentNode.getAttribute("class").indexOf("selection") > 0)) {
          return;
        }
      }
      if (targetEle.getAttribute("id").indexOf("_connector_") > -1) {
        return;
      } else {
        this.isAlreadySelected(targetEle, eventType);
        if (this.accumulation.selectionMode === "Point" && eventType === "mousemove" && this.accumulation.accumulationLegendModule && this.accumulation.accumulationHighlightModule.highlightDataIndexes && this.accumulation.accumulationHighlightModule.highlightDataIndexes.length > 0 && targetEle.id.indexOf("_chart_legend_") === -1 && targetEle.id.indexOf("_Series_") === -1) {
          for (var i = 0; i < this.accumulation.accumulationHighlightModule.previousSelectedElement.length; i++) {
            this.removeStyles(this.accumulation.accumulationHighlightModule.previousSelectedElement, indexFinder(this.accumulation.accumulationHighlightModule.previousSelectedElement[i].id));
            this.blurEffect(this.accumulation.element.id, this.accumulation.visibleSeries);
          }
        }
        if (targetEle.id.indexOf("_Series_") > -1 || targetEle.id.indexOf("_datalabel_") > -1) {
          this.performSelection(indexFinder(targetEle.id), accumulation, targetEle);
        }
      }
    };
    AccumulationSelection2.prototype.performSelection = function(index, accumulation, element) {
      element = element.id.indexOf("datalabel") > -1 ? accumulation.getSeriesElement().childNodes[index.series].childNodes[index.point] : element;
      switch (this.currentMode) {
        case "Point":
          if (!isNaN(index.point)) {
            var dataLabelElement = document.getElementById(accumulation.element.id + "_datalabel_Series_" + index.series + "_g_" + index.point);
            if (this.series[0].dataLabel.visible && dataLabelElement) {
              dataLabelElement.setAttribute("class", element && element.hasAttribute("class") ? element.getAttribute("class") : dataLabelElement.hasAttribute("class") ? dataLabelElement.getAttribute("class") : "");
              this.selection(accumulation, index, [dataLabelElement]);
            }
            this.selection(accumulation, index, [element]);
            this.selectionComplete(accumulation, accumulation.series[0]);
            this.blurEffect(accumulation.element.id, accumulation.visibleSeries);
          }
          break;
      }
    };
    AccumulationSelection2.prototype.selectionComplete = function(accumulation, series) {
      var pointIndex;
      var selectedPointValues = [];
      for (var i = 0; i < this.selectedDataIndexes.length; i++) {
        pointIndex = this.selectedDataIndexes[i].point;
        if (!isNaN(pointIndex)) {
          selectedPointValues.push({
            x: series.dataSource[pointIndex][series.xName],
            y: series.points[pointIndex].y,
            seriesIndex: this.selectedDataIndexes[i].series,
            pointIndex
          });
        }
      }
      var args = {
        name: selectionComplete,
        selectedDataValues: selectedPointValues,
        cancel: false
      };
      accumulation.trigger(selectionComplete, args);
    };
    AccumulationSelection2.prototype.selection = function(accumulation, index, selectedElements) {
      if (!accumulation.isMultiSelect && this.styleId.indexOf("highlight") === -1 && accumulation.selectionMode !== "None") {
        this.removeMultiSelectEelments(accumulation, this.selectedDataIndexes, index, accumulation.series);
      }
      var className = selectedElements[0] && (selectedElements[0].getAttribute("class") || "");
      if (selectedElements[0] && className.indexOf(this.getSelectionClass(selectedElements[0].id, index.point)) > -1) {
        this.removeStyles(selectedElements, index);
        if (this.styleId.indexOf("highlight") > 0 && accumulation.highlightMode !== "None") {
          this.addOrRemoveIndex(this.highlightDataIndexes, index);
        } else {
          this.addOrRemoveIndex(this.selectedDataIndexes, index);
        }
        if (accumulation.enableBorderOnMouseMove && selectedElements[0].id.indexOf("datalabel") === -1) {
          var borderElement = document.getElementById(selectedElements[0].id.split("_")[0] + "PointHover_Border");
          if (!isNullOrUndefined(borderElement)) {
            this.removeSvgClass(borderElement, borderElement.getAttribute("class"));
          }
        }
      } else {
        this.previousSelectedElement = accumulation.highlightMode !== "None" ? selectedElements : [];
        if (selectedElements[0] && className.indexOf("selection") < 0) {
          this.applyStyles(selectedElements, index);
        }
        if (accumulation.enableBorderOnMouseMove && selectedElements[0].id.indexOf("datalabel") === -1) {
          var borderElement = document.getElementById(selectedElements[0].id.split("_")[0] + "PointHover_Border");
          if (!isNullOrUndefined(borderElement)) {
            this.removeSvgClass(borderElement, borderElement.getAttribute("class"));
            this.addSvgClass(borderElement, selectedElements[0].getAttribute("class"));
          }
        }
        if (this.styleId.indexOf("highlight") > 0 && accumulation.highlightMode !== "None") {
          this.addOrRemoveIndex(this.highlightDataIndexes, index, true);
        } else {
          this.addOrRemoveIndex(this.selectedDataIndexes, index, true);
        }
      }
    };
    AccumulationSelection2.prototype.redrawSelection = function(accumulation) {
      var selectedDataIndexes = extend([], this.selectedDataIndexes, null, true);
      var highlightDataIndexes = extend([], this.highlightDataIndexes, null, true);
      if (this.styleId.indexOf("highlight") > 0 && highlightDataIndexes.length > 0) {
        this.removeSelectedElements(accumulation, this.highlightDataIndexes);
        selectedDataIndexes = highlightDataIndexes;
      } else {
        this.removeSelectedElements(accumulation, this.selectedDataIndexes);
      }
      this.blurEffect(accumulation.element.id, accumulation.visibleSeries);
      this.selectDataIndex(selectedDataIndexes, accumulation);
    };
    AccumulationSelection2.prototype.removeSelectedElements = function(accumulation, indexes) {
      for (var _i = 0, indexes_1 = indexes; _i < indexes_1.length; _i++) {
        var index = indexes_1[_i];
        this.removeStyles([this.getElementByIndex(index)], index);
      }
      var points = accumulation.visibleSeries[0].points;
      for (var i = 0; i < points.length; i++) {
        var index = new Index(0, points[i].index);
        this.removeStyles([this.getElementByIndex(index)], index);
        if (accumulation.visibleSeries[0].dataLabel.visible) {
          this.removeStyles([document.getElementById(accumulation.element.id + "_datalabel_Series_0_g_" + points[i].index)], index);
        }
      }
    };
    AccumulationSelection2.prototype.legendSelection = function(accumulation, series, pointIndex, targetEle, eventType) {
      if (eventType === "mousemove") {
        if (targetEle.id.indexOf("text") > 1) {
          targetEle = getElement2(targetEle.id.replace("text", "shape"));
        }
        if (targetEle.hasAttribute("class") && (targetEle.getAttribute("class").indexOf("highlight") > -1 || targetEle.getAttribute("class").indexOf("selection") > -1)) {
          return;
        }
        this.currentMode = this.accumulation.highlightMode;
      }
      var isPreSelected = this.isAlreadySelected(targetEle, eventType);
      if (isPreSelected) {
        var seriesElements = accumulation.getSeriesElement().childNodes[series].childNodes[pointIndex];
        var dataLabelElement = document.getElementById(accumulation.element.id + "_datalabel_Series_" + series + "_g_" + pointIndex);
        if (this.series[0].dataLabel.visible && dataLabelElement) {
          this.selection(accumulation, new Index(series, pointIndex), [dataLabelElement]);
        }
        this.selection(accumulation, new Index(series, pointIndex), [seriesElements]);
        this.blurEffect(accumulation.element.id, accumulation.visibleSeries);
      }
    };
    AccumulationSelection2.prototype.selectDataIndex = function(indexes, accumulation) {
      var element;
      for (var _i = 0, indexes_2 = indexes; _i < indexes_2.length; _i++) {
        var index = indexes_2[_i];
        element = this.getElementByIndex(index);
        if (element) {
          this.performSelection(index, accumulation, element);
        }
      }
    };
    AccumulationSelection2.prototype.removeMultiSelectEelments = function(accumulation, index, currentIndex, seriesCollection) {
      var series;
      for (var i = 0; i < index.length; i++) {
        series = seriesCollection[index[i].series];
        if (!this.checkEquals(index[i], currentIndex)) {
          this.removeStyles(this.findElements(accumulation, series, index[i]), index[i]);
          if (series.dataLabel.visible) {
            this.removeStyles([document.getElementById(accumulation.element.id + "_datalabel_Series_0_g_" + index[i].point)], index[i]);
          }
          index.splice(i, 1);
          i--;
        }
      }
    };
    AccumulationSelection2.prototype.blurEffect = function(pieId, visibleSeries) {
      var visibility = this.checkVisibility(this.highlightDataIndexes) || this.checkVisibility(this.selectedDataIndexes);
      for (var _i = 0, visibleSeries_1 = visibleSeries; _i < visibleSeries_1.length; _i++) {
        var series = visibleSeries_1[_i];
        if (series.visible) {
          this.checkSelectionElements(document.getElementById(pieId + "_SeriesCollection"), this.generateStyle(series), visibility);
        }
      }
    };
    AccumulationSelection2.prototype.checkSelectionElements = function(element, className, visibility) {
      var selectionElements = [];
      var children = element.childNodes[0].childNodes;
      children.forEach(function(child) {
        return selectionElements.push(child);
      });
      var dataLabelElement = document.getElementById(this.control.element.id + "_datalabel_Series_0");
      if (dataLabelElement) {
        var dataLabelChildren = dataLabelElement.childNodes;
        dataLabelChildren.forEach(function(child) {
          return selectionElements.push(child);
        });
      }
      var legendShape;
      var elementClass;
      var parentClass;
      for (var i = 0; i < selectionElements.length; i++) {
        elementClass = selectionElements[i].getAttribute("class") || "";
        parentClass = selectionElements[i].parentNode.getAttribute("class") || "";
        if (this.accumulation.selectionMode !== "None" || this.accumulation.highlightMode !== "None") {
          className = elementClass.indexOf("selection") > 0 || elementClass.indexOf("highlight") > 0 ? elementClass : className;
          className = parentClass.indexOf("selection") > 0 || parentClass.indexOf("highlight") > 0 ? parentClass : className;
        }
        if (elementClass.indexOf(className) === -1 && parentClass.indexOf(className) === -1 && visibility) {
          this.addSvgClass(selectionElements[i], this.unselected);
        } else {
          this.removeSvgClass(selectionElements[i], this.unselected);
        }
        if (elementClass.indexOf(className) === -1 && parentClass.indexOf(className) === -1 && visibility) {
          this.addSvgClass(selectionElements[i], this.unselected);
        } else {
          this.removeSvgClass(selectionElements[i], this.unselected);
          this.removeSvgClass(selectionElements[i].parentNode, this.unselected);
        }
        if (this.control.accumulationLegendModule && this.control.legendSettings.visible) {
          legendShape = document.getElementById(this.control.element.id + "_chart_legend_shape_" + i);
          if (legendShape) {
            if (elementClass.indexOf(className) === -1 && parentClass.indexOf(className) === -1 && visibility) {
              this.addSvgClass(legendShape, this.unselected);
            } else {
              this.removeSvgClass(legendShape, this.unselected);
            }
          }
        }
      }
    };
    AccumulationSelection2.prototype.applyStyles = function(elements, index) {
      var accumulationTooltip = this.control.accumulationTooltipModule;
      for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
        var element = elements_1[_i];
        var legendShape = void 0;
        if (element) {
          if (this.control.accumulationLegendModule && this.control.legendSettings.visible) {
            legendShape = document.getElementById(this.control.element.id + "_chart_legend_shape_" + index.point);
            this.removeSvgClass(legendShape, legendShape.getAttribute("class"));
            this.addSvgClass(legendShape, this.getSelectionClass(legendShape.id, index.point));
          }
          this.removeSvgClass(element.parentNode, this.unselected);
          this.removeSvgClass(element, this.unselected);
          var opacity = accumulationTooltip && accumulationTooltip.previousPoints.length > 0 && accumulationTooltip.previousPoints[0].point.index !== index.point ? accumulationTooltip.svgTooltip.opacity : this.series[index.series].opacity;
          element.setAttribute("opacity", opacity.toString());
          this.addSvgClass(element, this.getSelectionClass(element.id, index.point));
        }
      }
    };
    AccumulationSelection2.prototype.getSelectionClass = function(id, point) {
      return this.generateStyle(this.control.series[indexFinder(id).series], point);
    };
    AccumulationSelection2.prototype.removeStyles = function(elements, index) {
      var accumulationTooltip = this.control.accumulationTooltipModule;
      var legendShape;
      for (var _i = 0, elements_2 = elements; _i < elements_2.length; _i++) {
        var element = elements_2[_i];
        if (element) {
          if (this.control.accumulationLegendModule && this.control.legendSettings.visible) {
            legendShape = document.getElementById(this.control.element.id + "_chart_legend_shape_" + index.point);
            this.removeSvgClass(legendShape, this.getSelectionClass(legendShape.id, index.point));
          }
          var opacity = accumulationTooltip && accumulationTooltip.previousPoints.length > 0 && accumulationTooltip.previousPoints[0].point.index === index.point ? accumulationTooltip.svgTooltip.opacity : this.series[index.series].opacity;
          element.setAttribute("opacity", opacity.toString());
          this.removeSvgClass(element, this.getSelectionClass(element.id, index.point));
        }
      }
    };
    AccumulationSelection2.prototype.addOrRemoveIndex = function(indexes, index, add) {
      for (var i = 0; i < indexes.length; i++) {
        if (this.checkEquals(indexes[i], index)) {
          indexes.splice(i, 1);
          i--;
        }
      }
      if (add) {
        indexes.push(index);
      }
    };
    AccumulationSelection2.prototype.checkEquals = function(first, second) {
      return first.point === second.point && first.series === second.series;
    };
    AccumulationSelection2.prototype.mouseMove = function(event2) {
      var accumulation = this.accumulation;
      var targetElement = event2.target;
      if (accumulation.highlightMode !== "None") {
        if (!isNullOrUndefined(targetElement)) {
          if (event2.target.id.indexOf("text") > 1) {
            targetElement = getElement2(event2.target.id.replace("text", "shape"));
          }
          if (targetElement.hasAttribute("class") && targetElement.getAttribute("class").indexOf("highlight") > -1) {
            return;
          }
          this.calculateSelectedElements(accumulation, event2.target, event2.type);
          return;
        }
      }
      if (accumulation.selectionMode === "None") {
        return;
      }
    };
    AccumulationSelection2.prototype.getModuleName = function() {
      return "AccumulationSelection";
    };
    AccumulationSelection2.prototype.destroy = function() {
      this.removeEventListener();
    };
    return AccumulationSelection2;
  }(BaseSelection)
);

// node_modules/@syncfusion/ej2-charts/src/accumulation-chart/user-interaction/high-light.js
var __extends75 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var AccumulationHighlight = (
  /** @class */
  function(_super) {
    __extends75(AccumulationHighlight2, _super);
    function AccumulationHighlight2(accumulation) {
      var _this = _super.call(this, accumulation) || this;
      _this.accumulation = accumulation;
      _this.renderer = accumulation.renderer;
      _this.wireEvents();
      return _this;
    }
    AccumulationHighlight2.prototype.wireEvents = function() {
      if (this.accumulation.isDestroyed) {
        return;
      }
      this.accumulation.on(Browser.touchMoveEvent, this.mouseMove, this);
    };
    AccumulationHighlight2.prototype.unWireEvents = function() {
      if (this.accumulation.isDestroyed) {
        return;
      }
      this.accumulation.off(Browser.touchMoveEvent, this.mouseMove);
    };
    AccumulationHighlight2.prototype.declarePrivateVariables = function(accumulation) {
      this.styleId = accumulation.element.id + "_ej2_chart_highlight";
      this.unselected = accumulation.element.id + "_ej2_deselected";
      this.selectedDataIndexes = [];
      this.highlightDataIndexes = [];
    };
    AccumulationHighlight2.prototype.invokeHighlight = function(accumulation) {
      this.declarePrivateVariables(accumulation);
      this.series = extend({}, accumulation.visibleSeries, null, true);
      this.seriesStyles();
      this.currentMode = accumulation.highlightMode;
    };
    AccumulationHighlight2.prototype.getModuleName = function() {
      return "AccumulationHighlight";
    };
    AccumulationHighlight2.prototype.destroy = function() {
      this.unWireEvents();
    };
    return AccumulationHighlight2;
  }(AccumulationSelection)
);

// node_modules/@syncfusion/ej2-charts/src/accumulation-chart/annotation/annotation.js
var __extends76 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var AccumulationAnnotation = (
  /** @class */
  function(_super) {
    __extends76(AccumulationAnnotation2, _super);
    function AccumulationAnnotation2(control) {
      var _this = _super.call(this, control) || this;
      _this.pie = control;
      return _this;
    }
    AccumulationAnnotation2.prototype.renderAnnotations = function(element) {
      var _this = this;
      this.annotations = this.pie.annotations;
      var redraw = this.pie.redraw;
      this.parentElement = redrawElement(redraw, this.pie.element.id + "_Annotation_Collections") || createElement("div", {
        id: this.pie.element.id + "_Annotation_Collections"
      });
      this.annotations.map(function(annotation, index) {
        _this.processAnnotation(annotation, index, _this.parentElement);
      });
      if (this.pie.series[0].animation.enable && this.pie.series[0].type === "Pie" && this.pie.animateSeries) {
        this.parentElement.style.visibility = "hidden";
      }
      appendElement(this.parentElement, element, redraw);
    };
    AccumulationAnnotation2.prototype.getModuleName = function() {
      return "Annotation";
    };
    AccumulationAnnotation2.prototype.destroy = function() {
    };
    return AccumulationAnnotation2;
  }(AnnotationBase)
);

// node_modules/@syncfusion/ej2-charts/src/range-navigator/utils/helper.js
function rangeValueToCoefficient(value, range, inversed) {
  var result = (value - range.min) / range.delta;
  return inversed ? 1 - result : result;
}
function getXLocation(x, range, size, inversed) {
  x = rangeValueToCoefficient(x, range, inversed);
  return x * size;
}
function getRangeValueXByPoint(value, size, range, inversed) {
  var actualValue = !inversed ? value / size : 1 - value / size;
  return actualValue * range.delta + range.min;
}
function getExactData(points, start, end) {
  var selectedData = [];
  points.map(function(point) {
    if (point.xValue >= start && point.xValue <= end) {
      selectedData.push({
        "x": point.x,
        "y": point.y
      });
    }
  });
  return selectedData;
}
function getNearestValue(values, point) {
  return values.reduce(function(prev, curr) {
    return Math.abs(curr - point) < Math.abs(prev - point) ? curr : prev;
  });
}
var DataPoint = (
  /** @class */
  /* @__PURE__ */ function() {
    function DataPoint2(x, y, xValue, yValue, visible) {
      if (visible === void 0) {
        visible = true;
      }
      this.x = x;
      this.y = y;
      this.xValue = xValue;
      this.visible = visible;
    }
    return DataPoint2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/range-navigator/renderer/chart-render.js
var __extends77 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var RangeSeries = (
  /** @class */
  function(_super) {
    __extends77(RangeSeries2, _super);
    function RangeSeries2(range) {
      var _this = _super.call(this) || this;
      _this.dataSource = range.dataSource;
      _this.xName = range.xName;
      _this.yName = range.yName;
      _this.query = range.query;
      _this.xMin = Infinity;
      _this.xMax = -Infinity;
      _this.yMin = Infinity;
      _this.yMax = -Infinity;
      _this.labels = [];
      _this.indexLabels = {};
      return _this;
    }
    RangeSeries2.prototype.renderChart = function(control) {
      var _this = this;
      var dataSource;
      var query;
      this.seriesLength = 0;
      control.rangeSlider.points = [];
      if (control.series.length) {
        control.series.map(function(series) {
          dataSource = series.dataSource || control.dataSource;
          query = series.query || control.query;
          series.points = [];
          _this.processDataSource(dataSource, query, control, series);
        });
      } else {
        this.processDataSource(control.dataSource, control.query, control);
      }
    };
    RangeSeries2.prototype.processDataSource = function(dataSource, query, control, series) {
      var _this = this;
      if (!(dataSource instanceof DataManager) && !isNullOrUndefined(dataSource) && isNullOrUndefined(query)) {
        this.dataManagerSuccess({
          result: dataSource,
          count: dataSource.length
        }, control, series);
        return;
      }
      control.dataModule = new Data(dataSource, query);
      var dataManager = control.dataModule.getData(control.dataModule.generateQuery().requiresCount());
      dataManager.then(function(e) {
        return _this.dataManagerSuccess(e, control, series);
      });
    };
    RangeSeries2.prototype.dataManagerSuccess = function(e, control, series) {
      var viewData = e.count ? e.result : [];
      control.allowServerDataBinding = false;
      this.processJsonData(viewData, control, Object.keys(viewData).length, series);
      this.seriesLength += series ? 1 : this.seriesLength;
      if (!series || this.seriesLength === control.series.length) {
        this.processXAxis(control);
        this.calculateGroupingBounds(control);
        this.processYAxis(control);
        control.renderChart();
      }
    };
    RangeSeries2.prototype.processJsonData = function(viewData, control, len, series) {
      var i = 0;
      var point;
      var xName = series && series.xName || control.xName;
      var yName = series && series.yName || control.yName;
      while (i < len) {
        point = new DataPoint(getValue(xName, viewData[i]), getValue(yName, viewData[i]));
        point.yValue = +point.y;
        if (control.valueType.indexOf("DateTime") > -1) {
          var dateParser = control.intl.getDateParser({
            skeleton: "full",
            type: "dateTime"
          });
          var dateFormatter = control.intl.getDateFormat({
            skeleton: "full",
            type: "dateTime"
          });
          point.x = new Date(DataUtil.parse.parseJson({
            val: point.x
          }).val);
          point.xValue = Date.parse(dateParser(dateFormatter(point.x)));
          if (control.valueType === "DateTimeCategory") {
            if (this.indexLabels[point.xValue.toString()] === void 0) {
              this.indexLabels[point.xValue.toString()] = this.labels.length;
              this.labels.push(point.xValue.toString());
            }
            point.xValue = this.indexLabels[point.xValue];
          }
        } else {
          point.xValue = +point.x;
        }
        if (series) {
          series.points.push(point);
        }
        this.xMin = Math.min(this.xMin, point.xValue);
        this.yMin = Math.min(this.yMin, point.yValue);
        this.xMax = Math.max(this.xMax, point.xValue);
        this.yMax = Math.max(this.yMax, point.yValue);
        control.rangeSlider.points.push(point);
        i++;
      }
    };
    RangeSeries2.prototype.processXAxis = function(control) {
      var axis = {
        minimum: control.minimum,
        maximum: control.maximum,
        interval: control.interval,
        valueType: control.valueType,
        isInversed: control.enableRtl,
        labelFormat: control.labelFormat,
        logBase: control.logBase,
        skeleton: control.skeleton,
        skeletonType: control.skeletonType
      };
      this.xAxis = axis;
      this.xAxis.intervalType = control.intervalType;
      this.xAxis.maximumLabels = 3;
      this.xAxis.skeleton = control.skeleton;
      this.xAxis.intervalDivs = [10, 5, 2, 1];
      this.xAxis.rect = control.bounds;
      this.xAxis.visibleLabels = [];
      this.xAxis.orientation = "Horizontal";
      this.xAxis.labels = this.labels;
      this.xAxis.indexLabels = this.indexLabels;
      var axisModule = control[firstToLowerCase(control.valueType) + "Module"];
      axisModule.min = this.xMin;
      axisModule.max = this.xMax;
      axisModule.getActualRange(this.xAxis, control.bounds);
      if (this.xAxis.valueType === "Double" || this.xAxis.valueType === "DateTime" || this.xAxis.valueType === "DateTimeCategory") {
        axisModule.updateActualRange(this.xAxis, this.xAxis.actualRange.min, this.xAxis.actualRange.max, this.xAxis.actualRange.interval);
      }
      this.xAxis.actualRange.delta = this.xAxis.actualRange.max - this.xAxis.actualRange.min;
      this.xAxis.visibleRange = this.xAxis.actualRange;
      axisModule.calculateVisibleLabels(this.xAxis, control);
      if (this.xAxis.valueType === "DateTimeCategory" && control.periodSelectorModule) {
        control.periodSelectorModule.isDatetimeCategory = true;
        control.periodSelectorModule.sortedData = this.labels.map(function(label) {
          return parseInt(label, 10);
        });
      }
    };
    RangeSeries2.prototype.processYAxis = function(control) {
      var axis = {
        majorGridLines: {
          width: 0
        },
        rangePadding: "None",
        majorTickLines: {
          width: 0
        },
        labelStyle: {
          size: "0"
        },
        visible: false,
        valueType: "Double",
        minimum: null,
        maximum: null,
        interval: null
      };
      this.yAxis = axis;
      this.yAxis.rect = control.bounds;
      this.yAxis.maximumLabels = 3;
      this.yAxis.intervalDivs = [10, 5, 2, 1];
      this.yAxis.orientation = "Vertical";
      if (this.yMin === this.yMax) {
        this.yMax += 1;
        this.yMin -= 1;
      }
      control.doubleModule.min = this.yMin;
      control.doubleModule.max = this.yMax;
      control.doubleModule.getActualRange(this.yAxis, control.bounds);
      control.doubleModule.updateActualRange(this.yAxis, this.yAxis.actualRange.min, this.yAxis.actualRange.max, this.yAxis.actualRange.interval);
      this.yAxis.actualRange.delta = this.yAxis.actualRange.max - this.yAxis.actualRange.min;
      this.yAxis.visibleRange = this.yAxis.actualRange;
    };
    RangeSeries2.prototype.renderSeries = function(control) {
      var _this = this;
      this.chartGroup = control.renderer.createGroup({
        id: control.element.id + "_chart"
      });
      var colors = getSeriesColor(control.theme);
      control.series.map(function(series, index) {
        var isSeriesVisible = control.stockChart ? control.stockChart.series[index].visible : true;
        if (isSeriesVisible) {
          series.xAxis = _this.xAxis;
          series.yAxis = _this.yAxis;
          series.chart = control;
          series.index = index;
          series.xAxis.isInversed = control.enableRtl;
          series.interior = series.fill || colors[index % colors.length];
          _this.createSeriesElement(control, series, index);
          if (series.xAxis.valueType === "DateTimeCategory") {
            for (var i = 0; i < series.points.length; i++) {
              series.points[i].xValue = _this.xAxis.labels.indexOf(Date.parse(series.points[i].x.toString()).toString());
            }
          }
          if (control[firstToLowerCase(series.type) + "SeriesModule"]) {
            control[firstToLowerCase(series.type) + "SeriesModule"].render(series, _this.xAxis, _this.yAxis, false);
          } else {
            control["lineSeriesModule"].render(series, _this.xAxis, _this.yAxis, false);
          }
          _this.chartGroup.appendChild(series.seriesElement);
          if ((series.animation.enable && animationMode !== "Disable" || animationMode === "Enable") && control.animateSeries) {
            if (control[firstToLowerCase(series.type) + "SeriesModule"]) {
              control[firstToLowerCase(series.type) + "SeriesModule"].doAnimation(series);
            } else {
            }
          }
        }
      });
    };
    RangeSeries2.prototype.appendSeriesElements = function(control) {
      control.svgObject.appendChild(this.chartGroup);
      if (control.series.length) {
        this.drawSeriesBorder(control);
      }
    };
    RangeSeries2.prototype.createSeriesElement = function(control, series, index) {
      var elementId = control.element.id;
      series.clipRect = new Rect(this.xAxis.rect.x, this.yAxis.rect.y, this.xAxis.rect.width, this.yAxis.rect.height);
      series.clipRectElement = control.renderer.drawClipPath(new RectOption(elementId + "_RangeSeriesClipRect_" + index, "transparent", {
        width: 1,
        color: "Gray"
      }, 1, {
        x: 0,
        y: 0,
        width: series.clipRect.width,
        height: series.clipRect.height
      }));
      series.seriesElement = control.renderer.createGroup({
        "id": elementId + "SeriesGroup" + index,
        "transform": "translate(" + series.clipRect.x + "," + series.clipRect.y + ")",
        "clip-path": "url(#" + elementId + "_RangeSeriesClipRect_" + index + ")"
      });
      series.seriesElement.appendChild(series.clipRectElement);
    };
    RangeSeries2.prototype.calculateGroupingBounds = function(control) {
      var padding = control.margin.bottom;
      var labelHeight = measureText("string", control.labelStyle, control.themeStyle.axisLabelFont).height;
      var xMin = control.valueType === "DateTimeCategory" ? parseInt(this.xAxis.labels[this.xMin], 10) : this.xMin;
      var xMax = control.valueType === "DateTimeCategory" ? parseInt(this.xAxis.labels[this.xMax], 10) : this.xMax;
      this.calculateDateTimeNiceInterval(this.xAxis, new Size(control.bounds.width, control.bounds.height), xMin, xMax, false);
      if (control.enableGrouping && (control.valueType === "DateTime" || control.valueType === "DateTimeCategory") && (this.xAxis.actualIntervalType !== "Years" || !control.series.length)) {
        control.bounds.height -= control.labelPosition === "Outside" || control.series.length === 0 ? padding + labelHeight : labelHeight + 2 * padding;
      }
      if (!control.series.length) {
        control.bounds.y += control.bounds.height / 4;
        control.bounds.height = control.bounds.height / 2;
      }
    };
    RangeSeries2.prototype.drawSeriesBorder = function(control) {
      var start = control.stockChart ? "M" : "L";
      var close = control.stockChart ? "" : "Z";
      var options = new PathOption(control.element.id + "_SeriesBorder", "transparent", control.navigatorBorder.width, control.navigatorBorder.color || (control.theme.indexOf("Dark") > -1 ? "#49454F" : "#DDDDDD"), 1, control.navigatorBorder.dashArray, "M " + control.bounds.x + " " + control.bounds.y + " L " + (control.bounds.x + control.bounds.width) + " " + control.bounds.y + start + (control.bounds.x + control.bounds.width) + " " + (control.bounds.y + control.bounds.height) + " L " + control.bounds.x + " " + (control.bounds.y + control.bounds.height) + close);
      var htmlObject = control.renderer.drawPath(options);
      control.svgObject.appendChild(htmlObject);
    };
    return RangeSeries2;
  }(NiceInterval)
);

// node_modules/@syncfusion/ej2-charts/src/range-navigator/renderer/range-axis.js
var __extends78 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var RangeNavigatorAxis = (
  /** @class */
  function(_super) {
    __extends78(RangeNavigatorAxis2, _super);
    function RangeNavigatorAxis2(range) {
      var _this = _super.call(this) || this;
      _this.firstLevelLabels = [];
      _this.secondLevelLabels = [];
      _this.rangeNavigator = range;
      return _this;
    }
    RangeNavigatorAxis2.prototype.renderGridLines = function() {
      var pointX = 0;
      var control = this.rangeNavigator;
      var majorGridLines = control.majorGridLines;
      var majorTickLines = control.majorTickLines;
      var majorGrid = "";
      var majorTick = "";
      var rect = control.bounds;
      var chartAxis = control.chartSeries.xAxis;
      var disabledColor = control.disableRangeSelector ? "transparent" : null;
      this.gridLines = control.renderer.createGroup({
        id: control.element.id + "_GridLines"
      });
      var tick = control.tickPosition === "Outside" || control.series.length === 0 ? rect.y + rect.height + majorTickLines.height : rect.y + rect.height - majorTickLines.height;
      this.firstLevelLabels = [];
      chartAxis.labelStyle = control.labelStyle;
      chartAxis.skeleton = control.skeleton;
      chartAxis.skeletonType = control.skeletonType;
      chartAxis.isChart = false;
      if (control.valueType.indexOf("DateTime") > -1) {
        var interval = this.calculateDateTimeNiceInterval(chartAxis, rect, chartAxis.doubleRange.start, chartAxis.doubleRange.end, chartAxis.isChart);
        if (control.valueType === "DateTime") {
          this.findAxisLabels(chartAxis, interval);
        }
        this.actualIntervalType = chartAxis.actualIntervalType;
        if (control.valueType === "DateTimeCategory" && (this.actualIntervalType === "Quarter" || this.actualIntervalType === "Weeks")) {
          this.findSecondaryAxisLabels(chartAxis);
        }
      }
      this.firstLevelLabels = chartAxis.visibleLabels;
      this.lowerValues = [];
      var labelLength = chartAxis.visibleLabels.length;
      for (var i = 0; i < labelLength; i++) {
        this.lowerValues.push(this.firstLevelLabels[i].value);
        pointX = valueToCoefficient(this.firstLevelLabels[i].value, chartAxis) * rect.width + rect.x;
        if (pointX >= rect.x && rect.x + rect.width >= pointX) {
          majorGrid = majorGrid.concat("M " + pointX + " " + (control.bounds.y + control.bounds.height) + " L " + pointX + " " + control.bounds.y + " ");
          majorTick = majorTick.concat("M " + pointX + " " + (rect.y + rect.height) + " L " + pointX + " " + tick + " ");
        }
      }
      var options = new PathOption(control.element.id + "_MajorGridLine", "transparent", majorGridLines.width, control.series.length ? disabledColor || majorGridLines.color || control.themeStyle.gridLineColor : "transparent", 1, majorGridLines.dashArray, majorGrid);
      this.gridLines.appendChild(control.renderer.drawPath(options));
      options = new PathOption(control.element.id + "_MajorTickLine", "transparent", majorTickLines.width, disabledColor || majorTickLines.color || control.themeStyle.gridLineColor, 1, majorGridLines.dashArray, majorTick);
      this.gridLines.appendChild(control.renderer.drawPath(options));
    };
    RangeNavigatorAxis2.prototype.renderAxisLabels = function() {
      var axis = this.rangeNavigator.chartSeries.xAxis;
      var control = this.rangeNavigator;
      var pointY;
      var labelElement = control.renderer.createGroup({
        id: control.element.id + "_AxisLabels"
      });
      var firstLevelElement = control.renderer.createGroup({
        id: control.element.id + "_FirstLevelAxisLabels"
      });
      var secondLevelElement = control.renderer.createGroup({
        id: control.element.id + "_SecondLevelAxisLabels"
      });
      var secondaryAxis = axis;
      pointY = this.findLabelY(control, false);
      this.placeAxisLabels(axis, pointY, "_AxisLabel_", control, firstLevelElement);
      secondaryAxis.intervalType = secondaryAxis.actualIntervalType = control.groupBy || this.getSecondaryLabelType(axis.actualIntervalType);
      secondaryAxis.labelFormat = "";
      if (control.enableGrouping && control.valueType.indexOf("DateTime") > -1 && this.actualIntervalType !== "Years") {
        secondaryAxis.visibleRange.interval = 1;
        secondaryAxis.visibleLabels = [];
        var interval = this.calculateDateTimeNiceInterval(secondaryAxis, control.bounds, secondaryAxis.doubleRange.start, secondaryAxis.doubleRange.end, secondaryAxis.isChart);
        if (control.valueType === "DateTime") {
          this.findAxisLabels(secondaryAxis, interval);
        } else {
          this.findSecondaryAxisLabels(secondaryAxis);
        }
        this.secondLevelLabels = secondaryAxis.visibleLabels;
        pointY = this.findLabelY(control, true);
        var border = this.placeAxisLabels(secondaryAxis, pointY, "_SecondaryLabel_", control, secondLevelElement);
        var path = new PathOption(control.element.id + "_SecondaryMajorLines", "transparent", control.majorTickLines.width, control.majorTickLines.color || control.themeStyle.gridLineColor, 1, control.majorGridLines.dashArray, border);
        this.gridLines.appendChild(control.renderer.drawPath(path));
      }
      control.chartSeries.xAxis.visibleLabels = control.chartSeries.xAxis.visibleLabels.concat(secondaryAxis.visibleLabels);
      labelElement.style.cursor = axis.valueType.indexOf("DateTime") > -1 ? "cursor: pointer" : "cursor: default";
      labelElement.appendChild(firstLevelElement);
      labelElement.appendChild(secondLevelElement);
      control.svgObject.appendChild(this.gridLines);
      control.svgObject.appendChild(labelElement);
    };
    RangeNavigatorAxis2.prototype.getSecondaryLabelType = function(type) {
      var types = ["Years", "Quarter", "Months", "Weeks", "Days", "Hours", "Minutes", "Seconds"];
      return type === "Years" ? "Years" : types[types.indexOf(type) - 1];
    };
    RangeNavigatorAxis2.prototype.findSecondaryAxisLabels = function(axis) {
      axis.visibleLabels = [];
      axis.visibleRange.interval = Math.max(axis.visibleRange.interval, 1);
      var previousIndex;
      this.rangeNavigator.format = this.rangeNavigator.intl.getDateFormat({
        format: axis.labelFormat || "",
        type: firstToLowerCase(axis.skeleton),
        skeleton: this.getSkeleton(axis, null, null)
      });
      for (var i = Math.ceil(axis.visibleRange.min); i <= axis.visibleRange.max; i += axis.visibleRange.interval) {
        if ((!this.rangeNavigator.dateTimeCategoryModule.sameInterval(axis.labels.map(Number)[i], axis.labels.map(Number)[i - axis.visibleRange.interval], axis.actualIntervalType, i) || axis.isIndexed) && withIn(i, axis.visibleRange) && this.rangeNavigator.dateTimeCategoryModule.isMaximum(i, previousIndex, axis)) {
          var currentLabel = new Date(axis.labels.map(Number)[i]);
          if (axis.actualIntervalType === "Quarter") {
            var quarterMonths = [0, 3, 6, 9];
            var quarterIndex = Math.floor(currentLabel.getMonth() / 3);
            currentLabel.setMonth(quarterMonths[quarterIndex]);
          }
          axis.visibleLabels.push(new VisibleLabels(this.dateFormats(this.rangeNavigator.format(currentLabel), axis, axis.visibleLabels.length), i, this.rangeNavigator.labelStyle, this.rangeNavigator.format(currentLabel)));
          previousIndex = i;
        }
      }
    };
    RangeNavigatorAxis2.prototype.findAxisLabels = function(axis, interval) {
      axis.visibleLabels = [];
      var start = new Date(axis.visibleRange.min);
      var nextInterval;
      var text;
      interval = this.rangeNavigator.interval ? this.rangeNavigator.interval : interval;
      switch (axis.actualIntervalType) {
        case "Years":
          start = new Date(start.getFullYear(), 0, 1);
          break;
        case "Quarter":
          if (start.getMonth() <= 2) {
            start = new Date(start.getFullYear(), 0, 1);
          } else if (start.getMonth() <= 5) {
            start = new Date(start.getFullYear(), 3, 1);
          } else if (start.getMonth() <= 8) {
            start = new Date(start.getFullYear(), 6, 1);
          } else {
            start = new Date(start.getFullYear(), 9, 1);
          }
          break;
        case "Months":
          start = new Date(start.getFullYear(), start.getMonth());
          break;
        case "Weeks":
          start = new Date(start.getFullYear(), start.getMonth(), start.getDate() - start.getDay());
          break;
        case "Days":
          start = new Date(start.getFullYear(), start.getMonth(), start.getDate());
          break;
        case "Hours":
          start = new Date(start.getFullYear(), start.getMonth(), start.getDate(), start.getHours());
          break;
        case "Minutes":
          start = new Date(start.getFullYear(), start.getMonth(), start.getDate(), start.getHours(), start.getMinutes());
          break;
        case "Seconds":
          start = new Date(start.getFullYear(), start.getMonth(), start.getDate(), start.getHours(), start.getMinutes(), start.getSeconds());
          break;
      }
      nextInterval = start.getTime();
      this.rangeNavigator.format = this.rangeNavigator.intl.getDateFormat({
        format: axis.labelFormat || "",
        type: firstToLowerCase(axis.skeletonType),
        skeleton: this.getSkeleton(axis, null, null)
      });
      while (nextInterval <= axis.visibleRange.max) {
        text = this.dateFormats(this.rangeNavigator.format(new Date(nextInterval)), axis, axis.visibleLabels.length);
        axis.visibleLabels.push(new VisibleLabels(text, nextInterval, this.rangeNavigator.labelStyle, text));
        nextInterval = this.increaseDateTimeInterval(axis, nextInterval, interval).getTime();
      }
    };
    RangeNavigatorAxis2.prototype.dateFormats = function(text, axis, index) {
      var changedText = text;
      var isFirstLevel = this.rangeNavigator.enableGrouping && this.firstLevelLabels.length === 0;
      switch (axis.actualIntervalType) {
        case "Quarter":
          if (text.indexOf("Jan") > -1) {
            changedText = !isFirstLevel ? text.replace("Jan", "Quarter1") : "Quarter1";
          } else if (text.indexOf("Apr") > -1) {
            changedText = !isFirstLevel ? text.replace("Apr", "Quarter2") : "Quarter2";
          } else if (text.indexOf("Jul") > -1) {
            changedText = !isFirstLevel ? text.replace("Jul", "Quarter3") : "Quarter3";
          } else if (text.indexOf("Oct") > -1) {
            changedText = !isFirstLevel ? text.replace("Oct", "Quarter4") : "Quarter4";
          }
          break;
        case "Weeks":
          changedText = "Week" + ++index;
          break;
        default:
          changedText = text;
          break;
      }
      return changedText;
    };
    RangeNavigatorAxis2.prototype.findLabelY = function(control, isSecondary) {
      var pointY;
      var reference = control.bounds.y + control.bounds.height;
      var tickHeight = control.majorTickLines.height;
      var textHeight = measureText("Quarter1 2011", control.labelStyle, control.themeStyle.axisLabelFont).height;
      var padding = control.labelPosition === "Inside" ? 3 : 8;
      if (control.labelPosition === "Outside" && control.tickPosition === "Outside" || control.series.length === 0) {
        pointY = reference + tickHeight + padding + textHeight * 0.75;
      } else if (control.labelPosition === "Inside" && control.tickPosition === "Inside") {
        pointY = reference - tickHeight - padding;
      } else if (control.labelPosition === "Inside" && control.tickPosition === "Outside") {
        pointY = reference - padding;
      } else {
        pointY = reference + padding + textHeight * 0.75;
      }
      if (isSecondary) {
        padding = 15;
        if (control.labelPosition === "Outside" || control.series.length === 0) {
          pointY += padding + textHeight * 0.75;
        } else {
          pointY = control.tickPosition === "Outside" || control.series.length === 0 ? reference + tickHeight + padding + textHeight * 0.75 : reference + padding + textHeight * 0.75;
        }
      }
      return pointY;
    };
    RangeNavigatorAxis2.prototype.placeAxisLabels = function(axis, pointY, id, control, labelElement) {
      var maxLabels = axis.visibleLabels.length;
      var label;
      var prevLabel;
      var pointX;
      var padding = 2;
      var rect = control.bounds;
      var border = "";
      var pointXGrid;
      var disabledColor = control.disableRangeSelector ? "transparent" : null;
      var prevX = control.enableRtl ? rect.x + rect.width : rect.x;
      var intervalType = axis.actualIntervalType;
      var intervalInTime = control.labelPlacement === "Auto" && control.valueType === "DateTime" || control.labelPlacement === "BetweenTicks" ? maxLabels > 1 ? axis.visibleLabels[1].value - axis.visibleLabels[0].value : (axis.visibleRange.max - axis.visibleLabels[0].value) / 2 : 0;
      if (control.valueType.indexOf("DateTime") > -1 && (intervalType === "Quarter" || intervalType === "Weeks")) {
        this.findSuitableFormat(axis, control);
      }
      for (var i = 0, len = maxLabels; i < len; i++) {
        label = axis.visibleLabels[i];
        label.size = measureText(label.text, axis.labelStyle, control.themeStyle.axisLabelFont);
        if ((control.secondaryLabelAlignment === "Middle" || id.indexOf("_AxisLabel_") > -1) && (control.labelPlacement === "Auto" || control.labelPlacement === "BetweenTicks")) {
          pointX = valueToCoefficient(label.value + intervalInTime / 2, axis) * rect.width + rect.x;
        } else if (id.indexOf("Secondary") > -1) {
          pointX = this.findAlignment(axis, i);
        }
        if (control.labelPlacement === "OnTicks" && control.labelPosition === "Inside") {
          pointX = valueToCoefficient(label.value, axis) * rect.width + rect.x + label.size.width / 2 + padding;
        } else if (control.labelPlacement === "OnTicks" && control.labelPosition === "Outside") {
          pointX = valueToCoefficient(label.value, axis) * rect.width + rect.x;
        }
        pointXGrid = valueToCoefficient(label.value, axis) * rect.width + rect.x;
        if ((i === 0 || i === axis.visibleLabels.length - 1 && control.enableRtl) && pointX < rect.x) {
          pointX = rect.x + label.size.width / 2;
        }
        if ((i === axis.visibleLabels.length - 1 || i === 0 && control.enableRtl) && pointX + label.size.width > rect.x + rect.width) {
          pointX = rect.x + rect.width - label.size.width / 2;
        }
        if (id.indexOf("_SecondaryLabel_") > -1) {
          if (pointX >= rect.x && rect.x + rect.width >= pointX) {
            border = border.concat("M " + pointXGrid + " " + pointY + " L " + pointXGrid + " " + (pointY - label.size.height));
          }
        }
        if (control.labelIntersectAction === "Hide" && i !== 0 && this.isIntersect(axis, pointX, label.size.width, prevX, prevLabel.size.width)) {
          continue;
        }
        if (control.secondaryLabelAlignment === "Middle" && axis.visibleLabels.length === 1) {
          pointX = valueToCoefficient(label.value, axis) + (rect.x + rect.width / 2);
        }
        var labelStyle = control.labelStyle;
        var style = {
          size: labelStyle.size,
          color: disabledColor || labelStyle.color || control.themeStyle.axisLabelFont.color,
          fontFamily: labelStyle.fontFamily,
          fontStyle: labelStyle.fontStyle || control.labelStyle.fontStyle,
          fontWeight: labelStyle.fontWeight || control.labelStyle.fontWeight,
          opacity: labelStyle.opacity || control.labelStyle.opacity,
          textAlignment: labelStyle.textAlignment || control.labelStyle.textAlignment,
          textOverflow: labelStyle.textOverflow || control.labelStyle.textOverflow
        };
        var argsData = {
          cancel: false,
          name: "labelRender",
          text: label.text,
          value: label.value,
          labelStyle: style,
          region: new Rect(pointX, pointY, label.size.width, label.size.height)
        };
        control.trigger("labelRender", argsData);
        if (!argsData.cancel) {
          control.labels.push(argsData);
        } else {
          continue;
        }
        textElement2(this.rangeNavigator.renderer, new TextOption(this.rangeNavigator.element.id + id + i, pointX, pointY, "middle", argsData.text), argsData.labelStyle, argsData.labelStyle.color || control.themeStyle.labelFontColor, labelElement, null, null, null, null, null, null, null, null, null, null, control.themeStyle.axisLabelFont).style.cursor = axis.valueType.indexOf("DateTime") > -1 ? "cursor: pointer" : "cursor: default";
        prevX = pointX;
        prevLabel = label;
      }
      return border;
    };
    RangeNavigatorAxis2.prototype.isIntersect = function(axis, currentX, currentWidth, prevX, prevWidth) {
      return axis.isInversed ? currentX + currentWidth / 2 > prevX - prevWidth / 2 : currentX - currentWidth / 2 < prevX + prevWidth / 2;
    };
    RangeNavigatorAxis2.prototype.findSuitableFormat = function(axis, control) {
      var labels = axis.visibleLabels;
      var labelLength = labels.length;
      var bounds = control.bounds;
      var prevX;
      var currentX;
      var interval = control.valueType === "DateTime" ? labelLength > 1 ? labels[1].value - labels[0].value : axis.visibleRange.interval : 0;
      for (var i = 0; i < labelLength; i++) {
        currentX = valueToCoefficient(labels[i].value + interval / 2, axis) * bounds.width + bounds.x;
        labels[i].size = measureText(labels[i].text, axis.labelStyle, control.themeStyle.axisLabelFont);
        if (i === 0 && currentX < bounds.x) {
          currentX = bounds.x + labels[i].size.width / 2;
        }
        if (axis.actualIntervalType === "Quarter") {
          if (i !== 0) {
            if (labels[i].text.indexOf("Quarter") > -1 && this.isIntersect(axis, currentX, labels[i].size.width, prevX, labels[i - 1].size.width)) {
              labels.every(function(label) {
                label.text = label.text.toString().replace("Quarter", "QTR");
                return true;
              });
              axis.visibleLabels = labels;
              this.findSuitableFormat(axis, control);
            } else {
              if (this.isIntersect(axis, currentX, labels[i].size.width, prevX, labels[i - 1].size.width)) {
                labels.every(function(label) {
                  label.text = label.text.toString().replace("QTR", "Q");
                  return true;
                });
                axis.visibleLabels = labels;
              }
            }
          }
        } else if (axis.actualIntervalType === "Weeks") {
          if (i !== 0 && labels[i].text.indexOf("Week") > -1 && this.isIntersect(axis, currentX, labels[i].size.width, prevX, labels[i - 1].size.width)) {
            labels.every(function(label) {
              label.text = label.text.toString().replace("Week", "W");
              return true;
            });
            axis.visibleLabels = labels;
          }
        }
        prevX = currentX;
      }
    };
    RangeNavigatorAxis2.prototype.findAlignment = function(axis, index) {
      var label = axis.visibleLabels[index];
      var nextLabel = axis.visibleLabels[index + 1];
      var bounds = this.rangeNavigator.bounds;
      return this.rangeNavigator.secondaryLabelAlignment === "Near" ? valueToCoefficient(label.value, axis) * bounds.width + bounds.x + label.size.width / 2 : valueToCoefficient(nextLabel ? nextLabel.value : axis.visibleRange.max, axis) * bounds.width + bounds.x - label.size.width;
    };
    return RangeNavigatorAxis2;
  }(DateTime)
);

// node_modules/@syncfusion/ej2-charts/src/range-navigator/model/range-base.js
var __extends79 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate10 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var RangeNavigatorSeries = (
  /** @class */
  function(_super) {
    __extends79(RangeNavigatorSeries2, _super);
    function RangeNavigatorSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.clipRect = new Rect(0, 0, 0, 0);
      return _this;
    }
    __decorate10([Property(null)], RangeNavigatorSeries2.prototype, "dataSource", void 0);
    __decorate10([Property(null)], RangeNavigatorSeries2.prototype, "xName", void 0);
    __decorate10([Property(null)], RangeNavigatorSeries2.prototype, "yName", void 0);
    __decorate10([Property()], RangeNavigatorSeries2.prototype, "query", void 0);
    __decorate10([Property("Line")], RangeNavigatorSeries2.prototype, "type", void 0);
    __decorate10([Complex({
      enable: false
    }, Animation2)], RangeNavigatorSeries2.prototype, "animation", void 0);
    __decorate10([Complex({
      color: "transparent",
      width: 2
    }, Border)], RangeNavigatorSeries2.prototype, "border", void 0);
    __decorate10([Property(null)], RangeNavigatorSeries2.prototype, "fill", void 0);
    __decorate10([Property(1)], RangeNavigatorSeries2.prototype, "width", void 0);
    __decorate10([Property(1)], RangeNavigatorSeries2.prototype, "opacity", void 0);
    __decorate10([Property("0")], RangeNavigatorSeries2.prototype, "dashArray", void 0);
    return RangeNavigatorSeries2;
  }(ChildProperty)
);
var ThumbSettings = (
  /** @class */
  function(_super) {
    __extends79(ThumbSettings2, _super);
    function ThumbSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate10([Property(null)], ThumbSettings2.prototype, "width", void 0);
    __decorate10([Property(null)], ThumbSettings2.prototype, "height", void 0);
    __decorate10([Complex({
      width: 1,
      color: null
    }, Border)], ThumbSettings2.prototype, "border", void 0);
    __decorate10([Property(null)], ThumbSettings2.prototype, "fill", void 0);
    __decorate10([Property("Circle")], ThumbSettings2.prototype, "type", void 0);
    return ThumbSettings2;
  }(ChildProperty)
);
var StyleSettings = (
  /** @class */
  function(_super) {
    __extends79(StyleSettings2, _super);
    function StyleSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate10([Complex({}, ThumbSettings)], StyleSettings2.prototype, "thumb", void 0);
    __decorate10([Property(null)], StyleSettings2.prototype, "selectedRegionColor", void 0);
    __decorate10([Property(null)], StyleSettings2.prototype, "unselectedRegionColor", void 0);
    return StyleSettings2;
  }(ChildProperty)
);
var RangeTooltipSettings = (
  /** @class */
  function(_super) {
    __extends79(RangeTooltipSettings2, _super);
    function RangeTooltipSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate10([Property(false)], RangeTooltipSettings2.prototype, "enable", void 0);
    __decorate10([Property(null)], RangeTooltipSettings2.prototype, "opacity", void 0);
    __decorate10([Property(null)], RangeTooltipSettings2.prototype, "fill", void 0);
    __decorate10([Property(null)], RangeTooltipSettings2.prototype, "format", void 0);
    __decorate10([Complex({
      fontFamily: null,
      size: "12px",
      fontStyle: "Normal",
      fontWeight: null,
      color: null
    }, Font)], RangeTooltipSettings2.prototype, "textStyle", void 0);
    __decorate10([Property(null)], RangeTooltipSettings2.prototype, "template", void 0);
    __decorate10([Complex({
      color: null,
      width: null
    }, Border)], RangeTooltipSettings2.prototype, "border", void 0);
    __decorate10([Property("OnDemand")], RangeTooltipSettings2.prototype, "displayMode", void 0);
    return RangeTooltipSettings2;
  }(ChildProperty)
);

// node_modules/@syncfusion/ej2-charts/src/range-navigator/renderer/slider.js
var RangeSlider = (
  /** @class */
  function() {
    function RangeSlider2(range) {
      this.control = range;
      this.points = [];
      this.isIOS = Browser.isIos || Browser.isIos7;
      var thumb = range.navigatorStyleSettings.thumb;
      this.thumbVisible = range.themeStyle.thumbWidth !== 0 && range.themeStyle.thumbHeight !== 0;
      this.elementId = range.element.id;
      this.thumpPadding = range.themeStyle.thumbWidth / 2;
      this.addEventListener();
      this.thumbColor = range.disableRangeSelector ? "transparent" : thumb.fill || range.themeStyle.thumbBackground;
    }
    RangeSlider2.prototype.render = function(range) {
      var renderer = range.renderer;
      var style = range.navigatorStyleSettings;
      var disabledColor = range.disableRangeSelector ? "transparent" : null;
      var sliderGroup = renderer.createGroup({
        "id": this.elementId + "_sliders",
        style: range.disableRangeSelector ? "pointer-events:none;" : ""
      });
      var option = new RectOption(this.elementId + "_leftUnSelectedArea", disabledColor || style.unselectedRegionColor || range.themeStyle.unselectedRectColor, {
        width: 0
      }, 1, {
        x: range.bounds.x,
        y: range.bounds.y,
        width: range.bounds.width / 3,
        height: range.bounds.height
      }, 0, 0, "", style.thumb.border.dashArray);
      this.leftUnSelectedElement = renderer.drawRectangle(option);
      option.id = this.elementId + "_rightUnSelectedArea";
      this.rightUnSelectedElement = renderer.drawRectangle(option);
      option.id = this.elementId + "_SelectedArea";
      option.fill = disabledColor || style.selectedRegionColor || range.themeStyle.selectedRegionColor;
      this.selectedElement = renderer.drawRectangle(option);
      this.selectedElement.setAttribute("role", "region");
      this.selectedElement.setAttribute("aria-label", "Range Slider with " + range.rangeSlider.points.length + " data points");
      this.selectedElement.style.cursor = "-webkit-grab";
      this.leftSlider = renderer.createGroup({
        "id": this.elementId + "_LeftSlider",
        "style": "cursor: ew-resize"
      });
      this.rightSlider = renderer.createGroup({
        "id": this.elementId + "_RightSlider",
        "style": "cursor: ew-resize"
      });
      this.createThump(renderer, range.bounds, this.leftSlider, this.elementId + "_LeftSlider", sliderGroup);
      this.createThump(renderer, range.bounds, this.rightSlider, this.elementId + "_RightSlider");
      sliderGroup.appendChild(this.leftUnSelectedElement);
      sliderGroup.appendChild(this.rightUnSelectedElement);
      sliderGroup.appendChild(this.selectedElement);
      sliderGroup.appendChild(this.leftSlider);
      sliderGroup.appendChild(this.rightSlider);
      range.svgObject.appendChild(sliderGroup);
    };
    RangeSlider2.prototype.createThump = function(render, bounds, parent, id, sliderGroup) {
      var control = this.control;
      var thump = control.navigatorStyleSettings.thumb;
      var style = control.themeStyle;
      var y = bounds.y + bounds.height / 2;
      var x = this.thumpPadding;
      var tickLength = control.themeStyle.thumbHeight / 2 - 5;
      var disabledColor = control.disableRangeSelector ? "transparent" : null;
      var lineColor = disabledColor || thump.border.color || style.thumpLineColor;
      var shadowElement;
      parent.appendChild(render.drawPath(new PathOption(id + "_ThumpLine", "transparent", thump.border.width, control.series.length ? lineColor : "transparent", 1, thump.border.dashArray, "M " + x + " " + bounds.y + " L " + x + " " + (bounds.y + bounds.height) + " ")));
      this.thumpY = y - control.themeStyle.thumbHeight / 2;
      this.sliderY = bounds.y > this.thumpY ? this.thumpY : bounds.y;
      if (sliderGroup && !control.disableRangeSelector) {
        shadowElement = render.createDefs();
        shadowElement.innerText = '<rect xmlns="http://www.w3.org/2000/svg" id="' + this.control.element.id + '_shadow" x="0" y="' + this.thumpY + '" width="' + control.themeStyle.thumbWidth + '" height="' + control.themeStyle.thumbHeight + '" rx="' + (thump.type === "Circle" ? "50%" : "0%") + '"/><filter xmlns="http://www.w3.org/2000/svg" x="-25.0%" y="-20.0%" width="150.0%" height="150.0%" filterUnits="objectBoundingBox" id="ej2-range-shadow"><feOffset dx="0" dy="1" in="SourceAlpha"result="shadowOffsetOuter1"/><feGaussianBlur stdDeviation="1.5" in="shadowOffsetOuter1" result="shadowBlurOuter1"/><feComposite in="shadowBlurOuter1" in2="SourceAlpha" operator="out" result="shadowBlurOuter1"/><feColorMatrix values="0 0 0 0 0   0 0 0 0 0   0 0 0 0 0  0 0 0 0.16 0" type="matrix" in="shadowBlurOuter1"/></filter>';
        sliderGroup.appendChild(shadowElement);
      }
      parent.innerText += '<use xmlns="http://www.w3.org/2000/svg" fill="black" fill-opacity="1" filter="url(#ej2-range-shadow)" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#path-1"/>';
      if (thump.type === "Circle") {
        parent.appendChild(drawSymbol({
          x,
          y
        }, "Circle", {
          width: control.themeStyle.thumbWidth,
          height: control.themeStyle.thumbHeight
        }, "", new PathOption(id + "_ThumpSymbol", disabledColor || this.thumbColor, thump.border.width, lineColor, 1, null), "Thumb"));
      } else {
        parent.appendChild(render.drawRectangle(new RectOption(id + "_ThumpSymbol", disabledColor || this.thumbColor, {
          width: thump.border.width,
          color: lineColor
        }, 1, {
          x: x - control.themeStyle.thumbWidth / 2,
          y: y - control.themeStyle.thumbHeight / 2,
          width: control.themeStyle.thumbWidth,
          height: control.themeStyle.thumbHeight
        }, 2, 2, "", thump.border.dashArray)));
      }
      if (this.thumbVisible) {
        parent.appendChild(render.drawPath(new PathOption(id + "_ThumpGrip", "transparent", 1, disabledColor || control.themeStyle.gripColor, 1, null, "M " + (x + 2) + " " + (y + tickLength) + " L " + (x + 2) + " " + (y - tickLength) + " " + (this.control.theme.indexOf("Fluent2") > -1 || this.control.theme.indexOf("Bootstrap5") > -1 || this.control.theme.indexOf("Tailwind3") > -1 ? "" : "M " + x + " " + (y + tickLength) + " L " + x + " " + (y - tickLength) + " ") + "M " + (x - 2) + " " + (y + tickLength) + " L " + (x - 2) + " " + (y - tickLength) + " ")));
      }
    };
    RangeSlider2.prototype.setSlider = function(start, end, trigger, showTooltip2, resize) {
      if (resize === void 0) {
        resize = false;
      }
      var range = this.control;
      var padding = range.bounds.x;
      var axisRange = range.chartSeries.xAxis.actualRange;
      var isLeightWeight = range.series.length === 0;
      if (isNaN(start) && isNaN(end)) {
        start = 0;
        end = range.bounds.width;
      }
      if (!(end >= start)) {
        start = [end, end = start][0];
      }
      start = end >= start ? start : [end, end = start][0];
      start = Math.max(start, axisRange.min);
      end = Math.min(end, axisRange.max);
      this.startX = padding + getXLocation(start, axisRange, range.bounds.width, range.enableRtl);
      this.endX = padding + getXLocation(end, axisRange, range.bounds.width, range.enableRtl);
      var selectedX = range.enableRtl ? this.endX : this.startX;
      var rightPadding = range.enableRtl ? this.startX : this.endX;
      this.sliderWidth = Math.abs(this.endX - this.startX);
      this.selectedElement.setAttribute("x", selectedX + "");
      this.selectedElement.setAttribute("width", this.sliderWidth + "");
      this.leftUnSelectedElement.setAttribute("width", selectedX - padding + "");
      this.rightUnSelectedElement.setAttribute("x", rightPadding + "");
      this.rightUnSelectedElement.setAttribute("width", range.bounds.width - (rightPadding - padding) + "");
      this.leftSlider.setAttribute("transform", "translate(" + (this.startX - this.thumpPadding) + ", 0)");
      this.rightSlider.setAttribute("transform", "translate(" + (this.endX - this.thumpPadding) + ", 0)");
      var left = this.control.svgObject.getBoundingClientRect().left - this.control.element.getBoundingClientRect().left;
      var leftX = this.control.enableRtl ? this.endX : this.startX;
      var rightX = this.control.enableRtl ? this.startX : this.endX;
      this.leftRect = {
        x: isLeightWeight ? left + padding : padding,
        y: isLeightWeight ? 0 : range.bounds.y,
        width: isLeightWeight ? leftX - padding : leftX,
        height: isLeightWeight ? this.thumpY : range.bounds.height
      };
      this.rightRect = {
        x: isLeightWeight ? left + rightX : rightX,
        y: isLeightWeight ? 0 : range.bounds.y,
        width: range.bounds.width - (rightPadding - padding),
        height: isLeightWeight ? this.thumpY : range.bounds.height
      };
      this.midRect = {
        x: isLeightWeight ? leftX + left : 0,
        y: isLeightWeight ? 0 : range.bounds.y,
        width: isLeightWeight ? Math.abs(this.endX - this.startX) : rightX,
        height: isLeightWeight ? this.thumpY : range.bounds.height
      };
      this.currentStart = start;
      this.currentEnd = end;
      if (showTooltip2) {
        this.control.rangeTooltipModule.renderLeftTooltip(this);
        this.control.rangeTooltipModule.renderRightTooltip(this);
      }
      var periodSelectorModule = this.control.periodSelectorModule;
      if (periodSelectorModule && this.control.redraw && this.control.getModuleName() === "rangeNavigator") {
        var selectedIndex = periodSelectorModule.findSelectedIndex(start, end, periodSelectorModule.control.periods);
        periodSelectorModule.setSelectedStyle(selectedIndex);
        this.control.redraw = false;
      }
      if (trigger && !resize) {
        this.triggerEvent(axisRange);
      }
    };
    RangeSlider2.prototype.triggerEvent = function(range) {
      var xAxis = this.control.chartSeries.xAxis;
      var valueType = xAxis.valueType;
      var argsData = {
        cancel: false,
        start: valueType === "DateTime" ? new Date(this.currentStart) : valueType === "DateTimeCategory" ? this.currentStart : valueType === "Logarithmic" ? Math.pow(xAxis.logBase, this.currentStart) : this.currentStart,
        end: valueType === "DateTime" ? new Date(this.currentEnd) : valueType === "DateTimeCategory" ? this.currentEnd : valueType === "Logarithmic" ? Math.pow(xAxis.logBase, this.currentEnd) : this.currentEnd,
        name: "changed",
        selectedData: getExactData(this.points, this.currentStart, this.currentEnd),
        zoomPosition: (this.control.enableRtl ? range.max - this.currentEnd : this.currentStart - range.min) / range.delta,
        zoomFactor: (this.currentEnd - this.currentStart) / range.delta,
        selectedPeriod: this.selectedPeriod ? this.selectedPeriod : ""
      };
      this.control.trigger("changed", argsData);
    };
    RangeSlider2.prototype.addEventListener = function() {
      if (this.control.isDestroyed) {
        return;
      }
      this.control.on(Browser.touchMoveEvent, this.mouseMoveHandler, this);
      this.control.on(Browser.touchStartEvent, this.mouseDownHandler, this);
      this.control.on(Browser.touchEndEvent, this.mouseUpHandler, this);
      this.control.on(Browser.isPointer ? "pointerleave" : "mouseleave", this.mouseCancelHandler, this);
    };
    RangeSlider2.prototype.removeEventListener = function() {
      if (this.control.isDestroyed) {
        return;
      }
      this.control.off(Browser.touchMoveEvent, this.mouseMoveHandler);
      this.control.off(Browser.touchStartEvent, this.mouseDownHandler);
      this.control.off(Browser.touchEndEvent, this.mouseUpHandler);
      this.control.off(Browser.isPointer ? "pointerleave" : "mouseleave", this.mouseCancelHandler);
    };
    RangeSlider2.prototype.mouseMoveHandler = function(e) {
      var control = this.control;
      var axisRange = control.chartSeries.xAxis.actualRange;
      var bounds = control.bounds;
      var start;
      var end;
      this.getCurrentSlider(e.target.id);
      if (this.isDrag && control.mouseX >= bounds.x) {
        switch (this.currentSlider) {
          case "Left":
            control.startValue = this.getRangeValue(Math.abs(control.mouseX - bounds.x));
            break;
          case "Right":
            control.endValue = this.getRangeValue(Math.abs(control.mouseX - bounds.x));
            break;
          case "Middle": {
            start = Math.max(this.getRangeValue(Math.abs(this.startX - (this.previousMoveX - control.mouseX) - bounds.x)), axisRange.min);
            end = Math.min(this.getRangeValue(Math.abs(this.endX - (this.previousMoveX - control.mouseX) - bounds.x)), axisRange.max);
            var currentWidth = Math.floor(Math.abs(getXLocation(end, axisRange, control.bounds.width, control.enableRtl) - getXLocation(start, axisRange, control.bounds.width, control.enableRtl)));
            if (currentWidth === Math.floor(this.sliderWidth)) {
              control.startValue = start;
              control.endValue = end;
            } else {
              if (end === axisRange.max) {
                control.endValue = axisRange.max;
              }
              if (Math.floor(this.startX) === bounds.x) {
                control.startValue = axisRange.min;
              }
            }
            break;
          }
        }
        if (e.preventDefault && this.isIOS) {
          e.preventDefault();
        }
        if (this.currentSlider !== "Middle") {
          var periodSelectorModule = this.control.periodSelectorModule;
          if (periodSelectorModule) {
            var buttons = periodSelectorModule.control.periods;
            buttons.map(function(period) {
              period.selected = false;
            });
            periodSelectorModule.selectedIndex = void 0;
            var selectedIndex = periodSelectorModule.findSelectedIndex(control.startValue, control.endValue, buttons);
            periodSelectorModule.setSelectedStyle(selectedIndex);
          }
        }
        this.setSlider(control.startValue, control.endValue, !control.enableDeferredUpdate, control.rangeTooltipModule && control.tooltip.enable);
        this.previousMoveX = control.mouseX;
      }
    };
    RangeSlider2.prototype.getRangeValue = function(x) {
      var control = this.control;
      var axisRange = control.chartSeries.xAxis.actualRange;
      var bounds = control.bounds;
      return getRangeValueXByPoint(x, bounds.width, axisRange, control.enableRtl);
    };
    RangeSlider2.prototype.mouseDownHandler = function(e) {
      this.currentSlider = this.getCurrentSlider(e.target.id);
      this.selectedElement.style.cursor = "-webkit-grabbing";
      this.isDrag = !(this.currentSlider === "UnSelectedArea" || !this.currentSlider);
      this.previousMoveX = this.control.mouseDownX;
    };
    RangeSlider2.prototype.getCurrentSlider = function(id) {
      var hoverColor = this.control.themeStyle.thumbHoverColor;
      if (id.indexOf(this.elementId + "_LeftSlider") > -1) {
        this.leftSlider.childNodes[2].setAttribute("fill", hoverColor);
        return "Left";
      } else if (id.indexOf(this.elementId + "_RightSlider") > -1) {
        this.rightSlider.childNodes[2].setAttribute("fill", hoverColor);
        return "Right";
      } else if (id.indexOf(this.elementId + "_SelectedArea") > -1) {
        return "Middle";
      } else if (id.indexOf("UnSelectedArea") > -1) {
        this.leftSlider.childNodes[2].setAttribute("fill", this.thumbColor);
        this.rightSlider.childNodes[2].setAttribute("fill", this.thumbColor);
        return "UnSelectedArea";
      } else if (id.indexOf(this.elementId + "_AxisLabel_") > -1 && (this.control.valueType === "DateTime" || this.control.valueType === "DateTimeCategory")) {
        this.labelIndex = +id.substring(id.lastIndexOf("_") + 1, id.length);
        return "firstLevelLabels";
      } else if (id.indexOf(this.elementId + "_SecondaryLabel") > -1 && (this.control.valueType === "DateTime" || this.control.valueType === "DateTimeCategory")) {
        this.labelIndex = +id.substring(id.lastIndexOf("_") + 1, id.length);
        return "secondLevelLabels";
      } else {
        this.leftSlider.childNodes[2].setAttribute("fill", this.thumbColor);
        this.rightSlider.childNodes[2].setAttribute("fill", this.thumbColor);
        if (this.control.periodSelectorModule) {
          this.control.periodSelectorModule.triggerChange = true;
        }
        return null;
      }
    };
    RangeSlider2.prototype.mouseUpHandler = function() {
      var control = this.control;
      var range = control.chartSeries.xAxis.actualRange;
      var trigger = control.enableDeferredUpdate;
      var enabledTooltip = control.tooltip.enable;
      if (control.stockChart) {
        control.stockChart.zoomChange = false;
      }
      if (this.currentSlider === "UnSelectedArea") {
        var value = void 0;
        var start = void 0;
        var end = void 0;
        var isRtl = control.enableRtl;
        var difference = control.endValue - control.startValue;
        if (control.mouseDownX < this.startX) {
          value = Math.max(this.getRangeValue(control.mouseDownX - this.sliderWidth / 2 - control.bounds.x), range.min);
          end = isRtl ? value : value + difference;
          start = isRtl ? value - difference : value;
        } else {
          value = Math.min(this.getRangeValue(control.mouseDownX + this.sliderWidth / 2 - control.bounds.x), range.max);
          start = isRtl ? value : value - difference;
          end = isRtl ? value + difference : value;
        }
        this.performAnimation(start, end, control);
        trigger = false;
      } else if (this.currentSlider === "firstLevelLabels" || this.currentSlider === "secondLevelLabels") {
        var secondLabel = control.rangeAxis[this.currentSlider][this.labelIndex + 1];
        if (this.selectedPeriod) {
          var periodSelectorModule = this.control.periodSelectorModule;
          if (periodSelectorModule) {
            var buttons = periodSelectorModule.control.periods;
            buttons.map(function(period) {
              period.selected = false;
            });
            periodSelectorModule.selectedIndex = void 0;
            var selectedIndex = periodSelectorModule.findSelectedIndex(control.rangeAxis[this.currentSlider][this.labelIndex].value, secondLabel ? control.allowIntervalData ? secondLabel.value - 1 : secondLabel.value : range.max, buttons);
            periodSelectorModule.setSelectedStyle(selectedIndex);
          }
        }
        this.performAnimation(control.rangeAxis[this.currentSlider][this.labelIndex].value, secondLabel ? control.allowIntervalData ? secondLabel.value - 1 : secondLabel.value : range.max, control);
        trigger = false;
      } else if (this.currentSlider === null) {
        trigger = false;
      }
      if (this.isDrag && control.allowSnapping) {
        this.setAllowSnapping(control, this.currentStart, this.currentEnd, true, enabledTooltip);
        trigger = false;
      }
      if (trigger) {
        this.setSlider(this.currentStart, this.currentEnd, true, enabledTooltip);
      }
      if (this.currentSlider !== null) {
        if (this.control.periodSelectorSettings.periods.length > 0) {
          this.control.periodSelectorModule.triggerChange = false;
          this.control.periodSelectorModule.datePicker.startDate = this.control.periodSelectorModule.isDatetimeCategory ? new Date(this.control.periodSelectorModule.sortedData[Math.floor(this.currentStart)]) : new Date(this.currentStart);
          this.control.periodSelectorModule.datePicker.endDate = this.control.periodSelectorModule.isDatetimeCategory ? new Date(this.control.periodSelectorModule.sortedData[Math.floor(this.currentEnd)]) : new Date(this.currentEnd);
        }
      }
      this.selectedElement.style.cursor = "-webkit-grab";
      control.startValue = this.currentStart;
      control.endValue = this.currentEnd;
      this.isDrag = false;
      this.labelIndex = null;
      this.currentSlider = null;
    };
    RangeSlider2.prototype.setAllowSnapping = function(control, start, end, trigger, tooltip) {
      var values = control.rangeAxis.lowerValues;
      values.push(control.chartSeries.xAxis.actualRange.max);
      this.setSlider(getNearestValue(values, start), getNearestValue(values, end), trigger, tooltip);
      control.startValue = this.currentStart;
      control.endValue = this.currentEnd;
    };
    RangeSlider2.prototype.performAnimation = function(start, end, control) {
      var _this = this;
      var currentStart = this.currentStart;
      var currentEnd = this.currentEnd;
      var isDeffered = control.enableDeferredUpdate;
      var enableTooltip = control.tooltip.enable;
      new Animation({}).animate(createElement("div"), {
        duration: this.control.animationDuration === 0 && animationMode === "Enable" ? 1e3 : this.control.animationDuration,
        progress: function(args) {
          _this.setSlider(linear(args.timeStamp, 0, start - currentStart, args.duration) + currentStart, linear(args.timeStamp, 0, end - currentEnd, args.duration) + currentEnd, !isDeffered, enableTooltip);
        },
        end: function() {
          if (control.allowSnapping) {
            _this.setAllowSnapping(control, start, end, true, enableTooltip);
          } else {
            _this.setSlider(start, end, true, enableTooltip);
          }
          _this.control.startValue = _this.currentStart;
          _this.control.endValue = _this.currentEnd;
          if (_this.control.periodSelectorSettings.periods.length > 0) {
            _this.control.periodSelectorModule.triggerChange = false;
            _this.control.periodSelectorModule.datePicker.startDate = _this.control.periodSelectorModule.isDatetimeCategory ? new Date(_this.control.periodSelectorModule.sortedData[Math.floor(_this.currentStart)]) : new Date(_this.currentStart);
            _this.control.periodSelectorModule.datePicker.endDate = _this.control.periodSelectorModule.isDatetimeCategory ? new Date(_this.control.periodSelectorModule.sortedData[Math.floor(_this.currentEnd)]) : new Date(_this.currentEnd);
          }
        }
      });
    };
    RangeSlider2.prototype.mouseCancelHandler = function() {
      if (this.isDrag && this.control.allowSnapping) {
        this.setAllowSnapping(this.control, this.currentStart, this.currentEnd, false, this.control.tooltip.enable);
      }
      this.isDrag = false;
      this.currentSlider = null;
      this.control.startValue = this.currentStart;
      this.control.endValue = this.currentEnd;
    };
    RangeSlider2.prototype.destroy = function() {
      this.removeEventListener();
    };
    return RangeSlider2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/range-navigator/utils/theme.js
function getRangeThemeColor(theme, range) {
  var thumbSize = range.navigatorStyleSettings.thumb;
  var thumbWidth = isNullOrUndefined(thumbSize.width) ? Browser.isDevice ? 15 : 20 : thumbSize.width;
  var thumbHeight = isNullOrUndefined(thumbSize.height) ? Browser.isDevice ? 15 : 20 : thumbSize.height;
  var darkAxisColor = theme === "HighContrast" ? "#969696" : "#6F6C6C";
  var darkGridlineColor = theme === "HighContrast" ? "#4A4848" : "#414040";
  var style = {
    gridLineColor: "#E0E0E0",
    axisLineColor: "#000000",
    labelFontColor: "#686868",
    unselectedRectColor: range.series.length ? "rgba(255, 255, 255, 0.6)" : "#EEEEEE",
    thumpLineColor: "rgba(189, 189, 189, 1)",
    thumbBackground: "rgba(250, 250, 250, 1)",
    gripColor: "#757575",
    background: "#FFFFFF",
    thumbHoverColor: "#EEEEEE",
    selectedRegionColor: range.series.length ? "transparent" : "#FF4081",
    tooltipBackground: theme === "Material" ? "#000816" : theme === "Fabric" ? "#FFFFFF" : "#212529",
    tooltipFontColor: "#dbdbdb",
    thumbWidth,
    thumbHeight,
    axisLabelFont: {
      color: theme === "Material" ? "rgba(97, 97, 97, 1)" : theme === "Fabric" ? "#666666" : "#676767",
      fontFamily: theme === "Material" ? "Roboto" : theme === "Fabric" ? "Segoe UI" : "Helvetica",
      size: "12px",
      fontStyle: "Normal",
      fontWeight: "400"
    },
    tooltipLabelFont: {
      color: theme === "Material" ? "rgba(249, 250, 251, 1)" : theme === "Fabric" ? "#333333" : "#F9FAFB",
      fontFamily: theme === "Material" ? "Roboto" : theme === "Fabric" ? "Segoe UI" : "Helvetica",
      size: "12px",
      fontStyle: "Normal",
      fontWeight: "400"
    }
  };
  switch (theme) {
    case "Fabric":
      style.selectedRegionColor = range.series.length ? "transparent" : "#007897";
      break;
    case "Bootstrap":
      style.selectedRegionColor = range.series.length ? "transparent" : "#428BCA";
      break;
    case "HighContrastLight":
      style = {
        gridLineColor: "#bdbdbd",
        axisLineColor: "#969696",
        labelFontColor: "#ffffff",
        unselectedRectColor: range.series.length ? "rgba(255, 255, 255, 0.3)" : "#EEEEEE",
        thumpLineColor: "#ffffff",
        thumbBackground: "#262626",
        gripColor: "#ffffff",
        background: "transparent",
        thumbHoverColor: "#BFBFBF",
        selectedRegionColor: range.series.length ? "transparent" : "#FFD939",
        tooltipBackground: "#ffffff",
        tooltipFontColor: "#000000",
        thumbWidth,
        thumbHeight,
        axisLabelFont: {
          color: "#969696",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#000000",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "HighContrast":
      style = {
        gridLineColor: darkGridlineColor,
        axisLineColor: darkAxisColor,
        labelFontColor: "#DADADA",
        unselectedRectColor: range.series.length ? "rgba(43, 43, 43, 0.6)" : "#514F4F",
        thumpLineColor: "#969696",
        thumbBackground: "#333232",
        gripColor: "#DADADA",
        background: "transparent",
        thumbHoverColor: "#BFBFBF",
        selectedRegionColor: range.series.length ? "rgba(22, 22, 22, 0.6)" : "#FFD939",
        tooltipBackground: "#FFFFFF",
        tooltipFontColor: "#282727",
        thumbWidth,
        thumbHeight,
        axisLabelFont: {
          color: "#969696",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#000000",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "MaterialDark":
    case "FabricDark":
    case "BootstrapDark":
      style = {
        labelFontColor: "#DADADA",
        axisLineColor: " #6F6C6C",
        gridLineColor: "#414040",
        tooltipBackground: theme === "FabricDark" ? "#A19F9D" : theme === "BootstrapDark" ? "#F0F0F0" : "#F4F4F4",
        tooltipFontColor: "#333232",
        unselectedRectColor: range.series.length ? "rgba(43, 43, 43, 0.6)" : "#514F4F",
        thumpLineColor: "#969696",
        thumbBackground: "#333232",
        gripColor: "#DADADA",
        background: "transparent",
        thumbHoverColor: "#BFBFBF",
        selectedRegionColor: range.series.length ? "rgba(22, 22, 22, 0.6)" : theme === "FabricDark" ? "#007897" : theme === "BootstrapDark" ? "#428BCA" : "#FF4081",
        thumbWidth,
        thumbHeight,
        axisLabelFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.6)" : theme === "FabricDark" ? "#A19F9D" : "#CED4DA",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: theme === "MaterialDark" ? "rgba(18, 18, 18, 1)" : theme === "FabricDark" ? "#DADADA" : "#1A1A1A",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Bootstrap4":
      style = {
        gridLineColor: "#E0E0E0",
        axisLineColor: "#CED4DA",
        labelFontColor: "#212529",
        unselectedRectColor: range.series.length ? "rgba(255, 255, 255, 0.6)" : "#514F4F",
        thumpLineColor: "rgba(189, 189, 189, 1)",
        thumbBackground: "#FFFFFF",
        gripColor: "#495057",
        background: "transparent",
        thumbHoverColor: "#EEEEEE",
        selectedRegionColor: range.series.length ? "transparent" : "#FFD939",
        tooltipBackground: "#212529",
        tooltipFontColor: "rgba(255, 255, 255)",
        thumbWidth,
        thumbHeight,
        axisLabelFont: {
          color: "#495057",
          fontFamily: "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#F9FAFB",
          fontFamily: "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Tailwind3":
      style = {
        gridLineColor: "#D1D5DB",
        axisLineColor: "#D1D5DB",
        labelFontColor: "#4B5563",
        unselectedRectColor: range.series.length ? "transparent" : "#E5E7EB",
        thumpLineColor: "#1F2937",
        thumbBackground: "#FFFFFF",
        gripColor: "#6B7280",
        background: "transparent",
        thumbHoverColor: "#1F2937",
        selectedRegionColor: range.series.length ? "#6B72801A" : "#4F46E5",
        tooltipBackground: "#111827",
        tooltipFontColor: "#F9FAFB",
        thumbWidth,
        thumbHeight,
        axisLabelFont: {
          color: "#4B5563",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#F9FAFB",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "500"
        }
      };
      break;
    case "Tailwind3Dark":
      style = {
        gridLineColor: "#374151",
        axisLineColor: "#374151",
        labelFontColor: "#D1D5DB",
        unselectedRectColor: range.series.length ? "transparent" : "#4B5563",
        thumpLineColor: "#6B7280",
        thumbBackground: "#111827",
        gripColor: "#D1D5DB",
        background: "transparent",
        thumbHoverColor: "#E5E7EB",
        selectedRegionColor: range.series.length ? "#6B72801A" : "#22D3EE",
        tooltipBackground: "#F9FAFB",
        tooltipFontColor: "#1F2937",
        thumbWidth,
        thumbHeight,
        axisLabelFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#1F2937",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "500"
        }
      };
      break;
    case "Tailwind":
      style = {
        gridLineColor: "#E5E7EB",
        axisLineColor: "#D1D5DB",
        labelFontColor: "#6B7280",
        unselectedRectColor: range.series.length ? "transparent" : "#E5E7EB",
        thumpLineColor: "#9CA3AF",
        thumbBackground: "#FFFFFF",
        gripColor: "#6B7280",
        background: "transparent",
        thumbHoverColor: "#374151",
        selectedRegionColor: range.series.length ? "rgba(79, 70, 229, 0.3)" : "#4F46E5",
        tooltipBackground: "#111827",
        tooltipFontColor: "#F9FAFB",
        thumbWidth,
        thumbHeight,
        axisLabelFont: {
          color: "#6B7280",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#F9FAFB",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "TailwindDark":
      style = {
        gridLineColor: "#374151",
        axisLineColor: "#4B5563",
        labelFontColor: "#9CA3AF",
        unselectedRectColor: range.series.length ? "transparent" : "#4B5563",
        thumpLineColor: "#6B7280",
        thumbBackground: "#1F2937",
        gripColor: "#D1D5DB",
        background: "transparent",
        thumbHoverColor: "#E5E7EB",
        selectedRegionColor: range.series.length ? "rgba(255, 255, 255, 0.6)" : "#22D3EE",
        tooltipBackground: "#E9ECEF",
        tooltipFontColor: "#1F2937",
        thumbWidth,
        thumbHeight,
        axisLabelFont: {
          color: "#9CA3AF",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#1F2937",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Bootstrap5":
      style = {
        gridLineColor: "#E9ECEF",
        axisLineColor: "#DEE2E6",
        labelFontColor: "#21252980",
        unselectedRectColor: range.series.length ? "transparent" : "#E5E7EB",
        thumpLineColor: "#CED4DA",
        thumbBackground: "#FFFFFF",
        gripColor: "#6E757D",
        background: "transparent",
        thumbHoverColor: "#666666",
        selectedRegionColor: range.series.length ? "rgba(52, 58, 64, 0.1)" : "#ADB5BD",
        tooltipBackground: "#000000E5",
        tooltipFontColor: "#FFFFFF",
        thumbWidth,
        thumbHeight,
        axisLabelFont: {
          color: "#21252980",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Bootstrap5Dark":
      style = {
        gridLineColor: "#343A40",
        axisLineColor: "#495057",
        labelFontColor: "#DEE2E680",
        unselectedRectColor: range.series.length ? "transparent" : "#E5E7EB",
        thumpLineColor: "#6C757D",
        thumbBackground: "#212529",
        gripColor: "#ADB5BD",
        background: "transparent",
        thumbHoverColor: "#666666",
        selectedRegionColor: range.series.length ? "rgba(173, 181, 189, 0.1)" : "#ADB5BD",
        tooltipBackground: "#FFFFFFE5",
        tooltipFontColor: "#212529",
        thumbWidth,
        thumbHeight,
        axisLabelFont: {
          color: "#DEE2E680",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Fluent":
      style = {
        gridLineColor: "#EDEBE9",
        axisLineColor: "#D2D0CE",
        labelFontColor: "#3B3A39",
        unselectedRectColor: range.series.length ? "transparent" : "#A19F9D",
        thumpLineColor: "#0078D4",
        thumbBackground: "#FFFFFF",
        gripColor: "#0078D4",
        background: "transparent",
        thumbHoverColor: "#FFFFFF",
        selectedRegionColor: range.series.length ? "rgba(0, 120, 212, 0.1)" : "#ADB5BD",
        tooltipBackground: "#FFFFFF",
        tooltipFontColor: "#323130",
        thumbWidth,
        thumbHeight,
        axisLabelFont: {
          color: "#3B3A39",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#323130",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "FluentDark":
      style = {
        gridLineColor: "#414040",
        axisLineColor: "#3B3A39",
        labelFontColor: "#C8C6C4",
        unselectedRectColor: range.series.length ? "transparent" : "#A19F9D",
        thumpLineColor: "#797775",
        thumbBackground: "black",
        gripColor: "#797775",
        background: "transparent",
        thumbHoverColor: "black",
        selectedRegionColor: range.series.length ? "rgba(121, 119, 117, 0.1)" : "#797775",
        tooltipBackground: "#323130",
        tooltipFontColor: "#F3F2F1",
        thumbWidth,
        thumbHeight,
        axisLabelFont: {
          color: "#C8C6C4",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#F3F2F1",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Fluent2":
      style = {
        gridLineColor: "#EDEBE9",
        axisLineColor: "#D2D0CE",
        labelFontColor: "#616161",
        unselectedRectColor: range.series.length ? "rgba(250, 250, 250, 0.1)" : "#A19F9D",
        thumpLineColor: "#A19F9D",
        thumbBackground: "#FAFAFA",
        gripColor: "#424242",
        background: "transparent",
        thumbHoverColor: "#FAFAFA",
        selectedRegionColor: range.series.length ? "rgba(161, 159, 157, 0.4)" : "#797775",
        tooltipBackground: "#FFFFFF",
        tooltipFontColor: "#242424",
        thumbWidth,
        thumbHeight,
        axisLabelFont: {
          color: "#616161",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#242424",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Fluent2Dark":
      style = {
        gridLineColor: "#8A8886",
        axisLineColor: "#3B3A39",
        labelFontColor: "#ADADAD",
        unselectedRectColor: range.series.length ? "transparent" : "#A19F9D",
        thumpLineColor: "#8A8886",
        thumbBackground: "#1F1F1F",
        gripColor: "#D6D6D6",
        background: "transparent",
        thumbHoverColor: "#1F1F1F",
        selectedRegionColor: range.series.length ? "rgba(138, 136, 134, 0.4)" : "#797775",
        tooltipBackground: "#292929",
        tooltipFontColor: "#FFFFFF",
        thumbWidth,
        thumbHeight,
        axisLabelFont: {
          color: "#ADADAD",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Fluent2HighContrast":
      style = {
        gridLineColor: "#8A8886",
        axisLineColor: "#3B3A39",
        labelFontColor: "#ADADAD",
        unselectedRectColor: range.series.length ? "transparent" : "#A19F9D",
        thumpLineColor: "#8A8886",
        thumbBackground: "#1F1F1F",
        gripColor: "#FFFFFF",
        background: "transparent",
        thumbHoverColor: "#1F1F1F",
        selectedRegionColor: range.series.length ? "rgba(138, 136, 134, 0.1)" : "#797775",
        tooltipBackground: "#000000",
        tooltipFontColor: "#FFFFFF",
        thumbWidth,
        thumbHeight,
        axisLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "10px",
          fontStyle: "Normal",
          fontWeight: "600"
        }
      };
      break;
    case "Material3":
      style = {
        gridLineColor: "#C4C7C5",
        axisLineColor: "#C4C7C5",
        labelFontColor: "#1E192B",
        unselectedRectColor: range.series.length ? "transparent" : "#E5E5E5",
        thumpLineColor: "#49454E",
        thumbBackground: "#FFFFFF",
        gripColor: "#49454E",
        background: "transparent",
        thumbHoverColor: "#FFFFFF",
        selectedRegionColor: range.series.length ? "rgba(73, 69, 78, 0.1)" : "#49454E",
        tooltipBackground: "#313033",
        tooltipFontColor: "#F4EFF4",
        thumbWidth,
        thumbHeight,
        axisLabelFont: {
          color: "#1E192B",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#F4EFF4",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Material3Dark":
      style = {
        gridLineColor: "#444746",
        axisLineColor: "#444746",
        labelFontColor: "#E6E1E5",
        unselectedRectColor: range.series.length ? "transparent" : "#E5E5E5",
        thumpLineColor: "#CAC4D0",
        thumbBackground: "#1C1B1F",
        gripColor: "#CAC4D0",
        background: "transparent",
        thumbHoverColor: "#FFFFFF",
        selectedRegionColor: range.series.length ? "rgba(202, 196, 208, 0.1)" : "#49454E",
        tooltipBackground: "#E6E1E5",
        tooltipFontColor: "#313033",
        thumbWidth,
        thumbHeight,
        axisLabelFont: {
          color: "#CAC4D0",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#F4EFF4",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    default:
      style.selectedRegionColor = range.series.length ? "transparent" : "#FF4081";
      break;
  }
  return style;
}

// node_modules/@syncfusion/ej2-charts/src/common/period-selector/period-selector.js
var PeriodSelector = (
  /** @class */
  function() {
    function PeriodSelector2(control) {
      this.control = {};
      this.isDatetimeCategory = false;
      this.sortedData = [];
      this.startValue = 0;
      this.endValue = 0;
      this.rootControl = control;
      if (this.rootControl.getModuleName() === "stockChart") {
        this.sortedData = this.rootControl.sortedData;
        this.isDatetimeCategory = this.rootControl.isDateTimeCategory;
      }
    }
    PeriodSelector2.prototype.setControlValues = function(control) {
      if (control.getModuleName() === "rangeNavigator") {
        this.control.periods = this.rootControl.periodSelectorSettings.periods;
        this.control.seriesXMax = control.chartSeries.xMax;
        this.control.seriesXMin = control.chartSeries.xMin;
        this.control.rangeSlider = control.rangeSlider;
        this.control.rangeNavigatorControl = control;
        this.control.endValue = control.endValue;
        this.control.startValue = control.startValue;
      } else {
        this.control.periods = this.rootControl.periods;
        this.control.endValue = this.control.seriesXMax = control.seriesXMax;
        this.control.startValue = this.control.seriesXMin = control.seriesXMin;
        this.control.rangeNavigatorControl = this.rootControl.rangeNavigator;
        if (this.control.rangeNavigatorControl) {
          this.control.rangeSlider = this.rootControl.rangeNavigator.rangeSlider;
        }
      }
      this.control.element = control.element;
      this.control.disableRangeSelector = control.disableRangeSelector;
    };
    PeriodSelector2.prototype.appendSelector = function(options, x) {
      if (x === void 0) {
        x = 0;
      }
      this.renderSelectorElement(null, options, x);
      this.renderSelector();
    };
    PeriodSelector2.prototype.renderSelectorElement = function(control, options, x) {
      this.periodSelectorSize = control ? this.periodSelectorSize : new Rect(x, this.rootControl.titleSize.height ? this.rootControl.titleSize.height : 10, options.width, options.height);
      var thumbSize;
      var element;
      if (control) {
        thumbSize = control.themeStyle.thumbWidth;
        element = control.element;
      } else {
        thumbSize = options.thumbSize;
        element = options.element;
      }
      if (getElement2(element.id + "_Secondary_Element")) {
        remove(getElement2(element.id + "_Secondary_Element"));
      }
      this.periodSelectorDiv = createElement("div", {
        id: element.id + "_Secondary_Element",
        styles: "width: " + (this.periodSelectorSize.width - thumbSize) + "px;height: " + this.periodSelectorSize.height + "px;top:" + this.periodSelectorSize.y + "px;left:" + (this.periodSelectorSize.x + thumbSize / 2) + "px; position: absolute"
      });
      element.appendChild(this.periodSelectorDiv);
    };
    PeriodSelector2.prototype.renderSelector = function() {
      var _this = this;
      this.setControlValues(this.rootControl);
      var enableCustom = true;
      var controlId = this.control.element.id;
      var selectorElement = createElement("div", {
        id: controlId + "_selector"
      });
      var buttons = this.control.periods;
      var selector = this.updateCustomElement();
      var buttonStyles = "text-transform: none; text-overflow: unset";
      var isStringTemplate = "isStringTemplate";
      var dateRangeId = controlId + "customRange";
      var selectedPeriod;
      this.periodSelectorDiv.appendChild(selectorElement);
      for (var i = 0; i < buttons.length; i++) {
        selector.push({
          align: "Left",
          text: buttons[i].text
        });
      }
      if (this.rootControl.getModuleName() === "stockChart") {
        enableCustom = this.rootControl.enableCustomRange;
      }
      if (enableCustom) {
        this.calendarId = controlId + "_calendar";
        selector.push({
          template: "<button id=" + this.calendarId + "></button>",
          align: "Right"
        });
      }
      var selctorArgs = {
        selector,
        name: "RangeSelector",
        cancel: false,
        enableCustomFormat: true,
        content: "Date Range"
      };
      if (this.rootControl.getModuleName() === "stockChart") {
        if (this.rootControl.exportType.length) {
          var exportElement = createElement("button", {
            id: controlId + "_export",
            styles: buttonStyles,
            className: "e-dropdown-btn e-btn e-flat"
          });
          exportElement.innerText = "Export";
          selector.push({
            template: exportElement,
            align: "Right"
          });
        }
      }
      this.rootControl.trigger("selectorRender", selctorArgs);
      this.toolbar = new Toolbar({
        items: selctorArgs.selector,
        height: this.periodSelectorSize.height,
        clicked: function(args) {
          _this.buttonClick(args, _this.control);
        },
        created: function() {
          _this.nodes = _this.toolbar.element.querySelectorAll(".e-toolbar-left")[0];
          if (isNullOrUndefined(_this.selectedIndex)) {
            buttons.map(function(period, index) {
              if (period.selected && _this.selectedPeriod !== null) {
                selectedPeriod = period;
                _this.control.startValue = _this.changedRange(period.intervalType, _this.control.endValue, period.interval).getTime();
                if (_this.isDatetimeCategory) {
                  _this.control.startValue = _this.rootControl.getModuleName() !== "stockChart" ? _this.findStartValue(_this.control.startValue, _this.control.endValue) : _this.rootControl.startValue;
                }
                _this.control.startValue = period.text && period.text.toLowerCase() === "all" ? _this.control.seriesXMin : _this.control.startValue;
                _this.control.endValue = period.text && period.text.toLowerCase() === "all" ? _this.control.seriesXMax : _this.control.endValue;
                _this.selectedIndex = _this.nodes.childNodes.length - buttons.length + index;
                var slider = _this.control.rangeSlider;
                if (slider) {
                  slider.selectedPeriod = period.text;
                }
              }
            });
          }
          if (!selectedPeriod && _this.rootControl.getModuleName() !== "stockChart") {
            var selectedIndex = _this.findSelectedIndex(_this.control.startValue, _this.control.endValue, buttons);
            _this.selectedIndex = selectedIndex ? selectedIndex : _this.selectedIndex;
          }
          _this.setSelectedStyle(_this.selectedIndex);
        }
      });
      this.toolbar[isStringTemplate] = true;
      this.toolbar.appendTo(selectorElement);
      this.triggerChange = true;
      if (enableCustom) {
        this.datePicker = new DateRangePicker({
          min: this.isDatetimeCategory ? new Date(this.sortedData[this.control.seriesXMin]) : new Date(this.control.seriesXMin),
          max: this.isDatetimeCategory ? new Date(this.sortedData[this.control.seriesXMax]) : new Date(this.control.seriesXMax),
          format: "dd/MM/yyyy",
          placeholder: "Select a range",
          showClearButton: false,
          startDate: this.isDatetimeCategory ? new Date(this.sortedData[Math.floor(this.control.startValue)]) : new Date(this.control.startValue),
          endDate: this.isDatetimeCategory ? new Date(this.sortedData[Math.floor(this.control.endValue)]) : new Date(this.control.endValue),
          created: function() {
            if (selctorArgs.enableCustomFormat) {
              var datePicker = document.getElementsByClassName("e-date-range-wrapper");
              var datePickerElement = void 0;
              for (var i2 = 0; i2 < datePicker.length; i2++) {
                if (datePicker[i2].children[0].id.indexOf(controlId) !== -1) {
                  datePickerElement = datePicker[i2];
                }
              }
              datePickerElement.style.display = "none";
              var element = createElement("div", {
                id: dateRangeId,
                className: "e-control e-btn e-dropdown-btn e-flat",
                styles: "font-size: 14px; font-weight: 500; text-transform: none "
              });
              element.innerText = selctorArgs.content;
              datePickerElement.insertAdjacentElement("afterend", element);
              getElement2(dateRangeId).insertAdjacentElement("afterbegin", createElement("span", {
                id: controlId + "dateIcon",
                className: "e-input-group-icon e-range-icon e-btn-icon e-icons",
                styles: "font-size: 16px; min-height: 0px; margin: -3px 0 0 0; outline: none; min-width: 30px"
                // fix for date range icon alignment issue.
              }));
              document.getElementById(dateRangeId).onclick = function() {
                _this.datePicker.show(getElement2(dateRangeId));
              };
            }
          },
          change: function(args) {
            if (_this.triggerChange) {
              if (_this.isDatetimeCategory) {
                _this.startValue = args.startDate.getTime();
                _this.endValue = args.endDate.getTime();
                _this.findPeriodValue(_this.startValue, _this.endValue);
              }
              if (_this.control.rangeSlider && args.event) {
                if (_this.rootControl.getModuleName() !== "stockChart") {
                  _this.control.rangeNavigatorControl.startValue = _this.isDatetimeCategory ? _this.startValue : args.startDate.getTime();
                  _this.control.rangeNavigatorControl.endValue = _this.isDatetimeCategory ? _this.endValue : args.endDate.getTime();
                  _this.selectedIndex = void 0;
                  _this.selectedPeriod = null;
                  _this.control.rangeNavigatorControl.refresh();
                }
                _this.control.rangeSlider.performAnimation(_this.isDatetimeCategory ? _this.startValue : args.startDate.getTime(), _this.isDatetimeCategory ? _this.endValue : args.endDate.getTime(), _this.control.rangeNavigatorControl);
              } else if (args.event) {
                _this.rootControl.rangeChanged(_this.isDatetimeCategory ? _this.startValue : args.startDate.getTime(), _this.isDatetimeCategory ? _this.endValue : args.endDate.getTime());
              }
              _this.nodes = _this.toolbar.element.querySelectorAll(".e-toolbar-left")[0];
              if (!_this.rootControl.resizeTo && _this.control.rangeSlider && _this.control.rangeSlider.isDrag) {
                for (var i2 = 0, length_1 = _this.nodes.childNodes.length; i2 < length_1; i2++) {
                  _this.nodes.childNodes[i2].childNodes[0].classList.remove("e-active");
                  _this.nodes.childNodes[i2].childNodes[0].classList.remove("e-active");
                }
              }
            }
          }
        });
        this.datePicker.appendTo("#" + this.calendarId);
      }
    };
    PeriodSelector2.prototype.findPeriodValue = function(startValue, endValue) {
      for (var index = 0; index < this.sortedData.length; index++) {
        if (this.sortedData[index] >= startValue) {
          this.startValue = index;
          break;
        }
      }
      for (var index = this.sortedData.length - 1; index >= 0; index--) {
        if (this.sortedData[index] <= endValue) {
          this.endValue = index;
          break;
        }
      }
    };
    PeriodSelector2.prototype.findSelectedIndex = function(startDate, endDate, buttons) {
      var daysDiffence = (endDate - startDate) / (1e3 * 60 * 60 * 24);
      var selectedIndex;
      for (var i = 0; i < buttons.length; i++) {
        var period = buttons[i];
        if (period.intervalType === "Years" && daysDiffence / 365 === period.interval) {
          selectedIndex = i;
        } else if (period.intervalType === "Months" && (daysDiffence / 30 === period.interval || daysDiffence / 31 === period.interval)) {
          selectedIndex = i;
        } else if (period.intervalType === "Days" && daysDiffence === period.interval) {
          selectedIndex = i;
        } else if (period.intervalType === "Weeks" && daysDiffence / 7 === period.interval) {
          selectedIndex = i;
        } else if (period.intervalType === "Hours" && daysDiffence * 24 === period.interval) {
          selectedIndex = i;
        } else if (period.intervalType === "Seconds" && daysDiffence * 24 * 3600 === period.interval) {
          selectedIndex = i;
        }
      }
      return selectedIndex;
    };
    PeriodSelector2.prototype.updateCustomElement = function() {
      var selector = [];
      var controlId = this.rootControl.element.id;
      var buttonStyles = "text-transform: none; text-overflow: unset";
      var className = "e-dropdown-btn e-btn e-flat";
      if (this.rootControl.getModuleName() === "stockChart") {
        if (this.rootControl.seriesType.length) {
          var SeriesElement = createElement("button", {
            id: controlId + "_seriesType",
            styles: buttonStyles,
            className
          });
          SeriesElement.innerText = "Series";
          selector.push({
            template: SeriesElement,
            align: "Left"
          });
        }
        if (this.rootControl.indicatorType.length) {
          var indicatorElement = createElement("button", {
            id: controlId + "_indicatorType",
            styles: buttonStyles,
            className
          });
          indicatorElement.innerText = "Indicators";
          selector.push({
            template: indicatorElement,
            align: "Left"
          });
        }
        if (this.rootControl.trendlineType.length) {
          var trendlineElement = createElement("button", {
            id: controlId + "_trendType",
            styles: buttonStyles,
            className
          });
          trendlineElement.innerText = "Trendline";
          selector.push({
            template: trendlineElement,
            align: "Left"
          });
        }
      }
      return selector;
    };
    PeriodSelector2.prototype.setSelectedStyle = function(selectedIndex) {
      for (var i = 0, length_2 = this.nodes.childNodes.length; i < length_2; i++) {
        this.nodes.childNodes[i].childNodes[0].classList.remove("e-active");
      }
      if (!isNullOrUndefined(selectedIndex)) {
        this.nodes.childNodes[selectedIndex].childNodes[0].classList.add("e-flat");
        this.nodes.childNodes[selectedIndex].childNodes[0].classList.add("e-active");
      }
    };
    PeriodSelector2.prototype.buttonClick = function(args, control) {
      var _this = this;
      var clickedEle = args.item;
      var slider = this.control.rangeSlider;
      var buttons = this.control.periods;
      var button = buttons.filter(function(btn) {
        return btn.text === clickedEle.text;
      });
      var updatedStart;
      var updatedEnd;
      buttons.map(function(period, index) {
        if (period.selected && _this.rootControl.getModuleName() !== "stockChart") {
          period.selected = false;
        }
        if (period.text === args.item.text) {
          _this.selectedIndex = _this.nodes.childNodes.length - buttons.length + index;
          if (_this.rootControl.getModuleName() !== "stockChart") {
            period.selected = true;
          }
        }
      });
      if (args.item.text !== "") {
        this.setSelectedStyle(this.selectedIndex);
      }
      if (slider && clickedEle.text) {
        slider.selectedPeriod = clickedEle.text;
      }
      if (clickedEle.text.toLowerCase() === "all") {
        updatedStart = control.seriesXMin;
        updatedEnd = control.seriesXMax;
        if (slider) {
          slider.performAnimation(updatedStart, updatedEnd, this.control.rangeNavigatorControl);
        } else {
          this.rootControl.rangeChanged(updatedStart, updatedEnd);
        }
      } else if (clickedEle.text.toLowerCase() === "ytd") {
        if (slider) {
          updatedStart = this.isDatetimeCategory ? new Date(new Date(this.sortedData[Math.floor(slider.currentEnd)]).getFullYear().toString()).getTime() : new Date(new Date(slider.currentEnd).getFullYear().toString()).getTime();
          updatedStart = this.isDatetimeCategory ? this.findStartValue(updatedStart, slider.currentEnd) : updatedStart;
          updatedEnd = slider.currentEnd;
          slider.performAnimation(updatedStart, updatedEnd, this.control.rangeNavigatorControl);
        } else {
          updatedStart = this.isDatetimeCategory ? new Date(new Date(this.sortedData[Math.floor(this.rootControl.currentEnd)]).getFullYear().toString()).getTime() : new Date(new Date(this.rootControl.currentEnd).getFullYear().toString()).getTime();
          updatedStart = this.isDatetimeCategory ? this.findStartValue(updatedStart, this.rootControl.currentEnd) : updatedStart;
          updatedEnd = this.rootControl.currentEnd;
          this.rootControl.rangeChanged(updatedStart, updatedEnd);
        }
      } else if (clickedEle.text.toLowerCase() !== "") {
        if (slider) {
          updatedStart = this.changedRange(button[0].intervalType, slider.currentEnd, button[0].interval).getTime();
          updatedStart = this.isDatetimeCategory ? this.findStartValue(updatedStart, slider.currentEnd) : updatedStart;
          updatedEnd = slider.currentEnd;
          slider.performAnimation(updatedStart, updatedEnd, this.control.rangeNavigatorControl);
        } else {
          updatedStart = this.changedRange(button[0].intervalType, this.rootControl.currentEnd, button[0].interval).getTime();
          updatedStart = this.isDatetimeCategory ? this.findStartValue(updatedStart, this.rootControl.currentEnd) : updatedStart;
          updatedEnd = this.rootControl.currentEnd;
          this.rootControl.rangeChanged(updatedStart, updatedEnd);
        }
      }
      if (this.rootControl.getModuleName() === "stockChart") {
        this.rootControl.zoomChange = false;
      }
      if (getElement2(this.calendarId + "_popup") && !Browser.isDevice) {
        var element = getElement2(this.calendarId + "_popup");
        element.querySelectorAll(".e-range-header")[0].style.display = "none";
      }
    };
    PeriodSelector2.prototype.findStartValue = function(startValue, endValue) {
      for (var index = Math.floor(endValue); index >= 0; index--) {
        if (this.sortedData[index] <= startValue) {
          return index + 1;
        }
      }
      return 0;
    };
    PeriodSelector2.prototype.changedRange = function(type, end, interval) {
      var result = this.isDatetimeCategory ? new Date(this.sortedData[Math.floor(end)]) : new Date(end);
      switch (type) {
        case "Quarter":
          result.setMonth(result.getMonth() - 3 * interval);
          break;
        case "Months":
          result.setMonth(result.getMonth() - interval);
          break;
        case "Weeks":
          result.setDate(result.getDate() - interval * 7);
          break;
        case "Days":
          result.setDate(result.getDate() - interval);
          break;
        case "Hours":
          result.setHours(result.getHours() - interval);
          break;
        case "Minutes":
          result.setMinutes(result.getMinutes() - interval);
          break;
        case "Seconds":
          result.setSeconds(result.getSeconds() - interval);
          break;
        default:
          result.setFullYear(result.getFullYear() - interval);
          break;
      }
      return result;
    };
    PeriodSelector2.prototype.getModuleName = function() {
      return "PeriodSelector";
    };
    PeriodSelector2.prototype.destroy = function() {
    };
    return PeriodSelector2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/range-navigator/range-navigator.js
var __extends80 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate11 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var RangeNavigator = (
  /** @class */
  function(_super) {
    __extends80(RangeNavigator2, _super);
    function RangeNavigator2(options, element) {
      var _this = _super.call(this, options, element) || this;
      _this.animateSeries = true;
      _this.chartid = 57725;
      _this.redraw = false;
      return _this;
    }
    RangeNavigator2.prototype.preRender = function() {
      this.unWireEvents();
      this.setCulture();
      this.allowServerDataBinding = false;
      if (this.periodSelectorModule) {
        this.periodSelectorModule.selectedIndex = null;
      }
      if (this.element.id === "") {
        var collection = document.getElementsByClassName("e-rangenavigator").length;
        this.element.id = "rangenavigator_" + this.chartid + "_" + collection;
      }
      this.wireEvents();
    };
    RangeNavigator2.prototype.initPrivateVariables = function() {
      this.doubleModule = new Double();
      this.labels = [];
      this.rangeSlider = new RangeSlider(this);
      this.chartSeries = new RangeSeries(this);
      this.lineSeriesModule = new LineSeries();
      this.rangeAxis = new RangeNavigatorAxis(this);
    };
    RangeNavigator2.prototype.setCulture = function() {
      this.intl = new Internationalization();
    };
    RangeNavigator2.prototype.setSliderValue = function() {
      var isDateTime = this.valueType === "DateTime";
      var isDateTimeCategory = this.valueType === "DateTimeCategory";
      var range = this.chartSeries.xAxis.actualRange;
      this.startValue = this.startValue || isDateTimeCategory && this.startValue === 0 ? this.startValue : !this.value[0] ? range.min : isDateTime ? new Date(this.value[0].toString()).getTime() : isDateTimeCategory ? this.getRangeValue(new Date(this.value[0].toString()).getTime(), true) : +this.value[0];
      this.endValue = this.endValue || isDateTimeCategory && this.endValue === 0 ? this.endValue : !this.value[1] ? range.max : isDateTime ? new Date(this.value[1].toString()).getTime() : isDateTimeCategory ? this.getRangeValue(new Date(this.value[1].toString()).getTime(), false) : +this.value[1];
    };
    RangeNavigator2.prototype.getRangeValue = function(value, isStart) {
      var labels = this.chartSeries.xAxis.labels;
      var index = labels.length - 1;
      while (index >= 0 && parseInt(labels[index], 10) > value) {
        index--;
      }
      return isStart ? index !== -1 ? index : this.chartSeries.xAxis.actualRange.min : index === 0 ? this.chartSeries.xAxis.actualRange.max : index;
    };
    RangeNavigator2.prototype.render = function() {
      var _this = this;
      var loadEventData = {
        name: "load",
        rangeNavigator: this,
        theme: this.theme
      };
      this.trigger("load", loadEventData, function() {
        _this.setTheme();
        _this.initPrivateVariables();
        _this.createRangeSvg();
        _this.calculateBounds();
        _this.chartSeries.renderChart(_this);
        removeElement2("chartmeasuretext");
        _this.renderComplete();
        _this.allowServerDataBinding = true;
      });
      this.element.setAttribute("tabindex", "0");
      this.element.style.outline = "none";
      this.element.setAttribute("role", "region");
      this.element.setAttribute("aria-label", "Range navigator Syncfusion interactive chart.");
    };
    RangeNavigator2.prototype.setTheme = function() {
      this.themeStyle = getRangeThemeColor(this.theme, this);
    };
    RangeNavigator2.prototype.createRangeSvg = function() {
      this.removeSvg();
      createSvg(this);
      this.renderChartBackground();
    };
    RangeNavigator2.prototype.calculateBounds = function() {
      var labelPadding = this.enableGrouping ? 15 : 8;
      var thumb = this.navigatorStyleSettings.thumb;
      var labelSize = measureText("tempString", this.labelStyle, this.themeStyle.axisLabelFont).height;
      var margin = this.margin;
      var isLeightWeight = !this.series.length;
      var tooltipSpace = !this.disableRangeSelector && isLeightWeight && this.tooltip.enable ? 35 : 0;
      if (!this.periodSelectorModule && this.periodSelectorSettings.periods.length && !this.stockChart) {
        this.periodSelectorModule = new PeriodSelector(this);
      }
      var selector = this.periodSelectorModule;
      if (this.periodSelectorModule && this.periodSelectorSettings.periods.length > 0) {
        selector.periodSelectorSize = {
          x: 0,
          y: 0,
          height: 0,
          width: 0
        };
        selector.periodSelectorSize.width = this.availableSize.width;
        selector.periodSelectorSize.height = this.periodSelectorSettings.height;
        selector.periodSelectorSize.y = this.periodSelectorSettings.position === "Bottom" ? this.availableSize.height - selector.periodSelectorSize.height : 0;
      }
      var periodSelectorY = this.periodSelectorSettings.position === "Top" && selector ? selector.periodSelectorSize.y + selector.periodSelectorSize.height : 0;
      var left = 0;
      var top = 0;
      if (this.stockChart && this.stockChart.stockLegendModule && this.stockChart.legendSettings.visible) {
        if (this.stockChart.legendSettings.position === "Left") {
          left += this.stockChart.stockLegendModule.legendBounds.width;
        } else if (this.stockChart.legendSettings.position === "Top") {
          top += this.stockChart.stockLegendModule.legendBounds.height;
        }
      }
      this.bounds = new Rect(this.themeStyle.thumbWidth / 2 + thumb.border.width + margin.left + left, margin.top + tooltipSpace + periodSelectorY + top, this.availableSize.width - this.themeStyle.thumbWidth - thumb.border.width * 2 - margin.left - margin.right, this.availableSize.height - margin.top - margin.bottom - tooltipSpace - (selector ? selector.periodSelectorSize.height : 0));
      var deductHeight = (this.labelPosition === "Outside" || isLeightWeight ? labelSize + labelPadding : 0) + (this.tickPosition === "Outside" || isLeightWeight ? this.majorTickLines.height : 0);
      this.bounds.height -= deductHeight;
      if (isLeightWeight) {
        var height = this.enableGrouping ? this.bounds.height - (labelSize + labelPadding) : this.bounds.height;
        this.bounds.y += this.themeStyle.thumbHeight > height ? (this.themeStyle.thumbHeight - height) / 2 : 0;
      }
      if (this.disableRangeSelector) {
        this.bounds.y = 0;
        this.bounds.height = this.periodSelectorSettings.periods.length > 0 ? this.periodSelectorSettings.height : 0;
      }
    };
    RangeNavigator2.prototype.renderChart = function(resize) {
      if (resize === void 0) {
        resize = false;
      }
      this.chartSeries.renderSeries(this);
      this.chartSeries.appendSeriesElements(this);
      this.rangeAxis.renderGridLines();
      this.rangeAxis.renderAxisLabels();
      this.createSecondaryElement();
      this.setSliderValue();
      this.renderPeriodSelector();
      this.renderSlider(resize);
      if (!this.stockChart) {
        this.element.appendChild(this.svgObject);
      }
      this.trigger("loaded", {
        rangeNavigator: this
      });
      this.rangeSlider.setSlider(this.startValue, this.endValue, false, this.tooltip.enable && this.tooltip.displayMode === "Always", resize);
    };
    RangeNavigator2.prototype.renderPeriodSelector = function() {
      if (this.periodSelectorModule) {
        this.periodSelectorModule.renderSelectorElement(this);
        this.periodSelectorModule.renderSelector();
      }
    };
    RangeNavigator2.prototype.createSecondaryElement = function() {
      if (this.tooltip.enable) {
        var tooltipDiv = this.createElement("div");
        tooltipDiv.id = this.element.id + "_Secondary_Element";
        tooltipDiv.style.position = "relative";
        this.element.appendChild(tooltipDiv);
      }
    };
    RangeNavigator2.prototype.renderSlider = function(resize) {
      this.rangeSlider.render(this);
      if (this.periodSelectorModule) {
        this.startValue = this.periodSelectorModule.control.startValue;
        this.endValue = this.periodSelectorModule.control.endValue;
      }
      this.rangeSlider.setSlider(this.startValue, this.endValue, true, this.tooltip.enable && this.tooltip.displayMode === "Always", resize);
    };
    RangeNavigator2.prototype.removeSvg = function() {
      if (getElement2(this.element.id + "_Secondary_Element")) {
        remove(getElement2(this.element.id + "_Secondary_Element"));
        if (this.isReact) {
          this.clearTemplate();
        }
      }
      var removeLength = 0;
      if (this.svgObject) {
        while (this.svgObject.childNodes.length > removeLength) {
          this.svgObject.removeChild(this.svgObject.firstChild);
        }
        if (!this.svgObject.hasChildNodes() && this.svgObject.parentNode && !this.stockChart) {
          remove(this.svgObject);
        }
      }
    };
    RangeNavigator2.prototype.unWireEvents = function() {
      var startEvent = Browser.touchStartEvent;
      var moveEvent = Browser.touchMoveEvent;
      var stopEvent = Browser.touchEndEvent;
      var cancelEvent = Browser.isPointer ? "pointerleave" : "mouseleave";
      EventHandler.remove(this.element, startEvent, this.rangeOnMouseDown);
      EventHandler.remove(this.element, moveEvent, this.mouseMove);
      EventHandler.remove(this.element, stopEvent, this.mouseEnd);
      EventHandler.remove(this.element, "click", this.rangeOnMouseClick);
      EventHandler.remove(this.element, cancelEvent, this.mouseLeave);
      window.removeEventListener(Browser.isTouch && "orientation" in window && "onorientationchange" in window ? "orientationchange" : "resize", this.rangeResize);
    };
    RangeNavigator2.prototype.wireEvents = function() {
      var cancelEvent = Browser.isPointer ? "pointerleave" : "mouseleave";
      EventHandler.add(this.element, Browser.touchStartEvent, this.rangeOnMouseDown, this);
      EventHandler.add(this.element, Browser.touchMoveEvent, this.mouseMove, this);
      EventHandler.add(this.element, Browser.touchEndEvent, this.mouseEnd, this);
      EventHandler.add(this.element, "click", this.rangeOnMouseClick, this);
      EventHandler.add(this.element, cancelEvent, this.mouseLeave, this);
      window.addEventListener(Browser.isTouch && "orientation" in window && "onorientationchange" in window ? "orientationchange" : "resize", this.rangeResize.bind(this));
      var element = this.element;
      element.style.touchAction = "none";
      element.style.msTouchAction = "none";
      element.style.msContentZooming = "none";
      element.style.msUserSelect = "none";
      element.style.webkitUserSelect = "none";
      element.style.position = "relative";
      element.style.display = "block";
    };
    RangeNavigator2.prototype.rangeResize = function() {
      var _this = this;
      if (!document.getElementById(this.element.id) || !this.svgObject) {
        return false;
      }
      this.animateSeries = false;
      this.removeAllTooltip();
      var beforeResizeArgs = {
        name: "beforeResize",
        cancelResizedEvent: false
      };
      if (this.resizeTo) {
        clearTimeout(this.resizeTo);
      }
      var arg = {
        rangeNavigator: this,
        name: "resized",
        currentSize: new Size(0, 0),
        previousSize: new Size(this.availableSize.width, this.availableSize.height)
      };
      this.trigger(beforeResize, beforeResizeArgs);
      if (!beforeResizeArgs.cancelResizedEvent) {
        this.resizeTo = +setTimeout(function() {
          if (_this.isDestroyed) {
            clearTimeout(_this.resizeTo);
            return;
          }
          _this.createRangeSvg();
          arg.currentSize = _this.availableSize;
          _this.trigger("resized", arg);
          _this.calculateBounds();
          _this.chartSeries.processXAxis(_this);
          _this.chartSeries.calculateGroupingBounds(_this);
          _this.chartSeries.processYAxis(_this);
          _this.renderChart(true);
        }, 500);
      }
      return false;
    };
    RangeNavigator2.prototype.removeAllTooltip = function() {
      if (this.tooltip.enable && this.tooltip.displayMode === "Always") {
        if (getElement2(this.element.id + "_leftTooltip")) {
          remove(getElement2(this.element.id + "_leftTooltip"));
        }
        if (getElement2(this.element.id + "_rightTooltip")) {
          remove(getElement2(this.element.id + "_rightTooltip"));
        }
      }
    };
    RangeNavigator2.prototype.mouseMove = function(e) {
      if (this.stockChart) {
        return false;
      }
      if (getElement2(!this.stockChart ? this.element.id + "_svg" : this.element.id)) {
        this.mouseX = this.setMouseX(e);
        this.notify(Browser.touchMoveEvent, e);
      }
      return false;
    };
    RangeNavigator2.prototype.mouseLeave = function(e) {
      var rangeSlider = this.rangeSlider;
      if (rangeSlider.isDrag) {
        if (this.stockChart) {
          return false;
        }
        var enabledTooltip = rangeSlider.control.tooltip.enable;
        if (rangeSlider.control.allowSnapping) {
          rangeSlider.isDrag = false;
          rangeSlider.setAllowSnapping(rangeSlider.control, rangeSlider.currentStart, rangeSlider.currentEnd, false, enabledTooltip);
        }
        rangeSlider.triggerEvent(this.chartSeries.xAxis.actualRange);
      }
      var cancelEvent = Browser.isPointer ? "pointerleave" : "mouseleave";
      this.mouseX = this.setMouseX(e);
      this.notify(cancelEvent, e);
      return false;
    };
    RangeNavigator2.prototype.rangeOnMouseClick = function(e) {
      this.notify("click", e);
      return false;
    };
    RangeNavigator2.prototype.print = function(id) {
      new PrintUtils(this).print(id);
    };
    RangeNavigator2.prototype.export = function(type, fileName, orientation, controls, width, height, isVertical) {
      controls = controls ? controls : [this];
      new ExportUtils(this).export(type, fileName, orientation, controls, width, height, isVertical);
    };
    RangeNavigator2.prototype.renderChartBackground = function() {
      var top = 0;
      var left = 0;
      if (this.stockChart && this.stockChart.legendSettings.visible && this.stockChart.stockLegendModule) {
        if (this.stockChart.legendSettings.position === "Top") {
          top += this.stockChart.stockLegendModule.legendBounds.height;
        } else if (this.stockChart.legendSettings.position === "Left") {
          left += this.stockChart.stockLegendModule.legendBounds.width;
        }
      }
      var rect = new RectOption(this.element.id + "_ChartBorder", this.background || this.themeStyle.background, {
        width: 0,
        color: "transparent"
      }, 1, new Rect(left, top, this.availableSize.width, this.availableSize.height));
      this.svgObject.appendChild(this.renderer.drawRectangle(rect));
    };
    RangeNavigator2.prototype.rangeOnMouseDown = function(e) {
      this.mouseDownX = this.setMouseX(e);
      this.notify(Browser.touchStartEvent, e);
      return false;
    };
    RangeNavigator2.prototype.mouseEnd = function(e) {
      this.mouseX = this.setMouseX(e);
      this.notify(Browser.touchEndEvent, e);
      return false;
    };
    RangeNavigator2.prototype.setMouseX = function(e) {
      var pageX = e.type.indexOf("touch") > -1 ? e.changedTouches[0].clientX : e.clientX;
      var rect = this.element.getBoundingClientRect();
      var svgRect = !this.stockChart ? getElement2(this.element.id + "_svg").getBoundingClientRect() : getElement2(this.element.id).getBoundingClientRect();
      return pageX - rect.left - Math.max(svgRect.left - rect.left, 0);
    };
    RangeNavigator2.prototype.getPersistData = function() {
      var keyEntity = ["loaded"];
      return this.addOnPersist(keyEntity);
    };
    RangeNavigator2.prototype.onPropertyChanged = function(newProp) {
      var renderer = false;
      var refreshBounds = false;
      var refreshRange = false;
      this.animateSeries = false;
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "width":
          case "height":
          case "navigatorBorder":
          case "enableGrouping":
          case "labelPosition":
          case "tickPosition":
          case "labelStyle":
            refreshBounds = true;
            break;
          case "enableRtl":
          case "xName":
          case "yName":
          case "query":
          case "minimum":
          case "maximum":
          case "interval":
          case "intervalType":
          case "logBase":
          case "valueType":
          case "majorGridLines":
          case "minorGridLines":
          case "navigatorStyleSettings":
          case "labelFormat":
          case "skeleton":
          case "skeletonType":
          case "secondaryLabelAlignment":
          case "background":
            renderer = true;
            break;
          case "dataSource":
          case "series":
            renderer = true;
            refreshBounds = true;
            break;
          case "theme":
            this.animateSeries = true;
            break;
          case "locale":
            _super.prototype.refresh.call(this);
            break;
          case "value":
            this.startValue = null;
            this.endValue = null;
            refreshRange = true;
            this.redraw = true;
            break;
        }
      }
      if (!refreshBounds && renderer) {
        this.removeSvg();
        this.chartSeries.xMin = Infinity;
        this.chartSeries.xMax = -Infinity;
        this.chartSeries.renderChart(this);
      }
      if (refreshBounds && renderer) {
        this.removeSvg();
        this.chartSeries.xMin = this.chartSeries.yMin = Infinity;
        this.chartSeries.xMax = this.chartSeries.yMax = -Infinity;
        this.calculateBounds();
        this.chartSeries.renderChart(this);
      }
      if (refreshBounds && !renderer) {
        this.removeSvg();
        this.calculateBounds();
        this.chartSeries.renderChart(this);
      }
      if (!refreshBounds && !renderer && refreshRange) {
        this.setSliderValue();
        this.rangeSlider.setSlider(this.startValue, this.endValue, true, this.tooltip.enable && this.tooltip.displayMode === "Always");
      }
    };
    RangeNavigator2.prototype.requiredModules = function() {
      var _this = this;
      var modules = [];
      this.series.map(function(series) {
        if (series.type === "Area" || series.type === "StepLine") {
          modules.push({
            member: series.type + "Series",
            args: [_this]
          });
        }
      });
      if (this.periodSelectorSettings.periods.length > 0) {
        modules.push({
          member: "PeriodSelector",
          args: [this]
        });
      }
      if (this.valueType !== "Double") {
        modules.push({
          member: this.valueType,
          args: [this]
        });
      }
      if (this.tooltip.enable) {
        modules.push({
          member: "RangeTooltip",
          args: [this]
        });
      }
      return modules;
    };
    RangeNavigator2.prototype.getModuleName = function() {
      return "rangeNavigator";
    };
    RangeNavigator2.prototype.destroy = function() {
      this.unWireEvents();
      if (this.isReact) {
        this.clearTemplate();
      }
      this.rangeSlider.destroy();
      _super.prototype.destroy.call(this);
      this.element.innerText = "";
      this.element.classList.remove("e-rangenavigator");
    };
    __decorate11([Property(null)], RangeNavigator2.prototype, "width", void 0);
    __decorate11([Property(null)], RangeNavigator2.prototype, "height", void 0);
    __decorate11([Property(null)], RangeNavigator2.prototype, "dataSource", void 0);
    __decorate11([Property(null)], RangeNavigator2.prototype, "xName", void 0);
    __decorate11([Property(null)], RangeNavigator2.prototype, "yName", void 0);
    __decorate11([Property()], RangeNavigator2.prototype, "query", void 0);
    __decorate11([Collection([], RangeNavigatorSeries)], RangeNavigator2.prototype, "series", void 0);
    __decorate11([Complex({}, RangeTooltipSettings)], RangeNavigator2.prototype, "tooltip", void 0);
    __decorate11([Property(null)], RangeNavigator2.prototype, "minimum", void 0);
    __decorate11([Property(null)], RangeNavigator2.prototype, "maximum", void 0);
    __decorate11([Property(null)], RangeNavigator2.prototype, "interval", void 0);
    __decorate11([Property("Auto")], RangeNavigator2.prototype, "intervalType", void 0);
    __decorate11([Property("Hide")], RangeNavigator2.prototype, "labelIntersectAction", void 0);
    __decorate11([Property(10)], RangeNavigator2.prototype, "logBase", void 0);
    __decorate11([Property("Double")], RangeNavigator2.prototype, "valueType", void 0);
    __decorate11([Property("Outside")], RangeNavigator2.prototype, "labelPosition", void 0);
    __decorate11([Property("Auto")], RangeNavigator2.prototype, "labelPlacement", void 0);
    __decorate11([Property(500)], RangeNavigator2.prototype, "animationDuration", void 0);
    __decorate11([Property(false)], RangeNavigator2.prototype, "enableGrouping", void 0);
    __decorate11([Property(false)], RangeNavigator2.prototype, "enableDeferredUpdate", void 0);
    __decorate11([Property(false)], RangeNavigator2.prototype, "disableRangeSelector", void 0);
    __decorate11([Property(false)], RangeNavigator2.prototype, "allowSnapping", void 0);
    __decorate11([Property(false)], RangeNavigator2.prototype, "allowIntervalData", void 0);
    __decorate11([Property(false)], RangeNavigator2.prototype, "useGroupingSeparator", void 0);
    __decorate11([Property()], RangeNavigator2.prototype, "groupBy", void 0);
    __decorate11([Property("Outside")], RangeNavigator2.prototype, "tickPosition", void 0);
    __decorate11([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, Font)], RangeNavigator2.prototype, "labelStyle", void 0);
    __decorate11([Complex({}, MajorGridLines)], RangeNavigator2.prototype, "majorGridLines", void 0);
    __decorate11([Complex({}, MajorTickLines)], RangeNavigator2.prototype, "majorTickLines", void 0);
    __decorate11([Complex({}, StyleSettings)], RangeNavigator2.prototype, "navigatorStyleSettings", void 0);
    __decorate11([Complex({}, PeriodSelectorSettings)], RangeNavigator2.prototype, "periodSelectorSettings", void 0);
    __decorate11([Complex({
      color: null,
      width: 1
    }, Border)], RangeNavigator2.prototype, "navigatorBorder", void 0);
    __decorate11([Property("Material")], RangeNavigator2.prototype, "theme", void 0);
    __decorate11([Property([])], RangeNavigator2.prototype, "value", void 0);
    __decorate11([Property(null)], RangeNavigator2.prototype, "background", void 0);
    __decorate11([Property("")], RangeNavigator2.prototype, "labelFormat", void 0);
    __decorate11([Property("")], RangeNavigator2.prototype, "skeleton", void 0);
    __decorate11([Property("DateTime")], RangeNavigator2.prototype, "skeletonType", void 0);
    __decorate11([Property("Middle")], RangeNavigator2.prototype, "secondaryLabelAlignment", void 0);
    __decorate11([Complex({
      top: 5,
      bottom: 5,
      right: 5,
      left: 5
    }, Margin)], RangeNavigator2.prototype, "margin", void 0);
    __decorate11([Event()], RangeNavigator2.prototype, "load", void 0);
    __decorate11([Event()], RangeNavigator2.prototype, "loaded", void 0);
    __decorate11([Event()], RangeNavigator2.prototype, "resized", void 0);
    __decorate11([Event()], RangeNavigator2.prototype, "beforeResize", void 0);
    __decorate11([Event()], RangeNavigator2.prototype, "labelRender", void 0);
    __decorate11([Event()], RangeNavigator2.prototype, "changed", void 0);
    __decorate11([Event()], RangeNavigator2.prototype, "tooltipRender", void 0);
    __decorate11([Event()], RangeNavigator2.prototype, "selectorRender", void 0);
    __decorate11([Event()], RangeNavigator2.prototype, "beforePrint", void 0);
    RangeNavigator2 = __decorate11([NotifyPropertyChanges], RangeNavigator2);
    return RangeNavigator2;
  }(Component)
);

// node_modules/@syncfusion/ej2-charts/src/stock-chart/model/base.js
var __extends81 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate12 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var StockChartFont = (
  /** @class */
  function(_super) {
    __extends81(StockChartFont2, _super);
    function StockChartFont2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate12([Property("")], StockChartFont2.prototype, "color", void 0);
    __decorate12([Property("16px")], StockChartFont2.prototype, "size", void 0);
    __decorate12([Property("Segoe UI")], StockChartFont2.prototype, "fontFamily", void 0);
    __decorate12([Property("Normal")], StockChartFont2.prototype, "fontStyle", void 0);
    __decorate12([Property("Normal")], StockChartFont2.prototype, "fontWeight", void 0);
    __decorate12([Property(1)], StockChartFont2.prototype, "opacity", void 0);
    __decorate12([Property("Trim")], StockChartFont2.prototype, "textOverflow", void 0);
    __decorate12([Property("Center")], StockChartFont2.prototype, "textAlignment", void 0);
    return StockChartFont2;
  }(ChildProperty)
);
var StockChartBorder = (
  /** @class */
  function(_super) {
    __extends81(StockChartBorder2, _super);
    function StockChartBorder2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate12([Property("")], StockChartBorder2.prototype, "color", void 0);
    __decorate12([Property(1)], StockChartBorder2.prototype, "width", void 0);
    return StockChartBorder2;
  }(ChildProperty)
);
var StockChartArea = (
  /** @class */
  function(_super) {
    __extends81(StockChartArea2, _super);
    function StockChartArea2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate12([Complex({}, StockChartBorder)], StockChartArea2.prototype, "border", void 0);
    __decorate12([Property("transparent")], StockChartArea2.prototype, "background", void 0);
    __decorate12([Property(1)], StockChartArea2.prototype, "opacity", void 0);
    return StockChartArea2;
  }(ChildProperty)
);
var StockMargin = (
  /** @class */
  function(_super) {
    __extends81(StockMargin2, _super);
    function StockMargin2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate12([Property(null)], StockMargin2.prototype, "left", void 0);
    __decorate12([Property(null)], StockMargin2.prototype, "right", void 0);
    __decorate12([Property(null)], StockMargin2.prototype, "top", void 0);
    __decorate12([Property(null)], StockMargin2.prototype, "bottom", void 0);
    return StockMargin2;
  }(ChildProperty)
);
var StockChartStripLineSettings = (
  /** @class */
  function(_super) {
    __extends81(StockChartStripLineSettings2, _super);
    function StockChartStripLineSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate12([Property(false)], StockChartStripLineSettings2.prototype, "startFromAxis", void 0);
    __decorate12([Property(true)], StockChartStripLineSettings2.prototype, "visible", void 0);
    __decorate12([Property(null)], StockChartStripLineSettings2.prototype, "start", void 0);
    __decorate12([Property("#808080")], StockChartStripLineSettings2.prototype, "color", void 0);
    __decorate12([Property(null)], StockChartStripLineSettings2.prototype, "end", void 0);
    __decorate12([Property(null)], StockChartStripLineSettings2.prototype, "size", void 0);
    __decorate12([Property("Auto")], StockChartStripLineSettings2.prototype, "sizeType", void 0);
    __decorate12([Property(null)], StockChartStripLineSettings2.prototype, "dashArray", void 0);
    __decorate12([Property(false)], StockChartStripLineSettings2.prototype, "isRepeat", void 0);
    __decorate12([Property(null)], StockChartStripLineSettings2.prototype, "repeatEvery", void 0);
    __decorate12([Property(false)], StockChartStripLineSettings2.prototype, "isSegmented", void 0);
    __decorate12([Property(null)], StockChartStripLineSettings2.prototype, "repeatUntil", void 0);
    __decorate12([Property(null)], StockChartStripLineSettings2.prototype, "segmentStart", void 0);
    __decorate12([Property(null)], StockChartStripLineSettings2.prototype, "segmentAxisName", void 0);
    __decorate12([Property(null)], StockChartStripLineSettings2.prototype, "segmentEnd", void 0);
    __decorate12([Property(1)], StockChartStripLineSettings2.prototype, "opacity", void 0);
    __decorate12([Property("")], StockChartStripLineSettings2.prototype, "text", void 0);
    __decorate12([Complex({
      color: "transparent",
      width: 1
    }, StockChartBorder)], StockChartStripLineSettings2.prototype, "border", void 0);
    __decorate12([Property(null)], StockChartStripLineSettings2.prototype, "rotation", void 0);
    __decorate12([Property("Behind")], StockChartStripLineSettings2.prototype, "zIndex", void 0);
    __decorate12([Property("Middle")], StockChartStripLineSettings2.prototype, "horizontalAlignment", void 0);
    __decorate12([Property("Middle")], StockChartStripLineSettings2.prototype, "verticalAlignment", void 0);
    __decorate12([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, StockChartFont)], StockChartStripLineSettings2.prototype, "textStyle", void 0);
    return StockChartStripLineSettings2;
  }(ChildProperty)
);
var StockEmptyPointSettings = (
  /** @class */
  function(_super) {
    __extends81(StockEmptyPointSettings2, _super);
    function StockEmptyPointSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate12([Property(null)], StockEmptyPointSettings2.prototype, "fill", void 0);
    __decorate12([Property("Gap")], StockEmptyPointSettings2.prototype, "mode", void 0);
    __decorate12([Complex({
      color: "transparent",
      width: 0
    }, StockChartBorder)], StockEmptyPointSettings2.prototype, "border", void 0);
    return StockEmptyPointSettings2;
  }(ChildProperty)
);
var StockChartConnector = (
  /** @class */
  function(_super) {
    __extends81(StockChartConnector2, _super);
    function StockChartConnector2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate12([Property("Line")], StockChartConnector2.prototype, "type", void 0);
    __decorate12([Property(null)], StockChartConnector2.prototype, "length", void 0);
    __decorate12([Property(null)], StockChartConnector2.prototype, "color", void 0);
    __decorate12([Property("")], StockChartConnector2.prototype, "dashArray", void 0);
    __decorate12([Property(1)], StockChartConnector2.prototype, "width", void 0);
    return StockChartConnector2;
  }(ChildProperty)
);
var StockSeries = (
  /** @class */
  function(_super) {
    __extends81(StockSeries2, _super);
    function StockSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.localData = void 0;
      return _this;
    }
    __decorate12([Property("date")], StockSeries2.prototype, "xName", void 0);
    __decorate12([Property("close")], StockSeries2.prototype, "yName", void 0);
    __decorate12([Property("open")], StockSeries2.prototype, "open", void 0);
    __decorate12([Property("close")], StockSeries2.prototype, "close", void 0);
    __decorate12([Property("high")], StockSeries2.prototype, "high", void 0);
    __decorate12([Property("low")], StockSeries2.prototype, "low", void 0);
    __decorate12([Property("volume")], StockSeries2.prototype, "volume", void 0);
    __decorate12([Property("")], StockSeries2.prototype, "pointColorMapping", void 0);
    __decorate12([Property("SeriesType")], StockSeries2.prototype, "legendShape", void 0);
    __decorate12([Property("")], StockSeries2.prototype, "legendImageUrl", void 0);
    __decorate12([Complex(null, Animation2)], StockSeries2.prototype, "animation", void 0);
    __decorate12([Property(null)], StockSeries2.prototype, "xAxisName", void 0);
    __decorate12([Property(null)], StockSeries2.prototype, "yAxisName", void 0);
    __decorate12([Property(null)], StockSeries2.prototype, "fill", void 0);
    __decorate12([Property("0")], StockSeries2.prototype, "dashArray", void 0);
    __decorate12([Property(1)], StockSeries2.prototype, "width", void 0);
    __decorate12([Property("")], StockSeries2.prototype, "name", void 0);
    __decorate12([Property("")], StockSeries2.prototype, "dataSource", void 0);
    __decorate12([Property()], StockSeries2.prototype, "query", void 0);
    __decorate12([Property("#e74c3d")], StockSeries2.prototype, "bullFillColor", void 0);
    __decorate12([Property("#2ecd71")], StockSeries2.prototype, "bearFillColor", void 0);
    __decorate12([Property(false)], StockSeries2.prototype, "enableSolidCandles", void 0);
    __decorate12([Property(true)], StockSeries2.prototype, "visible", void 0);
    __decorate12([Complex({
      color: "transparent",
      width: 0
    }, Border)], StockSeries2.prototype, "border", void 0);
    __decorate12([Property(1)], StockSeries2.prototype, "opacity", void 0);
    __decorate12([Property("Candle")], StockSeries2.prototype, "type", void 0);
    __decorate12([Complex(null, MarkerSettings)], StockSeries2.prototype, "marker", void 0);
    __decorate12([Collection([], Trendline)], StockSeries2.prototype, "trendlines", void 0);
    __decorate12([Property(true)], StockSeries2.prototype, "enableTooltip", void 0);
    __decorate12([Property("")], StockSeries2.prototype, "tooltipMappingName", void 0);
    __decorate12([Property(null)], StockSeries2.prototype, "selectionStyle", void 0);
    __decorate12([Property(0.5)], StockSeries2.prototype, "cardinalSplineTension", void 0);
    __decorate12([Complex(null, CornerRadius)], StockSeries2.prototype, "cornerRadius", void 0);
    __decorate12([Complex(null, StockEmptyPointSettings)], StockSeries2.prototype, "emptyPointSettings", void 0);
    __decorate12([Property(null)], StockSeries2.prototype, "columnWidth", void 0);
    __decorate12([Property(0)], StockSeries2.prototype, "columnSpacing", void 0);
    __decorate12([Property(true)], StockSeries2.prototype, "showNearestTooltip", void 0);
    return StockSeries2;
  }(ChildProperty)
);
var StockChartIndicator = (
  /** @class */
  function(_super) {
    __extends81(StockChartIndicator2, _super);
    function StockChartIndicator2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate12([Property("Sma")], StockChartIndicator2.prototype, "type", void 0);
    __decorate12([Property(14)], StockChartIndicator2.prototype, "period", void 0);
    __decorate12([Property(3)], StockChartIndicator2.prototype, "dPeriod", void 0);
    __decorate12([Property(14)], StockChartIndicator2.prototype, "kPeriod", void 0);
    __decorate12([Property(80)], StockChartIndicator2.prototype, "overBought", void 0);
    __decorate12([Property(20)], StockChartIndicator2.prototype, "overSold", void 0);
    __decorate12([Property("Close")], StockChartIndicator2.prototype, "field", void 0);
    __decorate12([Property(2)], StockChartIndicator2.prototype, "standardDeviation", void 0);
    __decorate12([Property(12)], StockChartIndicator2.prototype, "slowPeriod", void 0);
    __decorate12([Property(true)], StockChartIndicator2.prototype, "showZones", void 0);
    __decorate12([Property(26)], StockChartIndicator2.prototype, "fastPeriod", void 0);
    __decorate12([Complex({
      color: "#ff9933",
      width: 2
    }, StockChartConnector)], StockChartIndicator2.prototype, "macdLine", void 0);
    __decorate12([Property("Both")], StockChartIndicator2.prototype, "macdType", void 0);
    __decorate12([Property("#e74c3d")], StockChartIndicator2.prototype, "macdNegativeColor", void 0);
    __decorate12([Property("#2ecd71")], StockChartIndicator2.prototype, "macdPositiveColor", void 0);
    __decorate12([Property("rgba(211,211,211,0.25)")], StockChartIndicator2.prototype, "bandColor", void 0);
    __decorate12([Complex({
      color: "#ffb735",
      width: 1
    }, StockChartConnector)], StockChartIndicator2.prototype, "upperLine", void 0);
    __decorate12([Property("")], StockChartIndicator2.prototype, "seriesName", void 0);
    __decorate12([Complex({
      color: "#f2ec2f",
      width: 1
    }, StockChartConnector)], StockChartIndicator2.prototype, "periodLine", void 0);
    __decorate12([Complex({
      color: "#f2ec2f",
      width: 1
    }, StockChartConnector)], StockChartIndicator2.prototype, "lowerLine", void 0);
    __decorate12([Property("")], StockChartIndicator2.prototype, "high", void 0);
    __decorate12([Property("")], StockChartIndicator2.prototype, "open", void 0);
    __decorate12([Property("")], StockChartIndicator2.prototype, "low", void 0);
    __decorate12([Property("")], StockChartIndicator2.prototype, "xName", void 0);
    __decorate12([Property("")], StockChartIndicator2.prototype, "close", void 0);
    __decorate12([Property("")], StockChartIndicator2.prototype, "pointColorMapping", void 0);
    __decorate12([Property("")], StockChartIndicator2.prototype, "volume", void 0);
    __decorate12([Property(null)], StockChartIndicator2.prototype, "xAxisName", void 0);
    __decorate12([Property(null)], StockChartIndicator2.prototype, "yAxisName", void 0);
    __decorate12([Complex(null, Animation2)], StockChartIndicator2.prototype, "animation", void 0);
    __decorate12([Property(null)], StockChartIndicator2.prototype, "fill", void 0);
    __decorate12([Property("0")], StockChartIndicator2.prototype, "dashArray", void 0);
    __decorate12([Property(1)], StockChartIndicator2.prototype, "width", void 0);
    __decorate12([Property()], StockChartIndicator2.prototype, "query", void 0);
    __decorate12([Property("")], StockChartIndicator2.prototype, "dataSource", void 0);
    return StockChartIndicator2;
  }(ChildProperty)
);
var StockChartAxis = (
  /** @class */
  function(_super) {
    __extends81(StockChartAxis2, _super);
    function StockChartAxis2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate12([Complex({}, CrosshairTooltip)], StockChartAxis2.prototype, "crosshairTooltip", void 0);
    __decorate12([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, Font)], StockChartAxis2.prototype, "labelStyle", void 0);
    __decorate12([Property("")], StockChartAxis2.prototype, "title", void 0);
    __decorate12([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, StockChartFont)], StockChartAxis2.prototype, "titleStyle", void 0);
    __decorate12([Property("")], StockChartAxis2.prototype, "labelFormat", void 0);
    __decorate12([Property("DateTime")], StockChartAxis2.prototype, "skeletonType", void 0);
    __decorate12([Property("")], StockChartAxis2.prototype, "skeleton", void 0);
    __decorate12([Property(0)], StockChartAxis2.prototype, "plotOffset", void 0);
    __decorate12([Property(10)], StockChartAxis2.prototype, "logBase", void 0);
    __decorate12([Property(0)], StockChartAxis2.prototype, "rowIndex", void 0);
    __decorate12([Property(1)], StockChartAxis2.prototype, "span", void 0);
    __decorate12([Property(3)], StockChartAxis2.prototype, "maximumLabels", void 0);
    __decorate12([Property(null)], StockChartAxis2.prototype, "desiredIntervals", void 0);
    __decorate12([Property(1)], StockChartAxis2.prototype, "zoomFactor", void 0);
    __decorate12([Property(0)], StockChartAxis2.prototype, "zoomPosition", void 0);
    __decorate12([Property(false)], StockChartAxis2.prototype, "opposedPosition", void 0);
    __decorate12([Property(true)], StockChartAxis2.prototype, "enableAutoIntervalOnZooming", void 0);
    __decorate12([Property("Double")], StockChartAxis2.prototype, "valueType", void 0);
    __decorate12([Property("Auto")], StockChartAxis2.prototype, "rangePadding", void 0);
    __decorate12([Property("None")], StockChartAxis2.prototype, "edgeLabelPlacement", void 0);
    __decorate12([Property("BetweenTicks")], StockChartAxis2.prototype, "labelPlacement", void 0);
    __decorate12([Property("Auto")], StockChartAxis2.prototype, "intervalType", void 0);
    __decorate12([Property("Outside")], StockChartAxis2.prototype, "tickPosition", void 0);
    __decorate12([Property("")], StockChartAxis2.prototype, "name", void 0);
    __decorate12([Property("Outside")], StockChartAxis2.prototype, "labelPosition", void 0);
    __decorate12([Property(true)], StockChartAxis2.prototype, "visible", void 0);
    __decorate12([Property(0)], StockChartAxis2.prototype, "labelRotation", void 0);
    __decorate12([Property(0)], StockChartAxis2.prototype, "minorTicksPerInterval", void 0);
    __decorate12([Property(null)], StockChartAxis2.prototype, "crossesAt", void 0);
    __decorate12([Property(null)], StockChartAxis2.prototype, "crossesInAxis", void 0);
    __decorate12([Property(true)], StockChartAxis2.prototype, "placeNextToAxisLine", void 0);
    __decorate12([Property(null)], StockChartAxis2.prototype, "minimum", void 0);
    __decorate12([Property(null)], StockChartAxis2.prototype, "interval", void 0);
    __decorate12([Property(null)], StockChartAxis2.prototype, "maximum", void 0);
    __decorate12([Property(34)], StockChartAxis2.prototype, "maximumLabelWidth", void 0);
    __decorate12([Complex({}, MajorTickLines)], StockChartAxis2.prototype, "majorTickLines", void 0);
    __decorate12([Property(false)], StockChartAxis2.prototype, "enableTrim", void 0);
    __decorate12([Complex({}, MinorTickLines)], StockChartAxis2.prototype, "minorTickLines", void 0);
    __decorate12([Complex({}, MinorGridLines)], StockChartAxis2.prototype, "minorGridLines", void 0);
    __decorate12([Complex({}, MajorGridLines)], StockChartAxis2.prototype, "majorGridLines", void 0);
    __decorate12([Complex({}, AxisLine)], StockChartAxis2.prototype, "lineStyle", void 0);
    __decorate12([Property(false)], StockChartAxis2.prototype, "isInversed", void 0);
    __decorate12([Property("Trim")], StockChartAxis2.prototype, "labelIntersectAction", void 0);
    __decorate12([Property(100)], StockChartAxis2.prototype, "coefficient", void 0);
    __decorate12([Property(0)], StockChartAxis2.prototype, "startAngle", void 0);
    __decorate12([Property(2)], StockChartAxis2.prototype, "tabIndex", void 0);
    __decorate12([Collection([], StockChartStripLineSettings)], StockChartAxis2.prototype, "stripLines", void 0);
    __decorate12([Property(null)], StockChartAxis2.prototype, "description", void 0);
    return StockChartAxis2;
  }(ChildProperty)
);
var StockChartRow = (
  /** @class */
  function(_super) {
    __extends81(StockChartRow2, _super);
    function StockChartRow2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate12([Property("100%")], StockChartRow2.prototype, "height", void 0);
    __decorate12([Complex({}, StockChartBorder)], StockChartRow2.prototype, "border", void 0);
    return StockChartRow2;
  }(ChildProperty)
);
var StockChartTrendline = (
  /** @class */
  function(_super) {
    __extends81(StockChartTrendline2, _super);
    function StockChartTrendline2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate12([Property(2)], StockChartTrendline2.prototype, "period", void 0);
    __decorate12([Property("")], StockChartTrendline2.prototype, "name", void 0);
    __decorate12([Property("Linear")], StockChartTrendline2.prototype, "type", void 0);
    __decorate12([Property(2)], StockChartTrendline2.prototype, "polynomialOrder", void 0);
    __decorate12([Property(0)], StockChartTrendline2.prototype, "forwardForecast", void 0);
    __decorate12([Property(0)], StockChartTrendline2.prototype, "backwardForecast", void 0);
    __decorate12([Complex({}, Animation2)], StockChartTrendline2.prototype, "animation", void 0);
    __decorate12([Property(true)], StockChartTrendline2.prototype, "enableTooltip", void 0);
    __decorate12([Complex({}, MarkerSettings)], StockChartTrendline2.prototype, "marker", void 0);
    __decorate12([Property(null)], StockChartTrendline2.prototype, "intercept", void 0);
    __decorate12([Property("")], StockChartTrendline2.prototype, "fill", void 0);
    __decorate12([Property("SeriesType")], StockChartTrendline2.prototype, "legendShape", void 0);
    __decorate12([Property(1)], StockChartTrendline2.prototype, "width", void 0);
    return StockChartTrendline2;
  }(ChildProperty)
);
var StockChartAnnotationSettings = (
  /** @class */
  function(_super) {
    __extends81(StockChartAnnotationSettings2, _super);
    function StockChartAnnotationSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate12([Property("0")], StockChartAnnotationSettings2.prototype, "y", void 0);
    __decorate12([Property("0")], StockChartAnnotationSettings2.prototype, "x", void 0);
    __decorate12([Property(null)], StockChartAnnotationSettings2.prototype, "content", void 0);
    __decorate12([Property("Chart")], StockChartAnnotationSettings2.prototype, "region", void 0);
    __decorate12([Property("Center")], StockChartAnnotationSettings2.prototype, "horizontalAlignment", void 0);
    __decorate12([Property("Pixel")], StockChartAnnotationSettings2.prototype, "coordinateUnits", void 0);
    __decorate12([Property("Middle")], StockChartAnnotationSettings2.prototype, "verticalAlignment", void 0);
    __decorate12([Property(null)], StockChartAnnotationSettings2.prototype, "yAxisName", void 0);
    __decorate12([Property(null)], StockChartAnnotationSettings2.prototype, "description", void 0);
    __decorate12([Property(null)], StockChartAnnotationSettings2.prototype, "xAxisName", void 0);
    return StockChartAnnotationSettings2;
  }(ChildProperty)
);
var StockChartIndexes = (
  /** @class */
  function(_super) {
    __extends81(StockChartIndexes2, _super);
    function StockChartIndexes2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate12([Property(0)], StockChartIndexes2.prototype, "point", void 0);
    __decorate12([Property(0)], StockChartIndexes2.prototype, "series", void 0);
    return StockChartIndexes2;
  }(ChildProperty)
);
var StockEventsSettings = (
  /** @class */
  function(_super) {
    __extends81(StockEventsSettings2, _super);
    function StockEventsSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate12([Property("Circle")], StockEventsSettings2.prototype, "type", void 0);
    __decorate12([Property("")], StockEventsSettings2.prototype, "text", void 0);
    __decorate12([Property("")], StockEventsSettings2.prototype, "description", void 0);
    __decorate12([Property()], StockEventsSettings2.prototype, "date", void 0);
    __decorate12([Complex({
      color: "black",
      width: 1
    }, StockChartBorder)], StockEventsSettings2.prototype, "border", void 0);
    __decorate12([Property("transparent")], StockEventsSettings2.prototype, "background", void 0);
    __decorate12([Property(true)], StockEventsSettings2.prototype, "showOnSeries", void 0);
    __decorate12([Property("close")], StockEventsSettings2.prototype, "placeAt", void 0);
    __decorate12([Complex(stockEventFont, StockChartFont)], StockEventsSettings2.prototype, "textStyle", void 0);
    __decorate12([Property([])], StockEventsSettings2.prototype, "seriesIndexes", void 0);
    return StockEventsSettings2;
  }(ChildProperty)
);

// node_modules/@syncfusion/ej2-charts/src/stock-chart/legend/legend.js
var __extends82 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate13 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var StockChartLegendSettings = (
  /** @class */
  function(_super) {
    __extends82(StockChartLegendSettings2, _super);
    function StockChartLegendSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate13([Property(false)], StockChartLegendSettings2.prototype, "visible", void 0);
    __decorate13([Property(null)], StockChartLegendSettings2.prototype, "height", void 0);
    __decorate13([Property(null)], StockChartLegendSettings2.prototype, "width", void 0);
    __decorate13([Complex({
      x: 0,
      y: 0
    }, Location)], StockChartLegendSettings2.prototype, "location", void 0);
    __decorate13([Property("Auto")], StockChartLegendSettings2.prototype, "position", void 0);
    __decorate13([Property("Series")], StockChartLegendSettings2.prototype, "mode", void 0);
    __decorate13([Property(8)], StockChartLegendSettings2.prototype, "padding", void 0);
    __decorate13([Property(null)], StockChartLegendSettings2.prototype, "itemPadding", void 0);
    __decorate13([Property("Center")], StockChartLegendSettings2.prototype, "alignment", void 0);
    __decorate13([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, StockChartFont)], StockChartLegendSettings2.prototype, "textStyle", void 0);
    __decorate13([Property(10)], StockChartLegendSettings2.prototype, "shapeHeight", void 0);
    __decorate13([Property(10)], StockChartLegendSettings2.prototype, "shapeWidth", void 0);
    __decorate13([Complex({}, StockChartBorder)], StockChartLegendSettings2.prototype, "border", void 0);
    __decorate13([Complex({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, StockMargin)], StockChartLegendSettings2.prototype, "margin", void 0);
    __decorate13([Complex({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, ContainerPadding)], StockChartLegendSettings2.prototype, "containerPadding", void 0);
    __decorate13([Property(8)], StockChartLegendSettings2.prototype, "shapePadding", void 0);
    __decorate13([Property("transparent")], StockChartLegendSettings2.prototype, "background", void 0);
    __decorate13([Property(1)], StockChartLegendSettings2.prototype, "opacity", void 0);
    __decorate13([Property(true)], StockChartLegendSettings2.prototype, "toggleVisibility", void 0);
    __decorate13([Property(null)], StockChartLegendSettings2.prototype, "description", void 0);
    __decorate13([Property(3)], StockChartLegendSettings2.prototype, "tabIndex", void 0);
    __decorate13([Property(null)], StockChartLegendSettings2.prototype, "title", void 0);
    __decorate13([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, StockChartFont)], StockChartLegendSettings2.prototype, "titleStyle", void 0);
    __decorate13([Property("Top")], StockChartLegendSettings2.prototype, "titlePosition", void 0);
    __decorate13([Property(100)], StockChartLegendSettings2.prototype, "maximumTitleWidth", void 0);
    __decorate13([Property(true)], StockChartLegendSettings2.prototype, "enablePages", void 0);
    __decorate13([Property(false)], StockChartLegendSettings2.prototype, "isInversed", void 0);
    return StockChartLegendSettings2;
  }(ChildProperty)
);
var StockLegend = (
  /** @class */
  function(_super) {
    __extends82(StockLegend2, _super);
    function StockLegend2(chart) {
      var _this = _super.call(this, chart) || this;
      _this.library = _this;
      _this.addEventListener();
      return _this;
    }
    StockLegend2.prototype.addEventListener = function() {
      if (this.chart.isDestroyed) {
        return;
      }
      this.chart.on("click", this.click, this);
      this.chart.on(Browser.touchEndEvent, this.mouseEnd, this);
      this.chart.on(Browser.touchMoveEvent, this.mouseMove, this);
    };
    StockLegend2.prototype.removeEventListener = function() {
      if (this.chart.isDestroyed) {
        return;
      }
      this.chart.off("click", this.click);
      this.chart.off(Browser.touchEndEvent, this.mouseEnd);
      this.chart.off(Browser.touchMoveEvent, this.mouseMove);
    };
    StockLegend2.prototype.mouseMove = function(e) {
      if (this.chart.legendSettings.visible && !this.chart.isTouch) {
        this.move(e);
      }
    };
    StockLegend2.prototype.mouseEnd = function(e) {
      if (this.chart.legendSettings.visible && this.chart.isTouch) {
        this.move(e);
      }
    };
    StockLegend2.prototype.getLegendOptions = function(visibleSeriesCollection) {
      this.legendCollections = [];
      var seriesType;
      var fillColor;
      if (visibleSeriesCollection.length > 1) {
        this.legend.mode = "Series";
      }
      for (var _i = 0, visibleSeriesCollection_1 = visibleSeriesCollection; _i < visibleSeriesCollection_1.length; _i++) {
        var series = visibleSeriesCollection_1[_i];
        if (this.legend.mode === "Series") {
          if (series.category !== "Indicator") {
            seriesType = series.type;
            fillColor = series.pointColorMapping && series.points.length > 0 ? series.points[0].interior ? series.points[0].interior : series.interior : series.interior;
            this.legendCollections.push(new LegendOptions(series.name, fillColor, series.legendShape, series.category === "TrendLine" ? this.chart.series[series.sourceIndex].trendlines[series.index].visible : series.visible, seriesType, series.legendImageUrl, series.marker.shape, series.marker.visible));
          }
        }
      }
    };
    StockLegend2.prototype.getLegendBounds = function(availableSize, legendBound, legend) {
      this.calculateLegendTitle(legend, legendBound);
      var padding = legend.padding;
      this.isTitle = legend.title ? true : false;
      var titlePosition = legend.titlePosition;
      var extraWidth = 0;
      var extraHeight = 0;
      var legendOption;
      var arrowHeight = this.arrowHeight;
      var arrowWidth = this.arrowWidth;
      var verticalArrowSpace = this.isVertical && !legend.enablePages ? arrowHeight : 0;
      var titleSpace = this.isTitle && titlePosition === "Top" ? this.fivePixel + this.legendTitleSize.height : 0;
      titleSpace = this.isTitle && this.isVertical && titlePosition !== "Top" ? this.fivePixel + this.legendTitleSize.height : titleSpace;
      if (!this.isVertical) {
        extraHeight = !legend.height ? availableSize.height / 100 * 5 : 0;
      } else {
        extraWidth = !legend.width ? availableSize.width / 100 * 5 : 0;
      }
      legendBound.height += extraHeight;
      legendBound.width += extraWidth;
      var shapePadding = legend.shapePadding;
      var shapeWidth = legend.shapeWidth;
      var maximumWidth = 0;
      var rowWidth = 0;
      var legendWidth = 0;
      var columnHeight = 0;
      var rowCount = 0;
      var titlePlusArrowSpace = 0;
      var legendEventArgs;
      this.maxItemHeight = Math.max(measureText("MeasureText", legend.textStyle, this.chart.themeStyle.legendLabelFont).height, legend.shapeHeight);
      var render = false;
      for (var i = 0; i < this.legendCollections.length; i++) {
        legendOption = this.legendCollections[i];
        if (regSup.test(legendOption.text)) {
          legendOption.text = getUnicodeText(legendOption.text, regSup);
        }
        if (regSub.test(legendOption.text)) {
          legendOption.text = getUnicodeText(legendOption.text, regSub);
        }
        legendEventArgs = {
          fill: legendOption.fill,
          text: legendOption.text,
          shape: legendOption.shape,
          markerShape: legendOption.markerShape,
          name: legendRender,
          cancel: false
        };
        this.chart.trigger(legendRender, legendEventArgs);
        legendOption.text = legendEventArgs.text;
        legendOption.render = !legendEventArgs.cancel;
        legendOption.shape = legendEventArgs.shape;
        legendOption.fill = legendEventArgs.fill;
        legendOption.markerShape = legendEventArgs.markerShape;
        legendOption.textSize = measureText(legendOption.text, legend.textStyle, this.chart.themeStyle.legendLabelFont);
        if (legendOption.render) {
          render = true;
          legendWidth = shapePadding + shapeWidth + legendOption.textSize.width + (!this.isVertical ? i === 0 ? padding : this.itemPadding : padding);
          rowWidth = rowWidth + legendWidth;
          if (!legend.enablePages && !this.isVertical) {
            titlePlusArrowSpace = this.isTitle && titlePosition !== "Top" ? this.legendTitleSize.width + this.fivePixel : 0;
            titlePlusArrowSpace += arrowWidth;
          }
          if (legendBound.width < padding + rowWidth + titlePlusArrowSpace || this.isVertical) {
            maximumWidth = Math.max(maximumWidth, rowWidth + padding + titlePlusArrowSpace - (this.isVertical ? 0 : legendWidth));
            if (rowCount === 0 && legendWidth !== rowWidth) {
              rowCount = 1;
            }
            rowWidth = this.isVertical ? 0 : legendWidth;
            rowCount++;
            columnHeight = rowCount * (this.maxItemHeight + (this.isVertical ? this.itemPadding : padding)) + padding + titleSpace + verticalArrowSpace;
          }
        }
      }
      columnHeight = Math.max(columnHeight, this.maxItemHeight + padding + padding + titleSpace);
      this.isPaging = legendBound.height < columnHeight;
      if (this.isPaging && !legend.enablePages) {
        if (!this.isVertical) {
          columnHeight = this.maxItemHeight + padding + padding + (titlePosition === "Top" ? titleSpace : 0);
        }
      }
      this.totalPages = rowCount;
      if (!this.isPaging && !this.isVertical) {
        rowWidth += this.isTitle && titlePosition !== "Top" ? this.fivePixel + this.legendTitleSize.width + this.fivePixel : 0;
      }
      if (render) {
        this.setBounds(Math.max(rowWidth + padding, maximumWidth), columnHeight, legend, legendBound);
      } else {
        this.setBounds(0, 0, legend, legendBound);
      }
    };
    StockLegend2.prototype.getRenderPoint = function(legendOptions, start, textPadding, prevLegend, rect, count, firstLegend) {
      var previousBound = prevLegend.location.x + textPadding + prevLegend.textSize.width;
      var padding = this.legend.padding;
      if (previousBound + (legendOptions.textSize.width + textPadding - this.itemPadding) > rect.x + rect.width + this.legend.shapeWidth / 2 || this.isVertical) {
        legendOptions.location.x = start.x;
        legendOptions.location.y = count === firstLegend ? prevLegend.location.y : prevLegend.location.y + this.maxItemHeight + (this.isVertical ? this.itemPadding : padding);
      } else {
        legendOptions.location.x = count === firstLegend ? prevLegend.location.x : previousBound;
        legendOptions.location.y = prevLegend.location.y;
      }
      var availwidth = this.legendBounds.width + this.legendBounds.x - (legendOptions.location.x + textPadding - this.itemPadding - this.legend.shapeWidth / 2);
      legendOptions.text = textTrim(+availwidth.toFixed(4), legendOptions.text, this.legend.textStyle, this.chart.enableRtl, this.chart.themeStyle.legendLabelFont);
    };
    StockLegend2.prototype.legendClick = function(index) {
      var chart = this.chart;
      var seriesIndex = chart.legendSettings.mode === "Series" ? index : 0;
      var targetSeries = chart.visibleSeries[seriesIndex];
      var targetLegend = this.legendCollections[index];
      var legendClickArgs = {
        legendText: targetLegend.text,
        legendShape: targetLegend.shape,
        chart,
        series: targetSeries,
        name: legendClick,
        cancel: false
      };
      this.chart.trigger(legendClick, legendClickArgs);
      targetSeries.legendShape = legendClickArgs.legendShape;
      if (targetSeries.fill !== null) {
        chart.visibleSeries[index].interior = targetSeries.fill;
      }
      if (chart.legendSettings.toggleVisibility) {
        chart.legendClicked = true;
        this.changeSeriesVisiblity(targetSeries, targetSeries.visible);
        targetLegend.visible = targetSeries.category === "TrendLine" ? chart.series[targetSeries.sourceIndex].trendlines[targetSeries.index].visible : targetSeries.visible;
        this.refreshLegendToggle(chart);
      }
    };
    StockLegend2.prototype.refreshLegendToggle = function(chart) {
      var bounds = chart.stockLegendModule.legendBounds;
      chart.stockLegendModule.renderLegend(chart, chart.legendSettings, bounds);
    };
    StockLegend2.prototype.changeSeriesVisiblity = function(series, visibility) {
      series.visible = !visibility;
      if (this.SecondaryAxis(series.yAxis)) {
        series.yAxis.internalVisibility = series.yAxis.series.some(function(value) {
          return value.visible;
        });
      }
      if (this.SecondaryAxis(series.xAxis)) {
        series.xAxis.internalVisibility = series.xAxis.series.some(function(value) {
          return value.visible;
        });
      }
    };
    StockLegend2.prototype.SecondaryAxis = function(axis) {
      return this.chart.axes.indexOf(axis) > -1;
    };
    StockLegend2.prototype.click = function(event2) {
      var _this = this;
      if (!this.chart.legendSettings.visible) {
        return;
      }
      var pageY = this.chart.mouseY;
      var pageX = this.chart.mouseX;
      var legendItemsId = [this.legendID + "_text_", this.legendID + "_shape_marker_", this.legendID + "_shape_"];
      var targetId = event2.target.id;
      var seriesIndex;
      for (var _i = 0, legendItemsId_1 = legendItemsId; _i < legendItemsId_1.length; _i++) {
        var id = legendItemsId_1[_i];
        if (targetId.indexOf(id) > -1) {
          seriesIndex = parseInt(targetId.split(id)[1], 10);
          this.legendClick(seriesIndex);
          break;
        }
      }
      if (targetId.indexOf(this.legendID + "_pagedown") > -1) {
        this.changePage(event2, false);
      } else if (targetId.indexOf(this.legendID + "_pageup") > -1) {
        this.changePage(event2, true);
      }
      this.legendRegions.filter(function(region) {
        return withInBounds(pageX, pageY + (_this.isPaging ? (_this.currentPageNumber - 1) * _this.translatePage(false, null, 1, 2) : 0), region.rect);
      });
    };
    StockLegend2.prototype.getModuleName = function() {
      return "StockLegend";
    };
    StockLegend2.prototype.destroy = function() {
      this.removeEventListener();
    };
    return StockLegend2;
  }(BaseLegend)
);

// node_modules/@syncfusion/ej2-charts/src/stock-chart/renderer/cartesian-chart.js
var CartesianChart = (
  /** @class */
  function() {
    function CartesianChart2(chart) {
      this.stockChart = chart;
    }
    CartesianChart2.prototype.initializeChart = function(chartArgsData) {
      var _this = this;
      var stockChart = this.stockChart;
      var isProtect = "isProtectedOnChange";
      var startValue = null;
      var endValue = null;
      stockChart[isProtect] = true;
      if (!stockChart.chartObject) {
        stockChart.chartObject = stockChart.renderer.createGroup({
          id: stockChart.element.id + "_stockChart_chart"
        });
        stockChart.mainObject.appendChild(stockChart.chartObject);
      } else {
        var chartElement = document.getElementById(stockChart.chartObject.id);
        while (chartElement.firstChild) {
          chartElement.removeChild(chartElement.firstChild);
        }
        if (getElement2(stockChart.chartObject + "_tooltip")) {
          remove(getElement2(stockChart.chartObject + "_tooltip"));
        }
      }
      this.stockChart.isDateTimeCategory = this.stockChart.primaryXAxis.valueType === "DateTimeCategory";
      if (this.stockChart.isDateTimeCategory && !this.stockChart.sortedData.length) {
        for (var _i = 0, _a = this.stockChart.series; _i < _a.length; _i++) {
          var series = _a[_i];
          var dataSource = series.dataSource;
          var xName = series.xName;
          for (var _b = 0, dataSource_1 = dataSource; _b < dataSource_1.length; _b++) {
            var dataItem = dataSource_1[_b];
            var currentData = Date.parse(new Date(DataUtil.parse.parseJson({
              val: dataItem[xName]
            }).val).toString());
            if (this.stockChart.sortedData.indexOf(currentData) === -1) {
              this.stockChart.sortedData.push(currentData);
            }
          }
        }
        this.stockChart.sortedData.sort(function(a, b) {
          return a - b;
        });
      }
      this.cartesianChartSize = this.calculateChartSize();
      stockChart.chart = new Chart({
        chartArea: stockChart.chartArea,
        margin: this.findMargin(stockChart),
        primaryXAxis: this.copyObject(stockChart.primaryXAxis),
        primaryYAxis: this.copyObject(stockChart.primaryYAxis),
        rows: stockChart.rows,
        indicators: stockChart.indicators,
        axes: stockChart.axes,
        tooltipRender: function(args) {
          _this.stockChart.trigger("tooltipRender", args);
        },
        axisLabelRender: function(args) {
          _this.stockChart.trigger("axisLabelRender", args);
        },
        seriesRender: function(args) {
          startValue = _this.stockChart.startValue != null && _this.stockChart.isDateTimeCategory ? _this.stockChart.sortedData[Math.floor(_this.stockChart.startValue)] : _this.stockChart.startValue;
          endValue = _this.stockChart.endValue != null && _this.stockChart.isDateTimeCategory ? _this.stockChart.sortedData[Math.floor(_this.stockChart.endValue)] : _this.stockChart.endValue;
          if (args.data && startValue && endValue) {
            args.data = args.data.filter(function(data) {
              return new Date(DataUtil.parse.parseJson({
                val: data[args.series.xName]
              }).val).getTime() >= startValue && new Date(DataUtil.parse.parseJson({
                val: data[args.series.xName]
              }).val).getTime() <= endValue;
            });
          }
          args.data = chartArgsData ? chartArgsData : args.data;
          _this.stockChart.trigger("seriesRender", args);
        },
        onZooming: function(args) {
          _this.stockChart.trigger(onZooming, args);
        },
        pointClick: function(args) {
          _this.stockChart.trigger("pointClick", args);
        },
        pointMove: function(args) {
          _this.stockChart.trigger("pointMove", args);
        },
        dataSource: stockChart.dataSource,
        series: this.findSeriesCollection(stockChart.series),
        zoomSettings: this.copyObject(stockChart.zoomSettings),
        tooltip: stockChart.tooltip,
        crosshair: stockChart.crosshair,
        height: this.cartesianChartSize.height.toString(),
        selectedDataIndexes: stockChart.selectedDataIndexes,
        selectionMode: stockChart.selectionMode,
        isMultiSelect: stockChart.isMultiSelect,
        annotations: stockChart.annotations,
        theme: stockChart.theme,
        legendSettings: {
          visible: false
        },
        enableRtl: stockChart.enableRtl,
        zoomComplete: function(args) {
          if (args.axis.valueType.indexOf("DateTime") !== -1 && stockChart.rangeNavigator) {
            _this.stockChart.zoomChange = true;
            var newRange = _this.calculateUpdatedRange(args.currentZoomFactor, args.currentZoomPosition, args.axis);
            stockChart.rangeSelector.sliderChange(newRange.start, newRange.end);
          }
        }
      });
      if (stockChart.indicators.length !== 0) {
        if (stockChart.isSelect) {
          for (var i = 0; i < stockChart.indicators.length; i++) {
            stockChart.chart.indicators[i].animation.enable = false;
            stockChart.chart.indicators[i].dataSource = extend([], stockChart.chart.series[0].dataSource, null, true);
          }
        }
        stockChart.isSelect = true;
      }
      stockChart.chart.stockChart = stockChart;
      stockChart.chart.appendTo(stockChart.chartObject);
      stockChart[isProtect] = false;
      if (stockChart.onPanning) {
        getElement2(this.stockChart.element.id + "_stockChart_chart").setAttribute("cursor", "pointer");
        stockChart.chart.mouseMove(stockChart.mouseMoveEvent);
      }
    };
    CartesianChart2.prototype.findMargin = function(stockChart) {
      var margin = {};
      margin.top = stockChart.stockLegendModule && stockChart.legendSettings.visible && stockChart.legendSettings.position === "Top" ? stockChart.margin.top : stockChart.margin.top * 2;
      margin.left = stockChart.margin.left;
      margin.right = stockChart.margin.right;
      margin.bottom = stockChart.margin.bottom;
      return margin;
    };
    CartesianChart2.prototype.findSeriesCollection = function(series) {
      var chartSeries = [];
      for (var i = 0, len = series.length; i < len; i++) {
        chartSeries.push(series[i]);
        chartSeries[i].high = series[i].high;
        chartSeries[i].low = series[i].low;
        chartSeries[i].open = series[i].open;
        chartSeries[i].close = series[i].close;
        chartSeries[i].xName = series[i].xName;
        chartSeries[i].volume = series[i].volume;
        chartSeries[i].animation = series[i].animation;
        if (series[i].localData) {
          chartSeries[i].dataSource = series[i].localData;
        }
        chartSeries[i].yName = series[i].yName === "" ? series[i].close : series[i].yName;
        chartSeries[i].splineType = chartSeries[i].type === "Spline" ? "Cardinal" : "Natural";
      }
      return chartSeries;
    };
    CartesianChart2.prototype.calculateChartSize = function() {
      var stockChart = this.stockChart;
      return new Size(stockChart.availableSize.width, stockChart.enablePeriodSelector && stockChart.enableSelector ? stockChart.availableSize.height - stockChart.toolbarHeight - 51 : stockChart.enableSelector && !stockChart.enablePeriodSelector ? stockChart.availableSize.height - 51 : stockChart.enablePeriodSelector && !stockChart.enableSelector ? stockChart.availableSize.height - stockChart.toolbarHeight : stockChart.availableSize.height);
    };
    CartesianChart2.prototype.calculateUpdatedRange = function(zoomFactor, zoomPosition, axis) {
      var start;
      var end;
      var chartRange = axis.actualRange;
      var inversed = false;
      if (!inversed) {
        start = chartRange.min + zoomPosition * chartRange.delta;
        end = start + zoomFactor * chartRange.delta;
      } else {
        start = chartRange.max - zoomPosition * chartRange.delta;
        end = start - zoomFactor * chartRange.delta;
      }
      if (this.stockChart.isDateTimeCategory) {
        start = this.stockChart.sortedData.indexOf(parseInt(axis.labels[Math.floor(start)], 10));
        end = this.stockChart.sortedData.indexOf(parseInt(axis.labels[Math.floor(end)], 10));
      }
      var result = {
        start,
        end
      };
      return result;
    };
    CartesianChart2.prototype.cartesianChartRefresh = function(stockChart, data) {
      stockChart.cartesianChart.initializeChart(data);
    };
    CartesianChart2.prototype.copyObject = function(originalObject) {
      return extend({}, originalObject, {}, true);
    };
    return CartesianChart2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/stock-chart/renderer/range-selector.js
var RangeSelector = (
  /** @class */
  function() {
    function RangeSelector2(stockChart) {
      this.stockChart = stockChart;
    }
    RangeSelector2.prototype.initializeRangeNavigator = function() {
      var _this = this;
      var stockChart = this.stockChart;
      var padding = stockChart.chart.axisCollections[1].labelPadding + stockChart.chart.axisCollections[1].lineStyle.width * 0.5;
      if (!stockChart.selectorObject) {
        stockChart.selectorObject = stockChart.renderer.createGroup({
          id: stockChart.element.id + "_stockChart_rangeSelector",
          transform: "translate(0," + stockChart.cartesianChart.cartesianChartSize.height + ")"
        });
        stockChart.mainObject.appendChild(stockChart.selectorObject);
      } else {
        var chartElement = document.getElementById(stockChart.selectorObject.id);
        while (chartElement.firstChild) {
          chartElement.removeChild(chartElement.firstChild);
        }
        if (getElement2(stockChart.selectorObject.id + "_leftTooltip")) {
          remove(getElement2(stockChart.selectorObject.id + "_leftTooltip"));
        }
        if (getElement2(stockChart.selectorObject.id + "_rightTooltip")) {
          remove(getElement2(stockChart.selectorObject.id + "_rightTooltip"));
        }
      }
      stockChart.rangeNavigator = new RangeNavigator({
        locale: "en",
        valueType: stockChart.primaryXAxis.valueType,
        theme: this.stockChart.theme,
        series: this.findSeriesCollection(stockChart.series),
        height: this.calculateChartSize().height.toString(),
        tickPosition: "Inside",
        majorTickLines: {
          width: 0
        },
        value: [stockChart.isDateTimeCategory ? new Date(stockChart.sortedData[Math.floor(stockChart.startValue)]) : new Date(stockChart.startValue), stockChart.isDateTimeCategory ? new Date(stockChart.sortedData[Math.floor(stockChart.endValue)]) : new Date(stockChart.endValue)],
        margin: this.findMargin(),
        tooltip: {
          enable: stockChart.tooltip.enable,
          displayMode: "OnDemand"
        },
        labelPlacement: "OnTicks",
        labelPosition: "Inside",
        dataSource: stockChart.dataSource,
        intervalType: stockChart.primaryXAxis.intervalType,
        enableRtl: stockChart.enableRtl,
        changed: function(args) {
          var arg = {
            name: "rangeChange",
            end: args.end,
            selectedData: args.selectedData,
            start: args.start,
            zoomFactor: args.zoomFactor,
            zoomPosition: args.zoomPosition,
            data: void 0
          };
          _this.stockChart.trigger("rangeChange", arg);
          _this.stockChart.startValue = args.start;
          _this.stockChart.endValue = args.end;
          if (!_this.stockChart.zoomChange) {
            _this.stockChart.cartesianChart.cartesianChartRefresh(_this.stockChart, arg.data);
          }
          if (stockChart.periodSelector && stockChart.periodSelector.datePicker) {
            stockChart.periodSelector.datePicker.startDate = _this.stockChart.isDateTimeCategory ? new Date(_this.stockChart.sortedData[Math.floor(args.start)]) : new Date(args.start);
            stockChart.periodSelector.datePicker.endDate = _this.stockChart.isDateTimeCategory ? new Date(_this.stockChart.sortedData[Math.floor(args.end)]) : new Date(args.end);
            stockChart.periodSelector.datePicker.dataBind();
          }
        }
      });
      stockChart.rangeNavigator.stockChart = stockChart;
      stockChart.rangeNavigator.appendTo(stockChart.selectorObject);
    };
    RangeSelector2.prototype.findMargin = function() {
      var margin = {};
      margin.top = 5;
      margin.left = 0;
      margin.right = 0;
      margin.bottom = 0;
      return margin;
    };
    RangeSelector2.prototype.findSeriesCollection = function(series) {
      var chartSeries = [];
      for (var i = 0, len = series.length; i < len; i++) {
        chartSeries.push(series[i]);
        chartSeries[i].xName = series[i].xName;
        chartSeries[i].yName = series[i].yName;
      }
      return chartSeries;
    };
    RangeSelector2.prototype.calculateChartSize = function() {
      var stockChart = this.stockChart;
      return new Size(stockChart.availableSize.width, stockChart.enableSelector ? 51 : 0);
    };
    RangeSelector2.prototype.sliderChange = function(start, end) {
      this.stockChart.rangeNavigator.rangeSlider.performAnimation(start, end, this.stockChart.rangeNavigator);
    };
    return RangeSelector2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/stock-chart/renderer/toolbar-selector.js
var ToolBarSelector = (
  /** @class */
  function() {
    function ToolBarSelector2(chart) {
      this.selectedSeries = "";
      this.selectedIndicator = "";
      this.selectedTrendLine = "";
      this.indicators = [];
      this.stockChart = chart;
      this.selectedSeries = this.stockChart.series[0].type;
    }
    ToolBarSelector2.prototype.initializePeriodSelector = function() {
      var periods = this.stockChart.tempPeriods;
      this.stockChart.periods = periods;
      this.stockChart.periodSelector.rootControl = this.stockChart;
      var rect = this.stockChart.chart.chartAxisLayoutPanel.seriesClipRect;
      var htmlElement = getElement2(this.stockChart.element.id + "_Secondary_Element");
      var height = this.stockChart.toolbarHeight;
      this.stockChart.periodSelector.appendSelector({
        thumbSize: 0,
        element: htmlElement,
        width: rect.width,
        height
      }, rect.x);
      if (this.stockChart.seriesType.length > 0) {
        this.initializeSeriesSelector();
      }
      this.initializeIndicatorSelector();
      if (this.stockChart.trendlineType.length > 0) {
        this.initializeTrendlineSelector();
      }
      this.exportButton();
    };
    ToolBarSelector2.prototype.getDropDownItems = function(type) {
      var result = [];
      if (type === this.stockChart.seriesType) {
        for (var i = 0; i < type.length; i++) {
          result.push({
            text: "&nbsp;&nbsp;&nbsp;" + type[i].toString()
          });
        }
        for (var i = 0; i < this.stockChart.series.length; i++) {
          for (var j = 0; j < result.length; j++) {
            var text = result[j].text.replace("&nbsp;&nbsp;&nbsp;", "");
            text = text === "OHLC" ? "HiloOpenClose" : text;
            if (text === this.stockChart.series[i].type) {
              result[j].text = result[j].text.replace("&nbsp;&nbsp;&nbsp;", "&#10004&nbsp;");
            }
          }
        }
      } else if (type === this.stockChart.indicatorType) {
        for (var i = 0; i < type.length; i++) {
          result.push({
            text: "&nbsp;&nbsp;&nbsp;" + type[i].toString()
          });
        }
        for (var i = 0; i < this.stockChart.indicators.length; i++) {
          for (var j = 0; j < result.length; j++) {
            var text = result[j].text.replace("&nbsp;&nbsp;&nbsp;", "");
            text = text.toLowerCase().replace(/(^\w|_\w)/g, function(match) {
              return match.toUpperCase();
            }).replace(/_/g, "");
            text = text === "Accumulation distribution" ? "AccumulationDistribution" : text === "Bollinger bands" ? "BollingerBands" : text;
            if (text === this.stockChart.indicators[i].type) {
              result[j].text = result[j].text.replace("&nbsp;&nbsp;&nbsp;", "&#10004&nbsp;");
              this.indicators.push(text);
            }
          }
        }
      } else if (type === this.stockChart.exportType) {
        for (var i = 0; i < type.length; i++) {
          result.push({
            text: type[i].toString()
          });
        }
      } else {
        for (var i = 0; i < type.length; i++) {
          if (type[i].toString() !== "Print") {
            result.push({
              text: "&nbsp;&nbsp;&nbsp;" + type[i].toString()
            });
          }
        }
      }
      return result;
    };
    ToolBarSelector2.prototype.addedSeries = function(seriesType) {
      var series = this.stockChart.series;
      for (var i = 0; i < series.length; i++) {
        if (series[i].yName === "volume") {
          continue;
        }
        series[i].type = seriesType.indexOf("Candle") > -1 ? "Candle" : seriesType.indexOf("OHLC") > -1 ? "HiloOpenClose" : seriesType;
        series[i].enableSolidCandles = seriesType === "Candle";
        for (var index = 0; index < series[i].trendlines.length; index++) {
          var trendLine = series[i].trendlines[index];
          trendLine.animation.enable = false;
          trendLine.enableTooltip = false;
        }
      }
    };
    ToolBarSelector2.prototype.initializeSeriesSelector = function() {
      var _this = this;
      if (this.stockChart.seriesType.indexOf("HiloOpenClose") > -1) {
        this.stockChart.seriesType[this.stockChart.seriesType.indexOf("HiloOpenClose")] = "OHLC";
      }
      if (this.stockChart.seriesType.indexOf("Candle") > -1 && this.stockChart.seriesType.indexOf("Hollow Candle") === -1) {
        this.stockChart.seriesType[this.stockChart.seriesType.length] = "Hollow Candle";
      }
      var seriesType = new DropDownButton({
        enableHtmlSanitizer: false,
        items: this.getDropDownItems(this.stockChart.seriesType),
        select: function(args) {
          _this.selectedSeries = args.item.text;
          var text = _this.tickMark(args);
          _this.addedSeries(text);
          _this.stockChart.cartesianChart.initializeChart();
          if (_this.stockChart.stockLegendModule && _this.stockChart.stockLegendModule.legendCollections.length && _this.stockChart.legendSettings.visible) {
            var bounds = _this.stockChart.stockLegendModule.legendBounds;
            _this.stockChart.stockLegendModule.renderLegend(_this.stockChart, _this.stockChart.legendSettings, bounds);
          }
        }
      });
      seriesType.appendTo("#" + this.stockChart.element.id + "_seriesType");
    };
    ToolBarSelector2.prototype.initializeTrendlineSelector = function() {
      var _this = this;
      this.trendlineDropDown = new DropDownButton({
        enableHtmlSanitizer: false,
        items: this.stockChart.resizeTo ? this.trendlineDropDown.items : this.getDropDownItems(this.stockChart.trendlineType),
        select: function(args) {
          var type = _this.tickMark(args);
          _this.selectedTrendLine = _this.selectedTrendLine === "" ? type : _this.selectedTrendLine + "," + type;
          if (_this.trendline !== type) {
            _this.trendline = type;
            for (var i = 0; i < _this.stockChart.series.length; i++) {
              if (_this.stockChart.series[i].yName === "volume") {
                continue;
              }
              if (_this.stockChart.series[0].trendlines.length === 0) {
                var trendlines = void 0;
                if (_this.stockChart.trendlinetriggered) {
                  trendlines = [{
                    type,
                    width: 1,
                    enableTooltip: false
                  }];
                  _this.stockChart.trendlinetriggered = false;
                }
                _this.stockChart.series[0].trendlines = trendlines;
              } else {
                _this.stockChart.series[0].trendlines[0].width = 1;
                _this.stockChart.series[0].trendlines[0].type = type;
                _this.stockChart.series[0].trendlines[0].animation.enable = _this.stockChart.trendlinetriggered ? true : false;
              }
            }
            _this.stockChart.cartesianChart.initializeChart();
          } else {
            args.item.text = "&nbsp;&nbsp;&nbsp;" + args.item.text.replace("&#10004&nbsp;", "");
            _this.stockChart.series[0].trendlines[0].width = 0;
            _this.trendline = null;
            _this.stockChart.cartesianChart.initializeChart();
          }
        }
      });
      this.trendlineDropDown.appendTo("#" + this.stockChart.element.id + "_trendType");
    };
    ToolBarSelector2.prototype.initializeIndicatorSelector = function() {
      var _this = this;
      this.indicatorDropDown = new DropDownButton({
        enableHtmlSanitizer: false,
        items: this.stockChart.resizeTo ? this.indicatorDropDown.items : this.getDropDownItems(this.stockChart.indicatorType),
        select: function(args) {
          for (var l = 0; l < _this.stockChart.series.length; l++) {
            if (_this.stockChart.series[l].trendlines.length !== 0) {
              _this.stockChart.series[l].trendlines[0].animation.enable = false;
            }
          }
          args.item.text = args.item.text.indexOf("&#10004&nbsp;") >= 0 ? args.item.text.substr(args.item.text.indexOf(";") + 1) : args.item.text;
          var text = args.item.text.replace("&nbsp;&nbsp;&nbsp;", "");
          text = text.split(" ")[0].toLocaleLowerCase() + (text.split(" ")[1] ? text.split(" ")[1] : "");
          text = text.substr(0, 1).toUpperCase() + text.substr(1);
          var type = text;
          _this.selectedIndicator = _this.selectedIndicator.indexOf(type) === -1 ? _this.selectedIndicator + " " + type : _this.selectedIndicator.replace(type, "");
          if (type === "Tma" || type === "BollingerBands" || type === "Sma" || type === "Ema") {
            if (_this.indicators.indexOf(type) === -1) {
              args.item.text = "&#10004&nbsp;" + args.item.text.replace("&nbsp;&nbsp;&nbsp;", "");
              var indicator = _this.getIndicator(type, _this.stockChart.series[0].yAxisName);
              _this.indicators.push(type);
              _this.stockChart.indicators = _this.stockChart.indicators.concat(indicator);
              _this.stockChart.cartesianChart.initializeChart();
            } else {
              args.item.text = "&nbsp;&nbsp;&nbsp;" + args.item.text;
              for (var z = 0; z < _this.stockChart.indicators.length; z++) {
                if (_this.stockChart.indicators[z].type === type) {
                  _this.stockChart.indicators.splice(z, 1);
                }
              }
              _this.indicators.splice(_this.indicators.indexOf(type), 1);
              _this.stockChart.cartesianChart.initializeChart();
            }
          } else {
            _this.createIndicatorAxes(type, args);
          }
        }
      });
      this.indicatorDropDown.appendTo("#" + this.stockChart.element.id + "_indicatorType");
    };
    ToolBarSelector2.prototype.getIndicator = function(type, yAxisName) {
      var currentSeries = this.stockChart.series[0];
      var indicator = [{
        type,
        period: 3,
        yAxisName,
        dataSource: currentSeries.localData,
        xName: currentSeries.xName,
        open: currentSeries.open,
        close: currentSeries.close,
        high: currentSeries.high,
        low: currentSeries.low,
        volume: currentSeries.volume,
        fill: type === "Sma" ? "#32CD32" : "#6063ff",
        animation: {
          enable: false
        },
        upperLine: {
          color: "#FFE200",
          width: 1
        },
        periodLine: {
          width: 2
        },
        lowerLine: {
          color: "#FAA512",
          width: 1
        },
        fastPeriod: 8,
        slowPeriod: 5,
        macdType: "Both",
        width: 1,
        macdPositiveColor: "#6EC992",
        macdNegativeColor: "#FF817F",
        bandColor: "rgba(245, 203, 35, 0.12)"
      }];
      return indicator;
    };
    ToolBarSelector2.prototype.createIndicatorAxes = function(type, args) {
      if (this.indicators.indexOf(type) === -1) {
        args.item.text = "&#10004&nbsp;" + args.item.text.replace("&nbsp;&nbsp;&nbsp;", "");
        this.indicators.push(type);
        var len = this.stockChart.rows.length;
        this.stockChart.rows[this.stockChart.rows.length - 1].height = "15%";
        var row = [{
          height: "" + (100 - len * 15) + "px"
        }];
        if (this.stockChart.rows.length === 1) {
          this.stockChart.isSingleAxis = true;
        }
        this.stockChart.rows = this.stockChart.rows.concat(row);
        if (!this.stockChart.isSingleAxis) {
          this.stockChart.axes[0].rowIndex += 1;
        } else {
          for (var i = 0; i < this.stockChart.axes.length; i++) {
            this.stockChart.axes[i].rowIndex += 1;
          }
        }
        var axis = [{
          plotOffset: 10,
          opposedPosition: true,
          rowIndex: !this.stockChart.isSingleAxis ? this.stockChart.axes.length : 0,
          desiredIntervals: 1,
          labelFormat: "n2",
          majorGridLines: this.stockChart.primaryYAxis.majorGridLines,
          lineStyle: this.stockChart.primaryYAxis.lineStyle,
          labelPosition: this.stockChart.primaryYAxis.labelPosition,
          majorTickLines: this.stockChart.primaryYAxis.majorTickLines,
          rangePadding: "None",
          name: type.toString()
        }];
        this.stockChart.axes = this.stockChart.axes.concat(axis);
        this.stockChart.primaryYAxis.rowIndex = !this.stockChart.isSingleAxis ? 0 : len + 1;
        var indicator = this.getIndicator(type, type.toString());
        this.stockChart.indicators = this.stockChart.indicators.concat(indicator);
        this.stockChart.cartesianChart.initializeChart();
      } else {
        args.item.text = "&nbsp;&nbsp;&nbsp;" + args.item.text;
        for (var i = 0; i < this.stockChart.indicators.length; i++) {
          if (this.stockChart.indicators[i].type === type) {
            this.stockChart.indicators.splice(i, 1);
          }
        }
        this.indicators.splice(this.indicators.indexOf(type), 1);
        var removedIndex = 0;
        for (var z = 0; z < this.stockChart.axes.length; z++) {
          if (this.stockChart.axes[z].name === type) {
            removedIndex = this.stockChart.axes[z].rowIndex;
            this.stockChart.rows.splice(z, 1);
            this.stockChart.axes.splice(z, 1);
          }
        }
        for (var z = 0; z < this.stockChart.axes.length; z++) {
          if (this.stockChart.axes[z].rowIndex !== 0 && this.stockChart.axes[z].rowIndex > removedIndex) {
            this.stockChart.axes[z].rowIndex = this.stockChart.axes[z].rowIndex - 1;
          }
        }
        this.stockChart.cartesianChart.initializeChart();
      }
    };
    ToolBarSelector2.prototype.tickMark = function(args) {
      var text;
      var items = args.item["parentObj"].items;
      for (var i = 0; i < items.length; i++) {
        items[i].text = items[i].text.indexOf("&#10004&nbsp;") >= 0 ? items[i].text.substr(items[i].text.indexOf(";") + 1) : items[i].text;
        if (!(items[i].text.indexOf("&nbsp;&nbsp;&nbsp;") >= 0)) {
          items[i].text = "&nbsp;&nbsp;&nbsp;" + items[i].text;
        }
      }
      if (args.item.text.indexOf("&nbsp;&nbsp;&nbsp;") >= 0) {
        text = args.item.text.replace("&nbsp;&nbsp;&nbsp;", "");
        args.item.text = args.item.text.replace("&nbsp;&nbsp;&nbsp;", "&#10004&nbsp;");
      } else {
        text = args.item.text.replace("&#10004&nbsp;", "");
      }
      return text;
    };
    ToolBarSelector2.prototype.exportButton = function() {
      var _this = this;
      var exportChart = new DropDownButton({
        enableHtmlSanitizer: false,
        items: this.getDropDownItems(this.stockChart.exportType),
        select: function(args) {
          var type = args.item.text;
          if (_this.stockChart.chart.exportModule) {
            var stockChart = _this.stockChart;
            var stockID = stockChart.element.id + "_stockChart_";
            var svgHeight = stockChart.svgObject.getBoundingClientRect();
            _this.stockChart.svgObject.insertAdjacentElement("afterbegin", _this.addExportSettings(type === "Print"));
            var additionalRect = stockChart.svgObject.firstElementChild.getBoundingClientRect();
            var rect = new RectOption("additionalRect", "transparent", {
              width: 0,
              color: "transparent"
            }, 1, new Rect(0, 0, _this.stockChart.availableSize.width, additionalRect.height));
            stockChart.svgObject.firstElementChild.insertAdjacentElement("afterbegin", _this.stockChart.renderer.drawRectangle(rect));
            _this.stockChart.svgObject.setAttribute("height", (svgHeight.height + additionalRect.height).toString());
            getElement2(stockID + "chart").style.transform = "translateY(" + additionalRect.height + "px)";
            if (stockChart.enableSelector) {
              getElement2(stockID + "rangeSelector").setAttribute("transform", "translate(0," + (stockChart.cartesianChart.cartesianChartSize.height + additionalRect.height) + ")");
            }
            if (_this.stockChart.legendSettings.visible && _this.stockChart.stockLegendModule) {
              getElement2(stockChart.element.id + "_chart_legend_g").style.transform = "translateY(" + additionalRect.height + "px)";
            }
            if (type === "Print") {
              _this.stockChart.chart.print(_this.stockChart.svgObject.id);
            } else {
              stockChart.chart.exportModule.export(type, "StockChart", null, [stockChart], null, stockChart.svgObject.clientHeight);
            }
            remove(getElement2(_this.stockChart.element.id + "_additionalExport"));
            getElement2(stockID + "chart").style.transform = "";
            if (stockChart.enableSelector) {
              getElement2(stockID + "rangeSelector").setAttribute("transform", "translate(0," + stockChart.cartesianChart.cartesianChartSize.height + ")");
            }
            if (_this.stockChart.legendSettings.visible && _this.stockChart.stockLegendModule) {
              getElement2(stockChart.element.id + "_chart_legend_g").style.transform = "translateY(0px)";
            }
            _this.stockChart.svgObject.setAttribute("height", svgHeight.height.toString());
          }
        }
      });
      exportChart.appendTo("#" + this.stockChart.element.id + "_export");
    };
    ToolBarSelector2.prototype.calculateAutoPeriods = function() {
      var defaultPeriods = [];
      var min = this.stockChart.isDateTimeCategory ? this.stockChart.sortedData[this.stockChart.seriesXMin] : this.stockChart.seriesXMin;
      var max = this.stockChart.isDateTimeCategory ? this.stockChart.sortedData[this.stockChart.seriesXMax] : this.stockChart.seriesXMax;
      defaultPeriods = this.findRange(min, max);
      defaultPeriods.push({
        text: "YTD",
        selected: true
      }, {
        text: "All"
      });
      return defaultPeriods;
    };
    ToolBarSelector2.prototype.findRange = function(min, max) {
      var defaultPeriods = [];
      if ((max - min) / 3154e7 >= 1) {
        defaultPeriods.push({
          text: "1M",
          interval: 1,
          intervalType: "Months"
        }, {
          text: "3M",
          interval: 3,
          intervalType: "Months"
        }, {
          text: "6M",
          interval: 6,
          intervalType: "Months"
        }, {
          text: "1Y",
          interval: 1,
          intervalType: "Years"
        });
      } else if ((max - min) / 1577e7 >= 1) {
        defaultPeriods.push({
          text: "1M",
          interval: 1,
          intervalType: "Months"
        }, {
          text: "3M",
          interval: 3,
          intervalType: "Months"
        }, {
          text: "6M",
          interval: 6,
          intervalType: "Months"
        });
      } else if ((max - min) / 2628e6 >= 1) {
        defaultPeriods.push({
          text: "1D",
          interval: 1,
          intervalType: "Days"
        }, {
          text: "3W",
          interval: 3,
          intervalType: "Weeks"
        }, {
          text: "1M",
          interval: 1,
          intervalType: "Months"
        });
      } else if ((max - min) / 864e5 >= 1) {
        defaultPeriods.push({
          text: "1H",
          interval: 1,
          intervalType: "Hours"
        }, {
          text: "12H",
          interval: 12,
          intervalType: "Hours"
        }, {
          text: "1D",
          interval: 1,
          intervalType: "Days"
        });
      }
      return defaultPeriods;
    };
    ToolBarSelector2.prototype.addExportSettings = function(isPrint) {
      var exportElement = this.stockChart.renderer.createGroup({
        id: this.stockChart.element.id + "_additionalExport",
        width: this.stockChart.availableSize.width,
        fill: this.stockChart.background ? this.stockChart.background : "transparent"
      });
      var titleHeight = measureText(this.stockChart.title, this.stockChart.titleStyle, this.stockChart.themeStyle.chartTitleFont).height;
      var options = new TextOption(exportElement.id + "_Title", titlePositionX(new Rect(0, 0, this.stockChart.availableSize.width, 0), this.stockChart.titleStyle), 0, "middle", this.stockChart.title, "", "text-before-edge");
      textElement2(this.stockChart.renderer, options, this.stockChart.titleStyle, this.stockChart.titleStyle.color || this.stockChart.themeStyle.chartTitleFont.color, exportElement, null, null, null, null, null, null, null, null, null, null, this.stockChart.themeStyle.chartTitleFont);
      if (isPrint) {
        return exportElement;
      }
      var style = {
        size: "16px",
        fontWeight: "600",
        color: this.stockChart.themeStyle.chartTitleFont.color,
        fontStyle: "Normal",
        fontFamily: this.stockChart.themeStyle.chartTitleFont.fontFamily
      };
      var x = measureText("Series: " + this.selectedSeries, style).width / 2;
      var y = titleHeight;
      this.textElementSpan(new TextOption(exportElement.id + "_Series", x, y, "start", ["Series : ", this.selectedSeries], "", "text-before-edge"), style, this.stockChart.themeStyle.chartTitleFont.color, exportElement);
      x += measureText("Series: " + this.selectedSeries + " Z", style).width;
      if (this.selectedIndicator !== "") {
        this.textElementSpan(new TextOption(exportElement.id + "_Indicator", x, y, "start", ["Indicator :", this.selectedIndicator], "", "text-before-edge"), style, this.stockChart.themeStyle.chartTitleFont.color, exportElement);
        x += measureText("Indicator: " + this.selectedIndicator + " Z", style).width;
      }
      if (this.selectedTrendLine !== "") {
        this.textElementSpan(new TextOption(exportElement.id + "_TrendLine", x, y, "start", ["Trendline :", this.selectedTrendLine], "", "text-before-edge"), style, this.stockChart.themeStyle.chartTitleFont.color, exportElement);
      }
      return exportElement;
    };
    ToolBarSelector2.prototype.textElementSpan = function(options, font, color, parent, isMinus, redraw, isAnimate, forceAnimate, animateDuration) {
      if (isMinus === void 0) {
        isMinus = false;
      }
      if (forceAnimate === void 0) {
        forceAnimate = false;
      }
      var renderer = new SvgRenderer("");
      var renderOptions = {};
      var tspanElement;
      renderOptions = {
        "id": options.id,
        "font-style": font.fontStyle,
        "font-family": font.fontFamily,
        "font-weight": font.fontWeight,
        "text-anchor": options.anchor,
        "x": options.x,
        "y": options.y,
        "fill": color,
        "font-size": font.size,
        "transform": options.transform,
        "opacity": font.opacity,
        "dominant-baseline": options.baseLine
      };
      var text = typeof options.text === "string" ? options.text : isMinus ? options.text[options.text.length - 1] : options.text[0];
      var htmlObject = renderer.createText(renderOptions, text);
      if (typeof options.text !== "string" && options.text.length > 1) {
        for (var i = 1, len = options.text.length; i < len; i++) {
          options.text[i] = " " + options.text[i];
          tspanElement = renderer.createTSpan({
            "x": options.x + measureText(text, font).width + 5,
            "id": options.id,
            "y": options.y,
            opacity: 0.5
          }, options.text[i]);
          htmlObject.appendChild(tspanElement);
        }
      }
      appendChildElement(false, parent, htmlObject, redraw, isAnimate, "x", "y", null, null, forceAnimate, false, null, animateDuration);
      return htmlObject;
    };
    return ToolBarSelector2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/stock-chart/renderer/stock-events.js
var __extends83 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var StockEvents = (
  /** @class */
  function(_super) {
    __extends83(StockEvents2, _super);
    function StockEvents2(stockChart) {
      var _this = _super.call(this, stockChart.chart) || this;
      _this.symbolLocations = [];
      _this.stockChart = stockChart;
      _this.chartId = _this.stockChart.element.id;
      return _this;
    }
    StockEvents2.prototype.renderStockEvents = function() {
      var sChart = this.stockChart;
      var stockEvent;
      var stockEventElement;
      var textSize;
      var stockEventsElementGroup = sChart.renderer.createGroup({
        id: this.chartId + "_StockEvents"
      });
      this.symbolLocations = initialArray(sChart.series.length, sChart.stockEvents.length, new ChartLocation(0, 0));
      for (var i = 0; i < sChart.stockEvents.length; i++) {
        stockEvent = this.stockChart.stockEvents[i];
        for (var _i = 0, _a = sChart.chart.series; _i < _a.length; _i++) {
          var series = _a[_i];
          var argsData = {
            name: stockEventRender,
            stockChart: sChart,
            text: stockEvent.text,
            type: stockEvent.type,
            cancel: false,
            series
          };
          sChart.trigger(stockEventRender, argsData);
          stockEvent.text = argsData.text;
          stockEvent.type = argsData.type;
          textSize = measureText(stockEvent.text + "W", stockEvent.textStyle, this.stockChart.themeStyle.axisLabelFont);
          if (!argsData.cancel) {
            stockEventElement = sChart.renderer.createGroup({
              id: this.chartId + "_Series_" + series.index + "_StockEvents_" + i
            });
            var stockEventDate = this.dateParse(stockEvent.date).getTime();
            stockEventDate = this.stockChart.isDateTimeCategory ? series.xAxis.labels.indexOf(stockEventDate.toString()) : stockEventDate;
            if (withIn(stockEventDate, series.xAxis.visibleRange) && stockEventDate >= series.xMin && stockEventDate <= series.xMax) {
              if (stockEvent.seriesIndexes.length > 0) {
                for (var j = 0; j < stockEvent.seriesIndexes.length; j++) {
                  if (stockEvent.seriesIndexes[j] === series.index) {
                    stockEventsElementGroup.appendChild(this.creatEventGroup(stockEventElement, series, stockEvent, i, textSize));
                  }
                }
              } else {
                stockEventsElementGroup.appendChild(this.creatEventGroup(stockEventElement, series, stockEvent, i, textSize));
              }
            }
          }
        }
      }
      return stockEventsElementGroup;
    };
    StockEvents2.prototype.creatEventGroup = function(stockEventElement, series, stockEvent, i, textSize) {
      var symbolLocation = this.findClosePoint(series, stockEvent);
      if (!stockEvent.showOnSeries) {
        symbolLocation.y = series.yAxis.rect.y + series.yAxis.rect.height;
      }
      this.symbolLocations[series.index][i] = symbolLocation;
      this.createStockElements(stockEventElement, stockEvent, series, i, symbolLocation, textSize);
      return stockEventElement;
    };
    StockEvents2.prototype.findClosePoint = function(series, sEvent) {
      var stockEventDate = this.dateParse(sEvent.date).getTime();
      stockEventDate = this.stockChart.isDateTimeCategory ? series.xAxis.labels.indexOf(stockEventDate.toString()) : stockEventDate;
      var closeIndex = this.getClosest(series, stockEventDate);
      var pointData;
      var point;
      var yPixel;
      for (var k = 0; k < series.points.length; k++) {
        point = series.points[k];
        if (closeIndex === point.xValue && point.visible) {
          pointData = new PointData(point, series);
        } else if (k !== 0 && k !== series.points.length - 1) {
          if (closeIndex > series.points[k - 1].xValue && closeIndex < series.points[k + 1].xValue) {
            pointData = new PointData(point, series);
          }
        }
      }
      var xPixel = series.xAxis.rect.x + valueToCoefficient(pointData.point.xValue, series.xAxis) * series.xAxis.rect.width;
      yPixel = valueToCoefficient(pointData.point[sEvent.placeAt], series.yAxis) * series.yAxis.rect.height;
      yPixel = yPixel * -1 + (series.yAxis.rect.y + series.yAxis.rect.height);
      return new ChartLocation(xPixel, yPixel);
    };
    StockEvents2.prototype.createStockElements = function(stockEventElement, stockEve, series, i, symbolLocation, textSize) {
      var result = new Size(textSize.width > 20 ? textSize.width : 20, textSize.height > 20 ? textSize.height : 20);
      var pathString;
      var pathOption;
      var lx = symbolLocation.x;
      var ly = symbolLocation.y;
      var stockId = this.chartId + "_Series_" + series.index + "_StockEvents_" + i;
      var border = stockEve.border;
      switch (stockEve.type) {
        case "Flag":
        case "Circle":
        case "Square":
          stockEventElement.appendChild(drawSymbol(new ChartLocation(lx, ly), "Circle", new Size(2, 2), "", new PathOption(stockId + "_Circle", "transparent", border.width, border.color), this.dateParse(stockEve.date).toISOString()));
          stockEventElement.appendChild(drawSymbol(new ChartLocation(lx, ly - 5), "VerticalLine", new Size(9, 9), "", new PathOption(stockId + "_Path", border.color, border.width, border.color), this.dateParse(stockEve.date).toISOString()));
          stockEventElement.appendChild(drawSymbol(new ChartLocation(stockEve.type !== "Flag" ? lx : lx + result.width / 2, ly - result.height), stockEve.type, result, "", new PathOption(stockId + "_Shape", stockEve.background, border.width, border.color), this.dateParse(stockEve.date).toISOString()));
          textElement2(this.stockChart.renderer, new TextOption(stockId + "_Text", stockEve.type !== "Flag" ? symbolLocation.x : symbolLocation.x + result.width / 2, symbolLocation.y - result.height, "middle", stockEve.text, "", "middle"), stockEve.textStyle, stockEve.textStyle.color, stockEventElement);
          break;
        case "ArrowUp":
        case "ArrowDown":
        case "ArrowRight":
        case "ArrowLeft":
          pathString = "M " + lx + " " + ly + " " + this.findArrowpaths(stockEve.type);
          pathOption = new PathOption(stockId + "_Shape", stockEve.background, border.width, border.color, 1, "", pathString);
          stockEventElement.appendChild(this.stockChart.renderer.drawPath(pathOption));
          break;
        case "Triangle":
        case "InvertedTriangle":
          result.height = 3 * textSize.height;
          result.width = textSize.width + 1.5 * textSize.width;
          stockEventElement.appendChild(drawSymbol(new ChartLocation(symbolLocation.x, symbolLocation.y), stockEve.type, new Size(20, 20), "", new PathOption(stockId + "_Shape", stockEve.background, border.width, border.color), this.dateParse(stockEve.date).toISOString()));
          textElement2(this.stockChart.renderer, new TextOption(stockId + "_Text", symbolLocation.x, symbolLocation.y, "middle", stockEve.text, "", "middle"), stockEve.textStyle, stockEve.textStyle.color, stockEventElement);
          break;
        case "Text":
          textSize.height += 8;
          pathString = "M " + lx + " " + ly + " L " + (lx - 5) + " " + (ly - 5) + " L " + (lx - textSize.width / 2) + " " + (ly - 5) + " L " + (lx - textSize.width / 2) + " " + (ly - textSize.height) + " L " + (lx + textSize.width / 2) + " " + (ly - textSize.height) + " L " + (lx + textSize.width / 2) + " " + (ly - 5) + " L " + (lx + 5) + " " + (ly - 5) + " Z";
          pathOption = new PathOption(stockId + "_Shape", stockEve.background, border.width, border.color, 1, "", pathString);
          stockEventElement.appendChild(this.stockChart.renderer.drawPath(pathOption));
          textElement2(this.stockChart.renderer, new TextOption(stockId + "_Text", lx, ly - textSize.height / 2, "middle", stockEve.text, "", "middle"), stockEve.textStyle, stockEve.textStyle.color, stockEventElement);
          break;
        default:
          pathString = "M " + lx + " " + ly + " L " + (lx - textSize.width / 2) + " " + (ly - textSize.height / 3) + " L " + (lx - textSize.width / 2) + " " + (ly - textSize.height) + " L " + (lx + textSize.width / 2) + " " + (ly - textSize.height) + " L " + (lx + textSize.width / 2) + " " + (ly - textSize.height / 3) + " Z";
          pathOption = new PathOption(stockId + "_Shape", stockEve.background, border.width, border.color, 1, "", pathString);
          stockEventElement.appendChild(this.stockChart.renderer.drawPath(pathOption));
          textElement2(this.stockChart.renderer, new TextOption(stockId + "_Text", lx, ly - textSize.height / 2, "middle", stockEve.text, "", "middle"), stockEve.textStyle, stockEve.textStyle.color, stockEventElement);
      }
    };
    StockEvents2.prototype.renderStockEventTooltip = function(targetId) {
      var seriesIndex = parseInt(targetId.split("_StockEvents_")[0].split(this.chartId + "_Series_")[1], 10);
      var pointIndex = parseInt(targetId.split("_StockEvents_")[1].replace(/\D+/g, ""), 10);
      var updatedLocation = this.symbolLocations[seriesIndex][pointIndex];
      var pointLocation = new ChartLocation(updatedLocation.x, updatedLocation.y + this.stockChart.toolbarHeight + this.stockChart.titleSize.height);
      this.applyHighLights(pointIndex, seriesIndex);
      var svgElement = this.getElement(this.chartId + "_StockEvents_Tooltip_svg");
      var isTooltip = this.stockEventTooltip && svgElement && parseInt(svgElement.getAttribute("opacity"), 10) > 0;
      if (!isTooltip) {
        if (getElement2(this.chartId + "_StockEvents_Tooltip_svg")) {
          remove(getElement2(this.chartId + "_StockEvents_Tooltip"));
        }
        var tooltipElement = createElement("div", {
          id: this.chartId + "_StockEvents_Tooltip",
          className: "ejSVGTooltip",
          attrs: {
            "style": "pointer-events:none; position:absolute;z-index: 1"
          }
        });
        getElement2(this.chartId + "_Secondary_Element").appendChild(tooltipElement);
        this.stockEventTooltip = new Tooltip({
          opacity: 1,
          header: "",
          content: [this.stockChart.stockEvents[pointIndex].description],
          enableAnimation: true,
          location: pointLocation,
          theme: this.stockChart.theme,
          inverted: true,
          areaBounds: this.stockChart.chart.chartAxisLayoutPanel.seriesClipRect
        });
        this.stockEventTooltip.areaBounds.y += this.stockChart.toolbarHeight + this.stockChart.titleSize.height;
        this.stockEventTooltip.appendTo("#" + tooltipElement.id);
      } else {
        this.stockEventTooltip.content = [this.stockChart.stockEvents[pointIndex].description];
        this.stockEventTooltip.location = pointLocation;
        this.stockEventTooltip.dataBind();
      }
    };
    StockEvents2.prototype.removeStockEventTooltip = function(duration) {
      var _this = this;
      var tooltipElement = this.getElement(this.chartId + "_StockEvents_Tooltip");
      this.stopAnimation();
      if (tooltipElement && this.stockEventTooltip) {
        this.toolTipInterval = +setTimeout(function() {
          _this.stockEventTooltip.fadeOut();
          _this.removeHighLights();
        }, duration);
      } else if (tooltipElement && this.stockChart.onPanning) {
        remove(tooltipElement);
      }
    };
    StockEvents2.prototype.findArrowpaths = function(type) {
      var arrowString = "";
      switch (type) {
        case "ArrowUp":
          arrowString = "l -10 10 l 5 0 l 0 10 l 10 0 l 0 -10 l 5 0 z";
          break;
        case "ArrowDown":
          arrowString = "l -10 -10 l 5 0 l 0 -10 l 10 0 l 0 10 l 5 0 z";
          break;
        case "ArrowLeft":
          arrowString = "l -10 -10 l 0 5 l -10 0 l 0 10 l 10 0 l 0 5 z";
          break;
        case "ArrowRight":
          arrowString = "l 10 -10 l 0 5 l 10 0 l 0 10 l -10 0 l 0 5 z";
          break;
      }
      return arrowString;
    };
    StockEvents2.prototype.applyHighLights = function(pointIndex, seriesIndex) {
      if (this.pointIndex !== pointIndex || this.seriesIndex !== seriesIndex) {
        this.removeHighLights();
      }
      this.pointIndex = pointIndex;
      this.seriesIndex = seriesIndex;
      var stockId = this.chartId + "_Series_" + seriesIndex + "_StockEvents_" + pointIndex;
      this.setOpacity(stockId + "_Shape", 0.5);
      this.setOpacity(stockId + "_Text", 0.5);
    };
    StockEvents2.prototype.removeHighLights = function() {
      var stockId = this.chartId + "_Series_" + this.seriesIndex + "_StockEvents_" + this.pointIndex;
      this.setOpacity(stockId + "_Shape", 1);
      this.setOpacity(stockId + "_Text", 1);
    };
    StockEvents2.prototype.setOpacity = function(elementId, opacity) {
      if (getElement2(elementId)) {
        getElement2(elementId).setAttribute("opacity", opacity.toString());
      }
    };
    StockEvents2.prototype.dateParse = function(value) {
      var dateParser = this.chart.intl.getDateParser({
        skeleton: "full",
        type: "dateTime"
      });
      var dateFormatter = this.chart.intl.getDateFormat({
        skeleton: "full",
        type: "dateTime"
      });
      return new Date(Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({
        val: value
      }).val)))));
    };
    return StockEvents2;
  }(BaseTooltip)
);
function initialArray(numrows, numcols, initial) {
  var arr = [];
  for (var i = 0; i < numrows; ++i) {
    var columns = [];
    for (var j = 0; j < numcols; ++j) {
      columns[j] = initial;
    }
    arr[i] = columns;
  }
  return arr;
}

// node_modules/@syncfusion/ej2-charts/src/stock-chart/stock-chart.js
var __extends84 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate14 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var StockChart = (
  /** @class */
  function(_super) {
    __extends84(StockChart2, _super);
    function StockChart2(options, element) {
      var _this = _super.call(this, options, element) || this;
      _this.isSingleAxis = false;
      _this.chartid = 57723;
      _this.tempSeriesType = [];
      _this.zoomChange = false;
      _this.allowPan = false;
      _this.onPanning = false;
      _this.trendlinetriggered = true;
      _this.initialRender = true;
      _this.rangeFound = false;
      _this.tempPeriods = [];
      _this.isDateTimeCategory = false;
      _this.sortedData = [];
      _this.visibleRange = {
        min: 0,
        max: 0,
        delta: 0,
        interval: 0
      };
      _this.isStockChartRendered = false;
      StockChart_1.Inject(ColumnSeries, RangeAreaSeries, SplineRangeAreaSeries);
      _this.toolbarHeight = _this.enablePeriodSelector ? Browser.isDevice ? 56 : 42 : 0;
      return _this;
    }
    StockChart_1 = StockChart2;
    StockChart2.prototype.onPropertyChanged = function(newProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var property = _a[_i];
        switch (property) {
          case "series":
            this.storeDataSource();
            this.chartRender();
            this.stockChartDataManagerSuccess();
            this.legendClicked = false;
            break;
        }
      }
    };
    StockChart2.prototype.rangeChanged = function(updatedStart, updatedEnd) {
      var chartElement = document.getElementById(this.chartObject.id);
      if (chartElement) {
        while (chartElement.firstChild) {
          chartElement.removeChild(chartElement.firstChild);
        }
      }
      this.startValue = updatedStart;
      this.endValue = updatedEnd;
      this.cartesianChart.initializeChart();
      this.periodSelector.datePicker.startDate = this.isDateTimeCategory ? new Date(this.sortedData[updatedStart]) : new Date(updatedStart);
      this.periodSelector.datePicker.endDate = this.isDateTimeCategory ? new Date(this.sortedData[updatedEnd]) : new Date(updatedEnd);
      this.periodSelector.datePicker.dataBind();
    };
    StockChart2.prototype.preRender = function() {
      this.unWireEvents();
      this.initPrivateVariable();
      this.allowServerDataBinding = false;
      this.isProtectedOnChange = true;
      this.setCulture();
      this.wireEvents();
    };
    StockChart2.prototype.unWireEvents = function() {
      var startEvent = Browser.touchStartEvent;
      var moveEvent = Browser.touchMoveEvent;
      var stopEvent = Browser.touchEndEvent;
      var cancelEvent = Browser.isPointer ? "pointerleave" : "mouseleave";
      EventHandler.remove(this.element, startEvent, this.stockChartOnMouseDown);
      EventHandler.remove(this.element, moveEvent, this.stockChartOnMouseMove);
      EventHandler.remove(this.element, stopEvent, this.stockChartMouseEnd);
      EventHandler.remove(this.element, "click", this.stockChartOnMouseClick);
      EventHandler.remove(this.element, "contextmenu", this.stockChartRightClick);
      EventHandler.remove(this.element, cancelEvent, this.stockChartOnMouseLeave);
      window.removeEventListener(Browser.isTouch && "orientation" in window && "onorientationchange" in window ? "orientationchange" : "resize", this.stockChartResize);
    };
    StockChart2.prototype.wireEvents = function() {
      var cancelEvent = Browser.isPointer ? "pointerleave" : "mouseleave";
      EventHandler.add(this.element, Browser.touchStartEvent, this.stockChartOnMouseDown, this);
      EventHandler.add(this.element, Browser.touchMoveEvent, this.stockChartOnMouseMove, this);
      EventHandler.add(this.element, Browser.touchEndEvent, this.stockChartMouseEnd, this);
      EventHandler.add(this.element, "click", this.stockChartOnMouseClick, this);
      EventHandler.add(this.element, "contextmenu", this.stockChartRightClick, this);
      EventHandler.add(this.element, cancelEvent, this.stockChartOnMouseLeave, this);
      window.addEventListener(Browser.isTouch && "orientation" in window && "onorientationchange" in window ? "orientationchange" : "resize", this.stockChartResize.bind(this));
      this.setStyle(this.element);
    };
    StockChart2.prototype.initPrivateVariable = function() {
      if (this.element.id === "") {
        var collection = document.getElementsByClassName("e-stockChart").length;
        this.element.id = "stockChart_" + this.chartid + "_" + collection;
      }
      this.seriesXMax = null;
      this.seriesXMin = null;
      this.startValue = null;
      this.endValue = null;
      this.currentEnd = null;
      this.margin = {
        right: this.margin.right === null ? Browser.isDevice ? 5 : 10 : this.margin.right,
        left: this.margin.left === null ? Browser.isDevice ? 5 : 10 : this.margin.left,
        top: this.margin.top === null ? Browser.isDevice ? 5 : 10 : this.margin.top,
        bottom: this.margin.bottom === null ? Browser.isDevice ? 5 : 10 : this.margin.bottom
      };
      this.isStockChartRendered = false;
    };
    StockChart2.prototype.setCulture = function() {
      this.intl = new Internationalization();
    };
    StockChart2.prototype.storeDataSource = function() {
      for (var i = 0; i < this.series.length; i++) {
        var series = this.series[i];
        this.tempSeriesType.push(series.type);
        series.localData = void 0;
      }
      if (this.series.length === 0) {
        this.series.push({});
      }
      this.initialRender = !this.legendClicked;
      this.rangeFound = false;
      this.resizeTo = null;
      this.startValue = null;
      this.endValue = null;
    };
    StockChart2.prototype.render = function() {
      var _this = this;
      var loadEventData = {
        name: "load",
        stockChart: this,
        theme: this.theme
      };
      this.trigger("load", loadEventData, function() {
        _this.themeStyle = getThemeColor(_this.theme, false, _this);
        _this.storeDataSource();
        _this.drawSVG();
        _this.renderTitle();
        _this.renderLegend();
        _this.chartModuleInjection();
        _this.chartRender();
        if (!(_this.dataSource instanceof DataManager) || !(_this.series[0].dataSource instanceof DataManager)) {
          _this.stockChartDataManagerSuccess();
          _this.initialRender = false;
        }
        _this.renderComplete();
        _this.allowServerDataBinding = true;
        _this.isStockChartRendered = true;
      });
      this.isProtectedOnChange = false;
    };
    StockChart2.prototype.stockChartDataManagerSuccess = function() {
      this.findRange();
      this.renderRangeSelector();
      this.renderPeriodSelector();
      this.trigger("loaded", {
        stockChart: this
      });
    };
    StockChart2.prototype.setStyle = function(element) {
      var zooming = this.zoomSettings;
      var disableScroll = zooming.enableSelectionZooming || zooming.enablePinchZooming || this.selectionMode !== "None" || this.crosshair.enable;
      element.style.msTouchAction = disableScroll ? "none" : "element";
      element.style.touchAction = disableScroll ? "none" : "element";
      element.style.msUserSelect = "none";
      element.style.msContentZooming = "none";
      element.style.position = "relative";
      element.style.display = "block";
      element.style.webkitUserSelect = "none";
    };
    StockChart2.prototype.drawSVG = function() {
      this.removeSvg();
      calculateSize(this);
      this.renderer = new SvgRenderer(this.element.id);
      this.renderBorder();
      this.createSecondaryElements();
      this.calculateVisibleSeries();
      this.calculateLegendBounds();
      this.mainObject = this.renderer.createSvg({
        id: this.element.id + "_stockChart_svg",
        width: this.availableSize.width,
        height: this.availableSize.height - (this.enablePeriodSelector ? this.toolbarHeight : 0) - this.titleSize.height,
        style: "display: block;"
      });
      this.svgObject = this.mainObject;
      this.element.appendChild(this.mainObject);
    };
    StockChart2.prototype.calculateVisibleSeries = function() {
      this.visibleSeries = [];
      var series;
      var color = getSeriesColor(this.theme);
      var count = color.length;
      var seriesCollections = this.series.sort(function(a, b) {
        return a.zOrder - b.zOrder;
      });
      for (var i = 0, len = seriesCollections.length; i < len; i++) {
        series = seriesCollections[i];
        series.category = "Series";
        series.index = i;
        series.interior = series.fill || color[i % count];
        this.visibleSeries.push(series);
        seriesCollections[i] = series;
      }
    };
    StockChart2.prototype.createSecondaryElements = function() {
      var tooltipDiv = redrawElement(false, this.element.id + "_Secondary_Element") || this.createElement("div");
      tooltipDiv.id = this.element.id + "_Secondary_Element";
      if (this.title) {
        this.titleSize = measureText(this.title, this.titleStyle, this.themeStyle.chartTitleFont);
        this.titleSize.height += 15;
      } else {
        this.titleSize = {
          height: null,
          width: null
        };
      }
      var height = (this.enablePeriodSelector ? this.toolbarHeight : 0) + this.titleSize.height;
      tooltipDiv.style.cssText = "position: relative; height:" + height + "px";
      appendChildElement(false, this.element, tooltipDiv, false);
    };
    StockChart2.prototype.requiredModules = function() {
      var modules = [];
      if (this.legendSettings.visible) {
        modules.push({
          member: "StockLegend",
          args: [this]
        });
      }
      return modules;
    };
    StockChart2.prototype.findCurrentData = function(totalData, xName) {
      var tempData = !this.enablePeriodSelector && !this.enableSelector ? totalData : void 0;
      var start = this.isDateTimeCategory ? new Date(this.sortedData[Math.floor(this.startValue)]).getTime() : this.startValue;
      var end = this.isDateTimeCategory ? new Date(this.sortedData[Math.floor(this.endValue)]).getTime() : this.endValue;
      if (totalData && start && end) {
        tempData = totalData.filter(function(data) {
          return new Date(Date.parse(data[xName])).getTime() >= start && new Date(Date.parse(data[xName])).getTime() <= end;
        });
      }
      return tempData;
    };
    StockChart2.prototype.renderPeriodSelector = function() {
      if (this.enablePeriodSelector) {
        this.toolbarSelector.initializePeriodSelector();
        this.periodSelector.toolbar.refreshOverflow();
        if (!this.enableSelector) {
          this.cartesianChart.cartesianChartRefresh(this);
        }
      }
    };
    StockChart2.prototype.chartRender = function() {
      this.sortedData = [];
      this.cartesianChart = new CartesianChart(this);
      this.cartesianChart.initializeChart();
    };
    StockChart2.prototype.renderRangeSelector = function() {
      if (this.enableSelector) {
        this.rangeSelector = new RangeSelector(this);
        this.rangeSelector.initializeRangeNavigator();
      }
    };
    StockChart2.prototype.getModuleName = function() {
      return "stockChart";
    };
    StockChart2.prototype.getPersistData = function() {
      return "";
    };
    StockChart2.prototype.removeSvg = function() {
      if (document.getElementById(this.element.id + "_Secondary_Element")) {
        remove(document.getElementById(this.element.id + "_Secondary_Element"));
      }
      var removeLength = 0;
      if (this.mainObject) {
        while (this.mainObject.childNodes.length > removeLength) {
          this.mainObject.removeChild(this.mainObject.firstChild);
        }
        if (!this.mainObject.hasChildNodes() && this.mainObject.parentNode) {
          remove(this.mainObject);
          this.mainObject = null;
          this.selectorObject = null;
          this.chartObject = null;
        }
      }
    };
    StockChart2.prototype.chartModuleInjection = function() {
      var moduleName;
      for (var _i = 0, _a = this.getInjectedModules(); _i < _a.length; _i++) {
        var modules = _a[_i];
        moduleName = modules.prototype.getModuleName().toLowerCase();
        if (moduleName.indexOf("rangetooltip") === -1) {
          Chart.Inject(modules);
        } else {
          RangeNavigator.Inject(modules);
        }
        if (moduleName === "datetime" || moduleName === "areaseries" || moduleName === "steplineseries" || moduleName === "datetimecategory") {
          RangeNavigator.Inject(modules);
        }
      }
    };
    StockChart2.prototype.findRange = function() {
      var _this = this;
      this.seriesXMin = Infinity;
      this.seriesXMax = -Infinity;
      for (var _i = 0, _a = this.chart.series; _i < _a.length; _i++) {
        var value = _a[_i];
        if (value.visible) {
          this.seriesXMin = Math.min(this.seriesXMin, value.xMin);
          this.seriesXMax = Math.max(this.seriesXMax, value.xMax);
        }
      }
      this.endValue = this.currentEnd = this.seriesXMax;
      if (this.enablePeriodSelector) {
        this.toolbarSelector = new ToolBarSelector(this);
        this.periodSelector = new PeriodSelector(this);
        this.tempPeriods = this.periods.length ? this.periods : this.toolbarSelector.calculateAutoPeriods();
        this.tempPeriods.map(function(period) {
          if (period.selected && period.text.toLowerCase() === "ytd") {
            if (_this.isDateTimeCategory) {
              var currentYear = new Date(_this.sortedData[_this.currentEnd]).getFullYear();
              var index = _this.currentEnd - 1;
              for (; index >= 0; index--) {
                if (new Date(_this.sortedData[index]).getFullYear() !== currentYear) {
                  _this.startValue = index + 1;
                  break;
                }
              }
              _this.startValue = index === -1 ? 0 : _this.startValue;
            } else {
              _this.startValue = new Date(new Date(_this.currentEnd).getFullYear().toString()).getTime();
            }
          } else if (period.selected && period.text.toLowerCase() === "all") {
            _this.startValue = _this.seriesXMin;
          } else if (period.selected) {
            _this.startValue = _this.periodSelector.changedRange(period.intervalType, _this.endValue, period.interval).getTime();
            _this.startValue = _this.isDateTimeCategory ? _this.periodSelector.findStartValue(_this.startValue, _this.endValue) : _this.startValue;
          }
        });
      } else {
        this.startValue = this.seriesXMin;
      }
      this.rangeFound = true;
    };
    StockChart2.prototype.stockChartResize = function() {
      var _this = this;
      if (!document.getElementById(this.element.id)) {
        return false;
      }
      this.animateSeries = false;
      if (this.resizeTo) {
        clearTimeout(this.resizeTo);
      }
      this.resizeTo = +setTimeout(function() {
        if (_this.cartesianChart) {
          calculateSize(_this);
          _this.renderBorder();
          _this.calculateLegendBounds();
          _this.renderTitle();
          _this.renderLegend();
          _this.cartesianChart.cartesianChartRefresh(_this);
          _this.mainObject.setAttribute("width", (_this.availableSize.width + (_this.stockLegendModule && (_this.legendSettings.position === "Right" || _this.legendSettings.position === "Left") ? _this.stockLegendModule.legendBounds.width : 0)).toString());
          if (_this.enablePeriodSelector) {
            _this.renderPeriodSelector();
          }
        }
      }, 500);
      return false;
    };
    StockChart2.prototype.stockChartOnMouseDown = function(e) {
      var pageX;
      var pageY;
      var target;
      var touchArg;
      var rect = this.chart.element.getBoundingClientRect();
      var element = e.target;
      this.trigger("stockChartMouseDown", {
        target: element.id,
        x: this.mouseX,
        y: this.mouseY
      });
      if (e.type === "touchstart") {
        this.isTouch = true;
        touchArg = e;
        pageX = touchArg.changedTouches[0].clientX;
        target = touchArg.target;
        pageY = touchArg.changedTouches[0].clientY;
      } else {
        this.isTouch = e.pointerType === "touch";
        pageX = e.clientX;
        pageY = e.clientY;
        target = e.target;
      }
      if (target.id.indexOf(this.element.id + "_stockChart_chart") > -1) {
        var svgRect = getElement2(this.element.id + "_stockChart_chart").getBoundingClientRect();
        this.mouseDownY = this.previousMouseMoveY = pageY - rect.top - Math.max(svgRect.top - rect.top, 0);
        this.mouseDownX = this.previousMouseMoveX = pageX - rect.left - Math.max(svgRect.left - rect.left, 0);
        this.setMouseXY(pageX, pageY);
        this.referenceXAxis = this.chart.primaryXAxis;
        getElement2(this.element.id + "_stockChart_chart").setAttribute("cursor", "pointer");
        if (this.isDateTimeCategory) {
          this.visibleRange.min = this.sortedData.indexOf(parseInt(this.referenceXAxis.labels[this.referenceXAxis.visibleRange.min], 10));
          this.visibleRange.max = this.sortedData.indexOf(parseInt(this.referenceXAxis.labels[this.referenceXAxis.visibleRange.max], 10));
          this.visibleRange.delta = this.referenceXAxis.visibleRange.delta;
          this.visibleRange.interval = this.referenceXAxis.visibleRange.interval;
        } else {
          this.visibleRange = this.referenceXAxis.visibleRange;
        }
        this.mouseDownXPoint = getRangeValueXByPoint(this.mouseX - this.referenceXAxis.rect.x, this.referenceXAxis.rect.width, this.visibleRange, this.referenceXAxis.isInversed);
        this.allowPan = true;
        this.notify(Browser.touchStartEvent, e);
      }
      return false;
    };
    StockChart2.prototype.stockChartMouseEnd = function(e) {
      var pageY;
      var pageX;
      var touchArg;
      if (e.type === "touchend") {
        touchArg = e;
        pageX = touchArg.changedTouches[0].clientX;
        pageY = touchArg.changedTouches[0].clientY;
        this.isTouch = true;
      } else {
        pageY = e.clientY;
        pageX = e.clientX;
        this.isTouch = e.pointerType === "touch" || e.pointerType === "2";
      }
      getElement2(this.element.id + "_stockChart_chart").setAttribute("cursor", "auto");
      this.onPanning = false;
      this.setMouseXY(pageX, pageY);
      this.stockChartOnMouseUp(e);
      return false;
    };
    StockChart2.prototype.stockChartOnMouseUp = function(e) {
      var element = e.target;
      this.trigger("stockChartMouseUp", {
        target: element.id,
        x: this.mouseX,
        y: this.mouseY
      });
      this.isChartDrag = false;
      this.allowPan = false;
      if (this.rangeNavigator) {
        this.rangeNavigator.rangeSlider.isDrag = false;
      }
      if (this.isTouch) {
        this.threshold = (/* @__PURE__ */ new Date()).getTime() + 300;
      }
      this.notify(Browser.touchEndEvent, e);
      if (this.stockEvent) {
        this.stockEvent.removeStockEventTooltip(0);
      }
      return false;
    };
    StockChart2.prototype.setMouseXY = function(pageX, pageY) {
      var svgRectElement = getElement2(this.element.id + "_stockChart_chart");
      if (this.element && svgRectElement) {
        var stockRect = this.element.getBoundingClientRect();
        var svgRect = svgRectElement.getBoundingClientRect();
        this.mouseX = pageX - stockRect.left - Math.max(svgRect.left - stockRect.left, 0);
        this.mouseY = pageY - stockRect.top - Math.max(svgRect.top - stockRect.top, 0);
      }
    };
    StockChart2.prototype.stockChartOnMouseMove = function(e) {
      var pageX;
      var touchArg;
      var pageY;
      this.mouseMoveEvent = e;
      if (e.type === "touchmove") {
        this.isTouch = true;
        touchArg = e;
        pageY = touchArg.changedTouches[0].clientY;
        pageX = touchArg.changedTouches[0].clientX;
      } else {
        this.isTouch = e.pointerType === "touch" || e.pointerType === "2" || this.isTouch;
        pageX = e.clientX;
        pageY = e.clientY;
      }
      this.trigger("stockChartMouseMove", {
        target: e.target.id,
        x: this.mouseX,
        y: this.mouseY
      });
      if (getElement2(this.element.id + "_stockChart_chart")) {
        this.setMouseXY(pageX, pageY);
        this.chartOnMouseMove(e);
      }
      return false;
    };
    StockChart2.prototype.chartOnMouseMove = function(e) {
      if (this.rangeNavigator && this.rangeNavigator.rangeSlider.isDrag) {
        this.rangeNavigator.mouseX = this.mouseX;
        this.rangeNavigator.rangeSlider.mouseMoveHandler(e);
      }
      if (this.allowPan && !this.chart.startMove && this.mouseDownXPoint && this.mouseX !== this.previousMouseMoveX && this.zoomSettings.enablePan) {
        this.onPanning = true;
        this.zoomChange = false;
        getElement2(this.element.id + "_stockChart_chart").setAttribute("cursor", "pointer");
        this.mouseUpXPoint = getRangeValueXByPoint(this.mouseX - this.referenceXAxis.rect.x, this.referenceXAxis.rect.width, this.visibleRange, this.referenceXAxis.isInversed);
        var diff = Math.abs(this.mouseUpXPoint - this.mouseDownXPoint);
        if (this.mouseDownXPoint < this.mouseUpXPoint) {
          if (this.seriesXMin <= this.visibleRange.min - diff) {
            this.startValue = this.visibleRange.min - diff;
            this.endValue = this.visibleRange.max - diff;
            if (this.enableSelector) {
              this.rangeNavigator.rangeSlider.setSlider(this.visibleRange.min - diff, this.visibleRange.max - diff, !this.rangeNavigator.enableDeferredUpdate, this.rangeNavigator.rangeTooltipModule && this.rangeNavigator.tooltip.enable);
            } else {
              this.cartesianChart.cartesianChartRefresh(this);
            }
          }
        } else {
          if (this.seriesXMax >= this.visibleRange.max + diff) {
            this.startValue = this.visibleRange.min + diff;
            this.endValue = this.visibleRange.max + diff;
            if (this.enableSelector) {
              this.rangeNavigator.rangeSlider.setSlider(this.visibleRange.min + diff, this.visibleRange.max + diff, !this.rangeNavigator.enableDeferredUpdate, this.rangeNavigator.rangeTooltipModule && this.rangeNavigator.tooltip.enable);
            } else {
              this.cartesianChart.cartesianChartRefresh(this);
            }
          }
        }
      }
      this.notify(Browser.touchMoveEvent, e);
      if (e.target.id === "" && !this.onPanning === true) {
        var element = void 0;
        if (this.chart.tooltip.enable || this.crosshair.enable) {
          element = document.getElementById(this.element.id + "_stockChart_chart_tooltip");
          if (element) {
            remove(element);
          }
        }
        if (getElement2(this.element.id + "_StockEvents_Tooltip")) {
          this.stockEvent.removeStockEventTooltip(0);
        }
      }
      if (e.target.id.indexOf("StockEvents") !== -1) {
        clearInterval(this.stockEvent.toolTipInterval);
        this.stockEvent.renderStockEventTooltip(e.target.id);
      } else {
        if (this.stockEvent) {
          this.stockEvent.removeStockEventTooltip(1e3);
        }
      }
      this.isTouch = false;
      return false;
    };
    StockChart2.prototype.stockChartOnMouseClick = function(e) {
      var element = e.target;
      this.trigger("stockChartMouseClick", {
        target: element.id,
        x: this.mouseX,
        y: this.mouseY
      });
      this.notify("click", e);
      return false;
    };
    StockChart2.prototype.stockChartRightClick = function(event2) {
      if (this.crosshair.enable && (event2.buttons === 2 || event2.which === 0 || event2.pointerType === "touch")) {
        event2.preventDefault();
        event2.stopPropagation();
        return false;
      }
      return true;
    };
    StockChart2.prototype.stockChartOnMouseLeave = function(e) {
      var touchArg;
      var pageX;
      var pageY;
      if (e.type === "touchleave") {
        this.isTouch = true;
        touchArg = e;
        pageX = touchArg.changedTouches[0].clientX;
        pageY = touchArg.changedTouches[0].clientY;
      } else {
        pageX = e.clientX;
        pageY = e.clientY;
        this.isTouch = e.pointerType === "touch" || e.pointerType === "2";
      }
      this.setMouseXY(pageX, pageY);
      this.allowPan = false;
      this.stockChartOnMouseLeaveEvent(e);
      return false;
    };
    StockChart2.prototype.stockChartOnMouseLeaveEvent = function(e) {
      var cancelEvent = Browser.isPointer ? "pointerleave" : "mouseleave";
      this.isChartDrag = false;
      this.notify(cancelEvent, e);
      if (this.stockEvent) {
        this.stockEvent.removeStockEventTooltip(1e3);
      }
      if (this.rangeNavigator) {
        this.rangeNavigator.rangeSlider.isDrag = false;
      }
      if (this.onPanning) {
        this.onPanning = false;
        this.chart.mouseLeave(e);
        getElement2(this.element.id + "_stockChart_chart").setAttribute("cursor", "auto");
      }
      return false;
    };
    StockChart2.prototype.destroy = function() {
      this.cartesianChart = null;
      this.chart = null;
      this.periodSelector = null;
      this.rangeNavigator = null;
      this.rangeSelector = null;
      this.tempPeriods = [];
      this.toolbarSelector = null;
      this.visibleSeries = [];
      this.yAxisElements = null;
      var element = document.getElementById(this.element.id + "_stockChart_chartKeyboard_chart_focus");
      if (element) {
        element.remove();
      }
      var borderElement = document.getElementById(this.element.id + "_stock_border");
      if (borderElement) {
        borderElement.remove();
      }
      if (this.element) {
        this.unWireEvents();
        _super.prototype.destroy.call(this);
        this.removeSvg();
        this.svgObject = null;
      }
    };
    StockChart2.prototype.renderBorder = function() {
      if (this.border.width) {
        var border = this.createElement("div");
        border.id = this.element.id + "_stock_border";
        border.style.width = this.availableSize.width + "px";
        border.style.height = this.availableSize.height + "px";
        border.style.position = "absolute";
        border.style.border = this.border.width + "px solid " + this.border.color;
        border.style.pointerEvents = "none";
        appendChildElement(false, getElement2(this.element.id), border);
      }
    };
    StockChart2.prototype.renderTitle = function() {
      var rect;
      if (this.title) {
        appendChildElement(false, getElement2(this.element.id + "_Secondary_Element"), this.renderer.createSvg({
          id: this.element.id + "_stockChart_Title",
          width: this.availableSize.width,
          height: this.titleSize.height,
          fill: this.background || this.themeStyle.background
        }), false);
        var alignment = this.titleStyle.textAlignment;
        var getAnchor = alignment === "Near" ? "start" : alignment === "Far" ? "end" : "middle";
        rect = new Rect(0, 0, this.availableSize.width, 0);
        var options = new TextOption(this.element.id + "_ChartTitle", titlePositionX(rect, this.titleStyle), this.titleSize.height - 10, getAnchor, this.title, "", "auto");
        textElement2(this.renderer, options, this.titleStyle, this.titleStyle.color || this.themeStyle.chartTitleFont.color || this.findTitleColor(), getElement2(this.element.id + "_stockChart_Title"), false, false, null, null, null, null, null, null, null, null, this.themeStyle.chartTitleFont);
        this.availableSize.height -= this.titleSize.height + 5;
      }
    };
    StockChart2.prototype.calculateLegendBounds = function() {
      if (this.stockLegendModule && this.legendSettings.visible) {
        this.stockLegendModule.getLegendOptions(this.visibleSeries);
      }
      var titleHeight = this.titleSize.height;
      var left = this.border.width;
      var width = this.availableSize.width - this.border.width - left;
      var top = this.chartArea.border.width * 0.5 + this.border.width;
      var height = this.availableSize.height - top - this.border.width - (this.enablePeriodSelector ? this.toolbarHeight : 0) - titleHeight;
      this.initialClipRect = new Rect(left, top, width, height);
      this.tempAvailableSize = new Size(this.availableSize.width, this.availableSize.height - (this.enablePeriodSelector ? this.toolbarHeight : 0) - titleHeight);
      if (this.stockLegendModule && this.legendSettings.visible) {
        this.stockLegendModule.calculateLegendBounds(this.initialClipRect, this.tempAvailableSize, null);
      }
    };
    StockChart2.prototype.renderLegend = function() {
      if (this.stockLegendModule && this.stockLegendModule.legendCollections.length && this.legendSettings.visible) {
        this.stockLegendModule.calTotalPage = true;
        var bounds = this.stockLegendModule.legendBounds;
        this.stockLegendModule.renderLegend(this, this.legendSettings, bounds);
        if (this.legendSettings.position === "Auto" || this.legendSettings.position === "Bottom" || this.legendSettings.position === "Top") {
          this.availableSize.height -= this.stockLegendModule.legendBounds.height;
        } else if (this.legendSettings.position === "Left" || this.legendSettings.position === "Right") {
          this.availableSize.width -= this.stockLegendModule.legendBounds.width;
        }
      }
    };
    StockChart2.prototype.findTitleColor = function() {
      if (this.theme.toLocaleLowerCase().indexOf("highcontrast") > -1 || this.theme.indexOf("Dark") > -1) {
        return "#ffffff";
      }
      return "#424242";
    };
    StockChart2.prototype.calculateStockEvents = function() {
      if (this.stockEvents.length) {
        this.stockEvent = new StockEvents(this);
        appendChildElement(false, this.chartObject, this.stockEvent.renderStockEvents());
      }
    };
    var StockChart_1;
    __decorate14([Property(null)], StockChart2.prototype, "width", void 0);
    __decorate14([Property(null)], StockChart2.prototype, "height", void 0);
    __decorate14([Property("")], StockChart2.prototype, "dataSource", void 0);
    __decorate14([Complex({}, StockMargin)], StockChart2.prototype, "margin", void 0);
    __decorate14([Complex({
      color: "#DDDDDD",
      width: 1
    }, StockChartBorder)], StockChart2.prototype, "border", void 0);
    __decorate14([Property(null)], StockChart2.prototype, "background", void 0);
    __decorate14([Property("Material")], StockChart2.prototype, "theme", void 0);
    __decorate14([Complex({
      name: "primaryXAxis",
      valueType: "DateTime"
    }, StockChartAxis)], StockChart2.prototype, "primaryXAxis", void 0);
    __decorate14([Complex({
      border: {
        color: null,
        width: 0.5
      },
      background: "transparent"
    }, StockChartArea)], StockChart2.prototype, "chartArea", void 0);
    __decorate14([Complex({
      name: "primaryYAxis",
      opposedPosition: true,
      labelPosition: "Inside",
      tickPosition: "Inside"
    }, StockChartAxis)], StockChart2.prototype, "primaryYAxis", void 0);
    __decorate14([Collection([{}], StockChartRow)], StockChart2.prototype, "rows", void 0);
    __decorate14([Collection([{
      opposedPosition: true
    }], StockChartAxis)], StockChart2.prototype, "axes", void 0);
    __decorate14([Collection([], StockSeries)], StockChart2.prototype, "series", void 0);
    __decorate14([Collection([], StockEventsSettings)], StockChart2.prototype, "stockEvents", void 0);
    __decorate14([Property(false)], StockChart2.prototype, "isTransposed", void 0);
    __decorate14([Property("")], StockChart2.prototype, "title", void 0);
    __decorate14([Complex({
      size: null,
      fontWeight: null,
      color: null,
      fontStyle: null,
      fontFamily: null
    }, StockChartFont)], StockChart2.prototype, "titleStyle", void 0);
    __decorate14([Collection([], StockChartIndicator)], StockChart2.prototype, "indicators", void 0);
    __decorate14([Complex({
      shared: true,
      enableMarker: false
    }, StockTooltipSettings)], StockChart2.prototype, "tooltip", void 0);
    __decorate14([Complex({
      dashArray: "5",
      lineType: "Vertical"
    }, CrosshairSettings)], StockChart2.prototype, "crosshair", void 0);
    __decorate14([Complex({}, StockChartLegendSettings)], StockChart2.prototype, "legendSettings", void 0);
    __decorate14([Complex({
      enablePan: true
    }, ZoomSettings)], StockChart2.prototype, "zoomSettings", void 0);
    __decorate14([Property(true)], StockChart2.prototype, "enablePeriodSelector", void 0);
    __decorate14([Property(true)], StockChart2.prototype, "enableCustomRange", void 0);
    __decorate14([Property(false)], StockChart2.prototype, "isSelect", void 0);
    __decorate14([Property(true)], StockChart2.prototype, "enableSelector", void 0);
    __decorate14([Collection([], Periods)], StockChart2.prototype, "periods", void 0);
    __decorate14([Collection([{}], StockChartAnnotationSettings)], StockChart2.prototype, "annotations", void 0);
    __decorate14([Event()], StockChart2.prototype, "selectorRender", void 0);
    __decorate14([Event()], StockChart2.prototype, "stockChartMouseMove", void 0);
    __decorate14([Event()], StockChart2.prototype, "stockChartMouseLeave", void 0);
    __decorate14([Event()], StockChart2.prototype, "stockChartMouseDown", void 0);
    __decorate14([Event()], StockChart2.prototype, "stockChartMouseUp", void 0);
    __decorate14([Event()], StockChart2.prototype, "stockChartMouseClick", void 0);
    __decorate14([Event()], StockChart2.prototype, "pointClick", void 0);
    __decorate14([Event()], StockChart2.prototype, "pointMove", void 0);
    __decorate14([Event()], StockChart2.prototype, "onZooming", void 0);
    __decorate14([Event()], StockChart2.prototype, "legendRender", void 0);
    __decorate14([Event()], StockChart2.prototype, "legendClick", void 0);
    __decorate14([Property("None")], StockChart2.prototype, "selectionMode", void 0);
    __decorate14([Property(false)], StockChart2.prototype, "isMultiSelect", void 0);
    __decorate14([Event()], StockChart2.prototype, "load", void 0);
    __decorate14([Event()], StockChart2.prototype, "loaded", void 0);
    __decorate14([Event()], StockChart2.prototype, "rangeChange", void 0);
    __decorate14([Event()], StockChart2.prototype, "axisLabelRender", void 0);
    __decorate14([Event()], StockChart2.prototype, "beforeExport", void 0);
    __decorate14([Event()], StockChart2.prototype, "tooltipRender", void 0);
    __decorate14([Event()], StockChart2.prototype, "seriesRender", void 0);
    __decorate14([Event()], StockChart2.prototype, "stockEventRender", void 0);
    __decorate14([Collection([], StockChartIndexes)], StockChart2.prototype, "selectedDataIndexes", void 0);
    __decorate14([Property([])], StockChart2.prototype, "seriesType", void 0);
    __decorate14([Property(["EMA", "TMA", "SMA", "Momentum", "ATR", "Accumulation Distribution", "Bollinger Bands", "MACD", "Stochastic", "RSI"])], StockChart2.prototype, "indicatorType", void 0);
    __decorate14([Property(["PNG", "JPEG", "SVG", "PDF", "XLSX", "CSV", "Print"])], StockChart2.prototype, "exportType", void 0);
    __decorate14([Property([])], StockChart2.prototype, "trendlineType", void 0);
    StockChart2 = StockChart_1 = __decorate14([NotifyPropertyChanges], StockChart2);
    return StockChart2;
  }(Component)
);

// node_modules/@syncfusion/ej2-charts/src/range-navigator/user-interaction/tooltip.js
var RangeTooltip = (
  /** @class */
  function() {
    function RangeTooltip2(range) {
      this.control = range;
      this.elementId = range.element.id;
    }
    RangeTooltip2.prototype.renderLeftTooltip = function(rangeSlider) {
      this.fadeOutTooltip();
      var content = this.getTooltipContent(rangeSlider.currentStart);
      var contentWidth = this.getContentSize(content);
      var rect = this.control.enableRtl ? rangeSlider.rightRect : rangeSlider.leftRect;
      if (contentWidth > rect.width) {
        rect = rangeSlider.midRect;
      }
      this.leftTooltip = this.renderTooltip(rect, this.createElement("_leftTooltip"), rangeSlider.startX, content);
    };
    RangeTooltip2.prototype.getContentSize = function(value) {
      var width;
      var font = this.control.tooltip.textStyle;
      if (this.control.tooltip.template) {
        width = createTemplate(createElement("div", {
          id: "measureElement",
          styles: "position: absolute;"
        }), 0, this.control.tooltip.template, this.control).getBoundingClientRect().width;
      } else {
        width = measureText(value[0], font, this.control.themeStyle.tooltipLabelFont).width + 20;
      }
      return width;
    };
    RangeTooltip2.prototype.renderRightTooltip = function(rangeSlider) {
      this.fadeOutTooltip();
      var content = this.getTooltipContent(rangeSlider.currentEnd);
      var contentWidth = this.getContentSize(content);
      var rect = this.control.enableRtl ? rangeSlider.leftRect : rangeSlider.rightRect;
      if (contentWidth > rect.width) {
        rect = rangeSlider.midRect;
        rect.x = !this.control.series.length ? rect.x : 0;
      }
      this.rightTooltip = this.renderTooltip(rect, this.createElement("_rightTooltip"), rangeSlider.endX, content);
    };
    RangeTooltip2.prototype.createElement = function(id) {
      if (getElement2(this.elementId + id)) {
        return getElement2(this.elementId + id);
      } else {
        var element = document.createElement("div");
        element.id = this.elementId + id;
        element.className = "ejSVGTooltip";
        element.style.cssText = "pointer-events:none; position:absolute;z-index: 1";
        if (!this.control.stockChart) {
          getElement2(this.elementId + "_Secondary_Element").appendChild(element);
        } else {
          var stockChart = this.control.stockChart;
          getElement2(stockChart.element.id + "_Secondary_Element").appendChild(element);
          element.style.transform = "translateY(" + (stockChart.availableSize.height - stockChart.toolbarHeight - 51 + stockChart.toolbarHeight + stockChart.titleSize.height) + "px)";
        }
        return element;
      }
    };
    RangeTooltip2.prototype.renderTooltip = function(bounds, parent, pointX, content) {
      var control = this.control;
      var tooltip = control.tooltip;
      var argsData = {
        cancel: false,
        name: "tooltipRender",
        text: content,
        textStyle: tooltip.textStyle
      };
      argsData.textStyle.fontWeight = tooltip.textStyle.fontWeight || this.control.themeStyle.tooltipLabelFont.fontWeight;
      this.control.trigger("tooltipRender", argsData);
      var left = control.svgObject.getBoundingClientRect().left - control.element.getBoundingClientRect().left;
      if (!argsData.cancel) {
        return new Tooltip({
          location: {
            x: pointX,
            y: control.rangeSlider.sliderY
          },
          content: argsData.text,
          marginX: 2,
          enableShadow: false,
          marginY: 2,
          arrowPadding: 8,
          rx: 4,
          ry: 4,
          inverted: control.series.length > 0,
          areaBounds: bounds,
          fill: tooltip.fill ? tooltip.fill : this.control.themeStyle.tooltipBackground,
          theme: this.control.theme,
          clipBounds: {
            x: left
          },
          border: tooltip.border,
          opacity: tooltip.opacity ? tooltip.opacity : this.control.theme === "Material3" || this.control.theme === "Material3Dark" || this.control.theme.indexOf("Bootstrap5") > -1 ? 1 : 0.75,
          template: tooltip.template,
          textStyle: argsData.textStyle,
          availableSize: control.availableSize,
          controlName: "RangeNavigator",
          data: {
            "start": this.getTooltipContent(this.control.startValue)[0],
            "end": this.getTooltipContent(this.control.endValue)[0],
            "value": content[0]
          }
        }, parent);
      } else {
        return null;
      }
    };
    RangeTooltip2.prototype.getTooltipContent = function(value) {
      var control = this.control;
      var tooltip = control.tooltip;
      var xAxis = control.chartSeries.xAxis;
      var text;
      var format = tooltip.format || xAxis.labelFormat;
      var isCustom = format.match("{value}") !== null;
      var valueType = xAxis.valueType;
      value = valueType === "DateTimeCategory" ? parseInt(xAxis.labels[Math.floor(value)], 10) : value;
      if (valueType.indexOf("DateTime") > -1) {
        text = control.intl.getDateFormat({
          format: format || "MM/dd/yyyy",
          type: firstToLowerCase(control.skeletonType),
          skeleton: valueType === "DateTime" ? control.dateTimeModule.getSkeleton(xAxis, null, null) : control.dateTimeCategoryModule.getSkeleton(xAxis, null, null)
        })(new Date(value));
      } else {
        xAxis.format = control.intl.getNumberFormat({
          format: isCustom ? "" : format,
          useGrouping: control.useGroupingSeparator
        });
        text = control.doubleModule.formatValue(xAxis, isCustom, format, valueType === "Logarithmic" ? Math.pow(xAxis.logBase, value) : value);
      }
      return [text];
    };
    RangeTooltip2.prototype.fadeOutTooltip = function() {
      var _this = this;
      var tooltip = this.control.tooltip;
      if (tooltip.displayMode === "OnDemand") {
        stopTimer(this.toolTipInterval);
        if (this.rightTooltip) {
          this.toolTipInterval = +setTimeout(function() {
            _this.leftTooltip.fadeOut();
            _this.rightTooltip.fadeOut();
          }, 1e3);
        }
      }
    };
    RangeTooltip2.prototype.getModuleName = function() {
      return "RangeTooltip";
    };
    RangeTooltip2.prototype.destroy = function() {
    };
    return RangeTooltip2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/bullet-chart/model/bullet-base.js
var __extends85 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate15 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Range = (
  /** @class */
  function(_super) {
    __extends85(Range2, _super);
    function Range2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate15([Property(null)], Range2.prototype, "end", void 0);
    __decorate15([Property(1)], Range2.prototype, "opacity", void 0);
    __decorate15([Property(null)], Range2.prototype, "color", void 0);
    __decorate15([Property(null)], Range2.prototype, "index", void 0);
    __decorate15([Property(null)], Range2.prototype, "name", void 0);
    __decorate15([Property("Rectangle")], Range2.prototype, "shape", void 0);
    __decorate15([Property("")], Range2.prototype, "legendImageUrl", void 0);
    return Range2;
  }(ChildProperty)
);
var MajorTickLinesSettings = (
  /** @class */
  function(_super) {
    __extends85(MajorTickLinesSettings2, _super);
    function MajorTickLinesSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate15([Property(12)], MajorTickLinesSettings2.prototype, "height", void 0);
    __decorate15([Property(1)], MajorTickLinesSettings2.prototype, "width", void 0);
    __decorate15([Property(null)], MajorTickLinesSettings2.prototype, "color", void 0);
    __decorate15([Property(false)], MajorTickLinesSettings2.prototype, "useRangeColor", void 0);
    return MajorTickLinesSettings2;
  }(ChildProperty)
);
var MinorTickLinesSettings = (
  /** @class */
  function(_super) {
    __extends85(MinorTickLinesSettings2, _super);
    function MinorTickLinesSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate15([Property(8)], MinorTickLinesSettings2.prototype, "height", void 0);
    __decorate15([Property(1)], MinorTickLinesSettings2.prototype, "width", void 0);
    __decorate15([Property(null)], MinorTickLinesSettings2.prototype, "color", void 0);
    __decorate15([Property(false)], MinorTickLinesSettings2.prototype, "useRangeColor", void 0);
    return MinorTickLinesSettings2;
  }(ChildProperty)
);
var BulletLabelStyle = (
  /** @class */
  function(_super) {
    __extends85(BulletLabelStyle2, _super);
    function BulletLabelStyle2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate15([Property("Normal")], BulletLabelStyle2.prototype, "fontStyle", void 0);
    __decorate15([Property("16px")], BulletLabelStyle2.prototype, "size", void 0);
    __decorate15([Property("")], BulletLabelStyle2.prototype, "color", void 0);
    __decorate15([Property("Normal")], BulletLabelStyle2.prototype, "fontWeight", void 0);
    __decorate15([Property("Segoe UI")], BulletLabelStyle2.prototype, "fontFamily", void 0);
    __decorate15([Property("Center")], BulletLabelStyle2.prototype, "textAlignment", void 0);
    __decorate15([Property("None")], BulletLabelStyle2.prototype, "textOverflow", void 0);
    __decorate15([Property(1)], BulletLabelStyle2.prototype, "opacity", void 0);
    __decorate15([Property(true)], BulletLabelStyle2.prototype, "enableTrim", void 0);
    __decorate15([Property(null)], BulletLabelStyle2.prototype, "maximumTitleWidth", void 0);
    __decorate15([Property(false)], BulletLabelStyle2.prototype, "useRangeColor", void 0);
    return BulletLabelStyle2;
  }(ChildProperty)
);
var BulletTooltipSettings = (
  /** @class */
  function(_super) {
    __extends85(BulletTooltipSettings2, _super);
    function BulletTooltipSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate15([Property(false)], BulletTooltipSettings2.prototype, "enable", void 0);
    __decorate15([Property(null)], BulletTooltipSettings2.prototype, "fill", void 0);
    __decorate15([Complex({
      fontFamily: null,
      size: "12px",
      fontStyle: "Normal",
      fontWeight: "400",
      color: null
    }, BulletLabelStyle)], BulletTooltipSettings2.prototype, "textStyle", void 0);
    __decorate15([Complex({
      color: null,
      width: null
    }, Border)], BulletTooltipSettings2.prototype, "border", void 0);
    __decorate15([Property(null)], BulletTooltipSettings2.prototype, "template", void 0);
    return BulletTooltipSettings2;
  }(ChildProperty)
);
var BulletDataLabel = (
  /** @class */
  function(_super) {
    __extends85(BulletDataLabel2, _super);
    function BulletDataLabel2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate15([Property(false)], BulletDataLabel2.prototype, "enable", void 0);
    __decorate15([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, BulletLabelStyle)], BulletDataLabel2.prototype, "labelStyle", void 0);
    return BulletDataLabel2;
  }(ChildProperty)
);
var BulletChartLegendSettings = (
  /** @class */
  function(_super) {
    __extends85(BulletChartLegendSettings2, _super);
    function BulletChartLegendSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate15([Property(false)], BulletChartLegendSettings2.prototype, "visible", void 0);
    __decorate15([Complex({
      x: 0,
      y: 0
    }, Location)], BulletChartLegendSettings2.prototype, "location", void 0);
    __decorate15([Property(8)], BulletChartLegendSettings2.prototype, "padding", void 0);
    __decorate15([Property("Center")], BulletChartLegendSettings2.prototype, "alignment", void 0);
    __decorate15([Property(10)], BulletChartLegendSettings2.prototype, "shapeHeight", void 0);
    __decorate15([Property(10)], BulletChartLegendSettings2.prototype, "shapeWidth", void 0);
    __decorate15([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, BulletLabelStyle)], BulletChartLegendSettings2.prototype, "textStyle", void 0);
    __decorate15([Property("Auto")], BulletChartLegendSettings2.prototype, "position", void 0);
    __decorate15([Complex({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, Margin)], BulletChartLegendSettings2.prototype, "margin", void 0);
    __decorate15([Complex({}, Border)], BulletChartLegendSettings2.prototype, "border", void 0);
    __decorate15([Property(5)], BulletChartLegendSettings2.prototype, "shapePadding", void 0);
    __decorate15([Property("transparent")], BulletChartLegendSettings2.prototype, "background", void 0);
    __decorate15([Property(1)], BulletChartLegendSettings2.prototype, "opacity", void 0);
    __decorate15([Property(3)], BulletChartLegendSettings2.prototype, "tabIndex", void 0);
    return BulletChartLegendSettings2;
  }(ChildProperty)
);

// node_modules/@syncfusion/ej2-charts/src/bullet-chart/utils/theme.js
function getBulletThemeColor(theme) {
  var darkBackground = theme === "MaterialDark" ? "#383838" : theme === "FabricDark" ? "#242424" : "#1b1b1b";
  var style = {
    majorTickLineColor: "#424242",
    minorTickLineColor: "#424242",
    background: "#FFFFFF",
    labelFontColor: "rgba(0,0,0,0.54)",
    categoryFontColor: "#666666",
    labelFontFamily: "SegoeUI",
    tooltipFill: "#000816",
    legendLabel: "#353535",
    tooltipBoldLabel: "#ffffff",
    featuredMeasureColor: "#181818",
    comparativeMeasureColor: "#181818",
    titleFontColor: "rgba(0,0,0,0.87)",
    dataLabelFontColor: "#ffffff",
    titleFontFamily: "SegoeUI",
    subTitleFontColor: " rgba(0,0,0,0.54)",
    subTitleFontFamily: "SegoeUI",
    firstRangeColor: "#959595",
    secondRangeColor: "#BDBDBD",
    thirdRangeColor: "#E3E2E2",
    tabColor: theme === "Material" ? "#ff4081" : theme === "Fabric" ? "#0078D6" : "#317AB9",
    rangeStrokes: [{
      color: "#959595"
    }, {
      color: "#BDBDBD"
    }, {
      color: "#E3E2E2"
    }],
    titleFont: {
      color: "rgba(0, 0, 0, 1)",
      fontFamily: "Roboto",
      size: "14px",
      fontStyle: "Normal",
      fontWeight: "500"
    },
    subTitleFont: {
      color: "rgba(0, 0, 0, 1)",
      fontFamily: "Roboto",
      size: "12px",
      fontStyle: "Normal",
      fontWeight: "400"
    },
    legendLabelFont: {
      color: "rgba(97, 97, 97, 1)",
      fontFamily: "Roboto",
      size: "14px",
      fontStyle: "Normal",
      fontWeight: "400"
    },
    axisLabelFont: {
      color: "rgba(97, 97, 97, 1)",
      fontFamily: "Roboto",
      size: "12px",
      fontStyle: "Normal",
      fontWeight: "400"
    },
    dataLabelFont: {
      color: "rgba(97, 97, 97, 1)",
      fontFamily: "Roboto",
      size: "12px",
      fontStyle: "Normal",
      fontWeight: "400"
    },
    tooltipLabelFont: {
      color: "rgba(249, 250, 251, 1)",
      fontFamily: "Roboto",
      size: "12px",
      fontStyle: "Normal",
      fontWeight: "400"
    }
  };
  switch (theme) {
    case "Fabric":
      style = {
        majorTickLineColor: "#424242",
        minorTickLineColor: "#424242",
        background: "#FFFFFF",
        labelFontColor: "#666666",
        categoryFontColor: "#666666",
        labelFontFamily: "SegoeUI",
        tooltipFill: "#FFFFFF",
        legendLabel: "#353535",
        tooltipBoldLabel: "#ffffff",
        featuredMeasureColor: "#181818",
        comparativeMeasureColor: "#181818",
        titleFontColor: "#333333",
        dataLabelFontColor: "#ffffff",
        titleFontFamily: "SegoeUI",
        subTitleFontColor: "#666666",
        subTitleFontFamily: "SegoeUI",
        firstRangeColor: "#959595",
        secondRangeColor: "#BDBDBD",
        thirdRangeColor: "#E3E2E2",
        tabColor: "#0078D6",
        rangeStrokes: [{
          color: "#959595"
        }, {
          color: "#BDBDBD"
        }, {
          color: "#E3E2E2"
        }],
        titleFont: {
          color: "#333333",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        subTitleFont: {
          color: "#333333",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendLabelFont: {
          color: "#666666",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#666666",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        dataLabelFont: {
          color: "#666666",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#333333",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Bootstrap":
      style = {
        majorTickLineColor: "#424242",
        minorTickLineColor: "#424242",
        background: "#FFFFFF",
        labelFontColor: "rgba(0,0,0,0.54)",
        categoryFontColor: "rgba(0,0,0,0.54)",
        labelFontFamily: "Helvetica",
        tooltipFill: "#212529",
        legendLabel: "#212529",
        tooltipBoldLabel: "rgba(255,255,255)",
        featuredMeasureColor: "#181818",
        comparativeMeasureColor: "#181818",
        titleFontColor: "rgba(0,0,0,0.87)",
        dataLabelFontColor: "#ffffff",
        titleFontFamily: "Helvetica-Bold",
        subTitleFontColor: " rgba(0,0,0,0.54)",
        subTitleFontFamily: "Helvetica",
        firstRangeColor: "#959595",
        secondRangeColor: "#BDBDBD",
        thirdRangeColor: "#E3E2E2",
        tabColor: "#317AB9",
        rangeStrokes: [{
          color: "#959595"
        }, {
          color: "#BDBDBD"
        }, {
          color: "#E3E2E2"
        }],
        titleFont: {
          color: "#212529",
          fontFamily: "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        subTitleFont: {
          color: "#212529",
          fontFamily: "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendLabelFont: {
          color: "#666666",
          fontFamily: "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#676767",
          fontFamily: "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        dataLabelFont: {
          color: "#676767",
          fontFamily: "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#F9FAFB",
          fontFamily: "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "HighContrast":
      style = {
        majorTickLineColor: "#FFFFFF",
        minorTickLineColor: "#FFFFFF",
        background: "#000000",
        labelFontColor: "#FFFFFF",
        categoryFontColor: "#FFFFFF",
        labelFontFamily: "SegoeUI",
        tooltipFill: "#FFFFFF",
        legendLabel: "#ffffff",
        tooltipBoldLabel: "#000000",
        featuredMeasureColor: "#000000",
        comparativeMeasureColor: "#000000",
        titleFontColor: "#FFFFFF",
        dataLabelFontColor: "#ffffff",
        titleFontFamily: "HelveticaNeue",
        subTitleFontColor: "#FFFFFF",
        subTitleFontFamily: "SegoeUI",
        firstRangeColor: "#959595",
        secondRangeColor: "#BDBDBD",
        thirdRangeColor: "#E3E2E2",
        tabColor: "#FFD939",
        rangeStrokes: [{
          color: "#757575"
        }, {
          color: "#BDBDBD"
        }, {
          color: "#EEEEEE"
        }],
        titleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        subTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendLabelFont: {
          color: "#969696",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#969696",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        dataLabelFont: {
          color: "#969696",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#000000",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "MaterialDark":
    case "FabricDark":
    case "BootstrapDark":
      style = {
        majorTickLineColor: "#F0F0F0",
        minorTickLineColor: "#F0F0F0",
        background: darkBackground,
        labelFontColor: "#FFFFFF",
        categoryFontColor: "#FFFFFF",
        labelFontFamily: "Helvetica",
        tooltipFill: theme === "MaterialDark" ? "#F4F4F4" : theme === "FabricDark" ? "#A19F9D" : "#F0F0F0",
        legendLabel: "#DADADA",
        tooltipBoldLabel: "#282727",
        featuredMeasureColor: "#181818",
        comparativeMeasureColor: "#181818",
        titleFontColor: "#FFFFFF",
        dataLabelFontColor: "#ffffff",
        titleFontFamily: "Helvetica-Bold",
        subTitleFontColor: "#FFFFFF",
        subTitleFontFamily: "Helvetica",
        firstRangeColor: "#8D8D8D",
        secondRangeColor: "#ADADAD",
        thirdRangeColor: "#EEEEEE",
        tabColor: theme === "MaterialDark" ? "#00B0FF" : theme === "FabricDark" ? "#0074CC" : "#0070F0",
        rangeStrokes: [{
          color: "#8D8D8D"
        }, {
          color: "#ADADAD"
        }, {
          color: "#EEEEEE"
        }],
        titleFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.87)" : theme === "FabricDark" ? "#DADADA" : "#FFFFFF",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        subTitleFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.87)" : theme === "FabricDark" ? "#DADADA" : "#FFFFFF",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendLabelFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.6)" : theme === "FabricDark" ? "#A19F9D" : "#676767",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.6)" : theme === "FabricDark" ? "#A19F9D" : "#676767",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        dataLabelFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.6)" : theme === "FabricDark" ? "#A19F9D" : "#676767",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: theme === "MaterialDark" ? "rgba(18, 18, 18, 1)" : theme === "FabricDark" ? "#DADADA" : "#1A1A1A",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Bootstrap4":
      style = {
        majorTickLineColor: "#424242",
        minorTickLineColor: "#424242",
        background: "#FFFFFF",
        labelFontColor: "#202528",
        categoryFontColor: "#202528",
        labelFontFamily: "HelveticaNeue",
        tooltipFill: "#212529",
        legendLabel: "#212529",
        tooltipBoldLabel: "rgba(255,255,255)",
        featuredMeasureColor: "#181818",
        comparativeMeasureColor: "#181818",
        titleFontColor: "#202528",
        dataLabelFontColor: "#ffffff",
        titleFontFamily: "HelveticaNeue-Bold",
        subTitleFontColor: "HelveticaNeue",
        subTitleFontFamily: "#202528",
        firstRangeColor: "#959595",
        secondRangeColor: "#BDBDBD",
        thirdRangeColor: "#E3E2E2",
        tabColor: "#007BFF",
        rangeStrokes: [{
          color: "#959595"
        }, {
          color: "#BDBDBD"
        }, {
          color: "#E3E2E2"
        }],
        titleFont: {
          color: "#212529",
          fontFamily: "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        subTitleFont: {
          color: "#212529",
          fontFamily: "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendLabelFont: {
          color: "#666666",
          fontFamily: "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#495057",
          fontFamily: "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        dataLabelFont: {
          color: "#495057",
          fontFamily: "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#F9FAFB",
          fontFamily: "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Tailwind3":
      style = {
        majorTickLineColor: "#9CA3AF",
        minorTickLineColor: "#9CA3AF",
        background: "transparent",
        labelFontColor: "#4B5563",
        categoryFontColor: "#111827",
        labelFontFamily: "Inter",
        tooltipFill: "#111827",
        legendLabel: "#4B5563",
        tooltipBoldLabel: "#F9FAFB",
        featuredMeasureColor: "#1F2937",
        comparativeMeasureColor: "#1F2937",
        titleFontColor: "#111827",
        dataLabelFontColor: "#111827",
        titleFontFamily: "Inter",
        subTitleFontColor: "#6B7280",
        subTitleFontFamily: "Inter",
        firstRangeColor: "#9CA3AF",
        secondRangeColor: "#D1D5DB",
        thirdRangeColor: "#E5E7EB",
        tabColor: "#4F46E5",
        rangeStrokes: [{
          color: "#9CA3AF"
        }, {
          color: "#D1D5DB"
        }, {
          color: "#E5E7EB"
        }],
        titleFont: {
          color: "#111827",
          fontFamily: "Inter",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        subTitleFont: {
          color: "#6B7280",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        legendLabelFont: {
          color: "#4B5563",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        axisLabelFont: {
          color: "#4B5563",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        dataLabelFont: {
          color: "#111827",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#F9FAFB",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "500"
        }
      };
      break;
    case "Tailwind3Dark":
      style = {
        majorTickLineColor: "#4B5563",
        minorTickLineColor: "#4B5563",
        background: "transparent",
        labelFontColor: "#D1D5DB",
        categoryFontColor: "#FFFFFF",
        labelFontFamily: "Inter",
        tooltipFill: "#F9FAFB",
        legendLabel: "#D1D5DB",
        tooltipBoldLabel: "#1F2937",
        featuredMeasureColor: "#6B7280",
        comparativeMeasureColor: "#6B7280",
        titleFontColor: "#FFFFFF",
        dataLabelFontColor: "#FFFFFF",
        titleFontFamily: "Inter",
        subTitleFontColor: "#9CA3AF",
        subTitleFontFamily: "Inter",
        firstRangeColor: "#4B5563",
        secondRangeColor: "#374151",
        thirdRangeColor: "#282F3C",
        tabColor: "#22D3EE",
        rangeStrokes: [{
          color: "#4B5563"
        }, {
          color: "#374151"
        }, {
          color: "#282F3C"
        }],
        titleFont: {
          color: "#FFFFFF",
          fontFamily: "Inter",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        subTitleFont: {
          color: "#9CA3AF",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        legendLabelFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        axisLabelFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        dataLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#1F2937",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "500"
        }
      };
      break;
    case "Tailwind":
      style = {
        majorTickLineColor: "#D1D5DB",
        minorTickLineColor: "#D1D5DB",
        background: "transparent",
        labelFontColor: "#6B7280",
        categoryFontColor: "#6B7280",
        labelFontFamily: "Inter",
        tooltipFill: "#111827",
        legendLabel: "#374151",
        tooltipBoldLabel: "#F9FAFB",
        featuredMeasureColor: "#1F2937",
        comparativeMeasureColor: "#1F2937",
        titleFontColor: "#374151",
        dataLabelFontColor: "#F9FAFB",
        titleFontFamily: "Inter",
        subTitleFontColor: "#374151",
        subTitleFontFamily: "Inter",
        firstRangeColor: "#9CA3AF",
        secondRangeColor: "#D1D5DB",
        thirdRangeColor: "#E5E7EB",
        tabColor: "#4F46E5",
        rangeStrokes: [{
          color: "#9CA3AF"
        }, {
          color: "#D1D5DB"
        }, {
          color: "#E5E7EB"
        }],
        titleFont: {
          color: "#374151",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        subTitleFont: {
          color: "#374151",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendLabelFont: {
          color: "#374151",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#6B7280",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        dataLabelFont: {
          color: "#6B7280",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#F9FAFB",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "TailwindDark":
      style = {
        majorTickLineColor: "#4B5563",
        minorTickLineColor: "#4B5563",
        background: "transparent",
        labelFontColor: "#9CA3AF",
        categoryFontColor: "#9CA3AF",
        labelFontFamily: "Inter",
        tooltipFill: "#E9ECEF",
        legendLabel: "#D1D5DB",
        tooltipBoldLabel: "#1F2937",
        featuredMeasureColor: "#1F2937",
        comparativeMeasureColor: "#1F2937",
        titleFontColor: "#D1D5DB",
        dataLabelFontColor: "#D1D5DB",
        titleFontFamily: "Inter",
        subTitleFontColor: "#D1D5DB",
        subTitleFontFamily: "Inter",
        firstRangeColor: "#6B7280",
        secondRangeColor: "#4B5563",
        thirdRangeColor: "#374151",
        tabColor: "#22D3EE",
        rangeStrokes: [{
          color: "#6B7280"
        }, {
          color: "#4B5563"
        }, {
          color: "#374151"
        }],
        titleFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        subTitleFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendLabelFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#9CA3AF",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        dataLabelFont: {
          color: "#9CA3AF",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#1F2937",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Bootstrap5":
      style = {
        majorTickLineColor: "#CED4DA",
        minorTickLineColor: "#CED4DA",
        background: "transparent",
        labelFontColor: "#212529",
        categoryFontColor: "#212529",
        labelFontFamily: "Segoe UI",
        tooltipFill: "#000000E5",
        legendLabel: "#212529",
        tooltipBoldLabel: "#212529",
        featuredMeasureColor: "#343A40",
        comparativeMeasureColor: "#343A40",
        titleFontColor: "#212529",
        dataLabelFontColor: "#212529",
        titleFontFamily: "Segoe UI",
        subTitleFontColor: "#212529",
        subTitleFontFamily: "Segoe UI",
        firstRangeColor: "#CED4DA",
        secondRangeColor: "#DEE2E6",
        thirdRangeColor: "#E9ECEF",
        tabColor: "#0D6EFD",
        rangeStrokes: [{
          color: "#CED4DA"
        }, {
          color: "#DEE2E6"
        }, {
          color: "#E9ECEF"
        }],
        titleFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        subTitleFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendLabelFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        dataLabelFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Bootstrap5Dark":
      style = {
        majorTickLineColor: "#6C757D",
        minorTickLineColor: "#6C757D",
        background: "#212529",
        labelFontColor: "#DEE2E6",
        categoryFontColor: "#DEE2E6",
        labelFontFamily: "Segoe UI",
        tooltipFill: "#FFFFFFE5",
        legendLabel: "#DEE2E6",
        tooltipBoldLabel: "#212529",
        featuredMeasureColor: "#ADB5BD",
        comparativeMeasureColor: "#ADB5BD",
        titleFontColor: "#DEE2E6",
        dataLabelFontColor: "#DEE2E6",
        titleFontFamily: "Segoe UI",
        subTitleFontColor: "#DEE2E6",
        subTitleFontFamily: "Segoe UI",
        firstRangeColor: "#6C757D",
        secondRangeColor: "#495057",
        thirdRangeColor: "#343A40",
        tabColor: "#0D6EFD",
        rangeStrokes: [{
          color: "#6C757D"
        }, {
          color: "#495057"
        }, {
          color: "#343A40"
        }],
        titleFont: {
          color: "#DEE2E6",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        subTitleFont: {
          color: "#DEE2E6",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendLabelFont: {
          color: "#DEE2E6",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#DEE2E6",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        dataLabelFont: {
          color: "#DEE2E6",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Fluent":
      style = {
        majorTickLineColor: "#C8C6C4",
        minorTickLineColor: "#C8C6C4",
        background: "rgba(255, 255, 255, 0.0001)",
        labelFontColor: "#3B3A39",
        categoryFontColor: "#3B3A39",
        labelFontFamily: "Segoe UI",
        tooltipFill: "#FFFFFF",
        legendLabel: "#3B3A39",
        tooltipBoldLabel: "#323130",
        featuredMeasureColor: "#A19F9D",
        comparativeMeasureColor: "#A19F9D",
        titleFontColor: "#201F1E",
        dataLabelFontColor: "#3B3A39",
        titleFontFamily: "Segoe UI",
        subTitleFontColor: "#201F1E",
        subTitleFontFamily: "Segoe UI",
        firstRangeColor: "#C8C6C4",
        secondRangeColor: "#D2D0CE",
        thirdRangeColor: "#EDEBE9",
        tabColor: "#0078D4",
        rangeStrokes: [{
          color: "#C8C6C4"
        }, {
          color: "#D2D0CE"
        }, {
          color: "#EDEBE9"
        }],
        titleFont: {
          color: "#201F1E",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        subTitleFont: {
          color: "#323129",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendLabelFont: {
          color: "#49454E",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#3B3A39",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        dataLabelFont: {
          color: "#3B3A39",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#323130",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "FluentDark":
      style = {
        majorTickLineColor: "#484644",
        minorTickLineColor: "#484644",
        background: "transparent",
        labelFontColor: "#C8C6C4",
        categoryFontColor: "#C8C6C4",
        labelFontFamily: "Segoe UI",
        tooltipFill: "#323130",
        legendLabel: "#C8C6C4",
        tooltipBoldLabel: "#F3F2F1",
        featuredMeasureColor: "#797775",
        comparativeMeasureColor: "#797775",
        titleFontColor: "#F3F2F1",
        dataLabelFontColor: "#C8C6C4",
        titleFontFamily: "Segoe UI",
        subTitleFontColor: "#F3F2F1",
        subTitleFontFamily: "Segoe UI",
        firstRangeColor: "#484644",
        secondRangeColor: "#3B3A39",
        thirdRangeColor: "#292827",
        tabColor: "#0078D4",
        rangeStrokes: [{
          color: "#484644"
        }, {
          color: "#3B3A39"
        }, {
          color: "#292827"
        }],
        titleFont: {
          color: "#C8C6C4",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        subTitleFont: {
          color: "#F3F2F1",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendLabelFont: {
          color: "#D2D0CE",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#C8C6C4",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        dataLabelFont: {
          color: "#D2D0CE",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#F3F2F1",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Fluent2":
      style = {
        majorTickLineColor: "#C8C6C4",
        minorTickLineColor: "#C8C6C4",
        background: "transparent",
        labelFontColor: "#C8C6C4",
        categoryFontColor: "#616161",
        labelFontFamily: "Segoe UI",
        tooltipFill: "#FFFFFF",
        legendLabel: "#242424",
        tooltipBoldLabel: "#242424",
        featuredMeasureColor: "#A19F9D",
        comparativeMeasureColor: "#A19F9D",
        titleFontColor: "#242424",
        dataLabelFontColor: "#424242",
        titleFontFamily: "Segoe UI",
        subTitleFontColor: "#616161",
        subTitleFontFamily: "Segoe UI",
        firstRangeColor: "#C8C6C4",
        secondRangeColor: "#D2D0CE",
        thirdRangeColor: "#EDEBE9",
        tabColor: "#0078D4",
        rangeStrokes: [{
          color: "#C8C6C4"
        }, {
          color: "#D2D0CE"
        }, {
          color: "#EDEBE9"
        }],
        titleFont: {
          color: "#242424",
          fontFamily: "Segoe UI",
          size: Browser.isDevice ? "16px" : "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        subTitleFont: {
          color: "#616161",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#242424",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#616161",
          fontFamily: "Segoe UI",
          size: Browser.isDevice ? "14px" : "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        dataLabelFont: {
          color: "#242424",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#242424",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        }
      };
      break;
    case "Fluent2Dark":
      style = {
        majorTickLineColor: "#484644",
        minorTickLineColor: "#484644",
        background: "transparent",
        labelFontColor: "#ADADAD",
        categoryFontColor: "#ADADAD",
        labelFontFamily: "Segoe UI",
        tooltipFill: "#292929",
        legendLabel: "#FFFFFF",
        tooltipBoldLabel: "#FFFFFF",
        featuredMeasureColor: "#8A8886",
        comparativeMeasureColor: "#8A8886",
        titleFontColor: "#FFFFFF",
        dataLabelFontColor: "#FFFFFF",
        titleFontFamily: "Segoe UI",
        subTitleFontColor: "#ADADAD",
        subTitleFontFamily: "Segoe UI",
        firstRangeColor: "#484644",
        secondRangeColor: "#3B3A39",
        thirdRangeColor: "#292827",
        tabColor: "#0078D4",
        rangeStrokes: [{
          color: "#484644"
        }, {
          color: "#3B3A39"
        }, {
          color: "#292827"
        }],
        titleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: Browser.isDevice ? "16px" : "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        subTitleFont: {
          color: "#ADADAD",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#ADADAD",
          fontFamily: "Segoe UI",
          size: Browser.isDevice ? "14px" : "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        dataLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        }
      };
      break;
    case "Fluent2HighContrast":
      style = {
        majorTickLineColor: "#484644",
        minorTickLineColor: "#484644",
        background: "transparent",
        labelFontColor: "#FFFFFF",
        categoryFontColor: "#FFFFFF",
        labelFontFamily: "Segoe UI",
        tooltipFill: "#000000",
        legendLabel: "#FFFFFF",
        tooltipBoldLabel: "#FFFFFF",
        featuredMeasureColor: "#8A8886",
        comparativeMeasureColor: "#8A8886",
        titleFontColor: "#FFFFFF",
        dataLabelFontColor: "#FFFFFF",
        titleFontFamily: "Segoe UI",
        subTitleFontColor: "#FFFFFF",
        subTitleFontFamily: "Segoe UI",
        firstRangeColor: "#484644",
        secondRangeColor: "#3B3A39",
        thirdRangeColor: "#292827",
        tabColor: "#0078D4",
        rangeStrokes: [{
          color: "#484644"
        }, {
          color: "#3B3A39"
        }, {
          color: "#292827"
        }],
        titleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: Browser.isDevice ? "16px" : "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        subTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: Browser.isDevice ? "14px" : "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        dataLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        }
      };
      break;
    case "Material3":
      style = {
        majorTickLineColor: "#C4C7C5",
        minorTickLineColor: "#C4C7C5",
        background: "transparent",
        labelFontColor: "#1E192B",
        categoryFontColor: "#1E192B",
        labelFontFamily: "Roboto",
        tooltipFill: "#313033",
        legendLabel: "#49454E",
        tooltipBoldLabel: "#F4EFF4",
        featuredMeasureColor: "#79747E",
        comparativeMeasureColor: "#79747E",
        titleFontColor: "#1C1B1F",
        dataLabelFontColor: "#49454E",
        titleFontFamily: "Roboto",
        subTitleFontColor: "#1C1B1F",
        subTitleFontFamily: "Roboto",
        firstRangeColor: "#a6a6a9",
        secondRangeColor: "#C4C7C5",
        thirdRangeColor: "#E7E0EC",
        tabColor: "#49454E",
        rangeStrokes: [{
          color: "#a6a6a9"
        }, {
          color: "#C4C7C5"
        }, {
          color: "#E7E0EC"
        }],
        titleFont: {
          color: "#1C1B1F",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        subTitleFont: {
          color: "#49454E",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendLabelFont: {
          color: "#49454E",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#1E192B",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        dataLabelFont: {
          color: "#49454E",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#F4EFF4",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Material3Dark":
      style = {
        majorTickLineColor: "#444746",
        minorTickLineColor: "#444746",
        background: "transparent",
        labelFontColor: "#E6E1E5",
        categoryFontColor: "#E6E1E5",
        labelFontFamily: "Roboto",
        tooltipFill: "#E6E1E5",
        legendLabel: "#CAC4D0",
        tooltipBoldLabel: "#313033",
        featuredMeasureColor: "#938F99",
        comparativeMeasureColor: "#938F99",
        titleFontColor: "#E6E1E5",
        dataLabelFontColor: "#CAC4D0",
        titleFontFamily: "Roboto",
        subTitleFontColor: "#E6E1E5",
        subTitleFontFamily: "Roboto",
        firstRangeColor: "rgba(147,143,153,0.4)",
        secondRangeColor: "#444746",
        thirdRangeColor: "#49454F",
        tabColor: "#CAC4D0",
        rangeStrokes: [{
          color: "rgba(147,143,153,0.4)"
        }, {
          color: "#444746"
        }, {
          color: "#49454F"
        }],
        titleFont: {
          color: "#E6E1E5",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        subTitleFont: {
          color: "#CAC4D0",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendLabelFont: {
          color: "#CAC4D0",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#CAC4D0",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        dataLabelFont: {
          color: "#CAC4D0",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#313033",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    default:
      break;
  }
  return style;
}

// node_modules/@syncfusion/ej2-charts/src/bullet-chart/renderer/bullet-axis.js
var BulletChartAxis = (
  /** @class */
  function() {
    function BulletChartAxis2(bullet) {
      this.bulletChart = bullet;
      this.isVertical = bullet.orientation === "Vertical";
      this.isLabelsInside = bullet.labelPosition === "Inside";
      this.isHorizontal = bullet.orientation === "Horizontal";
      this.isLeft = bullet.titlePosition === "Left";
      this.isRight = bullet.titlePosition === "Right";
      this.isTop = bullet.titlePosition === "Top";
      this.majorTickSize = bullet.majorTickLines.height;
      this.location = 10;
      this.labelOffset = 15;
      this.labelSize = parseFloat(bullet.labelStyle.size);
      this.isLabelBelow = !this.bulletChart.opposedPosition;
    }
    BulletChartAxis2.prototype.renderMajorTickLines = function(intervalValue, scale) {
      if (this.bulletChart.orientation === "Horizontal") {
        this.renderXMajorTickLines(intervalValue, scale);
      } else {
        this.renderYMajorTickLines(intervalValue, scale);
      }
    };
    BulletChartAxis2.prototype.renderMinorTickLines = function(intervalValue, scale) {
      if (this.bulletChart.orientation === "Horizontal") {
        this.renderXMinorTickLines(intervalValue, scale);
      } else {
        this.renderYMinorTickLines(intervalValue, scale);
      }
    };
    BulletChartAxis2.prototype.renderAxisLabels = function(intervalValue, scale) {
      if (this.bulletChart.orientation === "Horizontal") {
        this.renderXAxisLabels(intervalValue, scale);
      } else {
        this.renderYAxisLabels(intervalValue, scale);
      }
    };
    BulletChartAxis2.prototype.renderXMajorTickLines = function(intervalValue, scale) {
      var bullet = this.bulletChart;
      var tickGroup = bullet.renderer.createGroup({
        "id": bullet.svgObject.id + "_majorTickGroup"
      });
      var min = bullet.minimum;
      var max = bullet.maximum;
      var interval = bullet.interval;
      var enableRtl = bullet.enableRtl;
      var y1 = bullet.initialClipRect.y + (bullet.opposedPosition ? 0 : bullet.initialClipRect.height);
      var y2 = y1 + (!bullet.opposedPosition ? bullet.tickPosition !== "Inside" ? this.majorTickSize : -this.majorTickSize : bullet.tickPosition !== "Inside" ? -this.majorTickSize : this.majorTickSize);
      var majorTick = bullet.majorTickLines;
      var strokeColor = majorTick.color || bullet.themeStyle.majorTickLineColor;
      var options;
      var condition;
      var size = bullet.initialClipRect.x + (bullet.enableRtl ? bullet.initialClipRect.width : 0);
      var majorPointX = bullet.initialClipRect.x + majorTick.width / 2 + (enableRtl ? bullet.initialClipRect.width : 0);
      for (var i = min; i <= max; i += interval) {
        condition = !bullet.enableRtl ? i === max : i === min;
        if (condition) {
          majorPointX -= majorTick.width / 2;
        }
        condition = !bullet.enableRtl ? i === max : i === min;
        if (bullet.majorTickLines.useRangeColor) {
          strokeColor = this.bindingRangeStrokes(majorPointX - (condition ? this.bulletChart.majorTickLines.width / 2 : 0), size, this.bulletChart.orientation, bullet.enableRtl);
        }
        options = this.majorTicks(majorPointX, majorPointX, y1, y2, strokeColor, i);
        var majorTicks = bullet.renderer.drawLine(options);
        majorPointX = majorPointX + (enableRtl ? -intervalValue : intervalValue);
        tickGroup.appendChild(majorTicks);
        scale.appendChild(tickGroup);
      }
    };
    BulletChartAxis2.prototype.renderYMajorTickLines = function(intervalValue, scale) {
      var bulletChart = this.bulletChart;
      var tickGroup = bulletChart.renderer.createGroup({
        "id": bulletChart.svgObject.id + "_majorTickGroup"
      });
      var min = bulletChart.minimum;
      var max = bulletChart.maximum;
      var interval = bulletChart.interval;
      var enableRtl = bulletChart.enableRtl;
      var rect = bulletChart.initialClipRect;
      var x1 = rect.x + (!bulletChart.opposedPosition ? 0 : rect.width);
      var x2 = x1 - (!bulletChart.opposedPosition ? bulletChart.tickPosition !== "Inside" ? this.majorTickSize : -this.majorTickSize : bulletChart.tickPosition !== "Inside" ? -this.majorTickSize : this.majorTickSize);
      var majorTick = bulletChart.majorTickLines;
      var strokeColor = majorTick.color || bulletChart.themeStyle.majorTickLineColor;
      var condition;
      var options;
      var size = rect.y + (!bulletChart.enableRtl ? rect.height : 0);
      var majorPointY = rect.y + majorTick.width / 2 + (!enableRtl ? rect.height : 0);
      for (var i = min; i <= max; i += interval) {
        condition = bulletChart.enableRtl ? i === max : i === min;
        if (condition) {
          majorPointY -= majorTick.width / 2;
        }
        condition = !bulletChart.enableRtl ? i === max : i === min;
        if (bulletChart.majorTickLines.useRangeColor) {
          strokeColor = this.bindingRangeStrokes(majorPointY - (condition ? this.bulletChart.majorTickLines.width / 2 : 0), size, this.bulletChart.orientation, bulletChart.enableRtl);
        }
        options = this.majorTicks(x1, x2, majorPointY, majorPointY, strokeColor, i);
        var majorTicks = bulletChart.renderer.drawLine(options);
        majorPointY = majorPointY + (!enableRtl ? -intervalValue : intervalValue);
        tickGroup.appendChild(majorTicks);
        scale.appendChild(tickGroup);
      }
    };
    BulletChartAxis2.prototype.majorTicks = function(x1, x2, y1, y2, strokeColor, i) {
      var options = {
        "id": this.bulletChart.svgObject.id + "_MajorTickLine_" + i,
        "x1": x1,
        "y1": y1,
        "x2": x2,
        "y2": y2,
        "stroke-width": this.bulletChart.majorTickLines.width,
        "stroke": this.bulletChart.majorTickLines.useRangeColor && strokeColor ? strokeColor : this.bulletChart.majorTickLines.color || strokeColor
      };
      return options;
    };
    BulletChartAxis2.prototype.bindingRangeStrokes = function(majorPointX, size, orientation, rtl) {
      if (orientation === "Vertical" && !rtl || rtl && orientation === "Horizontal") {
        return this.backwardStrokeBinding(majorPointX, size);
      } else {
        return this.forwardStrokeBinding(majorPointX, size);
      }
    };
    BulletChartAxis2.prototype.renderXMinorTickLines = function(intervalValue, scaleGroup) {
      var minorTickGroup = this.bulletChart.renderer.createGroup({
        "id": this.bulletChart.svgObject.id + "_minorTickGroup"
      });
      var bullet = this.bulletChart;
      var max = bullet.maximum;
      var min = bullet.minimum;
      var interval = bullet.interval;
      var minorTick = bullet.minorTickLines.height;
      var minorTicksPerInterval = this.bulletChart.minorTicksPerInterval;
      var minorPointX;
      var x;
      var majorPointX = bullet.initialClipRect.x;
      var y1 = bullet.initialClipRect.y + (bullet.opposedPosition ? 0 : bullet.initialClipRect.height);
      var y2 = y1 + (!bullet.opposedPosition ? bullet.tickPosition !== "Inside" ? minorTick : -minorTick : bullet.tickPosition !== "Inside" ? -minorTick : minorTick);
      var strokeColor = bullet.minorTickLines.color || bullet.themeStyle.minorTickLineColor;
      var options;
      var minorTicks;
      var size = bullet.initialClipRect.x + (bullet.enableRtl ? bullet.initialClipRect.width : 0);
      for (var i = min; i < max; i += interval) {
        minorPointX = intervalValue / minorTicksPerInterval;
        for (var j = 1; j <= minorTicksPerInterval; j++) {
          x = majorPointX + minorPointX - minorPointX / (minorTicksPerInterval + 1);
          if (bullet.minorTickLines.useRangeColor) {
            strokeColor = this.bindingRangeStrokes(x, size, this.bulletChart.orientation, bullet.enableRtl);
          }
          options = this.minorXTicks(x, x, y1, y2, strokeColor, i.toString() + j.toString());
          minorTicks = this.bulletChart.renderer.drawLine(options);
          minorTickGroup.appendChild(minorTicks);
          scaleGroup.appendChild(minorTickGroup);
          minorPointX = intervalValue / minorTicksPerInterval * (j + 1);
        }
        majorPointX += intervalValue;
      }
    };
    BulletChartAxis2.prototype.renderYMinorTickLines = function(intervalValue, scaleGroup) {
      var minorTickGroup = this.bulletChart.renderer.createGroup({
        "id": this.bulletChart.svgObject.id + "_minorTickGroup"
      });
      var bulletChart = this.bulletChart;
      var max = bulletChart.maximum;
      var min = bulletChart.minimum;
      var interval = bulletChart.interval;
      var minorTick = bulletChart.minorTickLines.height;
      var minorTicksPerInterval = this.bulletChart.minorTicksPerInterval;
      var minorPointY;
      var y;
      var majorPointY = bulletChart.initialClipRect.y + (!bulletChart.enableRtl ? bulletChart.initialClipRect.height : 0);
      var x1 = bulletChart.initialClipRect.x + (!bulletChart.opposedPosition ? 0 : bulletChart.initialClipRect.width);
      var x2 = x1 - (!bulletChart.opposedPosition ? bulletChart.tickPosition !== "Inside" ? minorTick : -minorTick : bulletChart.tickPosition !== "Inside" ? -minorTick : minorTick);
      var strokeColor = bulletChart.minorTickLines.color || bulletChart.themeStyle.minorTickLineColor;
      var options;
      var minorTicks;
      var size = bulletChart.initialClipRect.y + (!bulletChart.enableRtl ? bulletChart.initialClipRect.height : 0);
      for (var i = min; i < max; i += interval) {
        minorPointY = intervalValue / minorTicksPerInterval;
        for (var j = 1; j <= minorTicksPerInterval; j++) {
          if (!this.bulletChart.enableRtl) {
            y = majorPointY - minorPointY + minorPointY / (minorTicksPerInterval + 1);
          } else {
            y = majorPointY + minorPointY - minorPointY / (minorTicksPerInterval + 1);
          }
          if (bulletChart.minorTickLines.useRangeColor) {
            strokeColor = this.bindingRangeStrokes(y, size, this.bulletChart.orientation, bulletChart.enableRtl);
          }
          options = this.minorXTicks(x1, x2, y, y, strokeColor, i.toString() + j.toString());
          minorTicks = this.bulletChart.renderer.drawLine(options);
          minorTickGroup.appendChild(minorTicks);
          scaleGroup.appendChild(minorTickGroup);
          minorPointY = intervalValue / minorTicksPerInterval * (j + 1);
        }
        majorPointY -= this.bulletChart.enableRtl ? -intervalValue : intervalValue;
      }
    };
    BulletChartAxis2.prototype.minorXTicks = function(x1, x2, y1, y2, strokeColor, i) {
      var options = {
        "id": this.bulletChart.svgObject.id + "_MajorTickLine_" + i,
        "x1": x1,
        "x2": x2,
        "y1": y1,
        "y2": y2,
        "stroke-width": this.bulletChart.minorTickLines.width,
        "stroke": this.bulletChart.minorTickLines.useRangeColor && strokeColor ? strokeColor : this.bulletChart.minorTickLines.color || strokeColor
      };
      return options;
    };
    BulletChartAxis2.prototype.forwardStrokeBinding = function(position, size) {
      var bullet = this.bulletChart;
      var previous = size;
      for (var k = 0; k <= bullet.rangeCollection.length - 1; k++) {
        previous += !k ? 0 : bullet.rangeCollection[k - 1];
        if (position >= previous && position < previous + bullet.rangeCollection[k]) {
          return bullet.ranges[k].color;
        }
      }
      return null;
    };
    BulletChartAxis2.prototype.backwardStrokeBinding = function(position, size) {
      var bullet = this.bulletChart;
      var previous = size;
      for (var k = 0; k <= bullet.rangeCollection.length - 1; k++) {
        previous -= !k ? 0 : bullet.rangeCollection[k - 1];
        if (Math.round(position) >= Math.round(previous - bullet.rangeCollection[k]) && position <= previous) {
          return bullet.ranges[k].color;
        }
      }
      return null;
    };
    BulletChartAxis2.prototype.renderXAxisLabels = function(intervalValue, scaleGroup) {
      var axisLabelGroup = this.bulletChart.renderer.createGroup({
        "id": this.bulletChart.svgObject.id + "_axisLabelGroup"
      });
      var text;
      var bullet = this.bulletChart;
      var locale = this.bulletChart.locale;
      var padding = 5;
      var enableRtl = bullet.enableRtl;
      var tick = (bullet.tickPosition === bullet.labelPosition ? bullet.majorTickLines.height : 0) + padding * 2;
      var y = bullet.initialClipRect.y + (bullet.opposedPosition ? bullet.labelPosition === "Inside" ? tick : -tick : bullet.initialClipRect.height + (bullet.labelPosition === "Inside" ? -tick : tick));
      var x = bullet.initialClipRect.x + (enableRtl ? bullet.initialClipRect.width : 0);
      var min = bullet.minimum;
      var max = bullet.maximum;
      var interval = bullet.interval;
      var localizedText = locale && this.bulletChart.enableGroupSeparator;
      var format = this.getFormat(this.bulletChart);
      var strokeColor = bullet.labelStyle.color || bullet.themeStyle.axisLabelFont.color;
      var condition;
      var isCustomFormat = format.match("{value}") !== null;
      this.format = this.bulletChart.intl.getNumberFormat({
        format: isCustomFormat ? "" : format,
        useGrouping: this.bulletChart.enableGroupSeparator
      });
      var size = bullet.initialClipRect.x + (bullet.enableRtl ? bullet.initialClipRect.width : 0);
      y += measureText(this.formatValue(this, isCustomFormat, format, this.bulletChart.maximum), bullet.labelStyle, this.bulletChart.themeStyle.axisLabelFont).height / 3;
      for (var i = min; i <= max; i += interval) {
        condition = !bullet.enableRtl ? i === max : i === min;
        if (bullet.labelStyle.useRangeColor) {
          strokeColor = this.bindingRangeStrokes(x - (condition ? this.bulletChart.majorTickLines.width / 2 : 0), size, this.bulletChart.orientation, bullet.enableRtl);
        }
        text = localizedText ? i.toLocaleString(locale) : this.formatValue(this, isCustomFormat, format, i);
        var labelOptions = this.labelXOptions(x, y, text, i);
        this.bulletChart.labelStyle.fontFamily = this.bulletChart.labelStyle.fontFamily || this.bulletChart.themeStyle.axisLabelFont.fontFamily;
        var label = textElement(labelOptions, this.bulletChart.labelStyle, strokeColor, scaleGroup, this.bulletChart.themeStyle.axisLabelFont);
        axisLabelGroup.appendChild(label);
        x += enableRtl ? -intervalValue : intervalValue;
      }
      scaleGroup.appendChild(axisLabelGroup);
    };
    BulletChartAxis2.prototype.labelXOptions = function(labelX, pointY, displayText, i) {
      var labelOptions = {
        "id": this.bulletChart.svgObject.id + "_AxisLabel_" + i,
        "anchor": "middle",
        "text": displayText,
        "transform": "",
        "x": labelX,
        "y": pointY,
        "baseLine": "",
        "labelRotation": 0
      };
      return labelOptions;
    };
    BulletChartAxis2.prototype.renderYAxisLabels = function(intervalValue, scaleGroup) {
      var axisLabelGroup = this.bulletChart.renderer.createGroup({
        "id": this.bulletChart.svgObject.id + "_axisLabelGroup"
      });
      var text;
      var bulletChart = this.bulletChart;
      var locale = bulletChart.locale;
      var padding = 5;
      var enableRtl = bulletChart.enableRtl;
      var tick = (bulletChart.tickPosition === bulletChart.labelPosition ? bulletChart.majorTickLines.height : 0) + padding * 2;
      var y = bulletChart.initialClipRect.y + (!enableRtl ? bulletChart.initialClipRect.height : 0);
      var x = bulletChart.initialClipRect.x + (!bulletChart.opposedPosition ? bulletChart.labelPosition === "Inside" ? tick + padding * 2 : -tick : bulletChart.initialClipRect.width + (bulletChart.labelPosition === "Inside" ? -(tick + padding * 2) : tick));
      var min = bulletChart.minimum;
      var max = bulletChart.maximum;
      var interval = bulletChart.interval;
      var localizedText = locale && this.bulletChart.enableGroupSeparator;
      var strokeColor = bulletChart.labelStyle.color || bulletChart.themeStyle.axisLabelFont.color;
      var format = this.getFormat(this.bulletChart);
      var isCustomFormat = format.match("{value}") !== null;
      var condition;
      this.format = this.bulletChart.intl.getNumberFormat({
        format: isCustomFormat ? "" : format,
        useGrouping: this.bulletChart.enableGroupSeparator
      });
      var size = bulletChart.initialClipRect.y + (!bulletChart.enableRtl ? bulletChart.initialClipRect.height : 0);
      var labelWidth = measureText(this.formatValue(this, isCustomFormat, format, this.bulletChart.maximum), bulletChart.labelStyle, this.bulletChart.themeStyle.axisLabelFont).width / 2;
      var height = measureText(this.formatValue(this, isCustomFormat, format, this.bulletChart.maximum), bulletChart.labelStyle, this.bulletChart.themeStyle.axisLabelFont).height / 3;
      y += height;
      for (var i = min; i <= max; i += interval) {
        condition = bulletChart.enableRtl ? i === max : i === min;
        if (bulletChart.labelStyle.useRangeColor) {
          strokeColor = this.bindingRangeStrokes(y - height - (condition ? this.bulletChart.majorTickLines.width / 2 : 0), size, this.bulletChart.orientation, bulletChart.enableRtl);
        }
        text = localizedText ? i.toLocaleString(locale) : this.formatValue(this, isCustomFormat, format, i);
        var labelOptions = this.labelXOptions(x - (!this.bulletChart.opposedPosition ? labelWidth : -labelWidth), y, text, i);
        this.bulletChart.labelStyle.fontFamily = this.bulletChart.labelStyle.fontFamily || this.bulletChart.themeStyle.axisLabelFont.fontFamily;
        var label = textElement(labelOptions, this.bulletChart.labelStyle, strokeColor, scaleGroup, bulletChart.themeStyle.axisLabelFont);
        axisLabelGroup.appendChild(label);
        y += !enableRtl ? -intervalValue : intervalValue;
      }
      scaleGroup.appendChild(axisLabelGroup);
    };
    BulletChartAxis2.prototype.getFormat = function(axis) {
      if (axis.labelFormat) {
        return axis.labelFormat;
      }
      return "";
    };
    BulletChartAxis2.prototype.formatValue = function(axis, isCustom, format, tempInterval) {
      return isCustom ? format.replace("{value}", axis.format(tempInterval)) : axis.format(tempInterval);
    };
    return BulletChartAxis2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/bullet-chart/renderer/scale-render.js
var ScaleGroup = (
  /** @class */
  function() {
    function ScaleGroup2(bulletChart) {
      this.comparative = [];
      this.dataSource = bulletChart.dataSource;
      this.isVertical = bulletChart.orientation === "Vertical";
      this.isTicksInside = bulletChart.tickPosition === "Inside";
      this.isLabelsInside = bulletChart.labelPosition === "Inside";
      this.isHorizontal = bulletChart.orientation === "Horizontal";
      this.isLeft = bulletChart.titlePosition === "Left";
      this.isRight = bulletChart.titlePosition === "Right";
      this.isTop = bulletChart.titlePosition === "Top";
      this.location = 10;
      this.featureBarBounds = [];
      this.majorTickSize = bulletChart.majorTickLines.height;
      this.labelOffset = 15;
      this.labelSize = 12;
      this.bulletChart = bulletChart;
      this.isLabelBelow = !this.bulletChart.opposedPosition;
      this.scaleOrientation = this.bulletChart.orientation;
      this.rangeColor = [];
    }
    ScaleGroup2.prototype.drawScaleGroup = function(scaleGroup) {
      var rangeGroup = this.bulletChart.renderer.createGroup({
        "id": this.bulletChart.svgObject.id + "_rangeGroup"
      });
      var max = this.bulletChart.maximum;
      var ranges = this.bulletChart.ranges;
      this.scaleSettingsGroup = scaleGroup;
      var rect;
      var bullet = this.bulletChart;
      var enableRtl = bullet.enableRtl;
      var initialRect = bullet.initialClipRect;
      var locX = initialRect.x + (enableRtl && bullet.orientation === "Horizontal" ? initialRect.width : 0);
      var locY = initialRect.y + (!enableRtl && bullet.orientation === "Vertical" ? initialRect.height : 0);
      var area = 0;
      bullet.rangeCollection = [];
      var start = 0;
      var range = bullet.orientation === "Horizontal" ? initialRect.width : initialRect.height;
      var fillRange = bullet.orientation === "Horizontal" ? initialRect.height : initialRect.width;
      for (var i = 0; i < ranges.length; i++) {
        area = range * ((ranges[i].end - start) / max);
        if (bullet.orientation === "Horizontal") {
          locX -= enableRtl ? area : 0;
        } else {
          locY -= !enableRtl ? area : 0;
        }
        rect = new RectOption(bullet.svgObject.id + "_range_" + i, ranges[i].color || this.bulletChart.themeStyle.rangeStrokes[i]["color"], {
          width: 1
        }, ranges[i].opacity, new Rect(locX, locY, bullet.orientation === "Horizontal" ? area : fillRange, bullet.orientation === "Horizontal" ? fillRange : area));
        var svgRect = bullet.renderer.drawRectangle(rect);
        rangeGroup.appendChild(svgRect);
        scaleGroup.appendChild(rangeGroup);
        if (bullet.orientation === "Horizontal") {
          locX += enableRtl ? 0 : area;
        } else {
          locY += !enableRtl ? 0 : area;
        }
        bullet.rangeCollection.push(area);
        start = ranges[i].end;
      }
      return this.bulletChart.rangeCollection;
    };
    ScaleGroup2.prototype.sortRangeCollection = function(a, b) {
      return a - b;
    };
    ScaleGroup2.prototype.renderFeatureBar = function(dataCount) {
      if (dataCount === 0) {
        return;
      }
      this.renderCommonFeatureBar(dataCount, this.isHorizontal);
    };
    ScaleGroup2.prototype.renderCommonFeatureBar = function(dataCount, isHorizontal) {
      var categoryValue;
      var dotWidth = 6;
      var padding = 5;
      var bulletChart = this.bulletChart;
      var initialBoundsStart = isHorizontal ? bulletChart.initialClipRect.y + bulletChart.initialClipRect.height : bulletChart.initialClipRect.x;
      var lPoint;
      var featueGroup = bulletChart.renderer.createGroup({
        "id": bulletChart.svgObject.id + "_featureGroup"
      });
      var data;
      var featureBarSize = (isHorizontal ? bulletChart.initialClipRect.height : bulletChart.initialClipRect.width) / dataCount;
      var bounds;
      for (var i = 0; i < dataCount; i++) {
        data = bulletChart.dataSource[i];
        categoryValue = data[bulletChart.categoryField];
        if (isHorizontal) {
          lPoint = initialBoundsStart - featureBarSize * i - (featureBarSize + bulletChart.valueHeight) / 2;
        } else {
          lPoint = initialBoundsStart + featureBarSize * i + featureBarSize / 2 - bulletChart.valueHeight / 2;
        }
        bounds = this.calculateFeatureMeasureBounds(data[bulletChart.valueField], categoryValue, isHorizontal);
        if (data && bulletChart.type === "Dot") {
          var value = data[bulletChart.valueField];
          if (isHorizontal) {
            bounds.pointX = bounds.pointX + (value > 0 && !bulletChart.enableRtl || value < 0 && bulletChart.enableRtl ? bounds.width : 0) - dotWidth / 2;
          } else {
            bounds.pointX = bounds.pointX + (value > 0 && bulletChart.enableRtl || value < 0 && !bulletChart.enableRtl ? bounds.width : 0) - dotWidth / 2;
          }
          bounds.width = dotWidth;
        }
        if (bounds) {
          var svgRect = isHorizontal ? this.featureBar(bounds.pointX, lPoint, bounds.width, i) : this.verticalFeatureBar(lPoint, bounds.pointX, bounds.width, i);
          featueGroup.appendChild(svgRect);
          this.feature = svgRect;
          this.scaleSettingsGroup.appendChild(featueGroup);
          this.featureBarBounds[i] = {
            x: bounds.pointX,
            y: lPoint,
            width: bounds.width,
            height: bulletChart.valueHeight
          };
          if (!isNullOrUndefined(categoryValue)) {
            var categoryTextSize = measureText(categoryValue, bulletChart.categoryLabelStyle, bulletChart.themeStyle.axisLabelFont);
            var categorySize = isHorizontal ? categoryTextSize.width : categoryTextSize.height;
            var initialRect = bulletChart.initialClipRect;
            var x = void 0;
            var categoryOptions = void 0;
            if (isHorizontal) {
              x = bulletChart.enableRtl ? initialRect.x + initialRect.width + padding + categorySize / 2 : initialRect.x - padding - categorySize / 2;
              categoryOptions = this.drawcategory(x, lPoint, categoryValue);
            } else {
              x = bulletChart.enableRtl ? initialRect.y - padding - categorySize / 2 : initialRect.y + initialRect.height + padding + categorySize / 2;
              categoryOptions = this.drawcategory(lPoint + bulletChart.valueHeight / 2, x, categoryValue);
            }
            bulletChart.categoryLabelStyle.fontFamily = bulletChart.categoryLabelStyle.fontFamily || bulletChart.themeStyle.axisLabelFont.fontFamily;
            textElement(categoryOptions, bulletChart.categoryLabelStyle, bulletChart.categoryLabelStyle.color || bulletChart.themeStyle.categoryFontColor, this.scaleSettingsGroup);
          }
        }
        if (bulletChart.animation.enable && animationMode !== "Disable" || animationMode === "Enable") {
          this.doValueBarAnimation();
        }
      }
    };
    ScaleGroup2.prototype.featureBar = function(pointX, pointY, width, i) {
      var featureBarOptions = new RectOption(this.bulletChart.svgObject.id + "_FeatureMeasure_" + i, this.bulletChart.dataSource[i][this.bulletChart.valueFill] || this.bulletChart.valueFill, this.bulletChart.valueBorder, 1, new Rect(pointX, pointY, width, this.bulletChart.valueHeight), 0, 0, "", this.bulletChart.valueBorder.dashArray);
      var svgRect = this.bulletChart.renderer.drawRectangle(featureBarOptions);
      svgRect.setAttribute("class", this.bulletChart.svgObject.id + "_FeatureMeasure");
      svgRect.id = this.bulletChart.svgObject.id + "_FeatureMeasure_" + i;
      svgRect.setAttribute("role", "img");
      svgRect.setAttribute("tabindex", "0");
      svgRect.style.outline = "none";
      svgRect.setAttribute("aria-label", this.bulletChart.title + ", value: " + this.bulletChart.dataSource[i].value + ", target: " + this.bulletChart.dataSource[i].target);
      return svgRect;
    };
    ScaleGroup2.prototype.verticalFeatureBar = function(pointX, pointY, width, i) {
      var featureBarOptions = new RectOption(this.bulletChart.svgObject.id + "_FeatureMeasure_" + i, this.bulletChart.dataSource[i][this.bulletChart.valueFill] || this.bulletChart.valueFill, this.bulletChart.valueBorder, 1, new Rect(pointX, pointY, this.bulletChart.valueHeight, width));
      var svgRect = this.bulletChart.renderer.drawRectangle(featureBarOptions);
      svgRect.setAttribute("class", this.bulletChart.svgObject.id + "_FeatureMeasure");
      svgRect.id = this.bulletChart.svgObject.id + "_FeatureMeasure_" + i;
      svgRect.setAttribute("role", "img");
      svgRect.setAttribute("tabindex", "0");
      svgRect.style.outline = "none";
      svgRect.setAttribute("aria-label", this.bulletChart.title + ", value: " + this.bulletChart.dataSource[i].value + ", target: " + this.bulletChart.dataSource[i].target);
      return svgRect;
    };
    ScaleGroup2.prototype.drawcategory = function(lPointX, lPointY, categoryValue) {
      var fontsize = parseInt(this.bulletChart.categoryLabelStyle.size, 10);
      var categoryOptions = {
        "id": "",
        "anchor": "middle",
        "x": lPointX,
        "y": lPointY + (fontsize / 4 + this.bulletChart.valueHeight / 2),
        "transform": "",
        "text": categoryValue,
        "baseLine": "",
        "labelRotation": 0
      };
      return categoryOptions;
    };
    ScaleGroup2.prototype.renderComparativeSymbol = function(dataCount) {
      if (dataCount === 0) {
        return;
      }
      this.renderCommonComparativeSymbol(dataCount, this.isHorizontal);
    };
    ScaleGroup2.prototype.renderCommonComparativeSymbol = function(dataCount, isHorizontal) {
      var bulletChart = this.bulletChart;
      var value;
      var rect = bulletChart.initialClipRect;
      var scaleLength = isHorizontal ? rect.width : rect.height;
      var y1;
      var y2;
      var x1;
      var pointY = isHorizontal ? rect.y + rect.height : rect.x;
      var comparativeGroup = bulletChart.renderer.createGroup({
        "id": bulletChart.svgObject.id + "_comparativeGroup"
      });
      var minimum = bulletChart.minimum;
      var maximum = bulletChart.maximum;
      var delta = maximum - minimum;
      var targetWidth = 5;
      var pointX = isHorizontal ? rect.x - targetWidth / 2 : rect.y + rect.height;
      var temp;
      var values = [];
      var targetTypes = bulletChart.targetTypes;
      var targetType = "Rect";
      var targetTypeLength = targetTypes.length;
      var featureBarSize = (isHorizontal ? rect.height : rect.width) / dataCount;
      var svgElement;
      for (var k = 0; k < dataCount; k++) {
        value = bulletChart.dataSource[k][bulletChart.targetField];
        values = values.concat(value);
        for (var i = 0; i < values.length; i++) {
          targetType = targetTypes[i % targetTypeLength];
          if (values[i] >= minimum && values[i] <= maximum) {
            if (isHorizontal) {
              temp = pointY - featureBarSize * k - featureBarSize / 2;
            } else {
              temp = pointY + featureBarSize * k + featureBarSize / 2;
            }
            y1 = temp - targetWidth * 1.5;
            y2 = temp + targetWidth * 1.5;
            temp = scaleLength / (delta / (delta - (maximum - values[i])));
            if (isHorizontal) {
              x1 = pointX + (bulletChart.enableRtl ? scaleLength - temp : temp);
            } else {
              x1 = pointX - (bulletChart.enableRtl ? scaleLength - temp : temp);
            }
            svgElement = this.getTargetElement(targetType, isHorizontal, x1, y1, y2, values[i], k);
            this.comparative.push(svgElement);
            comparativeGroup.appendChild(svgElement);
            y1 = 0;
            y2 = 0;
          }
          this.scaleSettingsGroup.appendChild(comparativeGroup);
        }
        values = [];
        if (bulletChart.animation.enable && animationMode !== "Disable" || animationMode === "Enable") {
          this.doTargetBarAnimation(0);
        }
      }
    };
    ScaleGroup2.prototype.getTargetElement = function(targetType, isHorizontal, x1, y1, y2, value, k) {
      var shapeObject;
      var shapeElement;
      var bulletChart = this.bulletChart;
      var strokeWidth = targetType === "Cross" ? bulletChart.targetWidth - 1 : 1;
      var size = targetType === "Circle" ? bulletChart.targetWidth - 1 : bulletChart.targetWidth;
      var lx = isHorizontal ? x1 + size / 2 : y1 + (y2 - y1) / 2;
      var ly = isHorizontal ? y1 + (y2 - y1) / 2 : x1;
      var id = bulletChart.svgObject.id + "_ComparativeMeasure_" + k;
      var className = bulletChart.svgObject.id + "_ComparativeMeasure";
      var targetColor = bulletChart.dataSource[k][bulletChart.targetColor] || bulletChart.targetColor;
      if (targetType === "Rect") {
        shapeObject = isHorizontal ? this.compareMeasure(x1, y1, y2, k, value) : this.compareVMeasure(y1, y2, x1, k);
        shapeElement = bulletChart.renderer.drawLine(shapeObject);
      } else if (targetType === "Circle") {
        shapeObject = new CircleOption(id, targetColor, {
          width: 1,
          color: targetColor || "black"
        }, 1, lx, ly, size);
        shapeElement = bulletChart.renderer.drawCircle(shapeObject);
      } else {
        var crossDirection = "M " + (lx - size) + " " + (ly - size) + " L " + (lx + size) + " " + (ly + size) + " M " + (lx - size) + " " + (ly + size) + " L " + (lx + size) + " " + (ly - size);
        shapeObject = new PathOption(id, "transparent", strokeWidth, targetColor, 1, "", crossDirection);
        shapeElement = bulletChart.renderer.drawPath(shapeObject);
      }
      shapeElement.setAttribute("class", className);
      return shapeElement;
    };
    ScaleGroup2.prototype.compareMeasure = function(x1, y1, y2, i, value) {
      var bulletChart = this.bulletChart;
      var compareMeasureOptions = {
        "class": bulletChart.svgObject.id + "_ComparativeMeasure",
        "id": bulletChart.svgObject.id + "_ComparativeMeasure_" + i,
        "x1": value === bulletChart.maximum ? x1 - bulletChart.targetWidth / 2 : value === bulletChart.minimum ? x1 + bulletChart.targetWidth / 2 : x1,
        "y1": y1,
        "x2": value === bulletChart.maximum ? x1 - bulletChart.targetWidth / 2 : value === bulletChart.minimum ? x1 + bulletChart.targetWidth / 2 : x1,
        "y2": y2,
        "stroke-width": bulletChart.targetWidth,
        "stroke": bulletChart.dataSource[i][bulletChart.targetColor] || bulletChart.targetColor || "black"
      };
      return compareMeasureOptions;
    };
    ScaleGroup2.prototype.compareVMeasure = function(x1, x2, y1, i) {
      var bulletChart = this.bulletChart;
      var compareMeasureOptions = {
        "class": bulletChart.svgObject.id + "_ComparativeMeasure",
        "id": bulletChart.svgObject.id + "_ComparativeMeasure_" + i,
        "x1": x1,
        "y1": y1,
        "x2": x2,
        "y2": y1,
        "stroke-width": bulletChart.targetWidth,
        "stroke": bulletChart.dataSource[i][bulletChart.targetColor] || bulletChart.targetColor || "black"
      };
      return compareMeasureOptions;
    };
    ScaleGroup2.prototype.calculateFeatureMeasureBounds = function(value, categoryValue, isHorizontal) {
      var bulletChart = this.bulletChart;
      var min = bulletChart.minimum;
      value = value < min && min <= 0 ? min : value;
      if (value >= min) {
        var pointX = void 0;
        var lastPointX = void 0;
        var width = void 0;
        var loc = isHorizontal ? bulletChart.initialClipRect.x : bulletChart.initialClipRect.y;
        var scaleLength = isHorizontal ? bulletChart.initialClipRect.width : bulletChart.initialClipRect.height;
        var delta = bulletChart.maximum - bulletChart.minimum;
        var valueDiff = bulletChart.maximum - value;
        var orientation_1 = (!bulletChart.enableRtl ? "forward" : "backward") + this.scaleOrientation.toLowerCase();
        categoryValue = isNullOrUndefined(categoryValue) ? "" : categoryValue;
        var stringLength = measureText(categoryValue.toString(), bulletChart.labelStyle, this.bulletChart.themeStyle.axisLabelFont).width;
        switch (orientation_1) {
          case "forwardhorizontal":
          case "backwardvertical":
            pointX = loc + (min > 0 ? 0 : scaleLength / delta * Math.abs(min));
            width = scaleLength / (delta / (min > 0 ? delta - valueDiff : value));
            if (value < 0) {
              width = Math.abs(width);
              pointX -= width;
            }
            width = pointX + width < loc + scaleLength ? width : loc + scaleLength - pointX;
            lastPointX = loc - (orientation_1 === "forwardhorizontal" ? stringLength / 2 + 5 : this.labelOffset);
            break;
          default:
            pointX = loc + (scaleLength - scaleLength / (delta / (delta - valueDiff)));
            width = min > 0 ? scaleLength / (delta / (delta - valueDiff)) : scaleLength / (delta / value);
            if (value < 0) {
              width = Math.abs(width);
              pointX -= width;
            }
            if (pointX < loc) {
              width = pointX + width - loc;
              pointX = loc;
            }
            lastPointX = loc + scaleLength + (orientation_1 === "backwardhorizontal" ? stringLength / 2 + 5 : 5);
            break;
        }
        return {
          pointX,
          width,
          lastPointX
        };
      }
      return null;
    };
    ScaleGroup2.prototype.doValueBarAnimation = function() {
      var valueBarElement = this.feature;
      if (!valueBarElement) {
        return null;
      }
      var animateOption = this.bulletChart.animation;
      var animateDuration = this.bulletChart.animateSeries ? this.bulletChart.animation.duration : animateOption.duration;
      var effectType = getAnimationFunction("Linear");
      var isValuePlot = this.bulletChart.dataSource < 0;
      var valueX;
      var valueY;
      var elementBarHeight = valueBarElement.getBoundingClientRect().height;
      var elementBarWidth = valueBarElement.getBoundingClientRect().width;
      var centerX;
      var centerY;
      var valueActual;
      if (this.bulletChart.orientation === "Horizontal" && valueBarElement) {
        valueY = parseInt(valueBarElement.getAttribute("height"), 10);
        valueX = parseInt(valueBarElement.getAttribute("x"), 10);
        centerY = isValuePlot ? valueY : valueY + elementBarHeight;
        centerX = valueX;
      }
      valueBarElement.style.visibility = "hidden";
      new Animation({}).animate(valueBarElement, {
        duration: animateDuration === 0 && animationMode === "Enable" ? 1e3 : animateDuration,
        delay: animateOption.delay,
        progress: function(args) {
          if (args.timeStamp >= args.delay) {
            valueBarElement.style.visibility = "visible";
            elementBarWidth = elementBarWidth ? elementBarWidth : 1;
            valueActual = effectType(args.timeStamp - args.delay, 0, elementBarWidth, args.duration);
            valueBarElement.setAttribute("transform", "translate(" + centerX + " " + centerY + ") scale(" + valueActual / elementBarWidth + ", 1) translate(" + -centerX + " " + -centerY + ")");
          }
        },
        end: function() {
          valueBarElement.setAttribute("transform", "translate(0,0)");
          valueBarElement.style.visibility = "visible";
        }
      });
    };
    ScaleGroup2.prototype.doTargetBarAnimation = function(index) {
      var x;
      var y;
      var centerX;
      var centerY;
      var targetBarelement = this.comparative[index];
      if (!targetBarelement) {
        return null;
      }
      if (this.bulletChart.orientation === "Horizontal" && targetBarelement) {
        y = parseFloat(targetBarelement.getAttribute("y1")) + parseFloat(targetBarelement.getAttribute("y2"));
        x = parseFloat(targetBarelement.getAttribute("x1"));
        centerY = y;
        centerX = x;
      }
      targetBarelement.style.visibility = "hidden";
      this.animateRect(targetBarelement, centerX, centerY, index + 1);
    };
    ScaleGroup2.prototype.animateRect = function(targetBarelement, centerX, centerY, index) {
      var _this = this;
      var effect = getAnimationFunction("Linear");
      var value;
      var option = this.bulletChart.animation;
      var threshold = this.comparative.length;
      var duration = this.bulletChart.animateSeries ? this.bulletChart.animation.duration : option.duration;
      new Animation({}).animate(targetBarelement, {
        duration: duration === 0 && animationMode === "Enable" ? 1e3 : duration,
        delay: option.delay,
        progress: function(args) {
          if (args.timeStamp >= args.delay) {
            targetBarelement.style.visibility = "visible";
            value = effect(args.timeStamp - args.delay, 0, 1, args.duration);
            targetBarelement.setAttribute("transform", "translate(" + centerX + " " + centerY / 2 + ") scale(1," + value + ") translate(" + -centerX + " " + -centerY / 2 + ")");
          }
        },
        end: function() {
          targetBarelement.setAttribute("transform", "translate(0,0)");
          if (index < threshold) {
            _this.doTargetBarAnimation(index + 1);
          }
        }
      });
    };
    return ScaleGroup2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/bullet-chart/bullet-chart.js
var __extends86 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate16 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var BulletChart = (
  /** @class */
  function(_super) {
    __extends86(BulletChart2, _super);
    function BulletChart2(options, element) {
      var _this = _super.call(this, options, element) || this;
      _this.bulletid = 57726;
      _this.animateSeries = true;
      _this.padding = 5;
      _this.leftSize = 0;
      _this.rightSize = 0;
      _this.topSize = 0;
      _this.bottomSize = 0;
      _this.maxLabelSize = new Size(0, 0);
      _this.maxTitleSize = new Size(0, 0);
      _this.intervalDivs = [10, 5, 2, 1];
      _this.currentLegendIndex = 0;
      _this.previousTargetId = "";
      return _this;
    }
    BulletChart2.prototype.preRender = function() {
      this.allowServerDataBinding = false;
      this.unWireEvents();
      this.initPrivateValues();
      this.setCulture();
      this.wireEvents();
    };
    BulletChart2.prototype.initPrivateValues = function() {
      this.delayRedraw = false;
      this.scale = new ScaleGroup(this);
      this.bulletAxis = new BulletChartAxis(this);
      if (this.element.id === "") {
        var collection = document.getElementsByClassName("e-BulletChart").length;
        this.element.id = "BulletChart_" + this.bulletid + "_" + collection;
      }
    };
    BulletChart2.prototype.setCulture = function() {
      this.intl = new Internationalization();
    };
    BulletChart2.prototype.render = function() {
      var _this = this;
      var loadEventData = {
        bulletChart: this,
        theme: this.theme,
        name: "load"
      };
      this.trigger("load", loadEventData, function() {
        _this.setTheme();
        _this.createSvg(_this);
        _this.findRange();
        if (_this.bulletChartLegendModule && _this.legendSettings.visible) {
          _this.calculateVisibleElements();
          _this.bulletChartLegendModule.getLegendOptions(_this.visibleRanges);
        }
        _this.calculatePosition();
        _this.renderBulletElements();
        _this.trigger("loaded", {
          bulletChart: _this
        });
        _this.allowServerDataBinding = true;
        _this.renderComplete();
      });
    };
    BulletChart2.prototype.setTheme = function() {
      this.themeStyle = getBulletThemeColor(this.theme);
      if ((this.targetColor === null || this.targetColor === "#191919" || this.valueFill == null) && (this.theme.indexOf("Fluent") > -1 || this.theme.indexOf("Bootstrap5") > -1 || this.theme.indexOf("Tailwind3") > -1)) {
        this.valueFill = !this.valueFill ? this.theme === "FluentDark" ? "#797775" : this.theme === "Bootstrap5" ? "#343A40" : this.theme === "Tailwind3" ? "#1F2937" : this.theme === "Tailwind3Dark" ? "#6B7280" : "#A19F9D" : this.valueFill;
        this.targetColor = this.targetColor === "#191919" ? this.theme === "FluentDark" ? "#797775" : this.theme === "Bootstrap5" ? "#343A40" : this.theme === "Tailwind3" ? "#1F2937" : this.theme === "Tailwind3Dark" ? "#6B7280" : "#A19F9D" : this.targetColor;
      }
      if ((this.targetColor === null || this.targetColor === "#191919" || this.valueFill == null) && (this.theme.indexOf("Material3") > -1 || this.theme.indexOf("Bootstrap5") > -1)) {
        this.valueFill = !this.valueFill ? this.theme === "Material3Dark" ? "#938F99" : this.theme === "Bootstrap5Dark" ? "#343A40" : "#79747E" : this.valueFill;
        this.targetColor = this.targetColor === "#191919" ? this.theme === "Material3Dark" ? "#938F99" : this.theme === "Bootstrap5Dark" ? "#343A40" : "#79747E" : this.targetColor;
      }
    };
    BulletChart2.prototype.findRange = function() {
      if (!this.minimum) {
        this.minimum = 0;
      }
      if (!this.maximum && this.ranges.length) {
        this.maximum = 0;
        for (var i = 0; i < this.ranges.length; i++) {
          this.maximum = this.maximum > this.ranges[i].end ? this.maximum : this.ranges[i].end;
        }
      }
      if (this.maximum === null) {
        if (!isNullOrUndefined(this.dataSource)) {
          for (var i = 0; i < Object.keys(this.dataSource).length; i++) {
            if (this.dataSource[i][this.targetField] > this.dataSource[i][this.valueField]) {
              this.maximum = this.maximum > this.dataSource[i][this.targetField] ? this.maximum + this.interval : this.dataSource[i][this.targetField] + this.interval;
            } else {
              this.maximum = this.maximum > this.dataSource[i][this.valueField] ? this.maximum + this.interval : this.dataSource[i][this.valueField] + this.interval;
            }
          }
        } else {
          this.maximum = 10;
        }
      }
      if (!this.interval) {
        this.interval = this.calculateNumericNiceInterval(this.maximum - this.minimum);
      }
    };
    BulletChart2.prototype.getActualDesiredIntervalsCount = function(availableSize) {
      var size = this.orientation === "Horizontal" ? availableSize.width : availableSize.height;
      var desiredIntervalsCount = (this.orientation === "Horizontal" ? 0.533 : 1) * 3;
      desiredIntervalsCount = Math.max(size * (desiredIntervalsCount / 100), 1);
      return desiredIntervalsCount;
    };
    BulletChart2.prototype.calculateNumericNiceInterval = function(delta) {
      var actualDesiredIntervalsCount = this.getActualDesiredIntervalsCount(this.availableSize);
      var niceInterval = delta / actualDesiredIntervalsCount;
      var minInterval = Math.pow(10, Math.floor(logBase(niceInterval, 10)));
      for (var _i = 0, _a = this.intervalDivs; _i < _a.length; _i++) {
        var interval = _a[_i];
        var currentInterval = minInterval * interval;
        if (actualDesiredIntervalsCount < delta / currentInterval) {
          break;
        }
        niceInterval = currentInterval;
      }
      return niceInterval;
    };
    BulletChart2.prototype.setSecondaryElementPosition = function() {
      var element = getElement2(this.element.id + "_Secondary_Element");
      if (!element) {
        return;
      }
      var rect = this.element.getBoundingClientRect();
      var svgRect = getElement2(this.element.id + "_svg").getBoundingClientRect();
      element.style.left = Math.max(svgRect.left - rect.left, 0) + "px";
      element.style.top = Math.max(svgRect.top - rect.top, 0) + "px";
      element.style.position = "relative";
    };
    BulletChart2.prototype.createSvg = function(chart) {
      this.removeSvg();
      chart.renderer = new SvgRenderer(chart.element.id);
      this.calculateAvailableSize(this);
      chart.svgObject = chart.renderer.createSvg({
        id: chart.element.id + "_svg",
        width: chart.availableSize.width,
        height: chart.availableSize.height
      });
      this.renderChartBackground();
    };
    BulletChart2.prototype.renderChartBackground = function() {
      var rect = new RectOption(this.element.id + "_ChartBorder", this.themeStyle.background, {
        width: this.border.width || 0,
        color: this.border.color || "transparent"
      }, 1, new Rect(0, 0, this.availableSize.width, this.availableSize.height), 0, 0, "", this.border.dashArray);
      this.svgObject.appendChild(this.renderer.drawRectangle(rect));
    };
    BulletChart2.prototype.renderBulletElements = function() {
      var scaleGroup = this.renderer.createGroup({
        "id": this.svgObject.id + "_scaleGroup"
      });
      this.renderBulletChartTitle();
      this.svgObject.appendChild(scaleGroup);
      this.rangeCollection = this.scale.drawScaleGroup(scaleGroup);
      var size = this.orientation === "Horizontal" ? this.initialClipRect.width : this.initialClipRect.height;
      var intervalValue = size / ((this.maximum - this.minimum) / this.interval);
      this.bulletAxis.renderMajorTickLines(intervalValue, scaleGroup);
      this.bulletAxis.renderMinorTickLines(intervalValue, scaleGroup);
      this.bulletAxis.renderAxisLabels(intervalValue, scaleGroup);
      this.bulletChartRect.x = this.titlePosition === "Left" || this.titlePosition === "Right" || this.orientation === "Vertical" ? this.bulletChartRect.x : 0;
      var elementId = this.element.id;
      if (this.element.tagName !== "g") {
        var tooltipDiv = redrawElement(this.redraw, elementId + "_Secondary_Element") || this.createElement("div");
        tooltipDiv.id = elementId + "_Secondary_Element";
        appendChildElement(false, this.element, tooltipDiv, this.redraw);
      }
      if (this.tooltip.enable) {
        appendChildElement(false, this.svgObject, this.renderer.createGroup({
          id: elementId + "_UserInteraction",
          style: "pointer-events:none;"
        }), this.redraw);
      }
      this.bindData();
      this.renderDataLabel();
      this.renderBulletLegend();
      this.element.appendChild(this.svgObject);
      this.setSecondaryElementPosition();
    };
    BulletChart2.prototype.renderBulletLegend = function() {
      if (this.bulletChartLegendModule && this.bulletChartLegendModule.legendCollections.length) {
        this.bulletChartLegendModule.calTotalPage = true;
        var bounds = this.bulletChartLegendModule.legendBounds;
        this.bulletChartLegendModule.renderLegend(this, this.legendSettings, bounds);
      }
    };
    BulletChart2.prototype.bulletResize = function() {
      var _this = this;
      this.animateSeries = false;
      var arg = {
        chart: this,
        name: resized,
        currentSize: new Size(0, 0),
        previousSize: new Size(this.availableSize.width, this.availableSize.height)
      };
      if (this.resizeTo) {
        clearTimeout(this.resizeTo);
      }
      this.resizeTo = +setTimeout(function() {
        if (_this.isDestroyed) {
          clearTimeout(_this.resizeTo);
          return;
        }
        _this.createSvg(_this);
        arg.currentSize = _this.availableSize;
        _this.trigger(resized, arg);
        _this.calculatePosition();
        _this.renderBulletElements();
      }, 500);
      return false;
    };
    BulletChart2.prototype.bindData = function() {
      if (this.dataSource != null) {
        this.dataCount = this.dataSource.length;
        this.drawMeasures(this.dataCount);
      }
    };
    BulletChart2.prototype.drawMeasures = function(dataCount) {
      this.scale.renderFeatureBar(dataCount);
      this.scale.renderComparativeSymbol(dataCount);
    };
    BulletChart2.prototype.calculatePosition = function() {
      var margin = this.margin;
      var titleHeight = 0;
      var subTitleHeight = 0;
      var titleSize = new Size(0, 0);
      var padding = 5;
      this.titleCollections = [];
      this.subTitleCollections = [];
      var maxTitlteWidth = 0;
      var maxTitlteHeight = 0;
      var maxVerticalTitlteHeight = padding;
      if (this.title) {
        this.titleCollections = getTitle(this.title, this.titleStyle, this.titleStyle.maximumTitleWidth, this.enableRtl, this.themeStyle.titleFont);
        titleHeight = measureText(this.title, this.titleStyle, this.themeStyle.titleFont).height * this.titleCollections.length + padding;
        for (var _i = 0, _a = this.titleCollections; _i < _a.length; _i++) {
          var titleText = _a[_i];
          titleSize = measureText(titleText, this.titleStyle, this.themeStyle.titleFont);
          maxTitlteWidth = titleSize.width > maxTitlteWidth ? titleSize.width : maxTitlteWidth;
          maxTitlteHeight = titleSize.height > maxTitlteHeight ? titleSize.height : maxTitlteHeight;
        }
        maxVerticalTitlteHeight += maxTitlteHeight;
        this.subTitleCollections = getTitle(this.subtitle, this.subtitleStyle, this.titleStyle.maximumTitleWidth, this.enableRtl);
        if (this.subtitle) {
          for (var _b = 0, _c = this.subTitleCollections; _b < _c.length; _b++) {
            var subText = _c[_b];
            titleSize = measureText(subText, this.subtitleStyle, this.themeStyle.subTitleFont);
            maxTitlteWidth = titleSize.width > maxTitlteWidth ? titleSize.width : maxTitlteWidth;
            maxTitlteHeight = titleSize.height > maxTitlteHeight ? titleSize.height : maxTitlteHeight;
          }
          subTitleHeight = measureText(this.subtitle, this.subtitleStyle, this.themeStyle.subTitleFont).height * this.subTitleCollections.length + padding;
          maxVerticalTitlteHeight += maxTitlteHeight;
        }
      }
      this.maxTitleSize = new Size(maxTitlteWidth, this.orientation === "Vertical" ? maxVerticalTitlteHeight : maxTitlteHeight);
      this.maxLabelSize = this.getMaxLabelWidth();
      this.initialClipRect = this.getBulletBounds(this.orientation === "Vertical" ? maxVerticalTitlteHeight : maxTitlteWidth, titleHeight, subTitleHeight, margin);
      this.bulletChartRect = new Rect(this.initialClipRect.x, this.initialClipRect.y, this.initialClipRect.width, this.initialClipRect.height);
      if (this.bulletChartLegendModule) {
        this.bulletChartLegendModule.calculateLegendBounds(this.initialClipRect, this.availableSize, this.maxLabelSize);
      }
    };
    BulletChart2.prototype.getBulletBounds = function(maxTitlteWidth, titleHeight, subTitleHeight, margin) {
      var padding = 5;
      var rect = new Rect(0, 0, 0, 0);
      var enableRtl = this.enableRtl;
      var labelSpace = this.labelPosition === this.tickPosition ? padding : 0;
      var tickSize = this.tickPosition === "Inside" ? 0 : this.majorTickLines.height;
      var labelSize = this.labelPosition === "Inside" ? 0 : padding + (this.tickPosition === "Outside" ? 0 : measureText(this.maximum.toString(), this.labelStyle, this.themeStyle.dataLabelFont).height);
      var topAxisLabel = 0;
      var bottomAxisLabel = 0;
      var leftAxisLabel = 0;
      var rightAxisLabel = 0;
      var topCategory = 0;
      var bottomCategory = 0;
      var leftCategory = 0;
      var rightCategory = 0;
      var title = maxTitlteWidth;
      var format = this.bulletAxis.getFormat(this);
      var isCustomFormat = format.match("{value}") !== null;
      this.bulletAxis.format = this.intl.getNumberFormat({
        format: isCustomFormat ? "" : format,
        useGrouping: this.enableGroupSeparator
      });
      var formatted = measureText(this.bulletAxis.formatValue(this.bulletAxis, isCustomFormat, format, this.maximum), this.labelStyle, this.themeStyle.axisLabelFont).width;
      var categoryLabelSize;
      if (this.orientation === "Horizontal") {
        categoryLabelSize = this.maxLabelSize.width;
        topAxisLabel = this.opposedPosition ? tickSize + labelSize + labelSpace : 0;
        bottomAxisLabel = !this.opposedPosition ? tickSize + labelSize + labelSpace : 0;
        leftCategory = categoryLabelSize && !enableRtl ? categoryLabelSize : 0;
        leftCategory += title && this.titlePosition === "Left" ? padding * 3 : 0;
        rightCategory = categoryLabelSize && enableRtl ? categoryLabelSize : 0;
        rightCategory += title && this.titlePosition === "Right" ? padding : 0;
      } else {
        categoryLabelSize = this.maxLabelSize.height;
        rightAxisLabel = this.opposedPosition ? tickSize + labelSpace : 0;
        rightAxisLabel += this.opposedPosition && this.labelPosition !== "Inside" ? formatted : 0;
        leftAxisLabel = !this.opposedPosition ? tickSize + labelSpace : 0;
        leftAxisLabel += !this.opposedPosition && this.labelPosition !== "Inside" ? formatted : 0;
        topCategory = categoryLabelSize && enableRtl ? categoryLabelSize + padding : 0;
        bottomCategory = categoryLabelSize && !enableRtl ? categoryLabelSize + padding : 0;
      }
      switch (this.titlePosition) {
        case "Left":
          rect.x = margin.left + title + leftCategory + leftAxisLabel;
          rect.width = this.availableSize.width - margin.right - rect.x - rightCategory - rightAxisLabel < 0 ? 0 : this.availableSize.width - margin.right - rect.x - rightCategory - rightAxisLabel;
          rect.y = margin.top + topAxisLabel + topCategory;
          rect.height = this.availableSize.height - rect.y - margin.bottom - bottomAxisLabel - bottomCategory < 0 ? 0 : this.availableSize.height - rect.y - margin.bottom - bottomAxisLabel - bottomCategory;
          break;
        case "Right":
          rect.x = margin.left + leftCategory + leftAxisLabel;
          rect.width = this.availableSize.width - rightAxisLabel - margin.right - rect.x - (title + padding) - rightCategory < 0 ? 0 : this.availableSize.width - rightAxisLabel - margin.right - rect.x - (title + padding) - rightCategory;
          rect.y = margin.top + topAxisLabel + topCategory;
          rect.height = this.availableSize.height - rect.y - margin.bottom - bottomAxisLabel - bottomCategory < 0 ? 0 : this.availableSize.height - rect.y - margin.bottom - bottomAxisLabel - bottomCategory;
          break;
        case "Top":
          rect.x = margin.left + leftAxisLabel + leftCategory;
          rect.width = this.availableSize.width - margin.right - rect.x - rightCategory - rightAxisLabel < 0 ? 0 : this.availableSize.width - margin.right - rect.x - rightCategory - rightAxisLabel;
          rect.y = margin.top + (titleHeight + subTitleHeight) + topAxisLabel + topCategory;
          rect.height = this.availableSize.height - rect.y - margin.bottom - bottomAxisLabel - bottomCategory < 0 ? 0 : this.availableSize.height - rect.y - margin.bottom - bottomAxisLabel - bottomCategory;
          break;
        case "Bottom":
          rect.x = margin.left + leftAxisLabel + leftCategory;
          rect.y = margin.top + topAxisLabel + topCategory;
          rect.width = this.availableSize.width - margin.right - rect.x - rightCategory - rightAxisLabel < 0 ? 0 : this.availableSize.width - margin.right - rect.x - rightCategory - rightAxisLabel;
          rect.height = this.availableSize.height - rect.y - bottomCategory - margin.bottom - bottomAxisLabel - (titleHeight + subTitleHeight) < 0 ? 0 : this.availableSize.height - rect.y - bottomCategory - margin.bottom - bottomAxisLabel - (titleHeight + subTitleHeight);
          break;
      }
      return rect;
    };
    BulletChart2.prototype.getMaxLabelWidth = function() {
      this.maxLabelSize = new Size(0, 0);
      if (!this.categoryField) {
        return this.maxLabelSize;
      }
      var label;
      if (!isNullOrUndefined(this.dataSource)) {
        for (var i = 0, len = Object.keys(this.dataSource).length; i < len; i++) {
          label = measureText(this.dataSource[i][this.categoryField] || "", this.categoryLabelStyle, this.themeStyle.axisLabelFont);
          if (label.width > this.maxLabelSize.width) {
            this.maxLabelSize.width = label.width;
          }
          if (label.height > this.maxLabelSize.height) {
            this.maxLabelSize.height = label.height;
          }
        }
      }
      return this.maxLabelSize;
    };
    BulletChart2.prototype.calculateVisibleElements = function() {
      var range;
      var rangeCollection = this.ranges;
      this.visibleRanges = [];
      for (var i = 0, len = rangeCollection.length; i < len; i++) {
        range = rangeCollection[i];
        range.index = i;
        this.visibleRanges.push(range);
        rangeCollection[i] = range;
      }
    };
    BulletChart2.prototype.renderBulletChartTitle = function() {
      var margin = this.margin;
      var x = 0;
      var y = 0;
      var padding = 5;
      var anchor = "middle";
      var transform = "";
      var alignment = this.titleStyle.textAlignment;
      var elementSize = measureText(this.title, this.titleStyle, this.themeStyle.titleFont);
      var subTitleSize = this.subtitle ? measureText(this.subtitle, this.subtitleStyle, this.themeStyle.subTitleFont) : new Size(0, 0);
      if (this.title) {
        if (this.orientation === "Horizontal") {
          switch (this.titlePosition) {
            case "Top":
              x = this.findHorizontalAlignment(margin);
              anchor = alignment === "Far" ? "end" : alignment === "Near" ? "start" : "middle";
              y = margin.top + elementSize.height / 2 + padding;
              break;
            case "Bottom":
              x = this.findHorizontalAlignment(margin);
              anchor = alignment === "Far" ? "end" : alignment === "Near" ? "start" : "middle";
              y = this.availableSize.height - margin.bottom - elementSize.height / 3 + padding * 2 - (subTitleSize.height ? subTitleSize.height + padding : 0);
              break;
            case "Left":
              anchor = "end";
              x = margin.left + this.maxTitleSize.width;
              y = this.margin.top + this.availableSize.height / 2 - elementSize.height / 3 - (subTitleSize.height ? subTitleSize.height : 0);
              break;
            case "Right":
              anchor = "start";
              x = this.availableSize.width - margin.right - this.maxTitleSize.width + padding;
              y = this.margin.top + this.availableSize.height / 2 - elementSize.height / 3 - (subTitleSize.height ? subTitleSize.height : 0);
              break;
          }
        } else {
          switch (this.titlePosition) {
            case "Top":
              x = this.availableSize.width / 2 + padding * 2;
              y = this.margin.top + elementSize.height / 2 + padding;
              break;
            case "Bottom":
              x = this.availableSize.width / 2;
              y = this.availableSize.height - this.margin.bottom - elementSize.height / 3 + padding * 2 - (subTitleSize.height ? subTitleSize.height + padding : 0);
              break;
            case "Left":
              y = this.findVerticalAlignment(margin);
              anchor = alignment === "Far" ? "start" : alignment === "Near" ? "end" : "middle";
              x = margin.left;
              break;
            case "Right":
              x = this.availableSize.width - margin.right - elementSize.height / 3;
              anchor = alignment === "Far" ? "start" : alignment === "Near" ? "end" : "middle";
              y = this.findVerticalAlignment(margin);
              break;
          }
          transform = this.titlePosition === "Left" ? "rotate(-90," + x + "," + y + ")" : this.titlePosition === "Right" ? "rotate(90," + x + "," + y + ")" : "";
        }
        var options = new TextOption(this.element.id + "_BulletChartTitle", x, y, anchor, this.titleCollections, transform, "auto");
        var element = textElement2(this.renderer, options, this.titleStyle, this.titleStyle.color || this.themeStyle.titleFont.color, this.svgObject, null, null, null, null, null, null, null, null, null, null, this.themeStyle.titleFont);
        if (element) {
          element.setAttribute("aria-label", this.title + ". Syncfusion interactive chart.");
          element.setAttribute("tabindex", "0");
          element.style.outline = "none";
          element.setAttribute("role", "img");
        }
        if (this.subtitle) {
          this.renderBulletChartSubTitle(x, y, anchor);
        }
      }
    };
    BulletChart2.prototype.renderDataLabel = function() {
      var x = 0;
      var y = 0;
      var anchor;
      var transform = "";
      var enableRtl = this.enableRtl;
      var data;
      var featureBounds;
      var alignment = this.dataLabel.labelStyle.textAlignment;
      var format = this.labelFormat ? this.labelFormat : "";
      var isCustomFormat = format.match("{value}") !== null;
      if (this.dataLabel.enable) {
        for (var i = 0, len = Object.keys(this.dataSource).length; i < len; i++) {
          data = this.dataSource[i];
          featureBounds = this.scale.featureBarBounds[i];
          var labelText = data[this.valueField].toString();
          this.format = this.intl.getNumberFormat({
            format: isCustomFormat ? "" : format,
            useGrouping: this.enableGroupSeparator
          });
          labelText = isCustomFormat ? format.replace("{value}", this.format(labelText)) : labelText;
          var labelSize = measureText(labelText, this.dataLabel.labelStyle, this.themeStyle.axisLabelFont);
          var textWidth = labelSize["width"];
          var textHeight = labelSize["height"];
          if (this.orientation === "Horizontal") {
            anchor = this.type === "Rect" ? "end" : enableRtl ? "end" : "start";
            x = this.findTextAlignment(featureBounds, textWidth, alignment);
            if (x - textWidth < this.initialClipRect.x) {
              anchor = "start";
            }
            if (x > this.initialClipRect.width) {
              x -= textWidth;
            }
            y = featureBounds.y + featureBounds.height / 2;
          } else {
            anchor = "middle";
            x = featureBounds.y + featureBounds.height / 2;
            y = this.findTextAlignment(featureBounds, textWidth, alignment);
            if (y + textHeight / 2 > this.initialClipRect.height + this.initialClipRect.y) {
              y = y - textHeight / 3;
            }
          }
          var labelOptions = new TextOption(this.element.id + "_DataLabel_" + i, x, y, anchor, labelText, transform, "middle");
          textElement2(this.renderer, labelOptions, this.dataLabel.labelStyle, this.dataLabel.labelStyle.color || this.themeStyle.dataLabelFont.color, this.svgObject, null, null, null, null, null, null, null, null, null, null, this.themeStyle.dataLabelFont);
        }
      }
    };
    BulletChart2.prototype.findTextAlignment = function(featureBounds, textWidth, alignment) {
      var elementSpacing = 10;
      var x = 0;
      switch (alignment) {
        case "Center":
          x = featureBounds.x + featureBounds.width / 2;
          break;
        case "Near":
          x = featureBounds.x + (this.orientation === "Horizontal" ? this.enableRtl ? featureBounds.width - elementSpacing / 2 : elementSpacing / 2 : this.enableRtl ? elementSpacing : featureBounds.width);
          break;
        case "Far":
          x = featureBounds.x + (this.orientation === "Horizontal" ? (this.enableRtl ? this.type === "Rect" ? textWidth + elementSpacing : -elementSpacing : featureBounds.width) + (this.type === "Rect" ? -elementSpacing / 2 : elementSpacing / 2) : (this.enableRtl ? featureBounds.width + (this.type === "Rect" ? -elementSpacing : elementSpacing) : 0) + (this.type === "Rect" ? elementSpacing : -elementSpacing));
          break;
      }
      return x;
    };
    BulletChart2.prototype.findHorizontalAlignment = function(margin) {
      var x = 0;
      switch (this.titleStyle.textAlignment) {
        case "Center":
          x = (this.availableSize.width - margin.left - margin.right) / 2;
          break;
        case "Near":
          x = margin.left;
          break;
        case "Far":
          x = this.availableSize.width - margin.right;
          break;
      }
      return x;
    };
    BulletChart2.prototype.findVerticalAlignment = function(margin) {
      var y = 0;
      switch (this.titleStyle.textAlignment) {
        case "Center":
          y = (this.availableSize.height - margin.top - margin.bottom) / 2;
          break;
        case "Near":
          y = margin.top;
          break;
        case "Far":
          y = this.availableSize.height - margin.bottom;
          break;
      }
      return y;
    };
    BulletChart2.prototype.renderBulletChartSubTitle = function(x, y, anchor) {
      var margin = this.margin;
      var padding = 5;
      var transform = "";
      var elementSize = measureText(this.subtitle, this.subtitleStyle, this.themeStyle.subTitleFont);
      if (this.orientation === "Horizontal") {
        switch (this.titlePosition) {
          case "Top":
            y = y + elementSize.height + padding / 2;
            break;
          case "Bottom":
            y = this.availableSize.height - margin.bottom - elementSize.height / 3 + padding;
            break;
          case "Left":
            y = y + elementSize.height + padding / 2;
            break;
          case "Right":
            y = y + elementSize.height + padding / 2;
            break;
        }
      } else {
        switch (this.titlePosition) {
          case "Top":
            y = y + elementSize.height + padding / 2;
            break;
          case "Bottom":
            y = this.availableSize.height - margin.bottom - elementSize.height / 3 + padding;
            break;
          case "Left":
            x += elementSize.height + padding / 2;
            break;
          case "Right":
            x -= elementSize.height + padding / 2;
            break;
        }
        transform = this.titlePosition === "Left" ? "rotate(-90," + x + "," + y + ")" : this.titlePosition === "Right" ? "rotate(90," + x + "," + y + ")" : "";
      }
      var subTitleOptions = new TextOption(this.element.id + "_BulletChartSubTitle", x, y, anchor, this.subTitleCollections, transform, "auto");
      var element = textElement2(this.renderer, subTitleOptions, this.subtitleStyle, this.subtitleStyle.color || this.themeStyle.subTitleFont.color, this.svgObject, null, null, null, null, null, null, null, null, null, null, this.themeStyle.subTitleFont);
      if (element) {
        element.setAttribute("aria-label", this.subtitle);
        element.setAttribute("tabindex", "0");
        element.style.outline = "none";
        element.setAttribute("role", "img");
      }
    };
    BulletChart2.prototype.calculateAvailableSize = function(bulletChart) {
      var containerWidth = this.element.clientWidth || this.element.offsetWidth || 200;
      var height = this.orientation === "Vertical" ? 450 : this.titlePosition === "Left" || this.titlePosition === "Right" ? 83 : 126;
      var containerHeight = this.element.clientHeight || height;
      bulletChart.availableSize = new Size(stringToNumber(bulletChart.width, containerWidth) || containerWidth, stringToNumber(bulletChart.height, containerHeight) || containerHeight);
    };
    BulletChart2.prototype.removeSvg = function() {
      var svgElement = document.getElementById(this.element.id + "_svg");
      if (svgElement) {
        remove(svgElement);
      }
    };
    BulletChart2.prototype.getPersistData = function() {
      var keyEntity = ["loaded"];
      return this.addOnPersist(keyEntity);
    };
    BulletChart2.prototype.unWireEvents = function() {
      var startEvent = Browser.touchStartEvent;
      var moveEvent = Browser.touchMoveEvent;
      var cancelEvent = Browser.isPointer ? "pointerleave" : "mouseleave";
      EventHandler.remove(this.element, startEvent, this.bulletMouseDown);
      EventHandler.remove(this.element, moveEvent, this.bulletMouseMove);
      EventHandler.remove(this.element, cancelEvent, this.bulletMouseLeave);
      EventHandler.remove(this.element, "click", this.bulletChartOnMouseClick);
      EventHandler.remove(this.element, "keyup", this.chartKeyUp);
      EventHandler.remove(this.element, "keydown", this.chartKeyDown);
      window.removeEventListener(Browser.isTouch && "orientation" in window && "onorientationchange" in window ? "orientationchange" : "resize", this.resizeBound);
    };
    BulletChart2.prototype.wireEvents = function() {
      var cancelEvent = Browser.isPointer ? "pointerleave" : "mouseleave";
      EventHandler.add(this.element, Browser.touchMoveEvent, this.bulletMouseMove, this);
      EventHandler.add(this.element, cancelEvent, this.bulletMouseLeave, this);
      EventHandler.add(this.element, Browser.touchStartEvent, this.bulletMouseDown, this);
      EventHandler.add(this.element, "click", this.bulletChartOnMouseClick, this);
      EventHandler.add(this.element, "keyup", this.chartKeyUp, this);
      EventHandler.add(this.element, "keydown", this.chartKeyDown, this);
      this.resizeBound = this.bulletResize.bind(this);
      window.addEventListener(Browser.isTouch && "orientation" in window && "onorientationchange" in window ? "orientationchange" : "resize", this.resizeBound);
      this.setStyle(this.element);
    };
    BulletChart2.prototype.chartKeyDown = function(e) {
      if (e.code === "Tab") {
        this.removeNavigationStyle();
      }
    };
    BulletChart2.prototype.setStyle = function(element) {
      element.style.position = "relative";
      element.style.display = "block";
    };
    BulletChart2.prototype.bulletMouseMove = function(e) {
      var pageX = e.clientX;
      var pageY = e.clientY;
      this.setPointMouseXY(pageX, pageY);
      var targetId = e.target.id;
      var targetClass = e.target.className["baseVal"];
      if (targetClass !== this.svgObject.id + "_FeatureMeasure" || this.svgObject.id + "_ComparativeMeasure") {
        if (!isNullOrUndefined(this.dataSource)) {
          for (var i = 0; i < Object.keys(this.dataSource).length; i++) {
            document.getElementById(this.svgObject.id + "_FeatureMeasure_" + i).setAttribute("opacity", "1");
            document.getElementById(this.svgObject.id + "_ComparativeMeasure_" + i).setAttribute("opacity", "1");
          }
        }
      }
      if (!this.isTouchEvent(e)) {
        var id = "tooltipDiv" + this.element.id;
        var tooltipDiv = document.getElementById(id);
        if (tooltipDiv) {
          if (this.isReact) {
            this.clearTemplate();
          }
          remove(tooltipDiv);
        }
        if (this.bulletTooltipModule) {
          this.bulletTooltipModule._elementTooltip(e, targetClass, targetId, this.mouseX);
          this.bulletTooltipModule._displayTooltip(e, targetClass, targetId, this.mouseX, this.mouseY);
        }
      }
    };
    BulletChart2.prototype.setPointMouseXY = function(pageX, pageY) {
      var svgClientRect = getElement2(this.svgObject.id).getBoundingClientRect();
      var elemntClientRect = this.element.getBoundingClientRect();
      this.mouseX = pageX - elemntClientRect.left - Math.max(svgClientRect.left - elemntClientRect.left, 0);
      this.mouseY = pageY - elemntClientRect.top - Math.max(svgClientRect.top - elemntClientRect.top, 0);
    };
    BulletChart2.prototype.bulletMouseLeave = function(e) {
      if (!this.isTouchEvent(e)) {
        var tooltipDiv = document.getElementById(".tooltipDiv" + this.element.id);
        if (tooltipDiv) {
          if (this.isReact) {
            this.clearTemplate();
          }
          remove(tooltipDiv);
        }
      }
    };
    BulletChart2.prototype.isTouchEvent = function(event2) {
      if (event2.pointerType === "touch" || event2.type.indexOf("touch") > -1) {
        return true;
      }
      return false;
    };
    BulletChart2.prototype.bulletMouseDown = function(e) {
      var pageX;
      var pageY;
      var touchArg;
      if (e.type === "touchstart") {
        this.isTouch = true;
        touchArg = e;
        pageX = touchArg.changedTouches[0].clientX;
        pageY = touchArg.changedTouches[0].clientY;
      } else {
        this.isTouch = e.pointerType === "touch";
        pageX = e.clientX;
        pageY = e.clientY;
      }
      this.setPointMouseXY(pageX, pageY);
      if (this.isTouchEvent(e)) {
        if (this.isReact) {
          this.clearTemplate();
        }
        var Element_1 = document.getElementById("tooltipDiv" + this.element.id);
        if (Element_1) {
          remove(Element_1);
        }
        var targetId = e.target.id;
        var targetClass = e.target.className["baseVal"];
        if (this.bulletTooltipModule) {
          this.bulletTooltipModule._elementTooltip(e, targetClass, targetId, this.mouseX);
          this.bulletTooltipModule._displayTooltip(e, targetClass, targetId, this.mouseX, this.mouseY);
        }
      }
      this.removeNavigationStyle();
    };
    BulletChart2.prototype.bulletChartOnMouseClick = function(e) {
      var element = e.target;
      this.trigger(bulletChartMouseClick, {
        target: element.id,
        x: this.mouseX,
        y: this.mouseY
      });
      this.notify("click", e);
      this.removeNavigationStyle();
      return false;
    };
    BulletChart2.prototype.print = function(id) {
      new PrintUtils(this).print(id);
    };
    BulletChart2.prototype.export = function(type, fileName, orientation, controls, width, height, isVertical) {
      controls = controls ? controls : [this];
      new ExportUtils(this).export(type, fileName, orientation, controls, width, height, isVertical);
    };
    BulletChart2.prototype.chartKeyUp = function(e) {
      var targetId = e.target["id"];
      var groupElement;
      var targetElement = e.target;
      var legendElement = getElement2(this.element.id + "_chart_legend_translate_g");
      this.removeNavigationStyle();
      if (e.code === "Tab") {
        this.setNavigationStyle(targetId);
      }
      if (legendElement) {
        var firstChild = legendElement.firstElementChild;
        var className = firstChild.getAttribute("class");
        if (className && className.indexOf("e-bullet-chart-focused") === -1) {
          className = className + " e-bullet-chart-focused";
        } else if (!className) {
          className = "e-bullet-chart-focused";
        }
        firstChild.setAttribute("class", className);
      }
      if (e.code === "Tab") {
        if (this.previousTargetId !== "") {
          if (this.previousTargetId.indexOf("_chart_legend_g_") > -1 && targetId.indexOf("_chart_legend_g_") === -1) {
            groupElement = getElement2(this.element.id + "_chart_legend_translate_g");
            this.setTabIndex(groupElement.children[this.currentLegendIndex], groupElement.firstElementChild);
          }
        }
        this.previousTargetId = targetId;
      } else if (e.code.indexOf("Arrow") > -1) {
        e.preventDefault();
        if (targetId.indexOf("_chart_legend_") > -1) {
          var legendElement_1 = targetElement.parentElement.children;
          legendElement_1[this.currentLegendIndex].removeAttribute("tabindex");
          this.currentLegendIndex += e.code === "ArrowUp" || e.code === "ArrowRight" ? 1 : -1;
          this.currentLegendIndex = this.getActualIndex(this.currentLegendIndex, legendElement_1.length);
          var currentLegend = legendElement_1[this.currentLegendIndex];
          this.focusChild(currentLegend);
          this.removeNavigationStyle();
          this.setNavigationStyle(currentLegend.id);
          targetId = currentLegend.children[1].id;
        }
      }
      return false;
    };
    BulletChart2.prototype.setNavigationStyle = function(target) {
      var currentElement = document.getElementById(target);
      if (currentElement) {
        currentElement.style.setProperty("outline", "1.5px solid " + this.themeStyle.tabColor);
      }
    };
    BulletChart2.prototype.removeNavigationStyle = function() {
      var currentElement = document.querySelectorAll("[id*=" + this.element.id + "], [id*=_ChartBorder], text[id*=_title], text[id*=_BulletChartTitle] ,g[id*=_chart_legend]");
      if (currentElement) {
        currentElement.forEach(function(element) {
          if (element instanceof HTMLElement || element instanceof SVGElement) {
            element.style.setProperty("outline", "none");
          }
        });
      }
    };
    BulletChart2.prototype.setTabIndex = function(previousElement, currentElement) {
      if (previousElement) {
        previousElement.removeAttribute("tabindex");
      }
      if (currentElement) {
        currentElement.setAttribute("tabindex", "0");
      }
    };
    BulletChart2.prototype.getActualIndex = function(index, totalLength) {
      return index > totalLength - 1 ? 0 : index < 0 ? totalLength - 1 : index;
    };
    BulletChart2.prototype.focusChild = function(element) {
      element.setAttribute("tabindex", "0");
      var className = element.getAttribute("class");
      element.setAttribute("tabindex", "0");
      if (className && className.indexOf("e-bullet-chart-focused") === -1) {
        className = "e-bullet-chart-focused " + className;
      } else if (!className) {
        className = "e-bullet-chart-focused";
      }
      element.setAttribute("class", className);
      element.focus();
      return element.id;
    };
    BulletChart2.prototype.onPropertyChanged = function(newProp) {
      var renderer = false;
      var refreshBounds = false;
      this.animateSeries = false;
      if (!this.delayRedraw) {
        for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
          var prop = _a[_i];
          switch (prop) {
            case "height":
            case "width":
              this.createSvg(this);
              refreshBounds = true;
              break;
            case "subtitle":
            case "title":
              refreshBounds = true;
              break;
            case "tickPosition":
              renderer = true;
              break;
            case "labelPosition":
              renderer = true;
              break;
            case "titlePosition":
              renderer = true;
              break;
            case "minimum":
            case "maximum":
            case "interval":
              refreshBounds = true;
              break;
            case "majorTickLines":
            case "minorTickLines":
            case "type":
            case "ranges":
            case "valueFill":
            case "targetColor":
              refreshBounds = true;
              break;
            case "titleStyle":
              if (newProp.titleStyle) {
                refreshBounds = true;
              } else {
                renderer = true;
              }
              break;
            case "subtitleStyle":
              if (newProp.subtitleStyle && (newProp.subtitleStyle.size || newProp.subtitleStyle.textOverflow)) {
                refreshBounds = true;
              } else {
                renderer = true;
              }
              break;
            case "border":
              renderer = true;
              break;
            case "opposedPosition":
              renderer = true;
              break;
            case "dataSource":
              this.bindData();
              refreshBounds = true;
              break;
            case "theme":
              this.animateSeries = true;
              break;
            case "enableRtl":
            case "locale":
            case "currencyCode":
              _super.prototype.refresh.call(this);
              break;
          }
        }
        if (!refreshBounds && renderer) {
          this.removeSvg();
          this.renderBulletElements();
          this.trigger("loaded", {
            bulletChart: this
          });
        }
        if (refreshBounds) {
          this.render();
          this.trigger("loaded", {
            bulletChart: this
          });
          this.redraw = false;
        }
      }
    };
    BulletChart2.prototype.requiredModules = function() {
      var modules = [];
      var rangeName;
      for (var i = 0; i < this.ranges.length; i++) {
        if (this.ranges[i].name !== null) {
          rangeName = true;
        }
      }
      this.isLegend = this.legendSettings.visible && (rangeName || !!this.isLegend || this.targetField !== "" || this.valueField !== "");
      if (this.tooltip.enable) {
        modules.push({
          member: "BulletTooltip",
          args: [this]
        });
      }
      if (this.isLegend) {
        modules.push({
          member: "BulletChartLegend",
          args: [this]
        });
      }
      return modules;
    };
    BulletChart2.prototype.getModuleName = function() {
      return "bulletChart";
    };
    BulletChart2.prototype.destroy = function() {
      this.unWireEvents();
      _super.prototype.destroy.call(this);
      this.removeSvg();
      this.svgObject = null;
      this.element.classList.remove("e-BulletChart");
      this.element.innerText = "";
      var element = document.getElementById(this.element.id + "Keyboard_bullet_chart_focus");
      if (element) {
        element.remove();
      }
      removeElement2("chartmeasuretext");
    };
    __decorate16([Property(null)], BulletChart2.prototype, "width", void 0);
    __decorate16([Property(null)], BulletChart2.prototype, "height", void 0);
    __decorate16([Property(null)], BulletChart2.prototype, "locale", void 0);
    __decorate16([Complex({}, MajorTickLinesSettings)], BulletChart2.prototype, "majorTickLines", void 0);
    __decorate16([Complex({}, MinorTickLinesSettings)], BulletChart2.prototype, "minorTickLines", void 0);
    __decorate16([Property(null)], BulletChart2.prototype, "minimum", void 0);
    __decorate16([Property(null)], BulletChart2.prototype, "maximum", void 0);
    __decorate16([Property(null)], BulletChart2.prototype, "interval", void 0);
    __decorate16([Property(4)], BulletChart2.prototype, "minorTicksPerInterval", void 0);
    __decorate16([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, BulletLabelStyle)], BulletChart2.prototype, "labelStyle", void 0);
    __decorate16([Complex({
      fontFamily: null,
      size: "12px",
      fontStyle: "Normal",
      fontWeight: "400",
      color: null
    }, BulletLabelStyle)], BulletChart2.prototype, "categoryLabelStyle", void 0);
    __decorate16([Property("")], BulletChart2.prototype, "labelFormat", void 0);
    __decorate16([Property("")], BulletChart2.prototype, "title", void 0);
    __decorate16([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, BulletLabelStyle)], BulletChart2.prototype, "titleStyle", void 0);
    __decorate16([Property("")], BulletChart2.prototype, "subtitle", void 0);
    __decorate16([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, BulletLabelStyle)], BulletChart2.prototype, "subtitleStyle", void 0);
    __decorate16([Property("Horizontal")], BulletChart2.prototype, "orientation", void 0);
    __decorate16([Complex({
      color: "#DDDDDD",
      width: 0
    }, Border)], BulletChart2.prototype, "border", void 0);
    __decorate16([Complex({}, BulletTooltipSettings)], BulletChart2.prototype, "tooltip", void 0);
    __decorate16([Collection([{
      end: null,
      opacity: 1,
      color: ""
    }, {
      end: null,
      opacity: 1,
      color: ""
    }, {
      end: null,
      opacity: 1,
      color: ""
    }], Range)], BulletChart2.prototype, "ranges", void 0);
    __decorate16([Property("Outside")], BulletChart2.prototype, "labelPosition", void 0);
    __decorate16([Property("Outside")], BulletChart2.prototype, "tickPosition", void 0);
    __decorate16([Property("Top")], BulletChart2.prototype, "titlePosition", void 0);
    __decorate16([Property(false)], BulletChart2.prototype, "opposedPosition", void 0);
    __decorate16([Property("Material")], BulletChart2.prototype, "theme", void 0);
    __decorate16([Complex({}, Animation2)], BulletChart2.prototype, "animation", void 0);
    __decorate16([Complex({}, BulletDataLabel)], BulletChart2.prototype, "dataLabel", void 0);
    __decorate16([Complex({}, BulletChartLegendSettings)], BulletChart2.prototype, "legendSettings", void 0);
    __decorate16([Property(false)], BulletChart2.prototype, "enableGroupSeparator", void 0);
    __decorate16([Complex({
      top: 15,
      bottom: 10,
      left: 15,
      right: 15
    }, Margin)], BulletChart2.prototype, "margin", void 0);
    __decorate16([Property(5)], BulletChart2.prototype, "targetWidth", void 0);
    __decorate16([Property("#191919")], BulletChart2.prototype, "targetColor", void 0);
    __decorate16([Property(6)], BulletChart2.prototype, "valueHeight", void 0);
    __decorate16([Property(null)], BulletChart2.prototype, "valueFill", void 0);
    __decorate16([Complex({
      color: "transparent",
      width: 0
    }, Border)], BulletChart2.prototype, "valueBorder", void 0);
    __decorate16([Property(null)], BulletChart2.prototype, "dataSource", void 0);
    __decorate16([Property(null)], BulletChart2.prototype, "query", void 0);
    __decorate16([Property(null)], BulletChart2.prototype, "categoryField", void 0);
    __decorate16([Property("Rect")], BulletChart2.prototype, "type", void 0);
    __decorate16([Property("")], BulletChart2.prototype, "valueField", void 0);
    __decorate16([Property("")], BulletChart2.prototype, "targetField", void 0);
    __decorate16([Property(["Rect", "Cross", "Circle"])], BulletChart2.prototype, "targetTypes", void 0);
    __decorate16([Property(0)], BulletChart2.prototype, "tabIndex", void 0);
    __decorate16([Event()], BulletChart2.prototype, "tooltipRender", void 0);
    __decorate16([Event()], BulletChart2.prototype, "load", void 0);
    __decorate16([Event()], BulletChart2.prototype, "loaded", void 0);
    __decorate16([Event()], BulletChart2.prototype, "bulletChartMouseClick", void 0);
    __decorate16([Event()], BulletChart2.prototype, "legendRender", void 0);
    __decorate16([Event()], BulletChart2.prototype, "beforePrint", void 0);
    BulletChart2 = __decorate16([NotifyPropertyChanges], BulletChart2);
    return BulletChart2;
  }(Component)
);

// node_modules/@syncfusion/ej2-charts/src/bullet-chart/user-interaction/tooltip.js
var BulletTooltip = (
  /** @class */
  function() {
    function BulletTooltip2(bullet) {
      this.control = bullet;
      this.elementId = bullet.element.id;
      this.bulletAxis = new BulletChartAxis(this.control);
    }
    BulletTooltip2.prototype._elementTooltip = function(e, targetClass, targetId, mouseX) {
      var tooltipDiv = this.control.createElement("div");
      tooltipDiv.id = "tooltip";
      tooltipDiv.className = "tooltipDiv";
      var target = e.target;
      var pageX = mouseX + 20;
      var pageY = e.clientY;
      var str = "";
      var font = this.control.tooltip.textStyle.fontStyle ? this.control.tooltip.textStyle.fontStyle : this.control.themeStyle.tooltipLabelFont.fontStyle;
      var fill = this.control.tooltip.fill ? this.control.tooltip.fill : this.control.themeStyle.tooltipFill;
      var color = this.control.themeStyle.tooltipLabelFont.color || this.control.themeStyle.tooltipBoldLabel;
      var style = "left:" + pageX + "px;top:" + pageY + 'px;display: block; position: absolute; "z-index": "13000",cursor: default;font-family: Segoe UI;color:' + color + "; font-size: 13px; background-color:" + fill + "; border: 1px solid #707070;font-style:" + font + ";";
      tooltipDiv.style.cssText = style;
      if (targetClass === this.control.svgObject.id + "_Caption") {
        str = target.textContent === this.control.title ? "" : this.control.title;
      } else if (targetClass === this.control.svgObject.id + "_SubTitle") {
        str = target.textContent === this.control.subtitle ? "" : this.control.subtitle;
      }
      if (str !== "") {
        tooltipDiv.innerHTML = "&nbsp" + str + "&nbsp";
        document.body.insertAdjacentElement("afterbegin", tooltipDiv);
      }
    };
    BulletTooltip2.prototype._displayTooltip = function(e, targetClass, targetId, mouseX, mouseY) {
      if (targetClass !== "undefined" && this.control.tooltip.enable && (targetClass === this.control.svgObject.id + "_FeatureMeasure" || targetClass === this.control.svgObject.id + "_ComparativeMeasure")) {
        var targetVal = [];
        var tooltipdiv = void 0;
        var format = this.bulletAxis.getFormat(this.control);
        var isCustomFormat = format.match("{value}") !== null;
        var measureId = targetId.substring(targetId.lastIndexOf("_") + 1);
        var targetValues = [];
        this.bulletAxis.format = this.bulletAxis.bulletChart.intl.getNumberFormat({
          format: isCustomFormat ? "" : format,
          useGrouping: this.bulletAxis.bulletChart.enableGroupSeparator
        });
        var currentVal = this.control.dataSource[measureId][this.control.valueField];
        targetVal = targetVal.concat(this.control.dataSource[measureId][this.control.targetField]);
        var categoryVal = this.control.dataSource[measureId][this.control.categoryField];
        var labelCurrentText = currentVal ? currentVal.toString() : "";
        var labelTargetText = targetVal ? targetVal.toString() : "";
        var labelCategoryText = categoryVal ? categoryVal.toString() : "";
        labelCurrentText = this.bulletAxis.formatValue(this.bulletAxis, isCustomFormat, format, +currentVal);
        for (var i = 0; i < targetVal.length; i++) {
          targetValues = targetValues.concat(this.bulletAxis.formatValue(this.bulletAxis, isCustomFormat, format, +targetVal[i]));
        }
        labelCategoryText = this.bulletAxis.formatValue(this.bulletAxis, isCustomFormat, format, +categoryVal);
        var data = {
          value: labelCurrentText,
          target: targetValues,
          category: labelCategoryText
        };
        var tooltipData = {
          value: labelCurrentText,
          target: labelTargetText,
          category: labelCategoryText
        };
        var style = "position: absolute; z-index: 13000; display: block;";
        if (document.getElementsByClassName("tooltipDiv" + this.control.element.id).length === 0) {
          tooltipdiv = this.control.createElement("div");
          tooltipdiv.id = "tooltipDiv" + this.control.element.id;
          tooltipdiv.style.cssText = style;
          document.getElementById(this.control.element.id + "_Secondary_Element").appendChild(tooltipdiv);
        }
        var argsData = {
          value: data.value,
          target: data.target,
          name: tooltipRender
        };
        if (this.control.tooltip.template !== "" && this.control.tooltip.template != null) {
          this.updateTemplateFn();
          var elem = this.control.createElement("div", {
            id: this.control.element.id + "parent_template"
          });
          var templateElement = this.templateFn(tooltipData, this.control, "template", elem.id + "_blazorTemplate", "", null, elem);
          while (templateElement && templateElement.length > 0) {
            if (templateElement.length === 1) {
              elem.appendChild(templateElement[0]);
              templateElement = null;
            } else {
              elem.appendChild(templateElement[0]);
            }
          }
          argsData.template = elem.innerHTML;
          this.control.trigger(tooltipRender, argsData);
          elem.innerHTML = argsData.template;
          tooltipdiv.appendChild(elem);
        } else {
          var argsText = "Value : " + argsData.value;
          for (var i = 0; i < argsData.target.length; i++) {
            argsText += "<br/> Target" + (i === 0 ? "" : "_" + i) + " : " + argsData.target[i];
          }
          argsData.text = argsText;
          this.control.trigger(tooltipRender, argsData);
          tooltipdiv.innerHTML = argsData.text;
          tooltipdiv.style.font = this.control.tooltip.textStyle.fontStyle ? this.control.tooltip.textStyle.fontStyle : this.control.themeStyle.tooltipLabelFont.fontStyle;
          tooltipdiv.style.color = this.control.themeStyle.tooltipLabelFont.color || this.control.themeStyle.tooltipBoldLabel;
          tooltipdiv.style.fontSize = this.control.themeStyle.titleFont.size;
        }
        var fill = this.control.tooltip.fill ? this.control.tooltip.fill : this.control.themeStyle.tooltipFill;
        var borderWidth = this.control.theme === "Fabric" || this.control.theme === "Fluent" && !this.control.tooltip.border.width ? 1 : this.control.tooltip.border.width;
        var borderColor = this.control.theme === "Fabric" || this.control.theme === "Fluent" && !this.control.tooltip.border.color ? "#D2D0CE" : this.control.tooltip.border.color;
        var borderDashArray = this.control.tooltip.border.dashArray ? "dashed " + borderColor + "; border-dasharray: " + this.control.tooltip.border.dashArray + ";" : "Solid " + borderColor + ";";
        var xPos = mouseX;
        var yPos = mouseY;
        xPos = xPos + stringToNumber(tooltipdiv.getAttribute("width"), this.control.containerWidth) < window.innerWidth ? xPos : stringToNumber(tooltipdiv.getAttribute("width"), this.control.containerWidth);
        yPos = yPos + stringToNumber(tooltipdiv.getAttribute("height"), this.control.containerHeight) < window.innerHeight ? yPos : stringToNumber(tooltipdiv.getAttribute("height"), this.control.containerHeight);
        if (xPos === void 0 || xPos === null) {
          xPos = mouseX;
        }
        if (xPos + tooltipdiv.clientWidth > this.control.availableSize.width) {
          xPos -= tooltipdiv.clientWidth + 20;
        }
        if (yPos === void 0 || yPos === null) {
          yPos = e.clientY;
        }
        if (yPos + tooltipdiv.clientHeight > this.control.availableSize.height) {
          yPos -= tooltipdiv.clientHeight + 20;
        }
        if (this.control.tooltip.template !== "" && this.control.tooltip.template != null) {
          tooltipdiv.style.cssText = "position: absolute;left:" + (xPos + 20) + "px;top:" + (yPos + 20) + "px;";
        } else {
          var fontFamily = this.control.tooltip.textStyle.fontFamily || this.control.themeStyle.tooltipLabelFont.fontFamily;
          var color = this.control.tooltip.textStyle.color || this.control.themeStyle.tooltipLabelFont.color;
          var divStyle = style + "left:" + (xPos + 20) + "px;top:" + (yPos + 20) + "px;-webkit-border-radius: 5px 5px 5px 5px; -moz-border-radius: 5px 5px 5px 5px;-o-border-radius: 5px 5px 5px 5px;border-radius: 5px 5px 5px 5px;background-color:" + fill + ";color:" + color + "; border:" + borderWidth + "px " + borderDashArray + "padding-bottom: 7px;font-style:" + this.control.themeStyle.tooltipLabelFont.fontStyle + "; padding-left: 10px; font-family:" + fontFamily + "; font-size:" + this.control.tooltip.textStyle.size + "; padding-right: 10px; padding-top: 7px";
          tooltipdiv.style.cssText = divStyle;
          if (this.control.theme.indexOf("Fluent2") > -1) {
            var shadowId = this.control.element.id + "_shadow";
            var shadow = '<filter id="' + shadowId + '" height="130%"><feGaussianBlur in="SourceAlpha" stdDeviation="3"/><feOffset dx="-1" dy="3.6" result="offsetblur"/><feComponentTransfer><feFuncA type="linear" slope="0.2"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge></filter>';
            var defElement = this.control.renderer.createDefs();
            defElement.setAttribute("id", this.control.element.id + "SVG_tooltip_definition");
            tooltipdiv.appendChild(defElement);
            defElement.innerHTML = shadow;
            tooltipdiv.style.filter = "url(#" + shadowId + ")";
          }
          if (targetClass === this.control.svgObject.id + "_FeatureMeasure" || targetClass === this.control.svgObject.id + "_ComparativeMeasure") {
            document.getElementById(targetId).setAttribute("opacity", "0.6");
          }
        }
        if (this.control.isReact) {
          this.control.renderReactTemplates();
        }
      }
    };
    BulletTooltip2.prototype.updateTemplateFn = function() {
      if (this.control.tooltip.template) {
        try {
          if (typeof this.control.tooltip.template !== "function" && document.querySelectorAll(this.control.tooltip.template).length) {
            this.templateFn = compile(document.querySelector(this.control.tooltip.template).innerHTML.trim());
          } else {
            this.templateFn = compile(this.control.tooltip.template);
          }
        } catch (e) {
          this.templateFn = compile(this.control.tooltip.template);
        }
      }
    };
    BulletTooltip2.prototype.getModuleName = function() {
      return "BulletTooltip";
    };
    BulletTooltip2.prototype.destroy = function() {
    };
    return BulletTooltip2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/bullet-chart/legend/legend.js
var __extends87 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var BulletChartLegend = (
  /** @class */
  function(_super) {
    __extends87(BulletChartLegend2, _super);
    function BulletChartLegend2(chart) {
      var _this = _super.call(this, chart) || this;
      _this.library = _this;
      _this.addEventListener();
      return _this;
    }
    BulletChartLegend2.prototype.addEventListener = function() {
      if (this.chart.isDestroyed) {
        return;
      }
      this.chart.on("click", this.click, this);
      this.chart.on(Browser.touchEndEvent, this.mouseEnd, this);
      this.chart.on(Browser.touchMoveEvent, this.bulletMouseMove, this);
    };
    BulletChartLegend2.prototype.removeEventListener = function() {
      if (this.chart.isDestroyed) {
        return;
      }
      this.chart.off("click", this.click);
      this.chart.off(Browser.touchEndEvent, this.mouseEnd);
      this.chart.off(Browser.touchMoveEvent, this.bulletMouseMove);
    };
    BulletChartLegend2.prototype.bulletMouseMove = function(e) {
      if (this.chart.legendSettings.visible && this.chart.isTouch) {
        this.move(e);
      }
    };
    BulletChartLegend2.prototype.mouseEnd = function(e) {
      if (this.chart.legendSettings.visible && this.chart.isTouch) {
        this.move(e);
      }
    };
    BulletChartLegend2.prototype.getLegendOptions = function(visibleRangeCollection) {
      this.legendCollections = [];
      var fill;
      var count = 0;
      this.isRtlEnable = this.chart.enableRtl;
      var key = "color";
      var bulletChart = this.chart;
      for (var _i = 0, visibleRangeCollection_1 = visibleRangeCollection; _i < visibleRangeCollection_1.length; _i++) {
        var range = visibleRangeCollection_1[_i];
        if (range.name !== null) {
          fill = range.color ? range.color : bulletChart.themeStyle.rangeStrokes[range.index][key];
          this.legendCollections.push(new LegendOptions(range.name, fill, range.shape, this.chart.legendSettings.visible, null, range.legendImageUrl, null, false, range.index, null));
          count++;
        }
      }
      if (bulletChart.dataSource !== null && bulletChart.valueField !== "") {
        fill = bulletChart.theme.indexOf("Dark") > -1 ? "white" : bulletChart.valueFill ? bulletChart.valueFill : "black";
        var shape = bulletChart.orientation === "Vertical" ? "TargetRect" : "ActualRect";
        this.legendCollections.push(new LegendOptions("Actual", fill, shape, this.chart.legendSettings.visible, null, "", null, false, count++, null));
      }
      if (bulletChart.dataSource !== null && bulletChart.targetField !== "") {
        fill = bulletChart.theme.indexOf("Dark") > -1 ? "white" : bulletChart.targetColor ? bulletChart.targetColor : "black";
        var shape = bulletChart.orientation === "Vertical" ? "ActualRect" : "TargetRect";
        for (var i = 0; i < Object.keys(bulletChart.dataSource).length; i++) {
          if (isNullOrUndefined(bulletChart.dataSource[i][bulletChart.targetField].length) || bulletChart.dataSource[i][bulletChart.targetField].length === 1) {
            while (i === 0) {
              this.legendCollections.push(new LegendOptions("Target", fill, shape, this.chart.legendSettings.visible, null, "", null, false, count++, null));
              break;
            }
          } else {
            var targetTypes = bulletChart.targetTypes;
            var targetType = [];
            var targetTypeLength = targetTypes.length;
            while (i === 0) {
              for (var i_1 = 0; i_1 < targetTypeLength; i_1++) {
                targetType[i_1] = targetTypes[i_1 % targetTypeLength];
                targetType[i_1] = targetType[i_1] === "Rect" ? bulletChart.orientation === "Vertical" ? "ActualRect" : "TargetRect" : targetType[i_1];
                targetType[i_1] = targetType[i_1] === "Cross" ? "Multiply" : targetType[i_1];
                this.legendCollections.push(new LegendOptions("Target_" + i_1, fill, targetType[i_1], this.chart.legendSettings.visible, null, "", null, false, count++, null));
              }
              break;
            }
          }
        }
      }
    };
    BulletChartLegend2.prototype.getLegendBounds = function(availableSize, bulletLegendBounds, legend) {
      var extraWidth = 0;
      var padding = legend.padding;
      var extraHeight = 0;
      if (!this.isVertical) {
        extraHeight = availableSize.height / 100 * 5;
      } else {
        extraWidth = availableSize.width / 100 * 5;
      }
      bulletLegendBounds.height += extraHeight;
      bulletLegendBounds.width += extraWidth;
      var maximumWidth = 0;
      var legendRowWidth = 0;
      var legendRowCount = 0;
      var legendWidth = 0;
      var columnHeight = 0;
      var shapeWidth = legend.shapeWidth;
      var shapePadding = legend.shapePadding;
      var legendEventArgs;
      this.maxItemHeight = Math.max(measureText("MeasureText", legend.textStyle, this.chart.themeStyle.legendLabelFont).height, legend.shapeHeight);
      var render = false;
      for (var _i = 0, _a = this.legendCollections; _i < _a.length; _i++) {
        var bulletLegendOption = _a[_i];
        legendEventArgs = {
          fill: bulletLegendOption.fill,
          text: bulletLegendOption.text,
          shape: bulletLegendOption.shape,
          name: legendRender,
          cancel: false
        };
        this.chart.trigger(legendRender, legendEventArgs);
        bulletLegendOption.render = !legendEventArgs.cancel;
        bulletLegendOption.text = legendEventArgs.text;
        bulletLegendOption.fill = legendEventArgs.fill;
        bulletLegendOption.shape = legendEventArgs.shape;
        bulletLegendOption.textSize = measureText(bulletLegendOption.text, legend.textStyle, this.chart.themeStyle.legendLabelFont);
        if (bulletLegendOption.render && bulletLegendOption.text !== "") {
          render = true;
          legendWidth = shapeWidth + shapePadding + bulletLegendOption.textSize.width + padding;
          legendRowWidth = legendRowWidth + legendWidth;
          if (bulletLegendBounds.width < padding + legendRowWidth || this.isVertical) {
            maximumWidth = Math.max(maximumWidth, legendRowWidth + padding - (this.isVertical ? 0 : legendWidth));
            if (legendRowCount === 0 && legendWidth !== legendRowWidth) {
              legendRowCount = 1;
            }
            legendRowWidth = this.isVertical ? 0 : legendWidth;
            legendRowCount++;
            columnHeight = legendRowCount * (this.maxItemHeight + padding) + padding;
          }
        }
      }
      columnHeight = Math.max(columnHeight, this.maxItemHeight + padding + padding);
      this.isPaging = bulletLegendBounds.height < columnHeight;
      this.totalPages = legendRowCount;
      if (render) {
        this.setBounds(Math.max(legendRowWidth + padding, maximumWidth), this.position === "Bottom" || this.position === "Top" ? Math.min(columnHeight, this.chart.initialClipRect.height - (this.legend.border.width + this.legend.margin.bottom + this.legend.margin.top)) : columnHeight, legend, bulletLegendBounds);
      } else {
        this.setBounds(0, 0, legend, bulletLegendBounds);
      }
    };
    BulletChartLegend2.prototype.getRenderPoint = function(bulletLegendOption, start, textPadding, prevLegend, rect, count, firstLegend) {
      var textWidth = textPadding + (this.legend.maximumLabelWidth ? this.legend.maximumLabelWidth : prevLegend.textSize.width);
      var previousBound = prevLegend.location.x + (!this.isRtlEnable ? textWidth : -textWidth);
      var padding = this.legend.padding;
      if (previousBound + (bulletLegendOption.textSize.width + textPadding) > rect.x + rect.width + this.legend.shapeWidth / 2 || this.isVertical) {
        bulletLegendOption.location.x = start.x;
        bulletLegendOption.location.y = count === firstLegend ? prevLegend.location.y : prevLegend.location.y + this.maxItemHeight + padding;
      } else {
        bulletLegendOption.location.x = count === firstLegend ? prevLegend.location.x : previousBound;
        bulletLegendOption.location.y = prevLegend.location.y;
      }
      var availwidth = !this.isRtlEnable ? this.legendBounds.x + this.legendBounds.width - (bulletLegendOption.location.x + textPadding - this.itemPadding - this.legend.shapeWidth / 2) : bulletLegendOption.location.x - textPadding + this.itemPadding + this.legend.shapeWidth / 2 - this.legendBounds.x;
      bulletLegendOption.text = textTrim(+availwidth.toFixed(4), bulletLegendOption.text, this.legend.textStyle, this.chart.enableRtl, this.chart.themeStyle.legendLabelFont);
    };
    BulletChartLegend2.prototype.click = function(event2) {
      var symbolTargetId = event2.target.id;
      if (symbolTargetId.indexOf(this.legendID + "_pagedown") > -1) {
        this.changePage(event2, false);
      } else if (symbolTargetId.indexOf(this.legendID + "_pageup") > -1) {
        this.changePage(event2, true);
      }
    };
    BulletChartLegend2.prototype.getModuleName = function() {
      return "BulletChartLegend";
    };
    BulletChartLegend2.prototype.destroy = function() {
      this.removeEventListener();
    };
    return BulletChartLegend2;
  }(BaseLegend)
);

// node_modules/@syncfusion/ej2-charts/src/smithchart/utils/utils.js
var __extends88 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate17 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SmithchartFont = (
  /** @class */
  function(_super) {
    __extends88(SmithchartFont2, _super);
    function SmithchartFont2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate17([Property("Segoe UI")], SmithchartFont2.prototype, "fontFamily", void 0);
    __decorate17([Property("Normal")], SmithchartFont2.prototype, "fontStyle", void 0);
    __decorate17([Property("Regular")], SmithchartFont2.prototype, "fontWeight", void 0);
    __decorate17([Property("")], SmithchartFont2.prototype, "color", void 0);
    __decorate17([Property("12px")], SmithchartFont2.prototype, "size", void 0);
    __decorate17([Property(1)], SmithchartFont2.prototype, "opacity", void 0);
    return SmithchartFont2;
  }(ChildProperty)
);
var SmithchartMargin = (
  /** @class */
  function(_super) {
    __extends88(SmithchartMargin2, _super);
    function SmithchartMargin2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate17([Property(Browser.isDevice ? 5 : 10)], SmithchartMargin2.prototype, "top", void 0);
    __decorate17([Property(Browser.isDevice ? 5 : 10)], SmithchartMargin2.prototype, "bottom", void 0);
    __decorate17([Property(Browser.isDevice ? 5 : 10)], SmithchartMargin2.prototype, "right", void 0);
    __decorate17([Property(Browser.isDevice ? 5 : 10)], SmithchartMargin2.prototype, "left", void 0);
    return SmithchartMargin2;
  }(ChildProperty)
);
var SmithchartBorder = (
  /** @class */
  function(_super) {
    __extends88(SmithchartBorder2, _super);
    function SmithchartBorder2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate17([Property(0)], SmithchartBorder2.prototype, "width", void 0);
    __decorate17([Property(1)], SmithchartBorder2.prototype, "opacity", void 0);
    __decorate17([Property("transparent")], SmithchartBorder2.prototype, "color", void 0);
    return SmithchartBorder2;
  }(ChildProperty)
);
var SmithchartRect = (
  /** @class */
  /* @__PURE__ */ function() {
    function SmithchartRect2(x, y, width, height) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
    }
    return SmithchartRect2;
  }()
);
var LabelCollection = (
  /** @class */
  /* @__PURE__ */ function() {
    function LabelCollection2() {
    }
    return LabelCollection2;
  }()
);
var LegendSeries = (
  /** @class */
  /* @__PURE__ */ function() {
    function LegendSeries2() {
    }
    return LegendSeries2;
  }()
);
var LabelRegion = (
  /** @class */
  /* @__PURE__ */ function() {
    function LabelRegion2() {
    }
    return LabelRegion2;
  }()
);
var HorizontalLabelCollection = (
  /** @class */
  function(_super) {
    __extends88(HorizontalLabelCollection2, _super);
    function HorizontalLabelCollection2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return HorizontalLabelCollection2;
  }(LabelCollection)
);
var RadialLabelCollections = (
  /** @class */
  function(_super) {
    __extends88(RadialLabelCollections2, _super);
    function RadialLabelCollections2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return RadialLabelCollections2;
  }(HorizontalLabelCollection)
);
var LineSegment = (
  /** @class */
  /* @__PURE__ */ function() {
    function LineSegment2() {
    }
    return LineSegment2;
  }()
);
var PointRegion = (
  /** @class */
  /* @__PURE__ */ function() {
    function PointRegion2() {
    }
    return PointRegion2;
  }()
);
var Point = (
  /** @class */
  /* @__PURE__ */ function() {
    function Point2() {
    }
    return Point2;
  }()
);
var ClosestPoint = (
  /** @class */
  /* @__PURE__ */ function() {
    function ClosestPoint2() {
    }
    return ClosestPoint2;
  }()
);
var MarkerOptions = (
  /** @class */
  /* @__PURE__ */ function() {
    function MarkerOptions2(id, fill, borderColor, borderWidth, opacity) {
      this.id = id;
      this.fill = fill;
      this.borderColor = borderColor;
      this.borderWidth = borderWidth;
      this.opacity = opacity;
    }
    return MarkerOptions2;
  }()
);
var SmithchartLabelPosition = (
  /** @class */
  /* @__PURE__ */ function() {
    function SmithchartLabelPosition2() {
    }
    return SmithchartLabelPosition2;
  }()
);
var Direction = (
  /** @class */
  /* @__PURE__ */ function() {
    function Direction2() {
      this.counterclockwise = 0;
      this.clockwise = 1;
    }
    return Direction2;
  }()
);
var DataLabelTextOptions = (
  /** @class */
  /* @__PURE__ */ function() {
    function DataLabelTextOptions2() {
    }
    return DataLabelTextOptions2;
  }()
);
var LabelOption = (
  /** @class */
  /* @__PURE__ */ function() {
    function LabelOption2() {
    }
    return LabelOption2;
  }()
);
var SmithchartSize = (
  /** @class */
  /* @__PURE__ */ function() {
    function SmithchartSize2(width, height) {
      this.width = width;
      this.height = height;
    }
    return SmithchartSize2;
  }()
);
var GridArcPoints = (
  /** @class */
  /* @__PURE__ */ function() {
    function GridArcPoints2() {
    }
    return GridArcPoints2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/smithchart/legend/legend.js
var __extends89 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate18 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var LegendTitle = (
  /** @class */
  function(_super) {
    __extends89(LegendTitle2, _super);
    function LegendTitle2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate18([Property(true)], LegendTitle2.prototype, "visible", void 0);
    __decorate18([Property("")], LegendTitle2.prototype, "text", void 0);
    __decorate18([Property("")], LegendTitle2.prototype, "description", void 0);
    __decorate18([Property("Center")], LegendTitle2.prototype, "textAlignment", void 0);
    __decorate18([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, SmithchartFont)], LegendTitle2.prototype, "textStyle", void 0);
    return LegendTitle2;
  }(ChildProperty)
);
var LegendLocation = (
  /** @class */
  function(_super) {
    __extends89(LegendLocation2, _super);
    function LegendLocation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate18([Property(0)], LegendLocation2.prototype, "x", void 0);
    __decorate18([Property(0)], LegendLocation2.prototype, "y", void 0);
    return LegendLocation2;
  }(ChildProperty)
);
var LegendItemStyleBorder = (
  /** @class */
  function(_super) {
    __extends89(LegendItemStyleBorder2, _super);
    function LegendItemStyleBorder2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate18([Property(1)], LegendItemStyleBorder2.prototype, "width", void 0);
    __decorate18([Property(null)], LegendItemStyleBorder2.prototype, "color", void 0);
    return LegendItemStyleBorder2;
  }(ChildProperty)
);
var LegendItemStyle = (
  /** @class */
  function(_super) {
    __extends89(LegendItemStyle2, _super);
    function LegendItemStyle2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate18([Property(10)], LegendItemStyle2.prototype, "width", void 0);
    __decorate18([Property(10)], LegendItemStyle2.prototype, "height", void 0);
    __decorate18([Complex({}, LegendItemStyleBorder)], LegendItemStyle2.prototype, "border", void 0);
    return LegendItemStyle2;
  }(ChildProperty)
);
var LegendBorder = (
  /** @class */
  function(_super) {
    __extends89(LegendBorder2, _super);
    function LegendBorder2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate18([Property(1)], LegendBorder2.prototype, "width", void 0);
    __decorate18([Property(null)], LegendBorder2.prototype, "color", void 0);
    return LegendBorder2;
  }(ChildProperty)
);
var SmithchartLegendSettings = (
  /** @class */
  function(_super) {
    __extends89(SmithchartLegendSettings2, _super);
    function SmithchartLegendSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate18([Property(false)], SmithchartLegendSettings2.prototype, "visible", void 0);
    __decorate18([Property("bottom")], SmithchartLegendSettings2.prototype, "position", void 0);
    __decorate18([Property("Center")], SmithchartLegendSettings2.prototype, "alignment", void 0);
    __decorate18([Property(null)], SmithchartLegendSettings2.prototype, "width", void 0);
    __decorate18([Property(null)], SmithchartLegendSettings2.prototype, "height", void 0);
    __decorate18([Property("circle")], SmithchartLegendSettings2.prototype, "shape", void 0);
    __decorate18([Property(null)], SmithchartLegendSettings2.prototype, "rowCount", void 0);
    __decorate18([Property(null)], SmithchartLegendSettings2.prototype, "columnCount", void 0);
    __decorate18([Property(8)], SmithchartLegendSettings2.prototype, "itemPadding", void 0);
    __decorate18([Property(5)], SmithchartLegendSettings2.prototype, "shapePadding", void 0);
    __decorate18([Property("")], SmithchartLegendSettings2.prototype, "description", void 0);
    __decorate18([Property(true)], SmithchartLegendSettings2.prototype, "toggleVisibility", void 0);
    __decorate18([Complex({}, LegendTitle)], SmithchartLegendSettings2.prototype, "title", void 0);
    __decorate18([Complex({}, LegendLocation)], SmithchartLegendSettings2.prototype, "location", void 0);
    __decorate18([Complex({}, LegendItemStyle)], SmithchartLegendSettings2.prototype, "itemStyle", void 0);
    __decorate18([Complex({}, LegendBorder)], SmithchartLegendSettings2.prototype, "border", void 0);
    __decorate18([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, SmithchartFont)], SmithchartLegendSettings2.prototype, "textStyle", void 0);
    return SmithchartLegendSettings2;
  }(ChildProperty)
);

// node_modules/@syncfusion/ej2-charts/src/smithchart/axis/axis.js
var __extends90 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate19 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SmithchartMajorGridLines = (
  /** @class */
  function(_super) {
    __extends90(SmithchartMajorGridLines2, _super);
    function SmithchartMajorGridLines2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate19([Property(1)], SmithchartMajorGridLines2.prototype, "width", void 0);
    __decorate19([Property("")], SmithchartMajorGridLines2.prototype, "dashArray", void 0);
    __decorate19([Property(true)], SmithchartMajorGridLines2.prototype, "visible", void 0);
    __decorate19([Property(null)], SmithchartMajorGridLines2.prototype, "color", void 0);
    __decorate19([Property(1)], SmithchartMajorGridLines2.prototype, "opacity", void 0);
    return SmithchartMajorGridLines2;
  }(ChildProperty)
);
var SmithchartMinorGridLines = (
  /** @class */
  function(_super) {
    __extends90(SmithchartMinorGridLines2, _super);
    function SmithchartMinorGridLines2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate19([Property(1)], SmithchartMinorGridLines2.prototype, "width", void 0);
    __decorate19([Property("")], SmithchartMinorGridLines2.prototype, "dashArray", void 0);
    __decorate19([Property(false)], SmithchartMinorGridLines2.prototype, "visible", void 0);
    __decorate19([Property(null)], SmithchartMinorGridLines2.prototype, "color", void 0);
    __decorate19([Property(8)], SmithchartMinorGridLines2.prototype, "count", void 0);
    return SmithchartMinorGridLines2;
  }(ChildProperty)
);
var SmithchartAxisLine = (
  /** @class */
  function(_super) {
    __extends90(SmithchartAxisLine2, _super);
    function SmithchartAxisLine2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate19([Property(true)], SmithchartAxisLine2.prototype, "visible", void 0);
    __decorate19([Property(1)], SmithchartAxisLine2.prototype, "width", void 0);
    __decorate19([Property(null)], SmithchartAxisLine2.prototype, "color", void 0);
    __decorate19([Property("")], SmithchartAxisLine2.prototype, "dashArray", void 0);
    return SmithchartAxisLine2;
  }(ChildProperty)
);
var SmithchartAxis = (
  /** @class */
  function(_super) {
    __extends90(SmithchartAxis2, _super);
    function SmithchartAxis2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate19([Property(true)], SmithchartAxis2.prototype, "visible", void 0);
    __decorate19([Property("Outside")], SmithchartAxis2.prototype, "labelPosition", void 0);
    __decorate19([Property("Hide")], SmithchartAxis2.prototype, "labelIntersectAction", void 0);
    __decorate19([Complex({}, SmithchartMajorGridLines)], SmithchartAxis2.prototype, "majorGridLines", void 0);
    __decorate19([Complex({}, SmithchartMinorGridLines)], SmithchartAxis2.prototype, "minorGridLines", void 0);
    __decorate19([Complex({}, SmithchartAxisLine)], SmithchartAxis2.prototype, "axisLine", void 0);
    __decorate19([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, SmithchartFont)], SmithchartAxis2.prototype, "labelStyle", void 0);
    return SmithchartAxis2;
  }(ChildProperty)
);

// node_modules/@syncfusion/ej2-charts/src/smithchart/title/title.js
var __extends91 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate20 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Subtitle = (
  /** @class */
  function(_super) {
    __extends91(Subtitle2, _super);
    function Subtitle2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate20([Property(true)], Subtitle2.prototype, "visible", void 0);
    __decorate20([Property("")], Subtitle2.prototype, "text", void 0);
    __decorate20([Property("")], Subtitle2.prototype, "description", void 0);
    __decorate20([Property("Far")], Subtitle2.prototype, "textAlignment", void 0);
    __decorate20([Property(true)], Subtitle2.prototype, "enableTrim", void 0);
    __decorate20([Property(null)], Subtitle2.prototype, "maximumWidth", void 0);
    __decorate20([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, SmithchartFont)], Subtitle2.prototype, "textStyle", void 0);
    return Subtitle2;
  }(ChildProperty)
);
var Title = (
  /** @class */
  function(_super) {
    __extends91(Title2, _super);
    function Title2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate20([Property(true)], Title2.prototype, "visible", void 0);
    __decorate20([Property("")], Title2.prototype, "text", void 0);
    __decorate20([Property("")], Title2.prototype, "description", void 0);
    __decorate20([Property("Center")], Title2.prototype, "textAlignment", void 0);
    __decorate20([Property(true)], Title2.prototype, "enableTrim", void 0);
    __decorate20([Property(null)], Title2.prototype, "maximumWidth", void 0);
    __decorate20([Complex({}, Subtitle)], Title2.prototype, "subtitle", void 0);
    __decorate20([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, SmithchartFont)], Title2.prototype, "font", void 0);
    __decorate20([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, SmithchartFont)], Title2.prototype, "textStyle", void 0);
    return Title2;
  }(ChildProperty)
);

// node_modules/@syncfusion/ej2-charts/src/smithchart/series/series.js
var __extends92 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate21 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SeriesTooltipBorder = (
  /** @class */
  function(_super) {
    __extends92(SeriesTooltipBorder2, _super);
    function SeriesTooltipBorder2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate21([Property(1)], SeriesTooltipBorder2.prototype, "width", void 0);
    __decorate21([Property(null)], SeriesTooltipBorder2.prototype, "color", void 0);
    return SeriesTooltipBorder2;
  }(ChildProperty)
);
var SeriesTooltip = (
  /** @class */
  function(_super) {
    __extends92(SeriesTooltip2, _super);
    function SeriesTooltip2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate21([Property(false)], SeriesTooltip2.prototype, "visible", void 0);
    __decorate21([Property(null)], SeriesTooltip2.prototype, "fill", void 0);
    __decorate21([Property(0.75)], SeriesTooltip2.prototype, "opacity", void 0);
    __decorate21([Property("")], SeriesTooltip2.prototype, "template", void 0);
    __decorate21([Complex({}, SeriesTooltipBorder)], SeriesTooltip2.prototype, "border", void 0);
    return SeriesTooltip2;
  }(ChildProperty)
);
var SeriesMarkerBorder = (
  /** @class */
  function(_super) {
    __extends92(SeriesMarkerBorder2, _super);
    function SeriesMarkerBorder2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate21([Property(3)], SeriesMarkerBorder2.prototype, "width", void 0);
    __decorate21([Property("white")], SeriesMarkerBorder2.prototype, "color", void 0);
    return SeriesMarkerBorder2;
  }(ChildProperty)
);
var SeriesMarkerDataLabelBorder = (
  /** @class */
  function(_super) {
    __extends92(SeriesMarkerDataLabelBorder2, _super);
    function SeriesMarkerDataLabelBorder2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate21([Property(0.1)], SeriesMarkerDataLabelBorder2.prototype, "width", void 0);
    __decorate21([Property("white")], SeriesMarkerDataLabelBorder2.prototype, "color", void 0);
    return SeriesMarkerDataLabelBorder2;
  }(ChildProperty)
);
var SeriesMarkerDataLabelConnectorLine = (
  /** @class */
  function(_super) {
    __extends92(SeriesMarkerDataLabelConnectorLine2, _super);
    function SeriesMarkerDataLabelConnectorLine2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate21([Property(1)], SeriesMarkerDataLabelConnectorLine2.prototype, "width", void 0);
    __decorate21([Property(null)], SeriesMarkerDataLabelConnectorLine2.prototype, "color", void 0);
    return SeriesMarkerDataLabelConnectorLine2;
  }(ChildProperty)
);
var SeriesMarkerDataLabel = (
  /** @class */
  function(_super) {
    __extends92(SeriesMarkerDataLabel2, _super);
    function SeriesMarkerDataLabel2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate21([Property(false)], SeriesMarkerDataLabel2.prototype, "visible", void 0);
    __decorate21([Property("")], SeriesMarkerDataLabel2.prototype, "template", void 0);
    __decorate21([Property(null)], SeriesMarkerDataLabel2.prototype, "fill", void 0);
    __decorate21([Property(1)], SeriesMarkerDataLabel2.prototype, "opacity", void 0);
    __decorate21([Complex({}, SeriesMarkerDataLabelBorder)], SeriesMarkerDataLabel2.prototype, "border", void 0);
    __decorate21([Complex({}, SeriesMarkerDataLabelConnectorLine)], SeriesMarkerDataLabel2.prototype, "connectorLine", void 0);
    __decorate21([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, SmithchartFont)], SeriesMarkerDataLabel2.prototype, "textStyle", void 0);
    return SeriesMarkerDataLabel2;
  }(ChildProperty)
);
var SeriesMarker = (
  /** @class */
  function(_super) {
    __extends92(SeriesMarker2, _super);
    function SeriesMarker2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate21([Property(false)], SeriesMarker2.prototype, "visible", void 0);
    __decorate21([Property("circle")], SeriesMarker2.prototype, "shape", void 0);
    __decorate21([Property(6)], SeriesMarker2.prototype, "width", void 0);
    __decorate21([Property(6)], SeriesMarker2.prototype, "height", void 0);
    __decorate21([Property("")], SeriesMarker2.prototype, "imageUrl", void 0);
    __decorate21([Property("")], SeriesMarker2.prototype, "fill", void 0);
    __decorate21([Property(1)], SeriesMarker2.prototype, "opacity", void 0);
    __decorate21([Complex({}, SeriesMarkerBorder)], SeriesMarker2.prototype, "border", void 0);
    __decorate21([Complex({}, SeriesMarkerDataLabel)], SeriesMarker2.prototype, "dataLabel", void 0);
    return SeriesMarker2;
  }(ChildProperty)
);
var SmithchartSeries = (
  /** @class */
  function(_super) {
    __extends92(SmithchartSeries2, _super);
    function SmithchartSeries2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate21([Property("visible")], SmithchartSeries2.prototype, "visibility", void 0);
    __decorate21([Property([])], SmithchartSeries2.prototype, "points", void 0);
    __decorate21([Property("")], SmithchartSeries2.prototype, "resistance", void 0);
    __decorate21([Property("")], SmithchartSeries2.prototype, "reactance", void 0);
    __decorate21([Property("")], SmithchartSeries2.prototype, "tooltipMappingName", void 0);
    __decorate21([Property(null)], SmithchartSeries2.prototype, "dataSource", void 0);
    __decorate21([Property("")], SmithchartSeries2.prototype, "name", void 0);
    __decorate21([Property(null)], SmithchartSeries2.prototype, "fill", void 0);
    __decorate21([Property(false)], SmithchartSeries2.prototype, "enableAnimation", void 0);
    __decorate21([Property("2000ms")], SmithchartSeries2.prototype, "animationDuration", void 0);
    __decorate21([Property(false)], SmithchartSeries2.prototype, "enableSmartLabels", void 0);
    __decorate21([Property(1)], SmithchartSeries2.prototype, "width", void 0);
    __decorate21([Property(1)], SmithchartSeries2.prototype, "opacity", void 0);
    __decorate21([Complex({}, SeriesMarker)], SmithchartSeries2.prototype, "marker", void 0);
    __decorate21([Complex({}, SeriesTooltip)], SmithchartSeries2.prototype, "tooltip", void 0);
    return SmithchartSeries2;
  }(ChildProperty)
);

// node_modules/@syncfusion/ej2-charts/src/smithchart/utils/enum.js
var smithchartBeforePrint = "beforePrint";

// node_modules/@syncfusion/ej2-charts/src/smithchart/utils/helper.js
var __extends93 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
function createSvg2(smithchart) {
  smithchart.renderer = new SvgRenderer(smithchart.element.id);
  calculateSize2(smithchart);
  smithchart.svgObject = smithchart.renderer.createSvg({
    id: smithchart.element.id + "_svg",
    width: smithchart.availableSize.width,
    height: smithchart.availableSize.height
  });
}
function getElement3(id) {
  return document.getElementById(id);
}
function textTrim2(maximumWidth, text, font, themeFontStyle) {
  var label = text;
  var size = measureText2(text, font, themeFontStyle).width;
  if (size > maximumWidth) {
    var textLength = text.length;
    for (var i = textLength - 1; i >= 0; --i) {
      label = text.substring(0, i) + "...";
      size = measureText2(label, font, themeFontStyle).width;
      if (size <= maximumWidth || label.length < 4) {
        if (label.length < 4) {
          label = " ";
        }
        return label;
      }
    }
  }
  return label;
}
function getTemplateFunction2(templateString) {
  var templateFn = null;
  try {
    if (typeof templateString !== "function" && document.querySelectorAll(templateString).length) {
      templateFn = compile(document.querySelector(templateString).innerHTML.trim());
    } else {
      templateFn = compile(templateString);
    }
  } catch (e) {
    templateFn = compile(templateString);
  }
  return templateFn;
}
function convertElementFromLabel(element, labelId, data) {
  var labelEle = element[0];
  var templateHtml = labelEle.outerHTML;
  var properties = Object.keys(data);
  var regExp = RegExp;
  for (var i = 0; i < properties.length; i++) {
    templateHtml = templateHtml.replace(new regExp("{{:" + properties[i] + "}}", "g"), data[properties[i].toString()]);
  }
  var templateElement = createElement("div", {
    id: labelId,
    styles: "position: absolute"
  });
  templateElement.innerText = templateHtml;
  return templateElement;
}
function _getEpsilonValue() {
  var e = 1;
  while (1 + 0.5 * e !== 1) {
    e *= 0.5;
  }
  return e;
}
function calculateSize2(smithchart) {
  var containerWidth = smithchart.element.clientWidth;
  var containerHeight = smithchart.element.clientHeight;
  smithchart.availableSize = new SmithchartSize(stringToNumber2(smithchart.width, containerWidth) || containerWidth || 600, stringToNumber2(smithchart.height, containerHeight) || containerHeight || 450);
}
function templateAnimate2(smithchart, element, delay, duration, name) {
  var opacity = 0;
  var delta;
  var value;
  new Animation({}).animate(element, {
    duration,
    delay,
    name,
    progress: function(args) {
      delta = (args.timeStamp - args.delay) / args.duration;
      value = opacity + delta * 1;
      args.element.style.opacity = value.toString();
    },
    end: function(args) {
      var opacity2 = 1;
      args.element.style.opacity = opacity2.toString();
      smithchart.trigger("animationComplete", event);
    }
  });
}
function stringToNumber2(value, containerSize) {
  if (value !== null && value !== void 0) {
    return value.indexOf("%") !== -1 ? containerSize / 100 * parseInt(value, 10) : parseInt(value, 10);
  }
  return null;
}
var PathOption2 = (
  /** @class */
  /* @__PURE__ */ function() {
    function PathOption4(id, fill, width, color, opacity, dashArray, d) {
      this.id = id;
      this.opacity = opacity;
      this.fill = fill;
      this.stroke = color;
      this["stroke-width"] = width;
      this["stroke-dasharray"] = dashArray;
      this.d = d;
    }
    return PathOption4;
  }()
);
var RectOption2 = (
  /** @class */
  function(_super) {
    __extends93(RectOption4, _super);
    function RectOption4(id, fill, border, opacity, rect) {
      var _this = _super.call(this, id, fill, border.width, border.color, opacity) || this;
      _this.y = rect.y;
      _this.x = rect.x;
      _this.height = rect.height;
      _this.width = rect.width;
      return _this;
    }
    return RectOption4;
  }(PathOption2)
);
var CircleOption2 = (
  /** @class */
  function(_super) {
    __extends93(CircleOption4, _super);
    function CircleOption4(id, fill, border, opacity, cx, cy, r, dashArray) {
      var _this = _super.call(this, id, fill, border.width, border.color, opacity) || this;
      _this.cy = cy;
      _this.cx = cx;
      _this.r = r;
      _this["stroke-dasharray"] = dashArray;
      return _this;
    }
    return CircleOption4;
  }(PathOption2)
);
function measureText2(text, font, themeFontStyle) {
  var htmlObject = document.getElementById("smithchartmeasuretext");
  if (htmlObject === null) {
    htmlObject = createElement("text", {
      id: "smithchartmeasuretext"
    });
    document.body.appendChild(htmlObject);
  }
  htmlObject.innerText = text;
  htmlObject.style.position = "absolute";
  htmlObject.style.visibility = "hidden";
  htmlObject.style.left = "0";
  htmlObject.style.top = "-100";
  htmlObject.style.whiteSpace = "nowrap";
  htmlObject.style.fontSize = font.size || themeFontStyle.size;
  htmlObject.style.fontWeight = font.fontWeight || themeFontStyle.fontWeight;
  htmlObject.style.fontStyle = font.fontStyle || themeFontStyle.fontStyle;
  htmlObject.style.fontFamily = font.fontFamily || themeFontStyle.fontFamily;
  htmlObject.style.lineHeight = "normal";
  return new SmithchartSize(htmlObject.clientWidth, htmlObject.clientHeight);
}
var TextOption2 = (
  /** @class */
  /* @__PURE__ */ function() {
    function TextOption4(id, x, y, anchor, text) {
      this.id = id;
      this.x = x;
      this.y = y;
      this.anchor = anchor;
      this.text = text;
    }
    return TextOption4;
  }()
);
function removeElement3(id) {
  var element = document.getElementById(id);
  return element ? remove(element) : null;
}
function linear2(currentTime, startValue, endValue, duration) {
  return -endValue * Math.cos(currentTime / duration * (Math.PI / 2)) + endValue + startValue;
}
function reverselinear(currentTime, startValue, endValue, duration) {
  return -startValue * Math.sin(currentTime / duration * (Math.PI / 2)) + endValue + startValue;
}
function getAnimationFunction2(effect) {
  var functionName;
  switch (effect) {
    case "Linear":
      functionName = linear2;
      break;
    case "Reverse":
      functionName = reverselinear;
      break;
  }
  return functionName;
}
function renderTextElement(options, font, color, parent, themeFontStyle) {
  var renderOptions = {
    "id": options.id,
    "x": options.x,
    "y": options.y,
    "fill": color,
    "font-size": font.size || themeFontStyle.size,
    "font-style": font.fontStyle || themeFontStyle.fontStyle,
    "font-family": font.fontFamily || themeFontStyle.fontFamily,
    "font-weight": font.fontWeight || themeFontStyle.fontWeight,
    "text-anchor": options.anchor,
    "opacity": font.opacity
  };
  var text = options.text;
  var renderer = new SvgRenderer("");
  var htmlObject = renderer.createText(renderOptions, text);
  parent.appendChild(htmlObject);
  return htmlObject;
}

// node_modules/@syncfusion/ej2-charts/src/smithchart/model/theme.js
function getSeriesColor2(theme) {
  var palette;
  switch (theme) {
    case "Fabric":
      palette = ["#4472c4", "#ed7d31", "#ffc000", "#70ad47", "#5b9bd5", "#c1c1c1", "#6f6fe2", "#e269ae", "#9e480e", "#997300"];
      break;
    case "Bootstrap4":
      palette = ["#a16ee5", "#f7ce69", "#55a5c2", "#7ddf1e", "#ff6ea6", "#7953ac", "#b99b4f", "#407c92", "#5ea716", "#b91c52"];
      break;
    case "Bootstrap":
      palette = ["#a16ee5", "#f7ce69", "#55a5c2", "#7ddf1e", "#ff6ea6", "#7953ac", "#b99b4f", "#407c92", "#5ea716", "#b91c52"];
      break;
    case "HighContrastLight":
    case "HighContrast":
      palette = ["#79ECE4", "#E98272", "#DFE6B6", "#C6E773", "#BA98FF", "#FA83C3", "#00C27A", "#43ACEF", "#D681EF", "#D8BC6E"];
      break;
    case "MaterialDark":
      palette = ["#9ECB08", "#56AEFF", "#C57AFF", "#61EAA9", "#EBBB3E", "#F45C5C", "#8A77FF", "#63C7FF", "#FF84B0", "#F7C928"];
      break;
    case "FabricDark":
      palette = ["#4472c4", "#ed7d31", "#ffc000", "#70ad47", "#5b9bd5", "#c1c1c1", "#6f6fe2", "#e269ae", "#9e480e", "#997300"];
      break;
    case "BootstrapDark":
      palette = ["#a16ee5", "#f7ce69", "#55a5c2", "#7ddf1e", "#ff6ea6", "#7953ac", "#b99b4f", "#407c92", "#5ea716", "#b91c52"];
      break;
    case "Tailwind3":
      palette = ["#2F4074", "#03B4B4", "#0D72DE", "#FF5733", "#D63384", "#F39C12", "#EF291F", "#91C822"];
      break;
    case "Tailwind3Dark":
      palette = ["#8029F1", "#1ABC9C", "#0D72DE", "#FF5733", "#D63384", "#F39C12", "#EF291F", "#91C822"];
      break;
    case "Tailwind":
      palette = ["#5A61F6", "#65A30D", "#334155", "#14B8A6", "#8B5CF6", "#0369A1", "#F97316", "#9333EA", "#F59E0B", "#15803D"];
      break;
    case "TailwindDark":
      palette = ["#8B5CF6", "#22D3EE", "#F87171", "#4ADE80", "#E879F9", "#FCD34D", "#F97316", "#2DD4BF", "#F472B6", "#10B981"];
      break;
    case "Bootstrap5Dark":
    case "Bootstrap5":
      palette = ["#FD7E14", "#6610F2", "#6F42C1", "#D63384", "#DC3545", "#FFC107", "#198754", "#0DCAF0"];
      break;
    case "Fluent":
      palette = ["#1AC9E6", "#DA4CB2", "#EDBB40", "#AF4BCF", "#FF7266", "#1BD565", "#EE993D", "#5887FF", "#EC548D", "#7D39C0"];
      break;
    case "FluentDark":
      palette = ["#1AC9E6", "#DA4CB2", "#EDBB40", "#AF4BCF", "#FF7266", "#1BD565", "#EE993D", "#5887FF", "#EC548D", "#7D39C0"];
      break;
    case "Fluent2":
      palette = ["#6200EE", "#09AF74", "#0076E5", "#CB3587", "#E7910F", "#0364DE", "#66CD15", "#F3A93C", "#107C10", "#C19C00"];
      break;
    case "Fluent2Dark":
      palette = ["#9BB449", "#2A72D5", "#43B786", "#3F579A", "#584EC6", "#E85F9C", "#6E7A89", "#EA6266", "#0B6A0B", "#C19C00"];
      break;
    case "Fluent2HighContrast":
      palette = ["#9BB449", "#2A72D5", "#43B786", "#3F579A", "#584EC6", "#E85F9C", "#6E7A89", "#EA6266", "#0B6A0B", "#C19C00"];
      break;
    case "Material3":
      palette = ["#6355C7", "#00AEE0", "#FFB400", "#F7523F", "#963C70", "#FD7400", "#4BE0BC", "#2196F5", "#DE3D8A", "#162F88"];
      break;
    case "Material3Dark":
      palette = ["#4EAAFF", "#FA4EAB", "#FFF500", "#17EA58", "#38FFE7", "#FF9E45", "#B3F32F", "#B93CE4", "#FC5664", "#9B55FF"];
      break;
    default:
      palette = ["#00bdae", "#404041", "#357cd2", "#e56590", "#f8b883", "#70ad47", "#dd8abd", "#7f84e8", "#7bb4eb", "#ea7a57"];
      break;
  }
  return palette;
}
function getThemeColor2(theme) {
  var style;
  var darkBackground = theme === "MaterialDark" ? "#383838" : theme === "FabricDark" ? "#242424" : "#1b1b1b";
  switch (theme) {
    case "HighContrast":
      style = {
        axisLabel: "#ffffff",
        axisLine: "#ffffff",
        majorGridLine: "#BFBFBF",
        minorGridLine: "#969696",
        chartTitle: "#ffffff",
        legendLabel: "#ffffff",
        background: "#000000",
        areaBorder: "#ffffff",
        tooltipFill: "#ffffff",
        dataLabel: "#ffffff",
        tooltipBoldLabel: "#000000",
        tooltipLightLabel: "#000000",
        tooltipHeaderLine: "#969696",
        tooltipFontSize: "12px",
        tabColor: "#FFD939",
        smithchartTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#969696",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        dataLabelFont: {
          color: "#969696",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#969696",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        smithchartSubtitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "MaterialDark":
    case "BootstrapDark":
    case "FabricDark":
      style = {
        axisLabel: "#DADADA",
        axisLine: " #6F6C6C",
        majorGridLine: "#414040",
        minorGridLine: "#514F4F",
        chartTitle: "#ffffff",
        legendLabel: "#DADADA",
        background: darkBackground,
        areaBorder: " #9A9A9A",
        tooltipFill: theme === "MaterialDark" ? "#F4F4F4" : theme === "BootstrapDark" ? "#F0F0F0" : "#A19F9D",
        dataLabel: "#DADADA",
        tooltipBoldLabel: theme === "MaterialDark" ? "rgba(18, 18, 18, 1)" : theme === "BootstrapDark" ? "#1A1A1A" : "#DADADA",
        tooltipLightLabel: theme === "MaterialDark" ? "rgba(18, 18, 18, 1)" : theme === "BootstrapDark" ? "#1A1A1A" : "#DADADA",
        tooltipHeaderLine: "#9A9A9A",
        tooltipFontSize: "12px",
        tabColor: theme === "MaterialDark" ? "#00B0FF" : theme === "FabricDark" ? "#0074CC" : "#0070F0",
        smithchartTitleFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.87)" : theme === "BootstrapDark" ? "#FFFFFF" : "#DADADA",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "BootstrapDark" ? "Helvetica" : "Segoe UI",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.6)" : theme === "BootstrapDark" ? "#676767" : "#A19F9D",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "BootstrapDark" ? "Helvetica" : "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.87)" : theme === "BootstrapDark" ? "#FFFFFF" : "#DADADA",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "BootstrapDark" ? "Helvetica" : "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        dataLabelFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.6)" : theme === "BootstrapDark" ? "#676767" : "#A19F9D",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "BootstrapDark" ? "Helvetica" : "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.6)" : theme === "BootstrapDark" ? "#CED4DA" : "#A19F9D",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "BootstrapDark" ? "Helvetica" : "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        smithchartSubtitleFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.87)" : theme === "BootstrapDark" ? "#FFFFFF" : "#DADADA",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "BootstrapDark" ? "Helvetica" : "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Bootstrap4":
      style = {
        axisLabel: "#212529",
        axisLine: "#ADB5BD",
        majorGridLine: "#CED4DA",
        minorGridLine: "#DEE2E6",
        chartTitle: "#212529",
        legendLabel: "#212529",
        background: "#FFFFFF",
        areaBorder: "#DEE2E6",
        tooltipFill: "#212529",
        dataLabel: "#212529",
        tooltipBoldLabel: "#F9FAFB",
        tooltipLightLabel: "#F9FAFB",
        tooltipHeaderLine: "#FFFFFF",
        tooltipFontSize: "12px",
        tabColor: "#007BFF",
        fontFamily: "Helvetica",
        fontSize: "16px",
        labelFontFamily: "Helvetica",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 0.9,
        smithchartTitleFont: {
          color: "#212529",
          fontFamily: "Helvetica",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#666666",
          fontFamily: "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#212529",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        dataLabelFont: {
          color: "#495057",
          fontFamily: "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#495057",
          fontFamily: "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        smithchartSubtitleFont: {
          color: "#212529",
          fontFamily: "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Tailwind3":
      style = {
        axisLabel: "#4B5563",
        axisLine: "#D1D5DB",
        majorGridLine: "#E5E7EB",
        minorGridLine: "#D1D5DB",
        chartTitle: "#6B7280",
        legendLabel: "#6B7280",
        background: "#FFFFFF",
        areaBorder: "#D1D5DB",
        tooltipFill: "#111827",
        dataLabel: "#111827",
        tooltipBoldLabel: "#F9FAFB",
        tooltipLightLabel: "#F9FAFB",
        tooltipHeaderLine: "#D1D5DB",
        tooltipFontSize: "12px",
        tabColor: "#4F46E5",
        fontFamily: "Inter",
        fontSize: "12px",
        labelFontFamily: "inter",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        smithchartTitleFont: {
          color: "#6B7280",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        legendLabelFont: {
          color: "#6B7280",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        legendTitleFont: {
          color: "#374151",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        dataLabelFont: {
          color: "#111827",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#4B5563",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        smithchartSubtitleFont: {
          color: "#6B7280",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        }
      };
      break;
    case "Tailwind3Dark":
      style = {
        axisLabel: "#D1D5DB",
        axisLine: "#282F3C",
        majorGridLine: "#282F3C",
        minorGridLine: "#374151",
        chartTitle: "#9CA3AF",
        legendLabel: "#9CA3AF",
        background: "rgba(17, 24, 39, 1)",
        areaBorder: "#374151",
        tooltipFill: "#F9FAFB",
        dataLabel: "#FFFFFF",
        tooltipBoldLabel: "#1F2937",
        tooltipLightLabel: "#1F2937",
        tooltipHeaderLine: "#374151",
        tooltipFontSize: "12px",
        tabColor: "#22D3EE",
        fontFamily: "Inter",
        fontSize: "14px",
        labelFontFamily: "inter",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        smithchartTitleFont: {
          color: "#9CA3AF",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        legendLabelFont: {
          color: "#9CA3AF",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        legendTitleFont: {
          color: "#E5E7EB",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        dataLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        smithchartSubtitleFont: {
          color: "#9CA3AF",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        }
      };
      break;
    case "Tailwind":
      style = {
        axisLabel: "#6B7280",
        axisLine: "#D1D5DB",
        majorGridLine: "#E5E7EB",
        minorGridLine: "#D1D5DB",
        chartTitle: "#374151",
        legendLabel: "#374151",
        background: "#FFFFFF",
        areaBorder: "#D1D5DB6",
        tooltipFill: "#111827",
        dataLabel: "#F9FAFB",
        tooltipBoldLabel: "#F9FAFB",
        tooltipLightLabel: "#F9FAFB",
        tooltipHeaderLine: "#9CA3AF",
        tooltipFontSize: "12px",
        tabColor: "#4F46E5",
        fontFamily: "Inter",
        fontSize: "14px",
        labelFontFamily: "inter",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        smithchartTitleFont: {
          color: "#374151",
          fontFamily: "Inter",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#374151",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#374151",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        dataLabelFont: {
          color: "#6B7280",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#6B7280",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        smithchartSubtitleFont: {
          color: "#374151",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "TailwindDark":
      style = {
        axisLabel: "#9CA3AF",
        axisLine: "#4B5563",
        majorGridLine: "#374151",
        minorGridLine: "#4B5563",
        chartTitle: "#D1D5DB",
        legendLabel: "#D1D5DB",
        background: "#1f2937",
        areaBorder: "#4B5563",
        tooltipFill: "#E9ECEF",
        dataLabel: "#D1D5DB",
        tooltipBoldLabel: "#1F2937",
        tooltipLightLabel: "#1F2937",
        tooltipHeaderLine: "#9CA3AF",
        tooltipFontSize: "12px",
        tabColor: "#22D3EE",
        fontFamily: "Inter",
        fontSize: "14px",
        labelFontFamily: "inter",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        smithchartTitleFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#D1D5DB",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        dataLabelFont: {
          color: "#9CA3AF",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#9CA3AF",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        smithchartSubtitleFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Bootstrap5":
      style = {
        axisLabel: "#21252980",
        axisLine: "#DEE2E6",
        majorGridLine: "#DEE2E6",
        minorGridLine: "#DEE2E6",
        chartTitle: "#212529",
        legendLabel: "#212529BF",
        background: "#FFFFFF",
        areaBorder: "#E9ECEF",
        tooltipFill: "#000000E5",
        dataLabel: "#212529",
        tooltipBoldLabel: "#FFFFFF",
        tooltipLightLabel: "#FFFFFF",
        tooltipHeaderLine: "#FFFFFF",
        tooltipFontSize: "12px",
        tabColor: "#0D6EFD",
        fontFamily: "Segoe UI",
        fontSize: "14px",
        labelFontFamily: "Segoe UI",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        smithchartTitleFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendLabelFont: {
          color: "#212529BF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        dataLabelFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#21252980",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        smithchartSubtitleFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        }
      };
      break;
    case "Bootstrap5Dark":
      style = {
        axisLabel: "#DEE2E680",
        axisLine: "#495057",
        majorGridLine: "#495057",
        minorGridLine: "#495057",
        chartTitle: "#DEE2E6",
        legendLabel: "#DEE2E6BF",
        background: "#212529",
        areaBorder: "#343A40",
        tooltipFill: "#FFFFFFE5",
        dataLabel: "#DEE2E6",
        tooltipBoldLabel: "#212529",
        tooltipLightLabel: "#212529",
        tooltipHeaderLine: "#212529",
        tooltipFontSize: "12px",
        tabColor: "#0D6EFD",
        fontFamily: "Segoe UI",
        fontSize: "14px",
        labelFontFamily: "Segoe UI",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        smithchartTitleFont: {
          color: "#DEE2E6",
          fontFamily: "Segoe UI",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendLabelFont: {
          color: "#DEE2E6BF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#DEE2E6",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        dataLabelFont: {
          color: "#E9ECEF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#DEE2E680",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        smithchartSubtitleFont: {
          color: "#DEE2E6",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        }
      };
      break;
    case "Fluent":
      style = {
        axisLabel: "#3B3A39",
        axisLine: "#D2D0CE",
        majorGridLine: "#D2D0CE",
        minorGridLine: "#EDEBE9",
        chartTitle: "#201F1E",
        legendLabel: "#323130",
        background: "#FFFFFF",
        areaBorder: " #D2D0CE",
        tooltipFill: "#FFFFFF",
        dataLabel: "#3B3A39",
        tooltipBoldLabel: "#323130",
        tooltipLightLabel: "#323130",
        tooltipHeaderLine: "#D2D0CE",
        tooltipFontSize: "12px",
        tabColor: "#0078D4",
        fontFamily: "Segoe UI",
        fontSize: "14px",
        labelFontFamily: "Segoe UI",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        smithchartTitleFont: {
          color: "#201F1E",
          fontFamily: "Segoe UI",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#49454E",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#201F1E",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        dataLabelFont: {
          color: "#3B3A39",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#3B3A39",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        smithchartSubtitleFont: {
          color: "#323129",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "FluentDark":
      style = {
        axisLabel: "#C8C6C4",
        axisLine: "#3B3A39",
        majorGridLine: "#414040",
        minorGridLine: "#414040",
        chartTitle: "#F3F2F1",
        legendLabel: "#D2D0CE",
        background: "transparent",
        areaBorder: "#414040",
        tooltipFill: "#323130",
        dataLabel: "#C8C6C4",
        tooltipBoldLabel: "#F3F2F1",
        tooltipLightLabel: "#F3F2F2",
        tooltipHeaderLine: "#3B3A39",
        tooltipFontSize: "12px",
        tabColor: "#0078D4",
        fontFamily: "Segoe UI",
        fontSize: "14px",
        labelFontFamily: "Segoe UI",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        smithchartTitleFont: {
          color: "#C8C6C4",
          fontFamily: "Segoe UI",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#D2D0CE",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#F3F2F1",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        dataLabelFont: {
          color: "#D2D0CE",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#C8C6C4",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        smithchartSubtitleFont: {
          color: "#F3F2F1",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Fluent2":
      style = {
        axisLabel: "#616161",
        axisLine: "#D2D0CE",
        majorGridLine: "#EDEBE9",
        minorGridLine: "#FAFAFA",
        chartTitle: "#242424",
        legendLabel: "#424242",
        background: "#FFFFFF",
        areaBorder: "#EDEBE9",
        tooltipFill: "#FFFFFF",
        dataLabel: "#242424",
        tooltipBoldLabel: "#242424",
        tooltipLightLabel: "#242424",
        tooltipHeaderLine: "#D2D0CE",
        tooltipFontSize: "12px",
        tabColor: "#0078D4",
        fontFamily: "Segoe UI",
        fontSize: "14px",
        labelFontFamily: "Segoe UI",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        smithchartTitleFont: {
          color: "#242424",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#424242",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#242424",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        dataLabelFont: {
          color: "#242424",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#616161",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        smithchartSubtitleFont: {
          color: "#616161",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        }
      };
      break;
    case "Fluent2Dark":
      style = {
        axisLabel: "#ADADAD",
        axisLine: "#3B3A39",
        majorGridLine: "#292827",
        minorGridLine: "#3B3A39",
        chartTitle: "#FFFFFF",
        legendLabel: "#D6D6D6",
        background: "transparent",
        areaBorder: "#292827",
        tooltipFill: "#292929",
        dataLabel: "#FFFFFF",
        tooltipBoldLabel: "#FFFFFF",
        tooltipLightLabel: "#FFFFFF",
        tooltipHeaderLine: "#3B3A39",
        tooltipFontSize: "12px",
        tabColor: "#0078D4",
        fontFamily: "Segoe UI",
        fontSize: "14px",
        labelFontFamily: "Segoe UI",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        smithchartTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#D6D6D6",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        dataLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#ADADAD",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        smithchartSubtitleFont: {
          color: "#ADADAD",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        }
      };
      break;
    case "Fluent2HighContrast":
      style = {
        axisLabel: "#FFFFFF",
        axisLine: "#3B3A39",
        majorGridLine: "#3B3A39",
        minorGridLine: "#3B3A39",
        chartTitle: "#FFFFFF",
        legendLabel: "#FFFFFF",
        background: "#1c1b1f",
        areaBorder: "#292827",
        tooltipFill: "#000000",
        dataLabel: "#FFFFFF",
        tooltipBoldLabel: "#FFFFFF",
        tooltipLightLabel: "#FFFFFF",
        tooltipHeaderLine: "#3B3A39",
        tooltipFontSize: "12px",
        tabColor: "#0078D4",
        fontFamily: "Segoe UI",
        fontSize: "14px",
        labelFontFamily: "Segoe UI",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        smithchartTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        dataLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        smithchartSubtitleFont: {
          color: "#ADADAD",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        }
      };
      break;
    case "Material3":
      style = {
        axisLine: "#C4C7C5",
        axisLabel: "#1C1B1F",
        majorGridLine: "#C4C7C5",
        minorGridLine: "#C4C7C5",
        legendLabel: "#1C1B1F",
        background: "#FFFFFF",
        chartTitle: "#1C1B1F",
        areaBorder: " #E7E0EC",
        dataLabel: "#49454E",
        tooltipFill: "#313033",
        tooltipBoldLabel: "#F4EFF4",
        tooltipLightLabel: "#F4EFF4",
        tooltipHeaderLine: "#F4EFF4",
        tooltipFontFamily: "Inter",
        tooltipFontSize: "12px",
        tabColor: "#49454E",
        fontFamily: "Inter",
        fontSize: "16px",
        labelFontFamily: "Inter",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        smithchartTitleFont: {
          color: "#1C1B1F",
          fontFamily: "Roboto",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#49454E",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#1C1B1F",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        dataLabelFont: {
          color: "#49454E",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#1E192B",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        smithchartSubtitleFont: {
          color: "#49454E",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Material3Dark":
      style = {
        axisLabel: "#E6E1E5",
        axisLine: "#444746",
        majorGridLine: "#444746",
        minorGridLine: "#444746",
        chartTitle: "#E6E1E5",
        legendLabel: "#E6E1E5",
        background: "transparent",
        areaBorder: " #49454F",
        tooltipFill: "#E6E1E5",
        dataLabel: "#CAC4D0",
        tooltipBoldLabel: "#313033",
        tooltipLightLabel: "#313033",
        tooltipHeaderLine: "#313033",
        tooltipFontFamily: "Roboto",
        tooltipFontSize: "12px",
        tabColor: "#CAC4D0",
        fontFamily: "Roboto",
        fontSize: "16px",
        labelFontFamily: "Roboto",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        smithchartTitleFont: {
          color: "#E6E1E5",
          fontFamily: "Roboto",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#CAC4D0",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#E6E1E5",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        dataLabelFont: {
          color: "#CAC4D0",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: "#CAC4D0",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        smithchartSubtitleFont: {
          color: "#CAC4D0",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    default:
      style = {
        axisLabel: "#686868",
        axisLine: "#b5b5b5",
        majorGridLine: "#dbdbdb",
        minorGridLine: "#eaeaea",
        chartTitle: "#424242",
        legendLabel: "#353535",
        background: "#FFFFFF",
        areaBorder: "Gray",
        tooltipFill: theme === "Material" ? "#000816" : theme === "Bootstrap" ? "#212529" : "#FFFFFF",
        dataLabel: "#424242",
        tooltipBoldLabel: theme === "Material" ? "rgba(249, 250, 251, 1)" : theme === "Bootstrap" ? "#F9FAFB" : "#333333",
        tooltipLightLabel: theme === "Material" ? "rgba(249, 250, 251, 1)" : theme === "Bootstrap" ? "#F9FAFB" : "#333333",
        tooltipHeaderLine: theme === "Fabric" ? "#D2D0CE" : "#ffffff",
        tooltipFontSize: "12px",
        tabColor: theme === "Material" ? "#ff4081" : theme === "Fabric" ? "#0078D6" : "#317AB9",
        fontFamily: theme === "Material" ? "Roboto" : theme === "Bootstrap" ? "Helvetica" : "Segoe UI",
        smithchartTitleFont: {
          color: theme === "Material" ? "rgba(0, 0, 0, 1)" : theme === "Bootstrap" ? "#212529" : "#333333",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Bootstrap" ? "Helvetica" : "Segoe UI",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: theme === "Material" ? "rgba(97, 97, 97, 1)" : theme === "Bootstrap" ? "#666666" : "#666666",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Bootstrap" ? "Helvetica" : "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: theme === "Material" ? "rgba(0, 0, 0, 1)" : theme === "Bootstrap" ? "#212529" : "#F3F2F1",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Bootstrap" ? "Helvetica" : "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        dataLabelFont: {
          color: theme === "Material" ? "rgba(97, 97, 97, 1)" : theme === "Bootstrap" ? "#676767" : "#666666",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Bootstrap" ? "Helvetica" : "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        axisLabelFont: {
          color: theme === "Material" ? "rgba(97, 97, 97, 1)" : theme === "Bootstrap" ? "#676767" : "#666666",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Bootstrap" ? "Helvetica" : "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        smithchartSubtitleFont: {
          color: theme === "Material" ? "rgba(0, 0, 0, 1)" : theme === "Bootstrap" ? "#212529" : "#333333",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Bootstrap" ? "Helvetica" : "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
  }
  return style;
}

// node_modules/@syncfusion/ej2-charts/src/smithchart/utils/area.js
var AreaBounds = (
  /** @class */
  function() {
    function AreaBounds2() {
    }
    AreaBounds2.prototype.calculateAreaBounds = function(smithchart, title, bounds) {
      var margin = smithchart.margin;
      var border = smithchart.border;
      var spaceValue = this.getLegendSpace(smithchart, bounds);
      var x = spaceValue["leftLegendWidth"] + margin.left + border.width;
      var rightSpace = spaceValue["rightLegendWidth"] + margin.left + margin.right + 2 * border.width;
      var width = smithchart.availableSize["width"] - (x + rightSpace);
      var y = margin["top"] + 2 * smithchart.elementSpacing + spaceValue["modelTitleHeight"] + spaceValue["modelsubTitleHeight"] + spaceValue["topLegendHeight"] + border.width;
      var height = smithchart.availableSize["height"] - (spaceValue["modelTitleHeight"] + 2 * smithchart.elementSpacing + spaceValue["modelsubTitleHeight"] + margin["top"] + spaceValue["topLegendHeight"] + spaceValue["bottomLegendHeight"]);
      return {
        x,
        y,
        width,
        height
      };
    };
    AreaBounds2.prototype.getLegendSpace = function(smithchart, bounds) {
      var title = smithchart.title;
      var legend = smithchart.legendSettings;
      var position = legend.position.toLowerCase();
      var subtitleHeight = 0;
      var modelsubTitleHeight = 0;
      var titleHeight = 0;
      var font = smithchart.font;
      var modelTitleHeight = 0;
      var itemPadding = 10;
      var legendBorder = legend.border.width;
      var leftLegendWidth = 0;
      var rightLegendWidth = 0;
      var topLegendHeight = 0;
      var bottomLegendHeight = 0;
      var ltheight = 0;
      var space;
      if (legend["visible"]) {
        space = bounds.width + itemPadding / 2 + smithchart.elementSpacing + 2 * legendBorder;
        leftLegendWidth = position === "left" ? space : 0;
        rightLegendWidth = position === "right" ? space : 0;
        ltheight = legend["title"].visible ? measureText2(legend["title"].text, font, smithchart.themeStyle.legendLabelFont)["height"] : 0;
        topLegendHeight = position === "top" ? smithchart.elementSpacing + bounds.height + ltheight : 0;
        bottomLegendHeight = position === "bottom" ? smithchart.elementSpacing + bounds.height + ltheight : 0;
      }
      subtitleHeight = measureText2(title.subtitle.text, font, smithchart.themeStyle.legendLabelFont)["height"];
      modelTitleHeight = title.text === "" || !title["visible"] ? 0 : titleHeight;
      modelsubTitleHeight = title["subtitle"].text === "" || !title["subtitle"].visible ? 0 : subtitleHeight;
      return {
        leftLegendWidth,
        rightLegendWidth,
        topLegendHeight,
        bottomLegendHeight,
        modelTitleHeight,
        modelsubTitleHeight
      };
    };
    return AreaBounds2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/smithchart/model/constant.js
var animationComplete2 = "animationComplete";
var legendRender2 = "legendRender";
var titleRender = "titleRender";
var subtitleRender = "subtitleRender";
var textRender2 = "textRender";
var seriesRender2 = "seriesRender";
var load2 = "load";
var loaded2 = "loaded";
var axisLabelRender2 = "axisLabelRender";

// node_modules/@syncfusion/ej2-charts/src/smithchart/axis/axisrender.js
var AxisRender = (
  /** @class */
  function() {
    function AxisRender2() {
      this.radialLabels = [-50, -20, -10, -5, -4, -3, -2, -1.5, -1, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8, 1, 1.5, 2, 3, 4, 5, 10, 20, 50];
      this.radialLabelCollections = [];
      this.horizontalLabelCollections = [];
      this.labelCollections = [];
      this.direction = new Direction();
    }
    AxisRender2.prototype.renderArea = function(smithchart, bounds) {
      this.calculateChartArea(smithchart, bounds);
      this.calculateCircleMargin(smithchart, bounds);
      this.calculateXAxisRange(smithchart);
      this.calculateRAxisRange(smithchart);
      this.measureHorizontalAxis(smithchart);
      this.measureRadialAxis(smithchart);
      if (smithchart.horizontalAxis.visible) {
        this.updateHAxis(smithchart);
      }
      if (smithchart.radialAxis.visible) {
        this.updateRAxis(smithchart);
      }
      if (smithchart.horizontalAxis.visible) {
        this.drawHAxisLabels(smithchart);
      }
      if (smithchart.radialAxis.visible) {
        this.drawRAxisLabels(smithchart);
      }
    };
    AxisRender2.prototype.updateHAxis = function(smithchart) {
      var majorGridLines = smithchart.horizontalAxis.majorGridLines;
      var minorGridLines = smithchart.horizontalAxis.minorGridLines;
      var axisLine = smithchart.horizontalAxis.axisLine;
      if (majorGridLines.visible) {
        this.updateHMajorGridLines(smithchart);
      }
      if (minorGridLines.visible) {
        this.updateHMinorGridLines(smithchart);
      }
      if (axisLine.visible) {
        this.updateHAxisLine(smithchart);
      }
    };
    AxisRender2.prototype.updateRAxis = function(smithchart) {
      var majorGridLines = smithchart.radialAxis.majorGridLines;
      var minorGridLines = smithchart.radialAxis.minorGridLines;
      var axisLine = smithchart.radialAxis.axisLine;
      if (majorGridLines.visible) {
        this.updateRMajorGridLines(smithchart);
      }
      if (minorGridLines.visible) {
        this.updateRMinorGridLines(smithchart);
      }
      if (axisLine.visible) {
        this.updateRAxisLine(smithchart);
      }
    };
    AxisRender2.prototype.measureHorizontalAxis = function(smithchart) {
      var minorGridLines = smithchart.horizontalAxis.minorGridLines;
      this.measureHMajorGridLines(smithchart);
      if (minorGridLines.visible) {
        this.measureHMinorGridLines(smithchart);
      }
    };
    AxisRender2.prototype.measureRadialAxis = function(smithchart) {
      var minorGridLines = smithchart.radialAxis.minorGridLines;
      this.measureRMajorGridLines(smithchart);
      if (minorGridLines.visible) {
        this.measureRMinorGridLines(smithchart);
      }
    };
    AxisRender2.prototype.calculateChartArea = function(smithchart, bounds) {
      var width = smithchart.availableSize.width;
      var height = smithchart.availableSize.height;
      width = bounds.width;
      height = bounds.height;
      var chartAreaWidth = Math.min(width, height);
      var chartAreaHeight = Math.min(width, height);
      var x = bounds.x + (bounds.width / 2 - chartAreaWidth / 2);
      var y = bounds.y + ((height - chartAreaHeight) / 2 > 0 ? (height - chartAreaHeight) / 2 : 0);
      smithchart.chartArea = {
        x,
        y,
        width: chartAreaWidth,
        height: chartAreaHeight
      };
    };
    AxisRender2.prototype.calculateCircleMargin = function(smithchart, bounds) {
      var padding = 10;
      var maxLabelWidth = 0;
      var width = smithchart.chartArea.width;
      var radius = smithchart.radius;
      maxLabelWidth = this.maximumLabelLength(smithchart);
      var labelMargin = smithchart.radialAxis.labelPosition === "Outside" ? maxLabelWidth + padding : padding;
      var diameter = width - labelMargin * 2 > 0 ? width - labelMargin * 2 : 0;
      var actualRadius = diameter / 2;
      var circleCoefficient = radius > 1 ? 1 : radius < 0.1 ? 0.1 : radius;
      this.areaRadius = actualRadius * circleCoefficient;
      this.circleLeftX = smithchart.chartArea.x + labelMargin + actualRadius * (1 - circleCoefficient);
      this.circleTopY = smithchart.chartArea.y + labelMargin + actualRadius * (1 - circleCoefficient);
      this.circleCenterX = this.circleLeftX + this.areaRadius;
      this.circleCenterY = bounds.y + bounds.height / 2;
    };
    AxisRender2.prototype.maximumLabelLength = function(smithchart) {
      var maximumLabelLength = 0;
      var font = smithchart.horizontalAxis.labelStyle;
      var label;
      var textSize;
      for (var i = 0; i < this.radialLabels.length; i++) {
        label = this.radialLabels[i].toString();
        textSize = measureText2(label, font, smithchart.themeStyle.axisLabelFont);
        if (maximumLabelLength < textSize.width) {
          maximumLabelLength = textSize.width;
        }
      }
      return maximumLabelLength;
    };
    AxisRender2.prototype.calculateAxisLabels = function() {
      var spacingBetweenGridLines = 30;
      var previousR = 0;
      var j = 0;
      var labels = [];
      var diameter = this.areaRadius * 2;
      for (var i = 0; i < 2; i = i + 0.1) {
        i = Math.round(i * 10) / 10;
        var coeff = 1 / (i + 1);
        var isOverlap1 = false;
        var isOverlap2 = false;
        var radius = diameter * coeff / 2 * 2;
        if (previousR === 0 || i === 1) {
          previousR = radius;
          labels[j] = i;
          j++;
          continue;
        }
        if (i < 1) {
          isOverlap1 = this.isOverlap(1, diameter, radius, spacingBetweenGridLines);
        }
        if (i > 1) {
          isOverlap2 = this.isOverlap(2, diameter, radius, spacingBetweenGridLines);
        }
        if (isOverlap1 || isOverlap2) {
          continue;
        }
        if (previousR - radius >= spacingBetweenGridLines) {
          labels[j] = i;
          j++;
          previousR = radius;
        }
      }
      var staticlabels = [2, 3, 4, 5, 10, 20, 50];
      for (var k = 0; k < staticlabels.length; k++) {
        labels[j] = staticlabels[k];
        j++;
      }
      return labels;
    };
    AxisRender2.prototype.isOverlap = function(x, d, previousR, spacingBetweenGridLines) {
      var coeff = 1 / (x + 1);
      var radius = d * coeff / 2 * 2;
      return previousR - radius < spacingBetweenGridLines;
    };
    AxisRender2.prototype.calculateXAxisRange = function(smithchart) {
      var x;
      var coeff;
      var radius;
      var cx;
      var diameter = this.areaRadius * 2;
      var horizontalAxisLabels = this.calculateAxisLabels();
      var cy = this.circleCenterY;
      var circleStartX = this.circleLeftX;
      var leftX = this.circleLeftX;
      for (var i = 0; i < horizontalAxisLabels.length; i++) {
        x = horizontalAxisLabels[i];
        coeff = 1 / (x + 1);
        radius = diameter * coeff / 2;
        if (smithchart.renderType === "Impedance") {
          leftX = circleStartX + diameter - radius * 2;
        }
        cx = leftX + radius;
        this.horizontalLabelCollections.push({
          centerX: cx,
          centerY: cy,
          radius,
          value: x,
          region: null
        });
      }
    };
    AxisRender2.prototype.calculateRAxisRange = function(smithchart) {
      var arcCy;
      var arcRadius;
      var diameter = this.areaRadius * 2;
      var y;
      var point = new Point();
      if (smithchart.renderType === "Impedance") {
        point.x = this.circleLeftX + diameter;
        point.y = this.circleTopY + this.areaRadius;
      } else {
        point.x = this.circleLeftX;
        point.y = this.circleTopY + this.areaRadius;
      }
      for (var i = 0; i < this.radialLabels.length; i++) {
        y = this.radialLabels[i];
        arcRadius = Math.abs(1 / y * diameter / 2);
        if (smithchart.renderType === "Impedance") {
          arcCy = y > 0 ? point.y - arcRadius : point.y + arcRadius;
        } else {
          arcCy = y < 0 ? point.y - arcRadius : point.y + arcRadius;
        }
        this.radialLabelCollections.push({
          centerX: point.x,
          centerY: arcCy,
          radius: arcRadius,
          value: y
        });
      }
    };
    AxisRender2.prototype.measureHMajorGridLines = function(smithchart) {
      var arcPoints = [];
      var startPoint;
      var endPoint;
      var radialPoint1;
      var radialPoint2;
      var size;
      this.majorHGridArcPoints = [];
      for (var i = 0; i < this.horizontalLabelCollections.length; i++) {
        var circlePoint = new HorizontalLabelCollection();
        circlePoint = this.horizontalLabelCollections[i];
        arcPoints = this.calculateHMajorArcStartEndPoints(circlePoint.value);
        if (smithchart.renderType === "Impedance") {
          radialPoint1 = arcPoints[0];
          radialPoint2 = arcPoints[1];
        } else {
          radialPoint1 = arcPoints[1];
          radialPoint2 = arcPoints[0];
        }
        size = {
          width: circlePoint.radius,
          height: circlePoint.radius
        };
        if (circlePoint.value !== 0 && circlePoint.value !== 50) {
          startPoint = this.intersectingCirclePoints(radialPoint1[0].centerX, radialPoint1[0].centerY, radialPoint1[0].radius, circlePoint.centerX, circlePoint.centerY, circlePoint.radius, smithchart.renderType);
          endPoint = this.intersectingCirclePoints(radialPoint2[0].centerX, radialPoint2[0].centerY, radialPoint2[0].radius, circlePoint.centerX, circlePoint.centerY, circlePoint.radius, smithchart.renderType);
          this.majorHGridArcPoints.push({
            startPoint,
            endPoint,
            rotationAngle: 2 * Math.PI,
            sweepDirection: smithchart.renderType === "Impedance" ? this.direction["counterclockwise"] : this.direction["clockwise"],
            isLargeArc: true,
            size
          });
        } else {
          startPoint = {
            x: circlePoint.centerX + circlePoint.radius,
            y: circlePoint.centerY
          };
          endPoint = {
            x: circlePoint.centerX + circlePoint.radius,
            y: circlePoint.centerY - 0.05
          };
          this.majorHGridArcPoints.push({
            startPoint,
            endPoint,
            rotationAngle: 2 * Math.PI,
            sweepDirection: this.direction["clockwise"],
            isLargeArc: true,
            size
          });
        }
      }
    };
    AxisRender2.prototype.measureRMajorGridLines = function(smithchart) {
      var radialPoint;
      var y;
      var arcPoints = [];
      var innerInterSectPoint;
      var outerInterSectPoint;
      var outterInterSectRadian;
      var outterInterSectAngle;
      var startPoint;
      var endPoint;
      var size;
      var sweepDirection;
      this.majorRGridArcPoints = [];
      this.labelCollections = [];
      var epsilon = _getEpsilonValue();
      for (var i = 0; i < this.radialLabelCollections.length; i++) {
        radialPoint = this.radialLabelCollections[i];
        if (radialPoint.radius <= epsilon) {
          continue;
        }
        y = radialPoint.value;
        arcPoints = this.calculateMajorArcStartEndPoints(radialPoint, Math.abs(y), smithchart);
        innerInterSectPoint = arcPoints[0];
        outerInterSectPoint = arcPoints[1];
        outterInterSectRadian = this.circleXYRadianValue(this.circleCenterX, this.circleCenterY, outerInterSectPoint.x, outerInterSectPoint.y);
        outterInterSectAngle = outterInterSectRadian * (180 / Math.PI);
        if (y !== 0) {
          startPoint = {
            x: innerInterSectPoint.x,
            y: innerInterSectPoint.y
          };
          endPoint = {
            x: outerInterSectPoint.x,
            y: outerInterSectPoint.y
          };
          size = {
            width: radialPoint.radius,
            height: radialPoint.radius
          };
          sweepDirection = y > 0 ? this.direction["clockwise"] : this.direction["counterclockwise"];
          this.majorRGridArcPoints.push({
            startPoint,
            endPoint,
            size,
            rotationAngle: 2 * Math.PI,
            isLargeArc: false,
            sweepDirection
          });
          this.labelCollections.push({
            centerX: outerInterSectPoint.x,
            centerY: outerInterSectPoint.y,
            angle: outterInterSectAngle,
            value: y,
            radius: this.areaRadius,
            region: null
          });
        } else {
          startPoint = {
            x: this.circleLeftX,
            y: this.circleCenterY
          };
          endPoint = {
            x: this.circleCenterX + this.areaRadius,
            y: this.circleCenterY
          };
          this.majorRGridArcPoints.push({
            startPoint,
            endPoint,
            size: null,
            rotationAngle: null,
            isLargeArc: null,
            sweepDirection: null
          });
          this.labelCollections.push({
            centerX: smithchart.renderType === "Impedance" ? this.circleCenterX - this.areaRadius : this.circleCenterX + this.areaRadius,
            centerY: this.circleCenterY,
            angle: smithchart.renderType === "Impedance" ? 180 : 360,
            value: y,
            radius: this.areaRadius,
            region: null
          });
        }
      }
    };
    AxisRender2.prototype.circleXYRadianValue = function(centerX, centerY, outterX, outterY) {
      var radian;
      radian = Math.atan2(outterY - centerY, outterX - centerX);
      radian = radian < 0 ? radian + 360 * Math.PI / 180 : radian;
      return radian;
    };
    AxisRender2.prototype.calculateMajorArcStartEndPoints = function(radialPoint, value, smithchart) {
      var arcPoints = [];
      var circlePoint = [];
      var cx = this.circleCenterX;
      var cy = this.circleCenterY;
      if (value >= 10) {
        arcPoints[0] = smithchart.renderType === "Impedance" ? {
          x: cx + this.areaRadius,
          y: cy
        } : {
          x: cx - this.areaRadius,
          y: cy
        };
      } else if (value >= 3) {
        circlePoint = this.horizontalLabelCollections.filter(function(c) {
          return c.value === 10;
        });
      } else if (value >= 1) {
        circlePoint = this.horizontalLabelCollections.filter(function(c) {
          return c.value === 5;
        });
      } else {
        circlePoint = this.horizontalLabelCollections.filter(function(c) {
          return c.value === 3;
        });
      }
      if (circlePoint.length > 0) {
        arcPoints[0] = this.intersectingCirclePoints(radialPoint.centerX, radialPoint.centerY, radialPoint.radius, circlePoint[0].centerX, circlePoint[0].centerY, circlePoint[0].radius, smithchart.renderType);
      }
      arcPoints[1] = this.intersectingCirclePoints(radialPoint.centerX, radialPoint.centerY, radialPoint.radius, cx, cy, this.areaRadius, smithchart.renderType);
      return arcPoints;
    };
    AxisRender2.prototype.calculateHMajorArcStartEndPoints = function(value) {
      var arcHPoints = [];
      var calValue1;
      var calValue2;
      if (value <= 0.3) {
        calValue1 = 2;
        calValue2 = -2;
      } else if (value <= 1) {
        calValue1 = 3;
        calValue2 = -3;
      } else if (value <= 2) {
        calValue1 = 5;
        calValue2 = -5;
      } else if (value <= 5) {
        calValue1 = 10;
        calValue2 = -10;
      } else {
        calValue1 = 50;
        calValue2 = -50;
      }
      arcHPoints[0] = this.radialLabelCollections.filter(function(c) {
        return c.value === calValue1;
      });
      arcHPoints[1] = this.radialLabelCollections.filter(function(c) {
        return c.value === calValue2;
      });
      return arcHPoints;
    };
    AxisRender2.prototype.calculateMinorArcStartEndPoints = function(value) {
      var calValue1;
      var calValue2;
      var marcHPoints = [];
      if (value <= 0.1) {
        calValue1 = 1;
        calValue2 = -1;
      } else if (value <= 0.2) {
        calValue1 = 0.8;
        calValue2 = -0.8;
      } else if (value <= 0.3) {
        calValue1 = 0.4;
        calValue2 = -0.4;
      } else if (value <= 0.6) {
        calValue1 = 1;
        calValue2 = -1;
      } else if (value <= 1) {
        calValue1 = 1.5;
        calValue2 = -1.5;
      } else if (value <= 1.5) {
        calValue1 = 2;
        calValue2 = -2;
      } else if (value <= 2) {
        calValue1 = 1;
        calValue2 = -1;
      } else if (value <= 5) {
        calValue1 = 3;
        calValue2 = -3;
      } else {
        calValue1 = 10;
        calValue2 = -10;
      }
      marcHPoints[0] = this.radialLabelCollections.filter(function(c) {
        return c["value"] === calValue1;
      });
      marcHPoints[1] = this.radialLabelCollections.filter(function(c) {
        return c["value"] === calValue2;
      });
      return marcHPoints;
    };
    AxisRender2.prototype.intersectingCirclePoints = function(x1, y1, r1, x2, y2, r2, renderType) {
      var point = {
        x: 0,
        y: 0
      };
      var cx = x1 - x2;
      var cy = y1 - y2;
      var midRadius = Math.sqrt(cx * cx + cy * cy);
      var radiusSquare = midRadius * midRadius;
      var a = (r1 * r1 - r2 * r2) / (2 * radiusSquare);
      var radiusSquare2 = r1 * r1 - r2 * r2;
      var c = Math.sqrt(2 * (r1 * r1 + r2 * r2) / radiusSquare - radiusSquare2 * radiusSquare2 / (radiusSquare * radiusSquare) - 1);
      var fx = (x1 + x2) / 2 + a * (x2 - x1);
      var gx = c * (y2 - y1) / 2;
      var ix1 = fx + gx;
      var ix2 = fx - gx;
      var fy = (y1 + y2) / 2 + a * (y2 - y1);
      var gy = c * (x1 - x2) / 2;
      var iy1 = fy + gy;
      var iy2 = fy - gy;
      if (renderType === "Impedance") {
        if (ix2 < ix1) {
          point.x = ix2;
          point.y = iy2;
        } else {
          point.x = ix1;
          point.y = iy1;
        }
      } else {
        if (ix1 > ix2) {
          point.x = ix1;
          point.y = iy1;
        } else {
          point.x = ix2;
          point.y = iy2;
        }
      }
      return {
        x: point.x,
        y: point.y
      };
    };
    AxisRender2.prototype.updateHMajorGridLines = function(smithchart) {
      var majorGridLine = smithchart.horizontalAxis.majorGridLines;
      var groupElement = smithchart.renderer.createGroup({
        "id": smithchart.element.id + "_svg_horizontalAxisMajorGridLines"
      });
      groupElement.setAttribute("aria-hidden", "true");
      var path = this.calculateGridLinesPath(this.majorHGridArcPoints);
      var haxismgoptions = new PathOption2(smithchart.element.id + "_horizontalAxisMajorGridLines", "none", majorGridLine["width"], majorGridLine.color ? majorGridLine.color : smithchart.themeStyle.majorGridLine, majorGridLine["opacity"], majorGridLine["dashArray"], path);
      var element = smithchart.renderer.drawPath(haxismgoptions);
      groupElement.appendChild(element);
      smithchart.svgObject.appendChild(groupElement);
    };
    AxisRender2.prototype.updateRMajorGridLines = function(smithchart) {
      var majorGridLine = smithchart.radialAxis.majorGridLines;
      var groupElement = smithchart.renderer.createGroup({
        "id": smithchart.element.id + "_svg_radialAxisMajorGridLines"
      });
      groupElement.setAttribute("aria-hidden", "true");
      var path = this.calculateGridLinesPath(this.majorRGridArcPoints);
      var raxismgoptions = new PathOption2(smithchart.element.id + "_radialAxisMajorGridLines", "none", majorGridLine["width"], majorGridLine.color ? majorGridLine.color : smithchart.themeStyle.majorGridLine, majorGridLine["opacity"], majorGridLine["dashArray"], path);
      var element = smithchart.renderer.drawPath(raxismgoptions);
      groupElement.appendChild(element);
      smithchart.svgObject.appendChild(groupElement);
    };
    AxisRender2.prototype.updateHAxisLine = function(smithchart) {
      var radius = this.areaRadius;
      var axisLine = smithchart.horizontalAxis.axisLine;
      var groupElement = smithchart.renderer.createGroup({
        "id": smithchart.element.id + "_svg_hAxisLine"
      });
      groupElement.setAttribute("aria-hidden", "true");
      var point1 = {
        x: this.circleCenterX + radius,
        y: this.circleCenterY
      };
      var point2 = {
        x: this.circleCenterX + radius,
        y: this.circleCenterY - 0.05
      };
      var size = {
        width: radius,
        height: radius
      };
      var sweep = this.direction["clockwise"];
      var isLargeArc = 1;
      var angle = Math.PI * 2;
      var direction = "M" + point1.x + " " + point1.y + " A " + size.width + " " + size.height + " " + angle + " " + isLargeArc + " " + sweep + " " + point2.x + " " + point2.y;
      var options = new PathOption2(smithchart.element.id + "_horizontalAxisLine", "none", axisLine.width, axisLine.color ? axisLine.color : smithchart.themeStyle.axisLine, 1, axisLine.dashArray, direction);
      var element = smithchart.renderer.drawPath(options);
      groupElement.appendChild(element);
      smithchart.svgObject.appendChild(groupElement);
    };
    AxisRender2.prototype.updateRAxisLine = function(smithchart) {
      var radius = this.areaRadius;
      var axisLine = smithchart.radialAxis.axisLine;
      var point1 = {
        x: this.circleCenterX - radius,
        y: this.circleCenterY
      };
      var point2 = {
        x: this.circleCenterX + radius,
        y: this.circleCenterY
      };
      var size = {
        width: 0,
        height: 0
      };
      var sweep = this.direction["counterclockwise"];
      var isLargeArc = 0;
      var angle = 0;
      var direction = "M " + point1.x + " " + point1.y + " A " + size.width + " " + size.height + " " + angle + " " + isLargeArc + " " + sweep + " " + point2.x + " " + point2.y;
      var options = new PathOption2(smithchart.element.id + "_radialAxisLine", "none", axisLine.width, axisLine.color ? axisLine.color : smithchart.themeStyle.axisLine, 1, axisLine.dashArray, direction);
      var groupElement = smithchart.renderer.createGroup({
        "id": smithchart.element.id + "_svg_rAxisLine"
      });
      groupElement.setAttribute("aria-hidden", "true");
      var element = smithchart.renderer.drawPath(options);
      groupElement.appendChild(element);
      smithchart.svgObject.appendChild(groupElement);
    };
    AxisRender2.prototype.drawHAxisLabels = function(smithchart) {
      var hAxis = smithchart.horizontalAxis;
      smithchart.radialAxis.labelStyle.fontFamily = smithchart.themeStyle.fontFamily || smithchart.radialAxis.labelStyle.fontFamily;
      var font = smithchart.horizontalAxis.labelStyle;
      var circleAxis;
      var label;
      var x;
      var y;
      var textSize;
      var curLabel;
      var curLabelBounds;
      var curWidth;
      var curX;
      var preLabel;
      var preLabelBounds;
      var preWidth;
      var preX;
      var groupEle = smithchart.renderer.createGroup({
        id: smithchart.element.id + "_HAxisLabels"
      });
      groupEle.setAttribute("aria-hidden", "true");
      var _loop_1 = function(i2) {
        circleAxis = this_1.horizontalLabelCollections[i2];
        label = this_1.horizontalLabelCollections[i2].value.toString();
        if (circleAxis.value !== 0) {
          x = smithchart.renderType === "Impedance" ? circleAxis.centerX - circleAxis.radius : circleAxis.centerX + circleAxis.radius;
          y = circleAxis.centerY;
          textSize = measureText2(label, font, smithchart.themeStyle.axisLabelFont);
          x = smithchart.renderType === "Impedance" ? x - textSize.width : x;
          if (hAxis.labelPosition === "Outside") {
            y -= textSize.height / 4;
          } else {
            y += textSize.height;
          }
          this_1.horizontalLabelCollections[i2].region = this_1.calculateRegion(label, textSize, x, y);
          if (hAxis.labelIntersectAction === "Hide") {
            curLabel = this_1.horizontalLabelCollections[i2];
            curLabelBounds = curLabel.region.bounds;
            curWidth = curLabelBounds.width;
            curX = curLabelBounds.x;
            for (var j = 1; j < i2; j++) {
              preLabel = this_1.horizontalLabelCollections[j];
              preLabelBounds = preLabel.region.bounds;
              preWidth = preLabelBounds.width;
              preX = preLabelBounds.x;
              if (smithchart.renderType === "Impedance" && preX + preWidth > curX) {
                label = "";
              }
              if (smithchart.renderType === "Admittance" && preX < curX + curWidth) {
                label = "";
              }
            }
          }
          var axisLabelRenderEventArgs_1 = {
            text: label.toString(),
            x,
            y,
            name: axisLabelRender2,
            cancel: false
          };
          var axisLabelRenderSuccess = function(args) {
            if (!args.cancel) {
              var options = new TextOption2(smithchart.element.id + "_HLabel_" + i2, axisLabelRenderEventArgs_1.x, axisLabelRenderEventArgs_1.y, "none", axisLabelRenderEventArgs_1.text);
              var color = font.color ? font.color : smithchart.themeStyle.axisLabelFont.color;
              font.fontFamily = font.fontFamily || smithchart.themeStyle.labelFontFamily;
              var element = renderTextElement(options, font, color, groupEle, smithchart.themeStyle.axisLabelFont);
              groupEle.appendChild(element);
            }
          };
          axisLabelRenderSuccess.bind(this_1);
          smithchart.trigger(axisLabelRender2, axisLabelRenderEventArgs_1, axisLabelRenderSuccess);
        }
      };
      var this_1 = this;
      for (var i = 0; i < this.horizontalLabelCollections.length; i++) {
        _loop_1(i);
      }
      smithchart.svgObject.appendChild(groupEle);
    };
    AxisRender2.prototype.drawRAxisLabels = function(smithchart) {
      var paddingRadius = 2;
      smithchart.radialAxis.labelStyle.fontFamily = smithchart.themeStyle.fontFamily || smithchart.radialAxis.labelStyle.fontFamily;
      var font = smithchart.radialAxis.labelStyle;
      var interSectPoint = new RadialLabelCollections();
      var label;
      var textSize;
      var angle;
      var position;
      var textPosition;
      var curX;
      var curY;
      var curWidth;
      var curHeight;
      var curLabel;
      var curLabelBounds;
      var preX;
      var preY;
      var preWidth;
      var preHeight;
      var preLabel;
      var preLabelBounds;
      var rAxis = smithchart.radialAxis;
      var groupEle = smithchart.renderer.createGroup({
        id: smithchart.element.id + "_RAxisLabels"
      });
      groupEle.setAttribute("aria-hidden", "true");
      var _loop_2 = function(i2) {
        interSectPoint = this_2.labelCollections[i2];
        label = interSectPoint.value.toString();
        textSize = measureText2(label, font, smithchart.themeStyle.axisLabelFont);
        angle = Math.round(interSectPoint.angle * 100) / 100;
        if (rAxis.labelPosition === "Outside") {
          position = this_2.circlePointPosition(this_2.circleCenterX, this_2.circleCenterY, interSectPoint["angle"], this_2.areaRadius + paddingRadius);
          textPosition = this_2.setLabelsOutsidePosition(angle, position.x, position.y, textSize);
        } else {
          position = this_2.circlePointPosition(this_2.circleCenterX, this_2.circleCenterY, interSectPoint["angle"], this_2.areaRadius - paddingRadius);
          textPosition = this_2.setLabelsInsidePosition(angle, position.x, position.y, textSize);
        }
        this_2.labelCollections[i2]["region"] = this_2.calculateRegion(label, textSize, textPosition.x, textPosition.y);
        if (rAxis.labelIntersectAction === "Hide") {
          curLabel = this_2.labelCollections[i2];
          curLabelBounds = curLabel["region"]["bounds"];
          curWidth = curLabelBounds["width"];
          curHeight = curLabelBounds["height"];
          curX = curLabelBounds["x"];
          curY = curLabelBounds["y"];
          for (var j = 0; j < i2; j++) {
            preLabel = this_2.labelCollections[j];
            preLabelBounds = preLabel["region"]["bounds"];
            preWidth = preLabelBounds["width"];
            preHeight = preLabelBounds["height"];
            preX = preLabelBounds["x"];
            preY = preLabelBounds["y"];
            if (preX <= curX + curWidth && curX <= preX + preWidth && preY <= curY + curHeight && curY <= preY + preHeight) {
              label = " ";
            }
          }
        }
        var axisLabelRenderEventArgs = {
          text: label.toString(),
          x: textPosition.x,
          y: textPosition.y,
          name: axisLabelRender2,
          cancel: false
        };
        var axisLabelRenderSuccess = function(args) {
          if (!args.cancel) {
            var options = new TextOption2(smithchart.element.id + "_RLabel_" + i2, axisLabelRenderEventArgs.x, axisLabelRenderEventArgs.y, "none", axisLabelRenderEventArgs.text);
            var color = font.color ? font.color : smithchart.themeStyle.axisLabelFont.color;
            font.fontFamily = smithchart.themeStyle.labelFontFamily ? smithchart.themeStyle.labelFontFamily : font.fontFamily;
            var element = renderTextElement(options, font, color, groupEle, smithchart.themeStyle.axisLabelFont);
            groupEle.appendChild(element);
          }
        };
        axisLabelRenderSuccess.bind(this_2);
        smithchart.trigger(axisLabelRender2, axisLabelRenderEventArgs, axisLabelRenderSuccess);
      };
      var this_2 = this;
      for (var i = 0; i < this.labelCollections.length; i++) {
        _loop_2(i);
      }
      smithchart.svgObject.appendChild(groupEle);
    };
    AxisRender2.prototype.calculateRegion = function(label, textSize, textPositionX, textPositionY) {
      var xAxisLabelRegions = new LabelRegion();
      var bounds = {
        x: textPositionX,
        y: textPositionY,
        width: textSize.width,
        height: textSize.height
      };
      xAxisLabelRegions = {
        bounds,
        labelText: label
      };
      return xAxisLabelRegions;
    };
    AxisRender2.prototype.updateHMinorGridLines = function(smithchart) {
      var minorGridLine = smithchart.horizontalAxis.minorGridLines;
      var groupElement = smithchart.renderer.createGroup({
        "id": smithchart.element.id + "_svg_horizontalAxisMinorGridLines"
      });
      var path = this.calculateGridLinesPath(this.minorHGridArcPoints);
      var haxismioptions = new PathOption2(smithchart.element.id + "_horizontalAxisMinorGridLines", "none", minorGridLine["width"], minorGridLine.color ? minorGridLine.color : smithchart.themeStyle.minorGridLine, minorGridLine["opacity"], minorGridLine["dashArray"], path);
      var element = smithchart.renderer.drawPath(haxismioptions);
      groupElement.appendChild(element);
      smithchart.svgObject.appendChild(groupElement);
    };
    AxisRender2.prototype.updateRMinorGridLines = function(smithchart) {
      var minorGridLine = smithchart.radialAxis.minorGridLines;
      var groupElement = smithchart.renderer.createGroup({
        "id": smithchart.element.id + "_svg_radialAxisMinorGridLines"
      });
      var path = this.calculateGridLinesPath(this.minorGridArcPoints);
      var raxismioptions = new PathOption2(smithchart.element.id + "_radialAxisMinorGridLines", "none", minorGridLine["width"], minorGridLine.color ? minorGridLine.color : smithchart.themeStyle.minorGridLine, minorGridLine["opacity"], minorGridLine["dashArray"], path);
      var element = smithchart.renderer.drawPath(raxismioptions);
      groupElement.appendChild(element);
      smithchart.svgObject.appendChild(groupElement);
    };
    AxisRender2.prototype.calculateGridLinesPath = function(points) {
      var x1;
      var y1;
      var x2;
      var y2;
      var r1;
      var r2;
      var pathSegment = new GridArcPoints();
      var angle;
      var isLargeArc;
      var sweep;
      var sb = "";
      for (var i = 0; i < points.length; i++) {
        pathSegment = points[i];
        x1 = pathSegment.startPoint.x;
        y1 = pathSegment.startPoint.y;
        x2 = pathSegment.endPoint.x;
        y2 = pathSegment.endPoint.y;
        r1 = pathSegment.size ? pathSegment.size.width : 0;
        r2 = pathSegment.size ? pathSegment.size.height : 0;
        angle = pathSegment.rotationAngle ? pathSegment.rotationAngle : 0;
        isLargeArc = pathSegment.isLargeArc ? 1 : 0;
        sweep = pathSegment.sweepDirection ? pathSegment.sweepDirection : 0;
        sb = sb + ("M " + x1 + " " + y1 + " A " + r1 + " " + r2 + " " + angle + " " + isLargeArc + " " + sweep + " " + x2 + " " + y2 + " ");
      }
      var path = sb.toString();
      return path;
    };
    AxisRender2.prototype.measureHMinorGridLines = function(smithchart) {
      var radialPoint1;
      var radialPoint2;
      var arcPoints = [];
      var isLargeArc;
      var startPoint;
      var endPoint;
      var size;
      var cx;
      var maxCount = smithchart.horizontalAxis.minorGridLines.count;
      var previous;
      var next;
      var space;
      var count;
      var interval;
      var radius;
      var leftX;
      this.minorHGridArcPoints = [];
      var diameter = this.areaRadius * 2;
      for (var i = 0; i < this.horizontalLabelCollections.length - 3; i++) {
        previous = this.horizontalLabelCollections[i];
        next = this.horizontalLabelCollections[i + 1];
        space = (previous["radius"] - next["radius"]) * 2;
        count = Math.floor(maxCount / 100 * space);
        interval = space / count;
        for (var j = 0; j < count; j++) {
          radius = next["radius"] + j * interval / 2;
          leftX = smithchart.renderType === "Impedance" ? this.circleLeftX + diameter - radius * 2 : this.circleLeftX;
          cx = leftX + radius;
          isLargeArc = next["value"] > 5;
          arcPoints = this.calculateMinorArcStartEndPoints(next["value"]);
          if (smithchart.renderType === "Impedance") {
            radialPoint1 = arcPoints[0];
            radialPoint2 = arcPoints[1];
          } else {
            radialPoint1 = arcPoints[1];
            radialPoint2 = arcPoints[0];
          }
          startPoint = this.intersectingCirclePoints(radialPoint1[0].centerX, radialPoint1[0].centerY, radialPoint1[0].radius, cx, previous["centerY"], radius, smithchart.renderType);
          endPoint = this.intersectingCirclePoints(radialPoint2[0].centerX, radialPoint2[0].centerY, radialPoint2[0].radius, cx, previous["centerY"], radius, smithchart.renderType);
          size = {
            width: radius,
            height: radius
          };
          this.minorHGridArcPoints.push({
            startPoint,
            endPoint,
            rotationAngle: 2 * Math.PI,
            sweepDirection: smithchart.renderType === "Impedance" ? this.direction["counterclockwise"] : this.direction["clockwise"],
            isLargeArc,
            size
          });
        }
      }
    };
    AxisRender2.prototype.measureRMinorGridLines = function(smithchart) {
      var maxCount = smithchart.radialAxis.minorGridLines.count;
      var arcCx;
      var nextAngle;
      var betweenAngle;
      var circlePoint;
      var previous;
      var next;
      var size;
      var distance;
      var count;
      var interval;
      var centerValue;
      var circumference = Math.PI * (this.areaRadius * 2);
      var arcStartX = arcCx = smithchart.renderType === "Impedance" ? this.circleCenterX + this.areaRadius : this.circleCenterX - this.areaRadius;
      var arcStartY = this.circleCenterY;
      this.minorGridArcPoints = [];
      var arcStartPoint = {
        x: arcStartX,
        y: arcStartY
      };
      for (var i = 2; i < this.labelCollections.length - 3; i++) {
        previous = this.labelCollections[i];
        next = this.labelCollections[i + 1];
        if (smithchart.renderType === "Impedance") {
          nextAngle = next["angle"] === 360 ? 0 : next["angle"];
          betweenAngle = Math.abs(nextAngle - previous["angle"]);
        } else {
          nextAngle = previous["angle"] === 360 ? 0 : previous["angle"];
          betweenAngle = Math.abs(nextAngle - next["angle"]);
        }
        distance = circumference / 360 * betweenAngle;
        count = Math.floor(maxCount / 100 * distance);
        interval = betweenAngle / count;
        centerValue = next["value"] > 0 ? next["value"] : previous["value"];
        circlePoint = this.minorGridLineArcIntersectCircle(Math.abs(centerValue));
        for (var j = 1; j < count; j++) {
          var outterInterSectAngle = interval * j + (previous["angle"] === 360 ? nextAngle : previous["angle"]);
          var outerInterSectPoint = this.circlePointPosition(this.circleCenterX, this.circleCenterY, outterInterSectAngle, this.areaRadius);
          var radius = this.arcRadius(arcStartPoint, outerInterSectPoint, outterInterSectAngle);
          var arcCy = outterInterSectAngle > 180 ? this.circleCenterY - radius : this.circleCenterY + radius;
          var innerInterSectPoint = this.intersectingCirclePoints(arcCx, arcCy, radius, circlePoint[0].centerX, circlePoint[0].centerY, circlePoint[0].radius, smithchart.renderType);
          var startPoint = {
            x: innerInterSectPoint.x,
            y: innerInterSectPoint.y
          };
          var endPoint = {
            x: outerInterSectPoint.x,
            y: outerInterSectPoint.y
          };
          size = {
            width: radius,
            height: radius
          };
          var sweepDirection = previous["value"] >= 0 ? this.direction["clockwise"] : this.direction["counterclockwise"];
          this.minorGridArcPoints.push({
            startPoint,
            endPoint,
            rotationAngle: 2 * Math.PI,
            sweepDirection,
            isLargeArc: false,
            size
          });
        }
      }
    };
    AxisRender2.prototype.minorGridLineArcIntersectCircle = function(centerValue) {
      var calValue;
      if (centerValue >= 3) {
        calValue = 20;
      } else if (centerValue >= 1.5) {
        calValue = 10;
      } else if (centerValue >= 0.6) {
        calValue = 3;
      } else {
        calValue = 2;
      }
      var circlePoint = this.horizontalLabelCollections.filter(function(c) {
        return c["value"] === calValue;
      });
      return circlePoint;
    };
    AxisRender2.prototype.circlePointPosition = function(cx, cy, angle, r) {
      var radian = angle * (Math.PI / 180);
      var pointX = cx + r * Math.cos(radian);
      var pointY = cy + r * Math.sin(radian);
      return {
        x: pointX,
        y: pointY
      };
    };
    AxisRender2.prototype.setLabelsInsidePosition = function(angle, px, py, textSize) {
      var x = px;
      var y = py;
      if (angle === 0 || angle === 360) {
        x -= textSize.width;
        y -= textSize.height / 2;
      } else if (angle === 90) {
        x -= textSize.width;
        y += textSize.height / 8;
      } else if (angle === 180) {
        y += textSize.height;
      } else if (angle === 270) {
        y += textSize.height / 2;
      } else if (angle > 0 && angle <= 20) {
        x -= textSize.width;
      } else if (angle > 20 && angle <= 60) {
        x -= textSize.width + textSize.width / 2;
        y += textSize.height / 2;
      } else if (angle > 60 && angle < 90) {
        x -= textSize.width + textSize.width / 4;
        y += textSize.height / 4;
      } else if (angle > 90 && angle <= 135) {
        x -= textSize.width / 2;
        y += textSize.height / 16;
      } else if (angle > 135 && angle <= 150) {
        x += textSize.width / 2;
        y += textSize.height / 2;
      } else if (angle > 150 && angle < 180) {
        x += textSize.width / 2;
        y += textSize.height;
      } else if (angle > 180 && angle <= 210) {
        x += textSize.width / 6;
        y += textSize.height / 6;
      } else if (angle > 210 && angle < 240) {
        y += textSize.height / 4;
      } else if (angle > 225 && angle < 270) {
        y += textSize.height / 3;
      } else if (angle > 270 && angle <= 300) {
        x -= textSize.width + textSize.width / 4;
        y += textSize.height / 4;
      } else if (angle > 300 && angle <= 330) {
        x -= textSize.width + textSize.width / 3;
        y += textSize.height / 4;
      } else if (angle > 330 && angle <= 340) {
        x -= textSize.width + textSize.width / 2;
        y += textSize.height / 4;
      } else if (angle > 340) {
        x -= textSize.width;
        y += textSize.height / 8;
      }
      return {
        x,
        y
      };
    };
    AxisRender2.prototype.setLabelsOutsidePosition = function(angle, px, py, textSize) {
      var x = px;
      var y = py;
      if (angle === 90) {
        x -= textSize.width / 2;
        y += textSize.height;
      } else if (angle === 180) {
        x -= textSize.width + 5;
        y -= textSize.height / 4;
      } else if (angle === 270) {
        x -= textSize.width / 2;
        y -= textSize.height / 4;
      } else if (angle === 360) {
        x += 5;
        y -= textSize.height / 2;
      } else if (angle > 0 && angle <= 30) {
        x += textSize.width / 4;
        y += textSize.height / 8;
      } else if (angle > 30 && angle <= 60) {
        x += textSize.width / 2;
        y += textSize.height / 4;
      } else if (angle > 60 && angle <= 90) {
        x -= textSize.width / 2;
        y += textSize.height;
      } else if (angle > 90 && angle <= 135) {
        x -= textSize.width;
        y += textSize.height;
      } else if (angle > 135 && angle <= 180) {
        x -= textSize.width + textSize.width / 4;
        y += textSize.height / 4;
      } else if (angle > 180 && angle <= 210) {
        x -= textSize.width + textSize.width / 4;
        y -= textSize.height / 4;
      } else if (angle > 210 && angle <= 270) {
        x -= textSize.width;
        y -= textSize.height / 4;
      } else if (angle > 270 && angle <= 340) {
        y -= textSize.height / 4;
      } else if (angle > 340) {
        y += textSize.height / 4;
        x += textSize.width / 6;
      }
      return {
        x,
        y
      };
    };
    AxisRender2.prototype.arcRadius = function(startPoint, endPoint, angle) {
      var radian = angle > 180 ? 90 * Math.PI / 180 : 270 * Math.PI / 180;
      var mx = (endPoint.x - startPoint.x) / 2;
      var my = (endPoint.y - startPoint.y) / 2;
      var u = (Math.cos(radian) * my - Math.sin(radian) * mx) / (Math.cos(radian) * mx + Math.sin(radian) * my);
      var t = (my - mx * u) / Math.sin(radian);
      var cy = startPoint.y + Math.sin(radian) * t;
      var radius = Math.abs(startPoint.y - cy);
      return radius;
    };
    return AxisRender2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/smithchart/series/marker.js
var Marker2 = (
  /** @class */
  function() {
    function Marker3() {
    }
    Marker3.prototype.drawMarker = function(smithchart, seriesindex, groupElement, pointsRegion) {
      if (smithchart.series[seriesindex].marker.visible) {
        var marker = smithchart.series[seriesindex].marker;
        var count = smithchart.series[seriesindex].points.length - 1;
        var width = marker.width;
        var height = marker.height;
        var symbolName = marker.shape;
        var gmEle = smithchart.renderer.createGroup({
          "id": smithchart.element.id + "_svg_series" + seriesindex + "_Marker"
        });
        groupElement.appendChild(gmEle);
        var borderWidth = marker.border.width;
        var borderColor = marker.border.color;
        var opacity = marker.opacity;
        var fill = marker.fill ? marker.fill : smithchart.series[seriesindex].fill || smithchart.seriesColors[seriesindex % smithchart.seriesColors.length];
        for (var i = 0; i < count + 1; i++) {
          var location_1 = pointsRegion[i]["point"];
          var pointIndex = i;
          var options = new MarkerOptions(smithchart.element.id + "_Series" + seriesindex + "_Points" + pointIndex + "_Marker" + pointIndex, fill, borderColor, borderWidth, opacity);
          gmEle.appendChild(this.drawSymbol(symbolName, marker.imageUrl, location_1, new SmithchartSize(width, height), options, smithchart));
        }
      }
    };
    Marker3.prototype.drawSymbol = function(symbolName, url, location, size, options, smithchart) {
      var markerEle;
      var shape = symbolName.toLowerCase();
      var circleOptions;
      var pathOptions;
      var path;
      var border = {
        color: options["borderColor"],
        width: options["borderWidth"]
      };
      var opacity = options.opacity;
      var startX = location.x;
      var startY = location.y;
      var radius = Math.sqrt(size.height * size.height + size.width * size.width) / 2;
      var eq = 72;
      switch (shape) {
        case "circle":
          circleOptions = new CircleOption2(options["id"], options["fill"], border, opacity, location.x, location.y, radius, null);
          markerEle = smithchart.renderer.drawCircle(circleOptions);
          break;
        case "rectangle":
          path = "M " + (startX + -size.width / 2) + " " + (startY + -size.height / 2) + " L " + (startX + size.width / 2) + " " + (startY + -size.height / 2) + " L " + (startX + size.width / 2) + " " + (startY + size.height / 2) + " L " + (startX + -size.width / 2) + " " + (startY + size.height / 2) + " L " + (startX + -size.width / 2) + " " + (startY + -size.height / 2) + "z";
          pathOptions = new PathOption2(options["id"], options["fill"], border.width, border.color, opacity, "", path);
          markerEle = smithchart.renderer.drawPath(pathOptions);
          break;
        case "triangle":
          path = "M " + (startX + -size.width / 2) + " " + (startY + size.height / 2) + " L " + startX + " " + (startY + -size.height / 2) + " L " + (startX + size.width / 2) + " " + (startY + size.height / 2) + " L " + (startX + -size.width / 2) + " " + (startY + size.height / 2) + "z";
          pathOptions = new PathOption2(options["id"], options["fill"], border.width, border.color, opacity, "", path);
          markerEle = smithchart.renderer.drawPath(pathOptions);
          break;
        case "diamond":
          path = "M " + (startX + -size.width / 2) + " " + startY + " L " + startX + " " + (startY + -size.height / 2) + " L " + (startX + size.width / 2) + " " + startY + " L " + startX + " " + (startY + size.height / 2) + " L " + (startX + -size.width / 2) + " " + startY + "z";
          pathOptions = new PathOption2(options["id"], options["fill"], border.width, border.color, opacity, "", path);
          markerEle = smithchart.renderer.drawPath(pathOptions);
          break;
        case "pentagon":
          for (var i = 0; i <= 5; i++) {
            var xValue = radius * Math.cos(Math.PI / 180 * (i * eq));
            var yValue = radius * Math.sin(Math.PI / 180 * (i * eq));
            if (i === 0) {
              path = "M " + (startX + xValue) + " " + (startY + yValue) + " ";
            } else {
              path = path.concat("L " + (startX + xValue) + " " + (startY + yValue) + " ");
            }
          }
          path = path.concat("Z");
          pathOptions = new PathOption2(options["id"], options["fill"], border.width, border.color, opacity, "", path);
          markerEle = smithchart.renderer.drawPath(pathOptions);
          break;
      }
      markerEle.setAttribute("role", "img");
      markerEle.setAttribute("aria-label", "x: " + location.x + ", y: " + location.y);
      if (smithchart.element.id + "_Series0_Points0_Marker0" === options.id) {
        markerEle.setAttribute("tabindex", "0");
      }
      return markerEle;
    };
    return Marker3;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/smithchart/series/datalabel.js
var DataLabel2 = (
  /** @class */
  function() {
    function DataLabel3() {
      this.textOptions = [];
      this.labelOptions = [];
      this.allPoints = [];
    }
    DataLabel3.prototype.drawDataLabel = function(smithchart, seriesindex, groupElement, pointsRegion, bounds) {
      this.textOptions = [];
      this.allPoints = [];
      var margin = smithchart.margin;
      var pointIndex;
      var marker = smithchart.series[seriesindex].marker;
      var region;
      var labelPosition;
      var labelText;
      var textSize;
      var dataLabel = marker.dataLabel;
      var font = dataLabel.textStyle;
      var count = pointsRegion.length;
      for (var i = 0; i < count; i++) {
        labelText = smithchart.series[seriesindex].points[i].reactance.toString();
        textSize = measureText2(labelText, font, smithchart.themeStyle.dataLabelFont);
        region = pointsRegion[i]["point"];
        var xPos = region.x - textSize.width / 2;
        var yPos = region.y - (textSize.height + marker["height"] + margin.top);
        var width = textSize.width + margin.left / 2 + margin.right / 2;
        var height = textSize.height + margin.top / 2 + margin.bottom / 2;
        font.fontFamily = font.fontFamily ? font.fontFamily : smithchart.themeStyle.dataLabelFont.fontFamily;
        pointIndex = i;
        labelPosition = new SmithchartLabelPosition();
        labelPosition = {
          textX: xPos + margin.left / 2,
          textY: yPos + height / 2 + margin.top / 2,
          x: xPos,
          y: yPos
        };
        this.textOptions[i] = {
          id: smithchart.element.id + "_Series" + seriesindex + "_Points" + pointIndex + "_dataLabel_displayText" + i,
          x: labelPosition["textX"],
          y: labelPosition["textY"],
          fill: "black",
          text: labelText,
          font,
          xPosition: xPos,
          yPosition: yPos,
          width,
          height,
          location: region,
          labelOptions: labelPosition,
          visible: true,
          connectorFlag: null
        };
      }
      var labelOption = new LabelOption();
      labelOption.textOptions = this.textOptions;
      this.labelOptions.push(labelOption);
      this.drawDatalabelSymbol(smithchart, seriesindex, dataLabel, groupElement, bounds, pointsRegion);
    };
    DataLabel3.prototype.calculateSmartLabels = function(points, seriesIndex) {
      var length = points["textOptions"].length;
      var count = 0;
      for (var k = 0; k < length; k++) {
        this.allPoints[this.allPoints.length] = points["textOptions"][k];
        this.connectorFlag = false;
        this.compareDataLabels(k, points, count, seriesIndex);
        this.labelOptions[seriesIndex]["textOptions"][k] = points["textOptions"][k];
        this.labelOptions[seriesIndex]["textOptions"][k].connectorFlag = this.connectorFlag;
      }
    };
    DataLabel3.prototype.compareDataLabels = function(i, points, count, m) {
      var length = this.allPoints.length;
      var padding = 10;
      var collide;
      var currentLabel;
      var prevLabel;
      for (var j = 0; j < length; j++) {
        prevLabel = this.allPoints[j];
        currentLabel = this.allPoints[length - 1];
        collide = this.isCollide(prevLabel, currentLabel);
        if (collide) {
          this.connectorFlag = true;
          switch (count) {
            case 0:
              this.resetValues(currentLabel);
              this.prevLabel = prevLabel;
              currentLabel["xPosition"] = this.prevLabel["xPosition"] + (this.prevLabel["width"] / 2 + currentLabel["width"] / 2 + padding);
              currentLabel["x"] = currentLabel["xPosition"] + padding / 2;
              count += 1;
              this.compareDataLabels(i, points, count, m);
              break;
            case 1:
              this.resetValues(currentLabel);
              currentLabel["xPosition"] = this.prevLabel["xPosition"] + this.prevLabel["width"] / 2 + currentLabel["width"] / 2 + padding;
              currentLabel["x"] = currentLabel["xPosition"] + padding / 2;
              currentLabel["yPosition"] = currentLabel["location"].y + currentLabel["height"] / 2 + padding / 2;
              currentLabel["y"] = currentLabel["yPosition"] + currentLabel["height"] / 2 + padding / 2;
              count += 1;
              this.compareDataLabels(i, points, count, m);
              break;
            case 2:
              this.resetValues(currentLabel);
              currentLabel["yPosition"] = currentLabel["location"].y + currentLabel["height"] / 2 + padding / 2;
              currentLabel["y"] = currentLabel["yPosition"] + currentLabel["height"] / 2 + padding / 2;
              count += 1;
              this.compareDataLabels(i, points, count, m);
              break;
            case 3:
              this.resetValues(currentLabel);
              currentLabel["xPosition"] = this.prevLabel["xPosition"] - this.prevLabel["width"] / 2 - currentLabel["width"] / 2 - padding;
              currentLabel["x"] = currentLabel["xPosition"] + padding / 2;
              currentLabel["yPosition"] = currentLabel["height"] / 2 + currentLabel["location"].y + padding / 2;
              currentLabel["y"] = currentLabel["yPosition"] + currentLabel["height"] / 2 + padding / 2;
              count += 1;
              this.compareDataLabels(i, points, count, m);
              break;
            case 4:
              this.resetValues(currentLabel);
              currentLabel["xPosition"] = this.prevLabel["xPosition"] - this.prevLabel["width"] / 2 - currentLabel["width"] / 2 - padding;
              currentLabel["x"] = currentLabel["xPosition"] + padding / 2;
              count += 1;
              this.compareDataLabels(i, points, count, m);
              break;
            case 5:
              this.resetValues(currentLabel);
              currentLabel["xPosition"] = this.prevLabel["xPosition"] - this.prevLabel["width"] / 2 - currentLabel["width"] / 2 - padding;
              currentLabel["x"] = currentLabel["xPosition"] + padding / 2;
              currentLabel["yPosition"] = this.prevLabel["yPosition"] - currentLabel["height"] - padding;
              currentLabel["y"] = currentLabel["yPosition"] + currentLabel["height"] / 2 + padding / 2;
              count += 1;
              this.compareDataLabels(i, points, count, m);
              break;
            case 6:
              this.resetValues(currentLabel);
              currentLabel["yPosition"] = this.prevLabel["yPosition"] - (currentLabel["height"] + padding);
              currentLabel["y"] = currentLabel["yPosition"] + currentLabel["height"] / 2 + padding / 2;
              count += 1;
              this.compareDataLabels(i, points, count, m);
              break;
            case 7:
              this.resetValues(currentLabel);
              currentLabel["xPosition"] = this.prevLabel["xPosition"] + this.prevLabel["width"] / 2 + currentLabel["width"] / 2 + padding;
              currentLabel["x"] = currentLabel["xPosition"] + padding / 2;
              currentLabel["yPosition"] = this.prevLabel["yPosition"] - currentLabel["height"] - padding;
              currentLabel["y"] = currentLabel["yPosition"] + currentLabel["height"] / 2 + padding / 2;
              count += 1;
              this.compareDataLabels(i, points, count, m);
              break;
            case 8:
              count = 0;
              this.compareDataLabels(i, points, count, m);
              break;
          }
        }
      }
    };
    DataLabel3.prototype.isCollide = function(dataLabel1, dataLabel2) {
      var state = false;
      if (dataLabel1 !== dataLabel2) {
        state = !// to compare data labels
        (dataLabel1["y"] + dataLabel1["height"] < dataLabel2["y"] || dataLabel1["y"] > dataLabel2["y"] + dataLabel2["height"] || dataLabel1["x"] + dataLabel1["width"] / 2 < dataLabel2["x"] - dataLabel2["width"] / 2 || dataLabel1["x"] - dataLabel1["width"] / 2 > dataLabel2["x"] + dataLabel2["width"] / 2);
      }
      return state;
    };
    DataLabel3.prototype.resetValues = function(currentPoint) {
      currentPoint["xPosition"] = currentPoint["labelOptions"]["x"];
      currentPoint["yPosition"] = currentPoint["labelOptions"]["y"];
      currentPoint["x"] = currentPoint["labelOptions"]["textX"];
      currentPoint["y"] = currentPoint["labelOptions"]["textY"];
    };
    DataLabel3.prototype.drawConnectorLines = function(smithchart, seriesIndex, index, currentPoint, groupElement) {
      var location = currentPoint["location"];
      var endY;
      if (location.y > currentPoint["y"]) {
        endY = currentPoint["y"];
      } else {
        endY = currentPoint["y"] - currentPoint["height"] / 2;
      }
      var connectorDirection = "M " + location.x + " " + location.y + " L " + currentPoint["x"] + " " + endY;
      var connectorLineValues = smithchart.series[seriesIndex].marker.dataLabel.connectorLine;
      var stroke = connectorLineValues.color ? connectorLineValues.color : smithchart.series[seriesIndex].fill || smithchart.seriesColors[seriesIndex % smithchart.seriesColors.length];
      var options = new PathOption2(smithchart.element.id + "_dataLabelConnectorLine_series" + seriesIndex + "_point" + index, "none", connectorLineValues.width, stroke, 1, "none", connectorDirection);
      var element = smithchart.renderer.drawPath(options);
      groupElement.appendChild(element);
    };
    DataLabel3.prototype.drawDatalabelSymbol = function(smithchart, seriesindex, dataLabel, groupElement, bounds, pointsRegion) {
      for (var i = 0; i < smithchart.series[seriesindex].points.length; i++) {
        if (dataLabel.template) {
          var labelTemplateElement = createElement("div", {
            id: smithchart.element.id + "_seriesIndex_" + seriesindex + "_Label_Template_Group",
            className: "template",
            styles: "position: absolute;"
            /* 'top:' + bounds['x'] + 'px;' +
            'left:' + bounds['y'] + 'px;' +
            'height:' + smithchart.availableSize.height + 'px;' +
            'width:' + smithchart.availableSize.width + 'px;'*/
          });
          document.getElementById(smithchart.element.id + "_Secondary_Element").appendChild(labelTemplateElement);
          var id = dataLabel.template + "_seriesIndex" + seriesindex + "_pointIndex" + i + smithchart.element.id;
          var data = {
            point: smithchart.series[seriesindex].points[i].reactance
          };
          var templateFn = getTemplateFunction2(dataLabel.template);
          var templateElement = templateFn(smithchart);
          var labelElement = convertElementFromLabel(templateElement, id, data);
          labelTemplateElement.appendChild(labelElement);
          labelElement.style.left = pointsRegion[i].point.x - labelElement.offsetWidth / 2 + "px";
          labelElement.style.top = pointsRegion[i].point.y - labelElement.offsetHeight - smithchart.series[seriesindex].marker.height / 2 + "px";
          var left = parseInt(labelElement.style.left, 10);
          var top_1 = parseInt(labelElement.style.top, 10);
          var width = labelElement.offsetWidth;
          var height = labelElement.offsetHeight;
          var region = pointsRegion[i]["point"];
          var labelPosition = {
            textX: left,
            textY: top_1,
            x: left,
            y: top_1
          };
          this.labelOptions[seriesindex]["textOptions"][i] = {
            id,
            x: left,
            y: top_1,
            fill: "black",
            text: "",
            font: dataLabel.textStyle,
            xPosition: left,
            yPosition: top_1,
            width,
            height,
            location: region,
            labelOptions: labelPosition,
            visible: true,
            connectorFlag: null
          };
        }
      }
    };
    return DataLabel3;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/smithchart/series/seriesrender.js
var SeriesRender = (
  /** @class */
  function() {
    function SeriesRender2() {
      this.xValues = [];
      this.yValues = [];
      this.pointsRegion = [];
      this.lineSegments = [];
      this.location = [];
      this.dataLabel = new DataLabel2();
    }
    SeriesRender2.prototype.processData = function(series) {
      var dataArray = series.dataSource;
      var resistance = series.resistance;
      var reactance = series.reactance;
      var tooltip = series.tooltipMappingName;
      series.points = [];
      for (var i = 0; i < dataArray.length; i++) {
        series.points.push({
          resistance: dataArray[i][resistance],
          reactance: dataArray[i][reactance],
          tooltip: dataArray[i][tooltip]
        });
      }
    };
    SeriesRender2.prototype.draw = function(smithchart, axisRender, bounds) {
      var groupElement = smithchart.renderer.createGroup({
        "id": smithchart.element.id + "_svg_seriesCollections"
      });
      var resistantCx;
      var reactanceCy;
      var series = smithchart.series;
      var seriesLength = series.length;
      var chartAreaRadius = axisRender.areaRadius;
      var interSectPoint;
      var index;
      for (var m = 0; m < seriesLength; m++) {
        var seriesIndex = m;
        if (series[m].dataSource && series[m].resistance && series[m].reactance) {
          this.processData(series[m]);
        }
        this.pointsRegion[m] = [];
        this.location[m] = [];
        for (var j = 0; j < series[m].points.length; j++) {
          this.xValues[j] = series[m].points[j]["resistance"];
          this.yValues[j] = series[m].points[j]["reactance"];
        }
        var chartAreaCx = axisRender.circleCenterX;
        var chartAreaCy = axisRender.circleCenterY;
        var diameter = axisRender.areaRadius * 2;
        var reactanceStartPoint = {
          x: chartAreaCx + (smithchart.renderType === "Impedance" ? chartAreaRadius : -chartAreaRadius),
          y: chartAreaCy
        };
        var resistantCy = chartAreaCy;
        var reactanceCx = reactanceStartPoint.x;
        for (var k = 0; k < series[m].points.length; k++) {
          var resistance = this.xValues[k];
          var resistantR = diameter * (1 / (resistance + 1)) / 2;
          var reactance = this.yValues[k];
          var reactanceR = Math.abs(1 / reactance * diameter / 2);
          if (smithchart.renderType === "Impedance") {
            reactanceCy = reactance > 0 ? chartAreaCy - reactanceR : chartAreaCy + reactanceR;
            resistantCx = axisRender.circleLeftX + diameter - resistantR;
          } else {
            reactanceCy = reactance < 0 ? chartAreaCy - reactanceR : chartAreaCy + reactanceR;
            resistantCx = axisRender.circleLeftX + resistantR;
          }
          interSectPoint = axisRender.intersectingCirclePoints(reactanceCx, reactanceCy, reactanceR, resistantCx, resistantCy, resistantR, smithchart.renderType);
          var epsilon = _getEpsilonValue();
          if (Math.abs(reactance) < epsilon) {
            interSectPoint.x = smithchart.renderType === "Impedance" ? resistantCx - resistantR : resistantCx + resistantR;
            interSectPoint.y = chartAreaCy;
          }
          this.pointsRegion[m][k] = new PointRegion();
          this.pointsRegion[m][k] = {
            point: interSectPoint,
            x: resistance,
            y: reactance
          };
          this.location[m][k] = {
            x: interSectPoint.x,
            y: interSectPoint.y
          };
        }
        for (var i = 0; i < series[m].points.length - 1; i++) {
          index = i + 1;
          this.lineSegments[i] = new LineSegment();
          this.lineSegments[i] = {
            x1: this.xValues[i],
            y1: this.yValues[i],
            x2: this.xValues[index],
            y2: this.yValues[index]
          };
        }
        smithchart.svgObject.appendChild(groupElement);
        this.drawSeries(smithchart, seriesIndex, groupElement, bounds);
      }
      for (var j = 0; j < smithchart.series.length; j++) {
        if (smithchart.series[j].enableSmartLabels && smithchart.series[j].marker.dataLabel.visible) {
          var gdlcEle = smithchart.renderer.createGroup({
            "id": smithchart.element.id + "_svg_series" + j + "_Datalabel_connectorLines"
          });
          var element = document.getElementById(smithchart.element.id + "_svg_seriesCollection" + j);
          if (element) {
            element.setAttribute("aria-label", "Smithchart with " + series[j].points.length + " points");
            element.appendChild(gdlcEle);
          }
          this.dataLabel.calculateSmartLabels(this.dataLabel.labelOptions[j], j);
          for (var k = 0; k < smithchart.series[j].points.length; k++) {
            var currentPoint = this.dataLabel.labelOptions[j]["textOptions"][k];
            if (currentPoint.xPosition + currentPoint.width > smithchart.chartArea.x + smithchart.chartArea.width || currentPoint.xPosition < smithchart.chartArea.x || currentPoint.yPosition < smithchart.chartArea.y || currentPoint.yPosition + currentPoint.height > smithchart.chartArea.y + smithchart.chartArea.height) {
              this.dataLabel.labelOptions[j].textOptions[k].connectorFlag = false;
              this.dataLabel.labelOptions[j].textOptions[k].visible = false;
            }
            if (currentPoint["connectorFlag"]) {
              this.dataLabel.drawConnectorLines(smithchart, j, k, currentPoint, gdlcEle);
            }
          }
        }
      }
      var _loop_1 = function(j2) {
        var dataLabel = smithchart.series[j2].marker.dataLabel;
        if (smithchart.series[j2].marker.dataLabel.visible) {
          var element2 = document.getElementById(smithchart.element.id + "_svg_seriesCollection" + j2);
          var gdEle_1 = smithchart.renderer.createGroup({
            "id": smithchart.element.id + "_svg_series" + j2 + "_Datalabel"
          });
          gdEle_1.setAttribute("aria-hidden", "true");
          if (element2) {
            element2.appendChild(gdEle_1);
          }
          var _loop_2 = function(k3) {
            var currentPoint2 = this_1.dataLabel.labelOptions[j2]["textOptions"][k3];
            if (!dataLabel.template && currentPoint2.visible) {
              var options_1 = new DataLabelTextOptions();
              options_1 = this_1.dataLabel.labelOptions[j2]["textOptions"][k3];
              var font_1 = dataLabel.textStyle;
              var x = options_1["xPosition"];
              var y = options_1["yPosition"];
              var id = smithchart.element.id + "_Series" + j2 + "_Points" + k3 + "_dataLabel_symbol" + k3;
              var fill = dataLabel["fill"] ? dataLabel["fill"] : smithchart.series[j2].fill || smithchart.seriesColors[j2 % smithchart.seriesColors.length];
              var border = smithchart.series[j2].marker.dataLabel.border;
              var rectOptions = new RectOption2(id, fill, border, options_1["opacity"], new SmithchartRect(x, y, options_1["width"], options_1["height"]));
              var dataEle = smithchart.renderer.drawRectangle(rectOptions);
              gdEle_1.appendChild(dataEle);
              var textRenderEventArgs = {
                text: options_1["text"],
                x: options_1["x"],
                y: options_1["y"],
                seriesIndex: j2,
                pointIndex: k3,
                name: textRender2,
                cancel: false
              };
              var textRenderSuccess = function(args) {
                if (!args.cancel) {
                  var textoptions = new TextOption2(options_1["id"], args.x, args.y, "start", args.text);
                  var color = font_1.color ? font_1.color : smithchart.themeStyle.dataLabelFont.color;
                  var element_1 = renderTextElement(textoptions, font_1, color, gdEle_1, smithchart.themeStyle.dataLabelFont);
                  gdEle_1.appendChild(element_1);
                }
              };
              textRenderSuccess.bind(this_1);
              smithchart.trigger(textRender2, textRenderEventArgs, textRenderSuccess);
            } else if (dataLabel.template) {
              var element_2 = document.getElementById(dataLabel.template + "_seriesIndex" + j2 + "_pointIndex" + k3 + smithchart.element.id);
              element_2.style.left = this_1.dataLabel.labelOptions[j2]["textOptions"][k3].xPosition + "px";
              element_2.style.top = this_1.dataLabel.labelOptions[j2]["textOptions"][k3].yPosition + "px";
            }
          };
          for (var k2 = 0; k2 < smithchart.series[j2].points.length; k2++) {
            _loop_2(k2);
          }
        }
      };
      var this_1 = this;
      for (var j = 0; j < smithchart.series.length; j++) {
        _loop_1(j);
      }
      for (var i = 0; i < smithchart.series.length; i++) {
        if ((smithchart.series[i].enableAnimation && animationMode !== "Disable" || animationMode === "Enable") && smithchart.animateSeries) {
          if (smithchart.series[i].marker.dataLabel.template) {
            this.animateDataLabelTemplate(i, smithchart);
          }
          var element = document.getElementById(smithchart.element.id + "_svg_seriesCollection" + i);
          element.setAttribute("aria-label", "Smithchart with " + series[i].points.length + " points");
          this.performAnimation(smithchart, element, i);
        }
      }
    };
    SeriesRender2.prototype.drawSeries = function(smithchart, seriesindex, groupElement, bounds) {
      var _this = this;
      var gsEle = smithchart.renderer.createGroup({
        "id": smithchart.element.id + "_svg_seriesCollection" + seriesindex,
        "clip-path": "url(#" + smithchart.element.id + "_ChartSeriesClipRect_" + seriesindex + ")"
      });
      if (!smithchart.series[seriesindex].marker.visible) {
        gsEle.setAttribute("tabindex", seriesindex === 0 ? "0" : "");
        gsEle.style.outline = "none";
      }
      gsEle.setAttribute("visibility", smithchart.series[seriesindex].visibility);
      gsEle.setAttribute("role", "region");
      gsEle.setAttribute("aria-label", "Smithchart with " + smithchart.series[seriesindex].points.length + " points");
      groupElement.appendChild(gsEle);
      var sb = "";
      var element;
      var count = smithchart.series[seriesindex].points.length - 1;
      for (var i = 0; i < count; i++) {
        var point1 = this.pointsRegion[seriesindex][i]["point"];
        var point2 = this.pointsRegion[seriesindex][i + 1]["point"];
        sb = sb + ("M " + point1.x + " " + point1.y + " L " + point2.x + " " + point2.y + " ");
      }
      var path = sb.toString();
      var fill = smithchart.series[seriesindex].fill || smithchart.seriesColors[seriesindex % smithchart.seriesColors.length];
      var seriesEventArgs = {
        text: smithchart.series[seriesindex].name,
        fill,
        name: seriesRender2,
        cancel: false
      };
      var seriesRenderSuccess = function(args) {
        if (!args.cancel) {
          var options = new PathOption2(smithchart.element.id + "_series" + seriesindex + "_points", "none", smithchart.series[seriesindex].width, seriesEventArgs.fill, smithchart.series[seriesindex].opacity, "none", path);
          _this.clipRectElement = smithchart.renderer.drawClipPath(new RectOption2(smithchart.element.id + "_ChartSeriesClipRect_" + seriesindex, "transparent", {
            width: 1,
            color: "Gray"
          }, 1, {
            x: bounds.x,
            y: bounds.y,
            width: smithchart.availableSize.width,
            height: smithchart.availableSize.height
          }));
          gsEle.appendChild(_this.clipRectElement);
          var gspEle = smithchart.renderer.createGroup({
            "id": smithchart.element.id + "_svg" + seriesindex
          });
          element = smithchart.renderer.drawPath(options);
          gspEle.appendChild(element);
          gsEle.appendChild(gspEle);
        }
      };
      seriesRenderSuccess.bind(this);
      smithchart.trigger(seriesRender2, seriesEventArgs, seriesRenderSuccess);
      var markerrender = new Marker2();
      markerrender.drawMarker(smithchart, seriesindex, gsEle, this.pointsRegion[seriesindex]);
      this.dataLabel.drawDataLabel(smithchart, seriesindex, gsEle, this.pointsRegion[seriesindex], bounds);
    };
    SeriesRender2.prototype.animateDataLabelTemplate = function(seriesindex, smithchart) {
      var length = smithchart.series[seriesindex].points.length;
      var delay = 0;
      var duration = parseFloat(smithchart.series[seriesindex].animationDuration);
      for (var i = 0; i < length; i++) {
        var element = document.getElementById(smithchart.series[seriesindex].marker.dataLabel.template + "_seriesIndex" + seriesindex + "_pointIndex" + i + smithchart.element.id);
        element.style.visibility = "hidden";
        templateAnimate2(smithchart, element, delay, duration, "FadeIn");
      }
    };
    SeriesRender2.prototype.performAnimation = function(smithchart, gsEle, seriesIndex) {
      var animation = new Animation({});
      var clipRect = gsEle.childNodes[0].childNodes[0].childNodes[0];
      var effect = getAnimationFunction2("Linear");
      var reveffect = getAnimationFunction2("Reverse");
      var width = +clipRect.getAttribute("width");
      var x = +clipRect.getAttribute("x");
      var value;
      animation.animate(clipRect, {
        duration: parseFloat(smithchart.series[seriesIndex].animationDuration) === 0 && animationMode === "Enable" ? 2e3 : parseFloat(smithchart.series[seriesIndex].animationDuration),
        progress: function(args) {
          if (smithchart.renderType === "Impedance") {
            value = effect(args.timeStamp - args.delay, 0, width, args.duration);
            clipRect.setAttribute("width", value.toString());
          } else {
            value = reveffect(args.timeStamp - args.delay, width, 0, args.duration);
            clipRect.setAttribute("x", value.toString());
          }
        },
        end: function() {
          if (smithchart.renderType === "Impedance") {
            clipRect.setAttribute("width", width.toString());
          } else {
            clipRect.setAttribute("x", x.toString());
          }
          var event2 = {
            cancel: false,
            name: animationComplete2,
            smithchart
          };
          smithchart.trigger(animationComplete2, event2);
        }
      });
    };
    SeriesRender2.prototype.getLocation = function(seriesindex, pointIndex) {
      var x = this.location[seriesindex][pointIndex].x;
      var y = this.location[seriesindex][pointIndex].y;
      return {
        x,
        y
      };
    };
    return SeriesRender2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/smithchart/utils/export.js
var ExportUtils2 = (
  /** @class */
  function() {
    function ExportUtils3(control) {
      this.control = control;
    }
    ExportUtils3.prototype.print = function(elements) {
      this.smithchartPrint = window.open("", "print", "height=" + window.outerHeight + ",width=" + window.outerWidth + ",tabbar=no");
      this.smithchartPrint.moveTo(0, 0);
      this.smithchartPrint.resizeTo(screen.availWidth, screen.availHeight);
      var argsData = {
        cancel: false,
        htmlContent: this.getHTMLContent(elements),
        name: smithchartBeforePrint
      };
      this.control.trigger(smithchartBeforePrint, argsData);
      if (!argsData.cancel) {
        print(argsData.htmlContent, this.smithchartPrint);
      }
    };
    ExportUtils3.prototype.getHTMLContent = function(svgElements) {
      var div = createElement("div");
      if (svgElements) {
        if (svgElements instanceof Array) {
          svgElements.forEach(function(value) {
            div.appendChild(getElement3(value).cloneNode(true));
          });
        } else if (svgElements instanceof Element) {
          div.appendChild(svgElements.cloneNode(true));
        } else {
          div.appendChild(getElement3(svgElements).cloneNode(true));
        }
      } else {
        div.appendChild(this.control.element.cloneNode(true));
      }
      return div;
    };
    ExportUtils3.prototype.export = function(exportType, fileName, orientation) {
      var _this = this;
      var canvas = createElement("canvas", {
        id: "ej2-canvas",
        attrs: {
          "width": this.control.availableSize.width.toString(),
          "height": this.control.availableSize.height.toString()
        }
      });
      var isDownload = !(Browser.userAgent.toString().indexOf("HeadlessChrome") > -1);
      orientation = isNullOrUndefined(orientation) ? PdfPageOrientation.Landscape : orientation;
      var svgData = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">' + this.control.svgObject.outerHTML + "</svg>";
      var url = window.URL.createObjectURL(new Blob(exportType === "SVG" ? [svgData] : [new XMLSerializer().serializeToString(this.control.svgObject)], {
        type: "image/svg+xml"
      }));
      if (exportType === "SVG") {
        this.triggerDownload(fileName, exportType, url, isDownload);
      } else {
        var image_1 = new Image();
        var ctx_1 = canvas.getContext("2d");
        image_1.onload = function() {
          ctx_1.drawImage(image_1, 0, 0);
          window.URL.revokeObjectURL(url);
          if (exportType === "PDF") {
            var document_1 = new PdfDocument();
            var imageString = canvas.toDataURL("image/jpeg").replace("image/jpeg", "image/octet-stream");
            document_1.pageSettings.orientation = orientation;
            imageString = imageString.slice(imageString.indexOf(",") + 1);
            document_1.pages.add().graphics.drawImage(new PdfBitmap(imageString), 0, 0, _this.control.availableSize.width - 60, _this.control.availableSize.height);
            if (isDownload) {
              document_1.save(fileName + ".pdf");
              document_1.destroy();
            }
          } else {
            _this.triggerDownload(fileName, exportType, canvas.toDataURL("image/png").replace("image/png", "image/octet-stream"), isDownload);
          }
        };
        image_1.src = url;
      }
    };
    ExportUtils3.prototype.triggerDownload = function(fileName, exportType, url, isDownload) {
      createElement("a", {
        attrs: {
          "download": fileName + "." + exportType.toLocaleLowerCase(),
          "href": url
        }
      }).dispatchEvent(new MouseEvent(isDownload ? "click" : "move", {
        view: window,
        bubbles: false,
        cancelable: true
      }));
    };
    return ExportUtils3;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/smithchart/smithchart.js
var __extends94 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate22 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Smithchart = (
  /** @class */
  function(_super) {
    __extends94(Smithchart2, _super);
    function Smithchart2(options, element) {
      var _this = _super.call(this, options, element) || this;
      _this.isLegendClicked = false;
      _this.previousTargetId = "";
      _this.currentPointIndex = 0;
      _this.currentSeriesIndex = 0;
      _this.currentLegendIndex = 0;
      return _this;
    }
    Smithchart2.prototype.getModuleName = function() {
      return "smithchart";
    };
    Smithchart2.prototype.getPersistData = function() {
      return "";
    };
    Smithchart2.prototype.createChartSvg = function() {
      this.removeSvg();
      createSvg2(this);
    };
    Smithchart2.prototype.renderTitle = function(title, type, groupEle) {
      var _this = this;
      var font = title.textStyle;
      var textSize = measureText2(title.text, font, this.themeStyle.smithchartTitleFont);
      var x;
      var textAlignment = title.textAlignment;
      var titleText = title.text;
      var maxTitleWidth = isNullOrUndefined(title.maximumWidth) ? Math.abs(this.margin.left + this.margin.right - this.availableSize.width) : title.maximumWidth;
      var titleWidthEnable = textSize.width > maxTitleWidth ? true : false;
      if (textSize.width > this.availableSize.width) {
        x = this.margin.left + this.border.width;
      } else {
        x = textAlignment === "Center" ? this.availableSize.width / 2 - textSize["width"] / 2 : textAlignment === "Near" ? this.margin.left + this.elementSpacing + this.border.width : this.availableSize.width - textSize["width"] - (this.margin.right + this.elementSpacing + this.border.width);
      }
      var y = this.margin.top + textSize["height"] / 2 + this.elementSpacing;
      if (title.enableTrim && titleWidthEnable) {
        titleText = textTrim2(maxTitleWidth, title.text, font, this.themeStyle.smithchartTitleFont);
        textSize = measureText2(titleText, font, this.themeStyle.smithchartTitleFont);
      }
      groupEle = this.renderer.createGroup({
        id: this.element.id + "_Title_Group"
      });
      var titleEventArgs = {
        text: titleText,
        x,
        y,
        name: titleRender,
        cancel: false
      };
      var options;
      var titleRenderSuccess = function(args) {
        if (!args.cancel) {
          options = new TextOption2(_this.element.id + "_Smithchart_" + type, args.x, args.y, "start", args.text);
          var element = renderTextElement(options, font, font.color || _this.themeStyle.smithchartTitleFont.color, groupEle, _this.themeStyle.smithchartTitleFont);
          element.setAttribute("tabindex", "0");
          var titleLocation = {
            x: args.x,
            y: args.y,
            textSize
          };
          _this.svgObject.appendChild(groupEle);
          if (title.subtitle.text !== "" && title.subtitle.visible) {
            _this.renderSubtitle(title, type, textSize, _this.availableSize, titleLocation, groupEle);
          }
        }
      };
      titleRenderSuccess.bind(this);
      this.trigger(titleRender, titleEventArgs, titleRenderSuccess);
    };
    Smithchart2.prototype.renderSubtitle = function(title, type, textSize, size, titleLocation, groupEle) {
      var _this = this;
      var font = title.subtitle.textStyle;
      var subTitle = title.subtitle;
      var subTitleSize = measureText2(subTitle.text, font, this.themeStyle.smithchartSubtitleFont);
      var subTitleText = subTitle.text;
      var maxSubTitleWidth = isNullOrUndefined(subTitle.maximumWidth) ? this.bounds.width * 0.75 : subTitle.maximumWidth;
      if (subTitle.enableTrim && subTitleSize.width > maxSubTitleWidth) {
        subTitleText = textTrim2(maxSubTitleWidth, subTitle.text, font, this.themeStyle.smithchartSubtitleFont);
      }
      var x = title["subtitle"].textAlignment === "Far" ? titleLocation.x + titleLocation.textSize.width : title["subtitle"].textAlignment === "Near" ? titleLocation.x : titleLocation.x + titleLocation.textSize.width / 2;
      var y = titleLocation.y + 2 * this.elementSpacing;
      var textAnchor = title["subtitle"].textAlignment === "Far" ? "end" : title["subtitle"].textAlignment === "Near" ? "start" : "middle";
      var subtitleEventArgs = {
        text: subTitleText,
        x,
        y,
        name: subtitleRender,
        cancel: false
      };
      var subtitleRenderSuccess = function(args) {
        if (!args.cancel) {
          var options = new TextOption2(_this.element.id + "_Smithchart_" + type, args.x, args.y, textAnchor, args.text);
          var element = renderTextElement(options, font, font.color || _this.themeStyle.smithchartSubtitleFont.color, groupEle, _this.themeStyle.smithchartSubtitleFont);
          element.setAttribute("aria-label", subTitle.description || args.text);
          groupEle.appendChild(element);
        }
      };
      subtitleRenderSuccess.bind(this);
      this.trigger(subtitleRender, subtitleEventArgs, subtitleRenderSuccess);
    };
    Smithchart2.prototype.renderBorder = function() {
      var border = this.border;
      this.background = this.background ? this.background : this.themeStyle.background;
      var borderRect = new RectOption2(this.element.id + "_SmithchartBorder", this.background, border, 1, new SmithchartRect(border.width / 2, border.width / 2, this.availableSize.width - border.width, this.availableSize.height - border.width));
      var element = this.svgObject.appendChild(this.renderer.drawRectangle(borderRect));
      element.setAttribute("aria-hidden", "true");
    };
    Smithchart2.prototype.onPropertyChanged = function(newProp) {
      var renderer = false;
      if (!this.delayRedraw) {
        for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
          var prop = _a[_i];
          switch (prop) {
            case "background":
            case "border":
            case "series":
            case "legendSettings":
            case "radius":
            case "enableRtl":
              renderer = true;
              break;
            case "size":
              this.createChartSvg();
              renderer = true;
              break;
            case "theme":
            case "renderType":
              this.animateSeries = true;
              renderer = true;
              break;
          }
        }
        if (renderer) {
          this.render();
        }
      }
    };
    Smithchart2.prototype.preRender = function() {
      this.allowServerDataBinding = false;
      this.trigger(load2, {
        smithchart: this
      });
      this.unWireEVents();
      this.initPrivateVariable();
      this.wireEVents();
    };
    Smithchart2.prototype.initPrivateVariable = function() {
      this.animateSeries = true;
      this.delayRedraw = false;
      this.element.setAttribute("role", "region");
      this.element.setAttribute("aria-label", this.title.description || this.title.text + ". Syncfusion interactive chart.");
      this.element.setAttribute("tabindex", "0");
      this.element.style.outline = "none";
    };
    Smithchart2.prototype.setNavigationStyle = function(target) {
      var currentElement = document.getElementById(target);
      if (currentElement) {
        currentElement.style.setProperty("outline", "1.5px solid " + this.themeStyle.tabColor);
      }
    };
    Smithchart2.prototype.removeNavigationStyle = function() {
      var currentElement = document.querySelectorAll("text[id*=_Smithchart_title], g[id*=_svg_Legend], g[id*=_svg_seriesCollection], path[id*=_Points], [id*=" + this.element.id + "]");
      if (currentElement) {
        currentElement.forEach(function(element) {
          if (element instanceof HTMLElement || element instanceof SVGElement) {
            element.style.setProperty("outline", "none");
            element.style.setProperty("margin", "");
          }
        });
      }
    };
    Smithchart2.prototype.setTheme = function() {
      this.themeStyle = getThemeColor2(this.theme);
      this.seriesColors = getSeriesColor2(this.theme);
    };
    Smithchart2.prototype.render = function() {
      this.createChartSvg();
      this.element.appendChild(this.svgObject);
      this.setTheme();
      this.createSecondaryElement();
      this.renderBorder();
      if (this.smithchartLegendModule && this.legendSettings.visible) {
        this.legendBounds = this.smithchartLegendModule.calculateLegendBounds(this);
      }
      var areaBounds = new AreaBounds();
      this.bounds = areaBounds.calculateAreaBounds(this, this.title, this.legendBounds);
      if (this.title.text !== "" && this.title.visible) {
        this.renderTitle(this.title, "title", null);
      }
      var axisRender = new AxisRender();
      axisRender.renderArea(this, this.bounds);
      this.seriesrender = new SeriesRender();
      this.seriesrender.draw(this, axisRender, this.bounds);
      if (this.smithchartLegendModule && this.legendSettings.visible) {
        this.smithchartLegendModule.renderLegend(this);
      }
      this.renderComplete();
      this.allowServerDataBinding = true;
      this.trigger(loaded2, {
        smithchart: this
      });
    };
    Smithchart2.prototype.createSecondaryElement = function() {
      if (isNullOrUndefined(document.getElementById(this.element.id + "_Secondary_Element"))) {
        var secondaryElement = createElement("div", {
          id: this.element.id + "_Secondary_Element",
          styles: "z-index:1;"
        });
        this.element.appendChild(secondaryElement);
        var rect = this.element.getBoundingClientRect();
        var svgRect = document.getElementById(this.element.id + "_svg");
        if (svgRect) {
          var svgClientRect = svgRect.getBoundingClientRect();
          secondaryElement.style.left = Math.max(svgClientRect.left - rect.left, 0) + "px";
          secondaryElement.style.top = Math.max(svgClientRect.top - rect.top, 0) + "px";
        }
      } else {
        removeElement3(this.element.id + "_Secondary_Element");
      }
    };
    Smithchart2.prototype.destroy = function() {
      if (this.element) {
        this.unWireEVents();
        _super.prototype.destroy.call(this);
        this.element.classList.remove("e-smithchart");
        this.removeSvg();
        this.svgObject = null;
        var element = document.getElementById(this.element.id + "Keyboard_smith_chart_focus");
        if (element) {
          element.remove();
        }
        removeElement3("smithchartmeasuretext");
      }
    };
    Smithchart2.prototype.wireEVents = function() {
      EventHandler.add(this.element, "click", this.smithchartOnClick, this);
      EventHandler.add(this.element, Browser.touchMoveEvent, this.mouseMove, this);
      EventHandler.add(this.element, Browser.touchEndEvent, this.mouseEnd, this);
      EventHandler.add(this.element, "keyup", this.chartKeyUp, this);
      EventHandler.add(this.element, "keydown", this.chartKeyDown, this);
      window.addEventListener(Browser.isTouch && "orientation" in window && "onorientationchange" in window ? "orientationchange" : "resize", this.smithchartOnResize.bind(this));
    };
    Smithchart2.prototype.mouseMove = function(e) {
      if (e.type === "touchmove") {
        this.isTouch = true;
      } else {
        this.isTouch = e.pointerType === "touch" || e.pointerType === "2" || this.isTouch;
      }
      if (this.tooltipRenderModule && !this.isTouch) {
        this.tooltipRenderModule.smithchartMouseMove(this, e);
      }
    };
    Smithchart2.prototype.mouseEnd = function(e) {
      if (e.type === "touchend") {
        this.isTouch = true;
      } else {
        this.isTouch = e.pointerType === "touch" || e.pointerType === "2";
      }
      if (this.tooltipRenderModule && this.isTouch) {
        var tooltipElement_1 = this.tooltipRenderModule.smithchartMouseMove(this, e);
        if (tooltipElement_1) {
          this.fadeoutTo = +setTimeout(function() {
            tooltipElement_1.fadeOut();
          }, 2e3);
        }
      }
    };
    Smithchart2.prototype.smithchartOnClick = function(e) {
      var targetEle = e.target;
      var targetId = this.isLegendClicked ? targetEle.children[1].id : targetEle.id;
      var parentElement = document.getElementById(targetId).parentElement;
      var grpElement = document.getElementById(parentElement.id).parentElement;
      if (grpElement.id === "containerlegendItem_Group" && this.legendSettings.toggleVisibility) {
        var childElement = parentElement.childNodes[1];
        var circleElement = parentElement.childNodes[0];
        var legendText = childElement.textContent;
        var seriesIndex = void 0;
        var fill = void 0;
        for (var i = 0; i < this.smithchartLegendModule.legendSeries.length; i++) {
          if (legendText === this.smithchartLegendModule.legendSeries[i]["text"]) {
            seriesIndex = this.smithchartLegendModule.legendSeries[i].seriesIndex;
            fill = this.smithchartLegendModule.legendSeries[i].fill;
          }
        }
        var seriesElement = document.getElementById(this.element.id + "_svg_seriesCollection" + seriesIndex);
        if (seriesElement.getAttribute("visibility") === "visible") {
          circleElement.setAttribute("fill", "gray");
          seriesElement.setAttribute("visibility", "hidden");
          this.series[seriesIndex].visibility = "hidden";
        } else {
          circleElement.setAttribute("fill", fill);
          seriesElement.setAttribute("visibility", "visible");
          this.series[seriesIndex].visibility = "visible";
        }
      }
      this.removeNavigationStyle();
    };
    Smithchart2.prototype.unWireEVents = function() {
      EventHandler.remove(this.element, "click", this.smithchartOnClick);
      EventHandler.remove(this.element, Browser.touchMoveEvent, this.mouseMove);
      EventHandler.remove(this.element, Browser.touchEndEvent, this.mouseEnd);
      EventHandler.remove(this.element, "keyup", this.chartKeyUp);
      EventHandler.remove(this.element, "keydown", this.chartKeyDown);
      window.removeEventListener(Browser.isTouch && "orientation" in window && "onorientationchange" in window ? "orientationchange" : "resize", this.smithchartOnResize);
    };
    Smithchart2.prototype.print = function(id) {
      var exportChart = new ExportUtils2(this);
      exportChart.print(id);
    };
    Smithchart2.prototype.export = function(type, fileName, orientation) {
      var exportMap = new ExportUtils2(this);
      exportMap.export(type, fileName, orientation);
    };
    Smithchart2.prototype.chartKeyDown = function(e) {
      var actionKey = "";
      if (this.series[this.currentSeriesIndex].tooltip.visible && (e.code === "Tab" && this.previousTargetId.indexOf("_Series") > -1 || e.code === "Escape")) {
        actionKey = "ESC";
      }
      if (actionKey !== "") {
        this.smithchartKeyboardNavigations(e, e.target.id, actionKey);
      }
      if (e.code === "Tab") {
        this.removeNavigationStyle();
      }
      return false;
    };
    Smithchart2.prototype.chartKeyUp = function(e) {
      var actionKey = "";
      var targetId = e.target["id"];
      var groupElement;
      var targetElement = e.target;
      var titleElement = getElement2(this.element.id + "_Smithchart_title");
      var seriesElement = getElement2(this.element.id + "_svg_seriesCollections");
      var legendElement = getElement2(this.element.id + "legendItem_Group");
      this.removeNavigationStyle();
      if (titleElement) {
        titleElement.setAttribute("class", "e-smith-chart-focused");
      }
      if (seriesElement && seriesElement.firstElementChild && seriesElement.firstElementChild.children[1].lastElementChild) {
        var firstChild = seriesElement.firstElementChild.children[1].lastElementChild;
        var className = firstChild.getAttribute("class");
        if (className && className.indexOf("e-smith-chart-focused") === -1) {
          className = className + " e-smith-chart-focused";
        } else if (!className) {
          className = "e-smith-chart-focused";
        }
        firstChild.setAttribute("class", className);
      }
      if (legendElement) {
        var firstChild = legendElement.firstElementChild;
        var className = firstChild.getAttribute("class");
        if (className && className.indexOf("e-smith-chart-focused") === -1) {
          className = className + " e-smith-chart-focused";
        } else if (!className) {
          className = "e-smith-chart-focused";
        }
        firstChild.setAttribute("class", className);
      }
      if (e.code === "Tab") {
        if (this.previousTargetId !== "") {
          if (this.previousTargetId.indexOf("_Series") > -1 && targetId.indexOf("_Series") === -1) {
            groupElement = getElement2(this.element.id + "_svg_seriesCollections");
            var previousElement = this.previousTargetId.indexOf("_Marker") > -1 ? getElement2(this.element.id + "_svg_series" + this.currentSeriesIndex + "_Marker").children[this.currentPointIndex] : groupElement.children[this.currentSeriesIndex];
            this.setTabIndex(previousElement, document.getElementById(this.element.id + "_Series0_Points0_Marker0"));
            this.currentPointIndex = 0;
            this.currentSeriesIndex = 0;
          } else if (this.previousTargetId.indexOf("_svg_Legend") > -1 && targetId.indexOf("_svg_Legend") === -1) {
            groupElement = getElement2(this.element.id + "legendItem_Group");
            this.setTabIndex(groupElement.children[this.currentLegendIndex], groupElement.firstElementChild);
          }
        }
        this.previousTargetId = targetId;
        actionKey = this.series[0].tooltip.visible ? "Tab" : "";
      } else if (e.code.indexOf("Arrow") > -1) {
        e.preventDefault();
        this.previousTargetId = targetId;
        if (targetId.indexOf("_svg_Legend") > -1) {
          var legendElement_1 = targetElement.parentElement.children;
          legendElement_1[this.currentLegendIndex].removeAttribute("tabindex");
          this.currentLegendIndex += e.code === "ArrowUp" || e.code === "ArrowRight" ? 1 : -1;
          this.currentLegendIndex = this.getActualIndex(this.currentLegendIndex, legendElement_1.length);
          var currentLegend = legendElement_1[this.currentLegendIndex];
          this.focusChild(currentLegend);
          this.removeNavigationStyle();
          this.setNavigationStyle(currentLegend.id);
          targetId = currentLegend.children[1].id;
        } else if (targetId.indexOf("_Series") > -1) {
          groupElement = targetElement.parentElement.parentElement.parentElement;
          var currentPoint = e.target;
          targetElement.removeAttribute("tabindex");
          targetElement.blur();
          if (e.code === "ArrowRight" || e.code === "ArrowLeft") {
            var seriesIndexes = [];
            for (var i = 0; i < groupElement.children.length; i++) {
              if (groupElement.children[i].id.indexOf("_svg_seriesCollection") > -1) {
                seriesIndexes.push(+groupElement.children[i].id.split("_svg_seriesCollection")[1]);
              }
            }
            this.currentSeriesIndex = seriesIndexes.indexOf(this.currentSeriesIndex) + (e.code === "ArrowRight" ? 1 : -1);
            this.currentSeriesIndex = seriesIndexes[this.getActualIndex(this.currentSeriesIndex, seriesIndexes.length)];
          } else {
            this.currentPointIndex += e.code === "ArrowUp" ? 1 : -1;
          }
          if (targetId.indexOf("_Marker") > -1) {
            this.currentPointIndex = this.getActualIndex(this.currentPointIndex, getElement2(this.element.id + "_svg_series" + this.currentSeriesIndex + "_Marker").childElementCount);
            currentPoint = getElement2(this.element.id + "_Series" + this.currentSeriesIndex + "_Points" + this.currentPointIndex + "_Marker" + this.currentPointIndex);
          }
          targetId = this.focusChild(currentPoint);
          this.removeNavigationStyle();
          this.setNavigationStyle(targetId);
          actionKey = this.series[this.currentSeriesIndex].tooltip.visible ? "ArrowMove" : "";
        }
      } else if ((e.code === "Enter" || e.code === "Space") && targetId.indexOf("_svg_Legend") > -1) {
        targetId = targetId.indexOf("_svg_Legend") > -1 ? targetElement.children[1].id : targetId;
        actionKey = "Enter";
      }
      if (actionKey !== "") {
        this.smithchartKeyboardNavigations(e, targetId, actionKey);
      }
      if (e.code === "Tab") {
        this.setNavigationStyle(targetId);
      }
      return false;
    };
    Smithchart2.prototype.smithchartKeyboardNavigations = function(e, targetId, actionKey) {
      this.isLegendClicked = false;
      switch (actionKey) {
        case "Tab":
        case "ArrowMove":
          if (targetId.indexOf("_Points") > -1) {
            var seriesIndex = +targetId.split("_Series")[1].split("_Points")[0];
            var pointIndex = +targetId.split("_Series")[1].split("_Marker")[0].split("_Points")[1];
            if (this.tooltipRenderModule && this.series[seriesIndex].tooltip.visible) {
              this.tooltipRenderModule.createTooltip(this, e, pointIndex, seriesIndex, this.series[seriesIndex]);
            }
          }
          break;
        case "Enter":
        case "Space":
          if (targetId.indexOf("_LegendItemText") > -1) {
            this.isLegendClicked = true;
            this.delayRedraw = true;
            this.smithchartOnClick(e);
            this.focusChild(document.getElementById(targetId).parentElement);
            this.setNavigationStyle(document.getElementById(targetId).parentElement.id);
          }
          break;
        case "ESC":
          this.tooltipRenderModule.tooltipElement.fadeOut();
          break;
      }
    };
    Smithchart2.prototype.setTabIndex = function(previousElement, currentElement) {
      if (previousElement) {
        previousElement.removeAttribute("tabindex");
      }
      if (currentElement) {
        currentElement.setAttribute("tabindex", "0");
      }
    };
    Smithchart2.prototype.getActualIndex = function(index, totalLength) {
      return index > totalLength - 1 ? 0 : index < 0 ? totalLength - 1 : index;
    };
    Smithchart2.prototype.focusChild = function(element) {
      element.setAttribute("tabindex", "0");
      var className = element.getAttribute("class");
      element.setAttribute("tabindex", "0");
      if (className && className.indexOf("e-smith-chart-focused") === -1) {
        className = "e-smith-chart-focused " + className;
      } else if (!className) {
        className = "e-smith-chart-focused";
      }
      element.setAttribute("class", className);
      element.focus();
      return element.id;
    };
    Smithchart2.prototype.smithchartOnResize = function() {
      var _this = this;
      this.animateSeries = false;
      if (this.resizeTo) {
        clearTimeout(this.resizeTo);
      }
      this.resizeTo = +setTimeout(function() {
        _this.render();
      }, 500);
      return false;
    };
    Smithchart2.prototype.requiredModules = function() {
      var modules = [];
      if (this.legendSettings.visible) {
        modules.push({
          member: "SmithchartLegend",
          args: [this]
        });
      }
      for (var i = 0; i < this.series.length; i++) {
        if (this.series[i].tooltip.visible) {
          modules.push({
            member: "TooltipRender",
            args: [this]
          });
          break;
        }
      }
      return modules;
    };
    Smithchart2.prototype.removeSvg = function() {
      removeElement3(this.element.id + "_Secondary_Element");
      var removeLength = 0;
      if (this.svgObject) {
        while (this.svgObject.childNodes.length > removeLength) {
          this.svgObject.removeChild(this.svgObject.firstChild);
        }
        if (!this.svgObject.hasChildNodes() && this.svgObject.parentNode) {
          remove(this.svgObject);
        }
      }
    };
    __decorate22([Property("Impedance")], Smithchart2.prototype, "renderType", void 0);
    __decorate22([Property("")], Smithchart2.prototype, "width", void 0);
    __decorate22([Property("")], Smithchart2.prototype, "height", void 0);
    __decorate22([Property("Material")], Smithchart2.prototype, "theme", void 0);
    __decorate22([Complex({}, SmithchartMargin)], Smithchart2.prototype, "margin", void 0);
    __decorate22([Complex({}, SmithchartFont)], Smithchart2.prototype, "font", void 0);
    __decorate22([Complex({}, SmithchartBorder)], Smithchart2.prototype, "border", void 0);
    __decorate22([Complex({}, Title)], Smithchart2.prototype, "title", void 0);
    __decorate22([Collection([{}], SmithchartSeries)], Smithchart2.prototype, "series", void 0);
    __decorate22([Complex({}, SmithchartLegendSettings)], Smithchart2.prototype, "legendSettings", void 0);
    __decorate22([Complex({}, SmithchartAxis)], Smithchart2.prototype, "horizontalAxis", void 0);
    __decorate22([Complex({}, SmithchartAxis)], Smithchart2.prototype, "radialAxis", void 0);
    __decorate22([Property(null)], Smithchart2.prototype, "background", void 0);
    __decorate22([Property(10)], Smithchart2.prototype, "elementSpacing", void 0);
    __decorate22([Property(1)], Smithchart2.prototype, "radius", void 0);
    __decorate22([Event()], Smithchart2.prototype, "beforePrint", void 0);
    __decorate22([Event()], Smithchart2.prototype, "animationComplete", void 0);
    __decorate22([Event()], Smithchart2.prototype, "load", void 0);
    __decorate22([Event()], Smithchart2.prototype, "loaded", void 0);
    __decorate22([Event()], Smithchart2.prototype, "legendRender", void 0);
    __decorate22([Event()], Smithchart2.prototype, "titleRender", void 0);
    __decorate22([Event()], Smithchart2.prototype, "subtitleRender", void 0);
    __decorate22([Event()], Smithchart2.prototype, "textRender", void 0);
    __decorate22([Event()], Smithchart2.prototype, "axisLabelRender", void 0);
    __decorate22([Event()], Smithchart2.prototype, "seriesRender", void 0);
    __decorate22([Event()], Smithchart2.prototype, "tooltipRender", void 0);
    Smithchart2 = __decorate22([NotifyPropertyChanges], Smithchart2);
    return Smithchart2;
  }(Component)
);

// node_modules/@syncfusion/ej2-charts/src/smithchart/series/tooltip.js
var TooltipRender = (
  /** @class */
  function() {
    function TooltipRender2() {
    }
    TooltipRender2.prototype.smithchartMouseMove = function(smithchart, e) {
      var touchArg;
      var pageX;
      var pageY;
      if (e.type === "touchend" || e.type === "touchmove") {
        touchArg = e;
        pageX = touchArg.changedTouches[0].clientX;
        pageY = touchArg.changedTouches[0].clientY;
        this.tooltipElement = void 0;
      } else {
        pageY = e.clientY;
        pageX = e.clientX;
      }
      this.setMouseXY(smithchart, pageX, pageY);
      for (var i = 0; i < smithchart.series.length; i++) {
        var series = smithchart.series[i];
        var seriesIndex = i;
        var closestPoint = new ClosestPoint();
        closestPoint = this.closestPointXY(smithchart, this.mouseX, this.mouseY, series, seriesIndex);
        if (closestPoint.location && series.tooltip.visible && series.visibility === "visible") {
          this.createTooltip(smithchart, e, closestPoint.index, seriesIndex, series);
          break;
        } else if (this.tooltipElement) {
          if (this.tooltipElement.enable && !series.tooltip.template) {
            this.tooltipElement.enable = false;
          }
          this.tooltipElement.fadeOut();
        }
      }
      return this.tooltipElement;
    };
    TooltipRender2.prototype.setMouseXY = function(smithchart, pageX, pageY) {
      var svgRectElement = document.getElementById(smithchart.element.id + "_svg");
      if (smithchart.element && svgRectElement) {
        var rect = smithchart.element.getBoundingClientRect();
        var svgRect = svgRectElement.getBoundingClientRect();
        this.mouseX = pageX - rect.left - Math.max(svgRect.left - rect.left, 0);
        this.mouseY = pageY - rect.top - Math.max(svgRect.top - rect.top, 0);
      }
    };
    TooltipRender2.prototype.createTooltip = function(smithchart, e, pointIndex, seriesindex, series) {
      var _this = this;
      var currentPoint = series.points[pointIndex];
      var pointX = currentPoint.resistance;
      var pointY = currentPoint.reactance;
      var tooltip = currentPoint.tooltip ? [currentPoint.tooltip] : null;
      var tooltipText = [pointX + " : " + (smithchart.theme.indexOf("Tailwind3") > -1 ? pointY : "<b>" + pointY + "</b>")];
      var argsData = {
        cancel: false,
        name: "tooltipRender",
        text: tooltip || tooltipText,
        headerText: smithchart.theme.indexOf("Tailwind3") > -1 ? series.name : "<b>" + series.name + "</b>",
        template: series.tooltip.template,
        point: currentPoint
      };
      var smithChartTooltipSuccess = function(argsData2) {
        var markerHeight = smithchart.series[seriesindex].marker.height / 2;
        var div = document.getElementById(smithchart.element.id + "_smithchart_tooltip_div");
        if (isNullOrUndefined(div)) {
          div = createElement("div", {
            id: smithchart.element.id + "_smithchart_tooltip_div",
            styles: "pointer-events: none; position: absolute;z-index:1;"
          });
          document.getElementById(smithchart.element.id + "_Secondary_Element").appendChild(div);
        }
        _this.tooltipElement = new Tooltip({
          enable: true,
          header: argsData2.headerText,
          content: argsData2.text,
          border: series.tooltip.border,
          fill: series.tooltip.fill || smithchart.themeStyle.tooltipFill,
          opacity: series.tooltip.opacity,
          data: currentPoint,
          template: argsData2.template,
          location: {
            x: _this.locationX + smithchart.element.offsetLeft,
            y: _this.locationY - markerHeight + smithchart.element.offsetTop
          },
          shared: false,
          areaBounds: new SmithchartRect(smithchart.bounds.x, smithchart.bounds.y, smithchart.bounds.width, smithchart.bounds.height),
          palette: [series.fill || smithchart.seriesColors[seriesindex % smithchart.seriesColors.length]],
          shapes: ["Circle"],
          availableSize: smithchart.availableSize,
          theme: smithchart.theme
        });
        _this.tooltipElement.opacity = smithchart.themeStyle.tooltipFillOpacity || _this.tooltipElement.opacity;
        _this.tooltipElement.textStyle.fontFamily = smithchart.themeStyle.fontFamily || "Roboto, Segoe UI, Noto, Sans-serif";
        _this.tooltipElement.textStyle.size = smithchart.themeStyle.tooltipFontSize || "13px";
        _this.tooltipElement.textStyle.color = smithchart.themeStyle.tooltipBoldLabel || _this.tooltipElement.textStyle.color;
        _this.tooltipElement.appendTo(div);
        var element = document.getElementById(smithchart.element.id + "_smithchart_tooltip_div_Trackball_0");
        if (element) {
          element.setAttribute("role", "img");
        }
      };
      smithChartTooltipSuccess.bind(this, smithchart);
      smithchart.trigger("tooltipRender", argsData, smithChartTooltipSuccess);
    };
    TooltipRender2.prototype.closestPointXY = function(smithchart, x, y, series, seriesindex) {
      var pointIndex;
      var chartPoint;
      var closePoint;
      for (var j = 0; j < series.points.length; j++) {
        chartPoint = smithchart.seriesrender.getLocation(seriesindex, j);
        this.locationX = chartPoint.x;
        this.locationY = chartPoint.y;
        pointIndex = j;
        var a = x - chartPoint.x;
        var b = y - chartPoint.y;
        var distance = Math.abs(Math.sqrt(a * a + b * b));
        if (distance < series.marker.width) {
          closePoint = chartPoint;
          pointIndex = j;
          break;
        }
      }
      return {
        location: closePoint,
        index: pointIndex
      };
    };
    TooltipRender2.prototype.getModuleName = function() {
      return "TooltipRender";
    };
    TooltipRender2.prototype.destroy = function() {
    };
    return TooltipRender2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/smithchart/legend/legendrender.js
var SmithchartLegend = (
  /** @class */
  function() {
    function SmithchartLegend2() {
      this.legendSeries = [];
    }
    SmithchartLegend2.prototype.renderLegend = function(smithchart) {
      this._drawLegend(smithchart);
    };
    SmithchartLegend2.prototype.calculateLegendBounds = function(smithchart) {
      this.legendSeries = [];
      var padding = 10;
      var legend = smithchart.legendSettings;
      var legendSizeHeight = legend.height;
      var legendSizeWidth = legend.width;
      var itemPadding = legend.itemPadding > 0 ? legend.itemPadding : 0;
      var position = legend.position.toLowerCase();
      var font = legend.title.textStyle;
      var width = 0;
      var height = 0;
      var legendItemWidth = 0;
      var legendItemHeight = 0;
      var legendHeight = 0;
      var svgObjectWidth = smithchart.availableSize.width - (smithchart.elementSpacing * 4 - legend.border.width * 2 + smithchart.border.width * 2);
      var rowCount = legend.rowCount;
      var columnCount = legend.columnCount;
      var titleSize = measureText2(smithchart.legendSettings["title"]["text"], font, smithchart.themeStyle.legendTitleFont);
      var maxRowWidth = 0;
      var totalRowHeight = 0;
      var curRowWidth = 0;
      var curRowHeight = 0;
      var allowItems;
      var itemsCountRow = 0;
      var length = smithchart.series.length;
      var legendBounds;
      if (smithchart.legendSettings.visible && length !== 0) {
        if (position === "bottom" || position === "top" || position === "custom") {
          if (rowCount && columnCount && rowCount <= columnCount) {
            rowCount = length / columnCount;
          } else if (rowCount == null && columnCount != null) {
            rowCount = length / columnCount;
          } else if (rowCount == null && columnCount == null) {
            rowCount = 1;
          }
          if (rowCount) {
            allowItems = Math.ceil(length / rowCount);
          }
        } else {
          if (rowCount && columnCount && rowCount <= columnCount) {
            columnCount = length / rowCount;
          } else if (rowCount != null && columnCount == null) {
            columnCount = length / rowCount;
          } else if (rowCount == null && columnCount == null) {
            columnCount = 1;
          }
          if (columnCount) {
            allowItems = columnCount;
          }
        }
        for (var i = 0; i < length; i++) {
          this.legendSeries.push({
            text: smithchart.series[i]["name"] ? smithchart.series[i]["name"] : "series" + i,
            seriesIndex: i,
            shape: smithchart.legendSettings.shape,
            fill: smithchart.series[i].fill || smithchart.seriesColors[i % smithchart.seriesColors.length],
            bounds: null
          });
          var legendsize = this._getLegendSize(smithchart, this.legendSeries[i]);
          legendItemWidth = Math.max(legendsize["width"], legendItemWidth);
          legendItemHeight = Math.max(legendsize["height"], legendItemHeight);
          this.legendSeries[i]["bounds"] = {
            width: legendItemWidth,
            height: legendItemHeight
          };
          itemsCountRow = itemsCountRow + 1;
          curRowWidth = curRowWidth + legendItemWidth + itemPadding;
          curRowHeight = Math.max(legendItemHeight, curRowHeight);
          if (position === "top" || position === "bottom" || position === "custom") {
            if (curRowWidth > svgObjectWidth) {
              curRowWidth -= legendsize.width + itemPadding;
              maxRowWidth = Math.max(maxRowWidth, curRowWidth);
              curRowWidth = legendsize.width + itemPadding;
              totalRowHeight = totalRowHeight + curRowHeight + itemPadding;
            }
          }
          if (itemsCountRow === allowItems || i === length - 1) {
            maxRowWidth = Math.max(maxRowWidth, curRowWidth);
            totalRowHeight = totalRowHeight + curRowHeight + itemPadding;
            legendHeight = totalRowHeight;
            itemsCountRow = 0;
            curRowHeight = 0;
            curRowWidth = 0;
          }
        }
        width = titleSize.width > maxRowWidth - itemPadding ? titleSize.width + padding * 2 + itemPadding : maxRowWidth + padding * 2 - smithchart.border.width * 2;
        height = legendHeight + smithchart.elementSpacing;
        legendBounds = {
          x: 0,
          y: 0,
          width,
          height
        };
      }
      this.legendActualBounds = legendBounds;
      if (legendSizeWidth != null) {
        this.legendActualBounds.width = legendSizeWidth;
      }
      if (legendSizeHeight != null) {
        this.legendActualBounds.height = legendSizeHeight;
      }
      return this.legendActualBounds;
    };
    SmithchartLegend2.prototype._getLegendSize = function(smithchart, series) {
      var legend = smithchart.legendSettings;
      var symbolWidth = legend.itemStyle.width;
      var symbolHeight = legend.itemStyle.height;
      var textSize = measureText2(series.text, legend.textStyle, smithchart.themeStyle.legendLabelFont);
      var width = symbolWidth + textSize.width + legend.shapePadding;
      var height = Math.max(symbolHeight, textSize.height);
      return {
        width,
        height
      };
    };
    SmithchartLegend2.prototype._drawLegend = function(smithchart) {
      var legend = smithchart.legendSettings;
      var legendPosition = legend.position.toLowerCase();
      var alignment = legend.alignment;
      var legendBounds = this.legendActualBounds;
      var maxWidth = 0;
      var startX;
      var startY;
      var titleFont = smithchart.title.font ? smithchart.title.font : smithchart.title.textStyle;
      var smithchartTitleHeight = measureText2(smithchart.title.text, titleFont, smithchart.themeStyle.legendLabelFont).height;
      var smithchartSubtitleHeight = measureText2(smithchart.title.subtitle.text, smithchart.title.subtitle.textStyle, smithchart.themeStyle.legendLabelFont).height;
      var elementSpacing = smithchart.elementSpacing;
      var offset = smithchartTitleHeight + smithchartSubtitleHeight + elementSpacing + smithchart.margin.top;
      var itemPadding = legend.itemPadding > 0 ? legend.itemPadding : 0;
      var svgObjectWidth = smithchart.availableSize.width;
      var svgObjectHeight = smithchart.availableSize.height;
      var legendBorder = legend.border.width;
      var legendWidth = 0;
      var titleSize = measureText2(legend["title"]["text"], legend.title.textStyle, smithchart.themeStyle.legendLabelFont);
      var legendTitleHeight = titleSize.height;
      var borderSize = smithchart.border.width;
      var svgWidth = svgObjectWidth - borderSize * 2;
      var svgHeight = svgObjectHeight - borderSize * 2;
      legendBounds.height += legendTitleHeight;
      if (legendPosition !== "custom") {
        switch (legendPosition) {
          case "bottom":
            legendBounds.y = svgHeight - (legendBounds.height + legendBorder + elementSpacing);
            break;
          case "top":
            legendBounds.y = borderSize + offset;
            break;
          case "right":
            legendBounds.x = svgWidth - legendBounds.width - elementSpacing * 2;
            break;
          case "left":
            legendBounds.x = borderSize + elementSpacing * 2;
            break;
        }
        if (legendPosition === "left" || legendPosition === "right") {
          switch (alignment) {
            case "Center":
              legendBounds.y = svgHeight / 2 - (legendBounds.height + legendBorder * 2) / 2 + elementSpacing / 2;
              break;
            case "Near":
              legendBounds.y = borderSize + elementSpacing * 2 + offset;
              break;
            case "Far":
              legendBounds.y = svgHeight - (legendBounds.height + legendBorder) - elementSpacing * 2;
              break;
          }
        } else {
          switch (alignment) {
            case "Center":
              legendBounds.x = svgWidth / 2 - (legendBounds.width + legendBorder * 2) / 2 + elementSpacing / 2;
              break;
            case "Near":
              legendBounds.x = borderSize + elementSpacing * 2;
              break;
            case "Far":
              legendBounds.x = svgWidth - (legendBounds.width + legendBorder) - elementSpacing * 2;
              break;
          }
        }
      } else {
        legendBounds.y = legend.location.y < svgHeight ? legend.location.y : 0;
        legendBounds.x = legend.location.x < svgWidth ? legend.location.x : 0;
      }
      if (legendPosition === "bottom" || legendPosition === "top") {
        for (var i = 0; i < this.legendSeries.length; i++) {
          legendWidth += this.legendSeries[i].bounds.width + itemPadding;
          if (legendWidth > svgWidth) {
            legendBounds.x = svgWidth / 2 - (legendBounds.width + legendBorder * 2) / 2 + elementSpacing / 2;
            break;
          }
        }
      }
      var gLegendEle = smithchart.renderer.createGroup({
        "id": smithchart.element.id + "_legend_group"
      });
      smithchart.svgObject.appendChild(gLegendEle);
      this.legendItemGroup = smithchart.renderer.createGroup({
        "id": smithchart.element.id + "legendItem_Group"
      });
      var currentX = startX = elementSpacing;
      var currentY = startY = elementSpacing;
      if (legend.title.text !== "" && legend.title.visible) {
        gLegendEle.appendChild(this.drawLegendTitle(smithchart, legend, legendBounds, gLegendEle));
        currentY = startY = elementSpacing + legendTitleHeight;
      }
      for (var k = 0; k < this.legendSeries.length; k++) {
        if ((legend.rowCount < legend.columnCount || legend.rowCount === legend.columnCount) && (legendPosition === "top" || legendPosition === "bottom" || legendPosition === "custom")) {
          if (currentX + this.legendSeries[k]["bounds"].width > legendBounds.width + startX) {
            currentX = elementSpacing;
            currentY += this.legendSeries[k]["bounds"].height + itemPadding;
          }
          this.legendGroup = this.drawLegendItem(smithchart, legend, this.legendSeries[k], k, currentX, currentY);
          gLegendEle.appendChild(this.legendGroup);
          currentX += this.legendSeries[k]["bounds"].width + itemPadding;
        } else {
          if (currentY + this.legendSeries[k]["bounds"].height + itemPadding + legendTitleHeight + borderSize > legendBounds.height + startY) {
            currentY = startY;
            currentX += maxWidth + itemPadding;
          }
          this.legendGroup = this.drawLegendItem(smithchart, legend, this.legendSeries[k], k, currentX, currentY);
          gLegendEle.appendChild(this.legendGroup);
          currentY += this.legendSeries[k]["bounds"].height + itemPadding;
          maxWidth = Math.max(maxWidth, this.legendSeries[k]["bounds"].width);
        }
      }
      gLegendEle.setAttribute("transform", "translate(" + legendBounds.x.toString() + "," + legendBounds.y.toString() + ")");
      this.drawLegendBorder(gLegendEle, smithchart, legend, legendBounds);
    };
    SmithchartLegend2.prototype.drawLegendBorder = function(gLegendEle, smithchart, legend, legendBounds) {
      var borderRect = new RectOption2(smithchart.element.id + "_svg_legendRect", "none", legend.border, 1, new SmithchartRect(0, 0, legendBounds.width, legendBounds.height));
      gLegendEle.appendChild(smithchart.renderer.drawRectangle(borderRect));
    };
    SmithchartLegend2.prototype.drawLegendTitle = function(smithchart, legend, legendBounds, gLegendEle) {
      var elementSpacing = smithchart.elementSpacing;
      var titleSize = measureText2(legend.title.text, legend.title.textStyle, smithchart.themeStyle.legendLabelFont);
      var titleWidth = titleSize.width;
      var titleHeight = titleSize.height;
      var textAlignment = legend.title.textAlignment;
      var startX = 0;
      var legendBoundsWidth = legendBounds.width;
      var startY = elementSpacing + titleHeight / 2;
      switch (textAlignment) {
        case "Far":
          startX = legendBoundsWidth - titleWidth - startX;
          break;
        case "Center":
          startX = legendBoundsWidth / 2 - titleWidth / 2;
          break;
      }
      if (startX < 0) {
        startX = 0;
        legendBoundsWidth = titleWidth;
      }
      if (legendBoundsWidth < titleWidth + startX) {
        legendBoundsWidth = titleWidth + startX;
      }
      var options = new TextOption2(smithchart.element.id + "_LegendTitleText", startX, startY, "start", legend.title.text);
      var element = renderTextElement(options, legend.title.textStyle, legend.title.textStyle.color || smithchart.themeStyle.legendTitleFont.color, gLegendEle, smithchart.themeStyle.legendTitleFont);
      element.setAttribute("aria-label", legend.title.description || legend.title.text);
      return element;
    };
    SmithchartLegend2.prototype.drawLegendItem = function(smithchart, legend, legendSeries, k, x, y) {
      var _this = this;
      var symbol = legend.itemStyle;
      var textHeight = measureText2(legendSeries["text"], legend.textStyle, smithchart.themeStyle.legendLabelFont).height;
      var location = {
        x: x + symbol["width"] / 2,
        y: y + (textHeight > symbol["height"] ? textHeight : symbol["height"]) / 2
      };
      var legendGroup = smithchart.renderer.createGroup({
        id: smithchart.element.id + "_svg_Legend" + k.toString()
      });
      legendGroup["style"]["cursor"] = legend.toggleVisibility ? "pointer" : "default";
      legendGroup.setAttribute("tabindex", k === 0 ? "0" : "");
      var legendEventArgs = {
        text: legendSeries["text"],
        fill: legendSeries["fill"],
        shape: legendSeries["shape"],
        name: legendRender2,
        cancel: false
      };
      var legendRenderSuccess = function(args) {
        if (!args.cancel) {
          var shape = _this.drawLegendShape(smithchart, legendSeries, location.x, location.y, k, legend, args);
          legendGroup.appendChild(shape);
          var options = new TextOption2(smithchart.element.id + "_LegendItemText" + k.toString(), location.x + symbol["width"] / 2 + legend.shapePadding, location.y + textHeight / 4, "start", args.text);
          legend.textStyle.fontFamily = legend.textStyle.fontFamily || smithchart.themeStyle.legendLabelFont.fontFamily;
          legend.textStyle.size = legend.textStyle.size || smithchart.themeStyle.legendLabelFont.size;
          var element = renderTextElement(options, legend.textStyle, legend.textStyle.color || smithchart.themeStyle.legendLabelFont.color, legendGroup, smithchart.themeStyle.legendLabelFont);
          legendGroup.setAttribute("aria-label", legend.description || "Show " + options.text);
          legendGroup.setAttribute("role", "button");
          legendGroup.appendChild(element);
          _this.legendItemGroup.appendChild(legendGroup);
        }
      };
      legendRenderSuccess.bind(this);
      smithchart.trigger(legendRender2, legendEventArgs, legendRenderSuccess);
      return this.legendItemGroup;
    };
    SmithchartLegend2.prototype.drawLegendShape = function(smithchart, legendSeries, locX, locY, index, legend, legendEventArgs) {
      var element;
      var circleOptions;
      var pathOptions;
      var path;
      var symbol = legend.itemStyle;
      var width = symbol["width"];
      var height = symbol["height"];
      var x = locX + -width / 2;
      var border = {
        color: symbol.border.color,
        width: symbol.border.width
      };
      var opacity = 1;
      var fill = smithchart.series[index].visibility === "visible" ? legendEventArgs.fill : "grey";
      var shape = legendEventArgs.shape.toLowerCase();
      var radius = Math.sqrt(height * height + width * width) / 2;
      switch (shape) {
        case "circle":
          circleOptions = new CircleOption2(smithchart.element.id + "_svg_LegendItemShape" + index.toString(), fill, border, opacity, locX, locY, radius, null);
          element = smithchart.renderer.drawCircle(circleOptions);
          break;
        case "rectangle":
          path = "M " + x + " " + (locY + -height / 2) + " L " + (width / 2 + locX) + " " + (locY + -height / 2) + " L " + (locX + width / 2) + " " + (locY + height / 2) + " L " + x + " " + (locY + height / 2) + " L " + x + " " + (locY + -height / 2) + " z";
          pathOptions = new PathOption2(smithchart.element.id + "_svg_LegendItemShape" + index.toString(), fill, border.width, border.color, 1, "", path);
          element = smithchart.renderer.drawPath(pathOptions);
          break;
        case "diamond":
          path = "M " + x + " " + locY + " L " + locX + " " + (locY + -height / 2) + " L " + (width / 2 + locX) + " " + locY + " L " + locX + " " + (locY + height / 2) + " L " + x + " " + locY + " z";
          pathOptions = new PathOption2(smithchart.element.id + "_svg_LegendItemShape" + index.toString(), fill, border.width, border.color, 1, "", path);
          element = smithchart.renderer.drawPath(pathOptions);
          break;
        case "pentagon": {
          var eq = 72;
          for (var j = 0; j <= 5; j++) {
            var xValue = radius * Math.cos(Math.PI / 180 * (j * eq));
            var yValue = radius * Math.sin(Math.PI / 180 * (j * eq));
            if (j === 0) {
              path = "M " + (xValue + locX) + " " + (locY + yValue) + " ";
            } else {
              path = path.concat("L " + (locX + xValue) + " " + (locY + yValue) + " ");
            }
          }
          path = path.concat("Z");
          pathOptions = new PathOption2(smithchart.element.id + "_svg_LegendItemShape" + index.toString(), fill, border.width, border.color, 1, "", path);
          element = smithchart.renderer.drawPath(pathOptions);
          break;
        }
        case "triangle":
          path = "M " + x + " " + (height / 2 + locY) + " L " + locX + " " + (locY + -height / 2) + " L " + (locX + width / 2) + " " + (locY + height / 2) + " L " + x + " " + (locY + height / 2) + " Z";
          pathOptions = new PathOption2(smithchart.element.id + "_svg_LegendItemShape" + index.toString(), fill, border.width, border.color, 1, "", path);
          element = smithchart.renderer.drawPath(pathOptions);
          break;
      }
      return element;
    };
    SmithchartLegend2.prototype.getModuleName = function() {
      return "SmithchartLegend";
    };
    SmithchartLegend2.prototype.destroy = function() {
    };
    return SmithchartLegend2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/sparkline/model/base.js
var __extends95 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate23 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SparklineBorder = (
  /** @class */
  function(_super) {
    __extends95(SparklineBorder2, _super);
    function SparklineBorder2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate23([Property("")], SparklineBorder2.prototype, "color", void 0);
    __decorate23([Property(0)], SparklineBorder2.prototype, "width", void 0);
    return SparklineBorder2;
  }(ChildProperty)
);
var SparklineFont = (
  /** @class */
  function(_super) {
    __extends95(SparklineFont2, _super);
    function SparklineFont2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate23([Property(null)], SparklineFont2.prototype, "size", void 0);
    __decorate23([Property(null)], SparklineFont2.prototype, "color", void 0);
    __decorate23([Property("Roboto, Segoe UI, Noto, Sans-serif")], SparklineFont2.prototype, "fontFamily", void 0);
    __decorate23([Property(null)], SparklineFont2.prototype, "fontWeight", void 0);
    __decorate23([Property(null)], SparklineFont2.prototype, "fontStyle", void 0);
    __decorate23([Property(1)], SparklineFont2.prototype, "opacity", void 0);
    return SparklineFont2;
  }(ChildProperty)
);
var TrackLineSettings = (
  /** @class */
  function(_super) {
    __extends95(TrackLineSettings2, _super);
    function TrackLineSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate23([Property(false)], TrackLineSettings2.prototype, "visible", void 0);
    __decorate23([Property(null)], TrackLineSettings2.prototype, "color", void 0);
    __decorate23([Property(1)], TrackLineSettings2.prototype, "width", void 0);
    return TrackLineSettings2;
  }(ChildProperty)
);
var SparklineTooltipSettings = (
  /** @class */
  function(_super) {
    __extends95(SparklineTooltipSettings2, _super);
    function SparklineTooltipSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate23([Property(false)], SparklineTooltipSettings2.prototype, "visible", void 0);
    __decorate23([Property("")], SparklineTooltipSettings2.prototype, "fill", void 0);
    __decorate23([Property("")], SparklineTooltipSettings2.prototype, "template", void 0);
    __decorate23([Property("")], SparklineTooltipSettings2.prototype, "format", void 0);
    __decorate23([Complex({
      color: null,
      width: null
    }, SparklineBorder)], SparklineTooltipSettings2.prototype, "border", void 0);
    __decorate23([Complex({
      size: "12px",
      fontWeight: null,
      fontStyle: "Normal",
      fontFamily: null
    }, SparklineFont)], SparklineTooltipSettings2.prototype, "textStyle", void 0);
    __decorate23([Complex({}, TrackLineSettings)], SparklineTooltipSettings2.prototype, "trackLineSettings", void 0);
    return SparklineTooltipSettings2;
  }(ChildProperty)
);
var ContainerArea = (
  /** @class */
  function(_super) {
    __extends95(ContainerArea2, _super);
    function ContainerArea2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate23([Property("transparent")], ContainerArea2.prototype, "background", void 0);
    __decorate23([Complex({}, SparklineBorder)], ContainerArea2.prototype, "border", void 0);
    return ContainerArea2;
  }(ChildProperty)
);
var LineSettings = (
  /** @class */
  function(_super) {
    __extends95(LineSettings2, _super);
    function LineSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate23([Property(false)], LineSettings2.prototype, "visible", void 0);
    __decorate23([Property(null)], LineSettings2.prototype, "color", void 0);
    __decorate23([Property("")], LineSettings2.prototype, "dashArray", void 0);
    __decorate23([Property(1)], LineSettings2.prototype, "width", void 0);
    __decorate23([Property(1)], LineSettings2.prototype, "opacity", void 0);
    return LineSettings2;
  }(ChildProperty)
);
var RangeBandSettings = (
  /** @class */
  function(_super) {
    __extends95(RangeBandSettings2, _super);
    function RangeBandSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate23([Property(null)], RangeBandSettings2.prototype, "startRange", void 0);
    __decorate23([Property(null)], RangeBandSettings2.prototype, "endRange", void 0);
    __decorate23([Property(null)], RangeBandSettings2.prototype, "color", void 0);
    __decorate23([Property(1)], RangeBandSettings2.prototype, "opacity", void 0);
    return RangeBandSettings2;
  }(ChildProperty)
);
var AxisSettings = (
  /** @class */
  function(_super) {
    __extends95(AxisSettings2, _super);
    function AxisSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate23([Property(null)], AxisSettings2.prototype, "minX", void 0);
    __decorate23([Property(null)], AxisSettings2.prototype, "maxX", void 0);
    __decorate23([Property(null)], AxisSettings2.prototype, "minY", void 0);
    __decorate23([Property(null)], AxisSettings2.prototype, "maxY", void 0);
    __decorate23([Property(0)], AxisSettings2.prototype, "value", void 0);
    __decorate23([Complex({}, LineSettings)], AxisSettings2.prototype, "lineSettings", void 0);
    return AxisSettings2;
  }(ChildProperty)
);
var Padding = (
  /** @class */
  function(_super) {
    __extends95(Padding2, _super);
    function Padding2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate23([Property(5)], Padding2.prototype, "left", void 0);
    __decorate23([Property(5)], Padding2.prototype, "right", void 0);
    __decorate23([Property(5)], Padding2.prototype, "bottom", void 0);
    __decorate23([Property(5)], Padding2.prototype, "top", void 0);
    return Padding2;
  }(ChildProperty)
);
var SparklineMarkerSettings = (
  /** @class */
  function(_super) {
    __extends95(SparklineMarkerSettings2, _super);
    function SparklineMarkerSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate23([Property([])], SparklineMarkerSettings2.prototype, "visible", void 0);
    __decorate23([Property(1)], SparklineMarkerSettings2.prototype, "opacity", void 0);
    __decorate23([Property(8)], SparklineMarkerSettings2.prototype, "size", void 0);
    __decorate23([Property("#00bdae")], SparklineMarkerSettings2.prototype, "fill", void 0);
    __decorate23([Complex({
      width: 1
    }, SparklineBorder)], SparklineMarkerSettings2.prototype, "border", void 0);
    return SparklineMarkerSettings2;
  }(ChildProperty)
);
var LabelOffset = (
  /** @class */
  function(_super) {
    __extends95(LabelOffset2, _super);
    function LabelOffset2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate23([Property(0)], LabelOffset2.prototype, "x", void 0);
    __decorate23([Property(0)], LabelOffset2.prototype, "y", void 0);
    return LabelOffset2;
  }(ChildProperty)
);
var SparklineDataLabelSettings = (
  /** @class */
  function(_super) {
    __extends95(SparklineDataLabelSettings2, _super);
    function SparklineDataLabelSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate23([Property([])], SparklineDataLabelSettings2.prototype, "visible", void 0);
    __decorate23([Property(1)], SparklineDataLabelSettings2.prototype, "opacity", void 0);
    __decorate23([Property("transparent")], SparklineDataLabelSettings2.prototype, "fill", void 0);
    __decorate23([Property("")], SparklineDataLabelSettings2.prototype, "format", void 0);
    __decorate23([Complex({
      color: "transparent",
      width: 0
    }, SparklineBorder)], SparklineDataLabelSettings2.prototype, "border", void 0);
    __decorate23([Complex({
      size: null,
      fontWeight: null,
      fontStyle: null,
      fontFamily: null
    }, SparklineFont)], SparklineDataLabelSettings2.prototype, "textStyle", void 0);
    __decorate23([Complex({}, LabelOffset)], SparklineDataLabelSettings2.prototype, "offset", void 0);
    __decorate23([Property("None")], SparklineDataLabelSettings2.prototype, "edgeLabelMode", void 0);
    return SparklineDataLabelSettings2;
  }(ChildProperty)
);

// node_modules/@syncfusion/ej2-charts/src/sparkline/utils/helper.js
var __extends96 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Size2 = (
  /** @class */
  /* @__PURE__ */ function() {
    function Size3(width, height) {
      this.width = width;
      this.height = height;
    }
    return Size3;
  }()
);
function getSeriesColor3(theme) {
  var palette;
  switch (theme) {
    case "Fabric":
      palette = ["#4472c4", "#ed7d31", "#ffc000", "#70ad47", "#5b9bd5", "#c1c1c1", "#6f6fe2", "#e269ae", "#9e480e", "#997300"];
      break;
    case "Bootstrap4":
      palette = ["#a16ee5", "#f7ce69", "#55a5c2", "#7ddf1e", "#ff6ea6", "#7953ac", "#b99b4f", "#407c92", "#5ea716", "#b91c52"];
      break;
    case "Bootstrap":
      palette = ["#a16ee5", "#f7ce69", "#55a5c2", "#7ddf1e", "#ff6ea6", "#7953ac", "#b99b4f", "#407c92", "#5ea716", "#b91c52"];
      break;
    case "HighContrastLight":
    case "HighContrast":
      palette = ["#79ECE4", "#E98272", "#DFE6B6", "#C6E773", "#BA98FF", "#FA83C3", "#00C27A", "#43ACEF", "#D681EF", "#D8BC6E"];
      break;
    case "MaterialDark":
      palette = ["#9ECB08", "#56AEFF", "#C57AFF", "#61EAA9", "#EBBB3E", "#F45C5C", "#8A77FF", "#63C7FF", "#FF84B0", "#F7C928"];
      break;
    case "FabricDark":
      palette = ["#4472c4", "#ed7d31", "#ffc000", "#70ad47", "#5b9bd5", "#c1c1c1", "#6f6fe2", "#e269ae", "#9e480e", "#997300"];
      break;
    case "BootstrapDark":
      palette = ["#a16ee5", "#f7ce69", "#55a5c2", "#7ddf1e", "#ff6ea6", "#7953ac", "#b99b4f", "#407c92", "#5ea716", "#b91c52"];
      break;
    case "Tailwind3":
      palette = ["#2F4074", "#03B4B4", "#0D72DE", "#FF5733", "#D63384", "#F39C12", "#EF291F", "#91C822"];
      break;
    case "Tailwind3Dark":
      palette = ["#8029F1", "#1ABC9C", "#0D72DE", "#FF5733", "#D63384", "#F39C12", "#EF291F", "#91C822"];
      break;
    case "Tailwind":
      palette = ["#5A61F6", "#65A30D", "#334155", "#14B8A6", "#8B5CF6", "#0369A1", "#F97316", "#9333EA", "#F59E0B", "#15803D"];
      break;
    case "TailwindDark":
      palette = ["#8B5CF6", "#22D3EE", "#F87171", "#4ADE80", "#E879F9", "#FCD34D", "#F97316", "#2DD4BF", "#F472B6", "#10B981"];
      break;
    case "Bootstrap5Dark":
    case "Bootstrap5":
      palette = ["#FD7E14", "#6610F2", "#6F42C1", "#D63384", "#DC3545", "#FFC107", "#198754", "#0DCAF0"];
      break;
    case "FluentDark":
      palette = ["#1AC9E6", "#DA4CB2", "#EDBB40", "#AF4BCF", "#FF7266", "#1BD565", "#EE993D", "#5887FF", "#EC548D", "#7D39C0"];
      break;
    case "Fluent":
      palette = ["#1AC9E6", "#DA4CB2", "#EDBB40", "#AF4BCF", "#FF7266", "#1BD565", "#EE993D", "#5887FF", "#EC548D", "#7D39C0"];
      break;
    case "Fluent2":
      palette = ["#6200EE", "#09AF74", "#0076E5", "#CB3587", "#E7910F", "#0364DE", "#66CD15", "#F3A93C", "#107C10", "#C19C00"];
      break;
    case "Fluent2Dark":
      palette = ["#9BB449", "#2A72D5", "#43B786", "#3F579A", "#584EC6", "#E85F9C", "#6E7A89", "#EA6266", "#0B6A0B", "#C19C00"];
      break;
    case "Fluent2HighContrast":
      palette = ["#9BB449", "#2A72D5", "#43B786", "#3F579A", "#584EC6", "#E85F9C", "#6E7A89", "#EA6266", "#0B6A0B", "#C19C00"];
      break;
    case "Material3":
      palette = ["#6355C7", "#00AEE0", "#FFB400", "#F7523F", "#963C70", "#FD7400", "#4BE0BC", "#2196F5", "#DE3D8A", "#162F88"];
      break;
    case "Material3Dark":
      palette = ["#4EAAFF", "#FA4EAB", "#FFF500", "#17EA58", "#38FFE7", "#FF9E45", "#B3F32F", "#B93CE4", "#FC5664", "#9B55FF"];
      break;
    default:
      palette = ["#00bdae", "#404041", "#357cd2", "#e56590", "#f8b883", "#70ad47", "#dd8abd", "#7f84e8", "#7bb4eb", "#ea7a57"];
      break;
  }
  return palette;
}
function getThemeColor3(theme) {
  var themeColors;
  switch (theme) {
    case "BootstrapDark":
    case "FabricDark":
    case "MaterialDark":
    case "HighContrast":
      themeColors = {
        axisLineColor: "#ffffff",
        dataLabelColor: theme === "BootstrapDark" ? "#676767" : theme === "FabricDark" ? "#A19F9D" : theme === "MaterialDark" ? "rgba(255, 255, 255, 0.6)" : "#969696",
        rangeBandColor: "#ffffff",
        tooltipFill: theme === "BootstrapDark" ? "#F0F0F0" : theme === "FabricDark" ? "#A19F9D" : theme === "MaterialDark" ? "#F4F4F4" : "#FFFFFF",
        background: "#000000",
        tooltipFontColor: theme === "BootstrapDark" ? "#1A1A1A" : theme === "FabricDark" ? "#DADADA" : theme === "MaterialDark" ? "rgba(18, 18, 18, 1)" : "#000000",
        trackerLineColor: "#ffffff",
        labelFontFamily: theme === "BootstrapDark" ? "Helvetica" : theme === "FabricDark" ? "Segoe UI" : theme === "MaterialDark" ? "Roboto" : "Segoe UI",
        tooltipFontFamily: theme === "BootstrapDark" ? "Helvetica" : theme === "FabricDark" ? "Segoe UI" : theme === "MaterialDark" ? "Roboto" : "Segoe UI",
        dataLabelFont: {
          fontFamily: theme === "BootstrapDark" ? "Helvetica" : theme === "FabricDark" ? "Segoe UI" : theme === "MaterialDark" ? "Roboto" : "Segoe UI",
          color: theme === "BootstrapDark" ? "#676767" : theme === "FabricDark" ? "#A19F9D" : theme === "MaterialDark" ? "rgba(255, 255, 255, 0.6)" : "#969696",
          size: "12px",
          fontWeight: "400",
          fontStyle: "Medium"
        },
        tooltipFontWeight: "400",
        tabColor: theme === "BootstrapDark" ? "#0070F0" : theme === "MaterialDark" ? "#00B0FF" : theme === "FabricDark" ? "#0074CC" : "#FFD939"
      };
      break;
    case "Bootstrap4":
      themeColors = {
        axisLineColor: "#6C757D",
        dataLabelColor: "#495057",
        rangeBandColor: "#212529",
        tooltipFill: "#212529",
        background: "#FFFFFF",
        tooltipFontColor: "#F9FAFB",
        trackerLineColor: "#212529",
        fontFamily: "Helvetica",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 0.9,
        labelFontFamily: "Helvetica",
        tooltipFontFamily: "Helvetica",
        dataLabelFont: {
          fontFamily: "Helvetica",
          color: "#495057",
          size: "12px",
          fontWeight: "400",
          fontStyle: "Medium"
        },
        tooltipFontWeight: "400",
        tabColor: "#007BFF"
      };
      break;
    case "Tailwind3":
      themeColors = {
        axisLineColor: "#4B5563",
        dataLabelColor: "#111827",
        rangeBandColor: "#1F2937",
        background: "#FFFFFF",
        tooltipFill: "#111827",
        tooltipFontColor: "#F9FAFB",
        trackerLineColor: "#1F2937",
        fontFamily: "Inter",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        labelFontFamily: "Inter",
        tooltipFontFamily: "Inter",
        dataLabelFont: {
          fontFamily: "Inter",
          color: "#6B7280",
          size: "12px",
          fontWeight: "400",
          fontStyle: "Medium"
        },
        tooltipFontWeight: "500",
        tabColor: "#4F46E5"
      };
      break;
    case "Tailwind3Dark":
      themeColors = {
        axisLineColor: "#D1D5DB",
        dataLabelColor: "#FFFFFF",
        rangeBandColor: "#6B7280",
        background: "transparent",
        tooltipFill: "#F9FAFB",
        tooltipFontColor: "#1F2937",
        trackerLineColor: "#6B7280",
        fontFamily: "Inter",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        labelFontFamily: "Inter",
        tooltipFontFamily: "Inter",
        dataLabelFont: {
          fontFamily: "Inter",
          color: "#FFFFFF",
          size: "12px",
          fontWeight: "400",
          fontStyle: "Medium"
        },
        tooltipFontWeight: "500",
        tabColor: "#22D3EE"
      };
      break;
    case "Tailwind":
      themeColors = {
        axisLineColor: "#4B5563",
        dataLabelColor: "#6B7280",
        rangeBandColor: "#212529",
        background: "#FFFFFF",
        tooltipFill: "#111827",
        tooltipFontColor: "#F9FAFB",
        trackerLineColor: "#1F2937",
        fontFamily: "Inter",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        labelFontFamily: "Inter",
        tooltipFontFamily: "Inter",
        dataLabelFont: {
          fontFamily: "Inter",
          color: "#6B7280",
          size: "12px",
          fontWeight: "400",
          fontStyle: "Medium"
        },
        tooltipFontWeight: "400",
        tabColor: "#4F46E5"
      };
      break;
    case "TailwindDark":
      themeColors = {
        axisLineColor: "#D1D5DB",
        dataLabelColor: "#9CA3AF",
        rangeBandColor: "#F9FAFB",
        background: "transparent",
        tooltipFill: "#E9ECEF",
        tooltipFontColor: "#1F2937",
        trackerLineColor: "#9CA3AF",
        fontFamily: "Inter",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        labelFontFamily: "Inter",
        tooltipFontFamily: "Inter",
        dataLabelFont: {
          fontFamily: "Inter",
          color: "#9CA3AF",
          size: "12px",
          fontWeight: "400",
          fontStyle: "Medium"
        },
        tooltipFontWeight: "400",
        tabColor: "#22D3EE"
      };
      break;
    case "Bootstrap5":
      themeColors = {
        axisLineColor: "#343A40",
        dataLabelColor: "#212529BF",
        rangeBandColor: "#343A40",
        background: "rgba(255, 255, 255, 0.0)",
        tooltipFill: "#000000E5",
        tooltipFontColor: "#FFFFFF",
        trackerLineColor: "#343A40",
        fontFamily: "Segoe UI",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        labelFontFamily: "Segoe UI",
        tooltipFontFamily: "Segoe UI",
        dataLabelFont: {
          fontFamily: "Segoe UI",
          color: "#495057",
          size: "12px",
          fontWeight: "400",
          fontStyle: "Medium"
        },
        tooltipFontWeight: "400",
        tabColor: "#0D6EFD"
      };
      break;
    case "Bootstrap5Dark":
      themeColors = {
        axisLineColor: "#ADB5BD",
        dataLabelColor: "#DEE2E6BF",
        rangeBandColor: "#ADB5BD",
        background: "rgba(255, 255, 255, 0.0)",
        tooltipFill: "#FFFFFFE5",
        tooltipFontColor: "#212529",
        trackerLineColor: "#ADB5BD",
        fontFamily: "Segoe UI",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        labelFontFamily: "Segoe UI",
        tooltipFontFamily: "Segoe UI",
        dataLabelFont: {
          fontFamily: "Segoe UI",
          color: "#E9ECEF",
          size: "12px",
          fontWeight: "400",
          fontStyle: "Medium"
        },
        tooltipFontWeight: "400",
        tabColor: "#0D6EFD"
      };
      break;
    case "Fluent":
      themeColors = {
        axisLineColor: "#D2D0CE;",
        dataLabelColor: "#3B3A39",
        rangeBandColor: "#A19F9D",
        background: "rgba(255, 255, 255, 0.0001)",
        tooltipFill: "#FFFFFF",
        tooltipFontColor: "#323130",
        trackerLineColor: "#A19F9D",
        fontFamily: "Segoe UI",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        labelFontFamily: "Segoe UI",
        tooltipFontFamily: "Segoe UI",
        dataLabelFont: {
          fontFamily: "Segoe UI",
          color: "#3B3A39",
          size: "12px",
          fontWeight: "400",
          fontStyle: "Medium"
        },
        tooltipFontWeight: "400",
        tabColor: "#0078D4"
      };
      break;
    case "FluentDark":
      themeColors = {
        axisLineColor: "#3B3A39;",
        dataLabelColor: "#D2D0CE",
        rangeBandColor: "#797775",
        background: "transparent",
        tooltipFill: "#323130",
        tooltipFontColor: "#F3F2F1",
        trackerLineColor: "#797775",
        fontFamily: "Segoe UI",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        labelFontFamily: "Segoe UI",
        tooltipFontFamily: "Segoe UI",
        dataLabelFont: {
          fontFamily: "Segoe UI",
          color: "#D2D0CE",
          size: "12px",
          fontWeight: "400",
          fontStyle: "Medium"
        },
        tooltipFontWeight: "400",
        tabColor: "#0078D4"
      };
      break;
    case "Fluent2":
      themeColors = {
        axisLineColor: "#D2D0CE",
        dataLabelColor: "#424242",
        rangeBandColor: "#A19F9D",
        background: "transparent",
        tooltipFill: "#FFFFFF",
        tooltipFontColor: "#242424",
        trackerLineColor: "#D2D0CE",
        fontFamily: "Segoe UI",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        labelFontFamily: "Segoe UI",
        tooltipFontFamily: "Segoe UI",
        dataLabelFont: {
          fontFamily: "Segoe UI",
          color: "#242424",
          size: "12px",
          fontWeight: "400",
          fontStyle: "Medium"
        },
        tooltipFontWeight: "400",
        tabColor: "#0078D4"
      };
      break;
    case "Fluent2Dark":
      themeColors = {
        axisLineColor: "#8A8886",
        dataLabelColor: "#D6D6D6",
        rangeBandColor: "#8A8886",
        background: "transparent",
        tooltipFill: "#292929",
        tooltipFontColor: "#FFFFFF",
        trackerLineColor: "#3B3A39",
        fontFamily: "Segoe UI",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        labelFontFamily: "Segoe UI",
        tooltipFontFamily: "Segoe UI",
        dataLabelFont: {
          fontFamily: "Segoe UI",
          color: "#D6D6D6",
          size: "12px",
          fontWeight: "400",
          fontStyle: "Medium"
        },
        tooltipFontWeight: "400",
        tabColor: "#0078D4"
      };
      break;
    case "Fluent2HighContrast":
      themeColors = {
        axisLineColor: "#8A8886",
        dataLabelColor: "#FFFFFF",
        rangeBandColor: "#8A8886",
        background: "transparent",
        tooltipFill: "#000000",
        tooltipFontColor: "#FFFFFF",
        trackerLineColor: "#3B3A39",
        fontFamily: "Segoe UI",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        labelFontFamily: "Segoe UI",
        tooltipFontFamily: "Segoe UI",
        dataLabelFont: {
          fontFamily: "Segoe UI",
          color: "#FFFFFF",
          size: "12px",
          fontWeight: "400",
          fontStyle: "Medium"
        },
        tooltipFontWeight: "400",
        tabColor: "#0078D4"
      };
      break;
    case "Material3":
      themeColors = {
        axisLineColor: "#C4C7C5",
        dataLabelColor: "#49454E",
        rangeBandColor: "rgba(73, 69, 78, 0.3)",
        background: "rgba(255, 255, 255, 0.0001)",
        tooltipFill: "#313033",
        tooltipFontColor: "#F4EFF4",
        trackerLineColor: "#49454E",
        fontFamily: "Roboto",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        labelFontFamily: "Roboto",
        tooltipFontFamily: "Roboto",
        dataLabelFont: {
          fontFamily: "Roboto",
          color: "#49454E",
          size: "12px",
          fontWeight: "400",
          fontStyle: "Medium"
        },
        tooltipFontWeight: "400",
        tabColor: "#49454E"
      };
      break;
    case "Material3Dark":
      themeColors = {
        axisLineColor: "#49454F",
        dataLabelColor: "#CAC4D0",
        rangeBandColor: "rgba(202, 196, 208, 0.3)",
        background: "transparent",
        tooltipFill: "#E6E1E5",
        tooltipFontColor: "#313033",
        trackerLineColor: "#CAC4D0",
        fontFamily: "Roboto",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        labelFontFamily: "Roboto",
        tooltipFontFamily: "Roboto",
        dataLabelFont: {
          fontFamily: "Roboto",
          color: "#CAC4D0",
          size: "12px",
          fontWeight: "400",
          fontStyle: "Medium"
        },
        tooltipFontWeight: "400",
        tabColor: "#CAC4D0"
      };
      break;
    default: {
      themeColors = {
        axisLineColor: "#000000",
        dataLabelColor: theme === "Bootstrap" ? "#676767" : theme === "Fabric" ? "#666666" : "rgba(97, 97, 97, 1)",
        rangeBandColor: "#000000",
        background: "#FFFFFF",
        tooltipFill: theme === "Bootstrap" ? "#212529" : theme === "Fabric" ? "#FFFFFF" : "#000816",
        tooltipFontColor: theme === "Bootstrap" ? "#F9FAFB" : theme === "Fabric" ? "#333333" : "rgba(249, 250, 251, 1)",
        trackerLineColor: "#000000",
        labelFontFamily: theme === "Bootstrap" ? "Helvetica" : theme === "Fabric" ? "Segoe UI" : "Roboto",
        tooltipFontFamily: theme === "Bootstrap" ? "Helvetica" : theme === "Fabric" ? "Segoe UI" : "Roboto",
        dataLabelFont: {
          fontFamily: theme === "Bootstrap" ? "Helvetica" : theme === "Fabric" ? "Segoe UI" : "Roboto",
          color: theme === "Bootstrap" ? "#676767" : theme === "Fabric" ? "#666666" : "rgba(97, 97, 97, 1)",
          size: "12px",
          fontWeight: "400",
          fontStyle: "Medium"
        },
        tooltipFontWeight: "400",
        tabColor: theme === "Material" ? "#ff4081" : theme === "Fabric" ? "#0078D6" : "#317AB9"
      };
      break;
    }
  }
  return themeColors;
}
function stringToNumber3(value, containerSize) {
  if (value !== null && value !== void 0) {
    return value.indexOf("%") !== -1 ? containerSize / 100 * parseInt(value, 10) : parseInt(value, 10);
  }
  return null;
}
function calculateSize3(sparkline) {
  var containerWidth = !sparkline.element.clientWidth ? !sparkline.element.parentElement ? 100 : !sparkline.element.parentElement.clientWidth ? window.innerWidth : sparkline.element.parentElement.clientWidth : sparkline.element.clientWidth;
  var containerHeight = !sparkline.element.clientHeight ? !sparkline.element.parentElement ? 50 : sparkline.element.parentElement.clientHeight : sparkline.element.clientHeight;
  sparkline.availableSize = new Size2(stringToNumber3(sparkline.width, containerWidth) || containerWidth, stringToNumber3(sparkline.height, containerHeight) || containerHeight || (sparkline.isDevice ? Math.min(window.innerWidth, window.innerHeight) : containerHeight));
}
function createSvg3(sparkline) {
  sparkline.renderer = new SvgRenderer(sparkline.element.id);
  calculateSize3(sparkline);
  sparkline.svgObject = sparkline.renderer.createSvg({
    id: sparkline.element.id + "_svg",
    width: sparkline.availableSize.width,
    height: sparkline.availableSize.height
  });
}
var Rect2 = (
  /** @class */
  /* @__PURE__ */ function() {
    function Rect3(x, y, width, height) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
    }
    return Rect3;
  }()
);
var PathOption3 = (
  /** @class */
  /* @__PURE__ */ function() {
    function PathOption4(id, fill, width, color, opacity, dashArray, d) {
      this.id = id;
      this.fill = fill;
      this.opacity = opacity;
      this["stroke-width"] = width;
      this.stroke = color;
      this.d = d;
      this["stroke-dasharray"] = dashArray;
    }
    return PathOption4;
  }()
);
var RectOption3 = (
  /** @class */
  function(_super) {
    __extends96(RectOption4, _super);
    function RectOption4(id, fill, border, opacity, rect, tl, tr, bl, br) {
      if (tl === void 0) {
        tl = 0;
      }
      if (tr === void 0) {
        tr = 0;
      }
      if (bl === void 0) {
        bl = 0;
      }
      if (br === void 0) {
        br = 0;
      }
      var _this = _super.call(this, id, fill, border.width, border.color, opacity) || this;
      _this.rect = rect;
      _this.topLeft = tl;
      _this.topRight = tr;
      _this.bottomLeft = bl;
      _this.bottomRight = br;
      return _this;
    }
    return RectOption4;
  }(PathOption3)
);
var CircleOption3 = (
  /** @class */
  function(_super) {
    __extends96(CircleOption4, _super);
    function CircleOption4(id, fill, border, opacity, cx, cy, r, dashArray) {
      var _this = _super.call(this, id, fill, border.width, border.color, opacity) || this;
      _this.cy = cy;
      _this.cx = cx;
      _this.r = r;
      _this["stroke-dasharray"] = dashArray;
      return _this;
    }
    return CircleOption4;
  }(PathOption3)
);
function appendShape(shape, element) {
  if (element) {
    element.appendChild(shape);
  }
  return shape;
}
function drawCircle(sparkline, options, element) {
  return appendShape(sparkline.renderer.drawCircle(options), element);
}
function calculateRoundedRectPath(r, topLeft, topRight, bottomLeft, bottomRight) {
  return "M " + r.x + " " + (topLeft + r.y) + " Q " + r.x + " " + r.y + " " + (r.x + topLeft) + " " + r.y + " L " + (r.x + r.width - topRight) + " " + r.y + " Q " + (r.x + r.width) + " " + r.y + " " + (r.x + r.width) + " " + (r.y + topRight) + " L " + (r.x + r.width) + " " + (r.y + r.height - bottomRight) + " Q " + (r.x + r.width) + " " + (r.y + r.height) + " " + (r.x + r.width - bottomRight) + " " + (r.y + r.height) + " L " + (r.x + bottomLeft) + " " + (r.y + r.height) + " Q " + r.x + " " + (r.y + r.height) + " " + r.x + " " + (r.y + r.height - bottomLeft) + " L " + r.x + " " + (topLeft + r.y) + " Z";
}
function drawRectangle(sparkline, options, element) {
  options.d = calculateRoundedRectPath(options.rect, options.topLeft, options.topRight, options.bottomLeft, options.bottomRight);
  return appendShape(sparkline.renderer.drawPath(options), element);
}
function drawPath(sparkline, options, element) {
  return appendShape(sparkline.renderer.drawPath(options), element);
}
function measureText3(text, font, themeStyle) {
  var htmlObject = document.getElementById("sparklinesmeasuretext");
  if (htmlObject === null) {
    htmlObject = createElement("text", {
      id: "sparklinesmeasuretext"
    });
    document.body.appendChild(htmlObject);
  }
  htmlObject.innerText = text;
  htmlObject.style.fontStyle = font.fontStyle || themeStyle.fontStyle;
  htmlObject.style.fontFamily = font.fontFamily || themeStyle.fontFamily;
  htmlObject.style.visibility = "hidden";
  htmlObject.style.top = "-100";
  htmlObject.style.left = "0";
  htmlObject.style.position = "absolute";
  htmlObject.style.fontSize = font.size || themeStyle.size;
  htmlObject.style.fontWeight = font.fontWeight || themeStyle.fontWeight;
  htmlObject.style.whiteSpace = "nowrap";
  htmlObject.style.lineHeight = "normal";
  return new Size2(htmlObject.clientWidth, htmlObject.clientHeight);
}
var TextOption3 = (
  /** @class */
  /* @__PURE__ */ function() {
    function TextOption4(id, x, y, anchor, text, baseLine, transform) {
      if (transform === void 0) {
        transform = "";
      }
      this.transform = "";
      this.baseLine = "auto";
      this.id = id;
      this.x = x;
      this.y = y;
      this.anchor = anchor;
      this.text = text;
      this.transform = transform;
      this.baseLine = baseLine;
    }
    return TextOption4;
  }()
);
function renderTextElement2(options, font, color, parent, themeStyle) {
  var textOptions = {
    "id": options.id,
    "x": options.x,
    "y": options.y,
    "transform": options.transform,
    "opacity": font.opacity,
    "fill": color,
    "font-family": font.fontFamily || themeStyle.fontFamily,
    "font-weight": font.fontWeight || themeStyle.fontWeight,
    "font-size": font.size || themeStyle.size,
    "font-style": font.fontStyle || themeStyle.fontStyle,
    "text-anchor": options.anchor,
    "dominant-baseline": options.baseLine
  };
  var renderer = new SvgRenderer("");
  var htmlObject = renderer.createText(textOptions, options.text);
  htmlObject.style["user-select"] = "none";
  htmlObject.style["-moz-user-select"] = "none";
  htmlObject.style["-webkit-touch-callout"] = "none";
  htmlObject.style["-webkit-user-select"] = "none";
  htmlObject.style["-khtml-user-select"] = "none";
  htmlObject.style["-ms-user-select"] = "none";
  htmlObject.style["-o-user-select"] = "none";
  parent.appendChild(htmlObject);
  return htmlObject;
}
function removeElement4(id) {
  var element = document.getElementById(id);
  return element ? remove(element) : null;
}
function getIdElement(id) {
  return document.getElementById(id);
}
function withInBounds2(x, y, bounds) {
  return x >= bounds.x && x <= bounds.x + bounds.width && y >= bounds.y && y <= bounds.y + bounds.height;
}

// node_modules/@syncfusion/ej2-charts/src/sparkline/rendering/sparkline-renderer.js
var SparklineRenderer = (
  /** @class */
  function() {
    function SparklineRenderer2(sparkline) {
      this.sparkline = sparkline;
    }
    SparklineRenderer2.prototype.processData = function() {
      var data = this.sparkline.dataSource;
      if (isNullOrUndefined(data) || !data.length) {
        return;
      } else if (!isNaN(this.sparkline.dataSource[0]) || this.sparkline.valueType === "Numeric") {
        data = this.sparkline.enableRtl ? data.reverse() : data;
        this.sparkline.sparklineData = data;
      } else {
        this["process" + this.sparkline.valueType]();
      }
      this.axisCalculation();
    };
    SparklineRenderer2.prototype.processDataManager = function() {
      var _this = this;
      var dataModule;
      var queryModule;
      if (this.sparkline.dataSource instanceof DataManager) {
        dataModule = this.sparkline.dataSource;
        queryModule = this.sparkline.query instanceof Query ? this.sparkline.query : new Query();
        var dataManager = dataModule.executeQuery(queryModule);
        dataManager.then(function(e) {
          _this.sparkline.setProperties({
            dataSource: e["result"]
          }, true);
          _this.sparkline.sparklineData = _this.sparkline.dataSource;
          _this.sparkline.processSparklineData();
        });
      } else {
        this.sparkline.processSparklineData();
      }
    };
    SparklineRenderer2.prototype.processCategory = function(data, x, y) {
      var _this = this;
      if (data === void 0) {
        data = this.sparkline.dataSource;
      }
      if (x === void 0) {
        x = this.sparkline.xName;
      }
      if (y === void 0) {
        y = this.sparkline.yName;
      }
      var temp = [];
      var xValues = [];
      data.forEach(function(value) {
        if (xValues.indexOf(value[x]) === -1) {
          xValues.push(value[x]);
        }
        var currentData = {};
        currentData[_this.sparkline.xName] = xValues.indexOf(value[x]);
        currentData[_this.sparkline.yName] = value[y];
        temp.push(currentData);
      });
      this.sparkline.sparklineData = temp;
    };
    SparklineRenderer2.prototype.processDateTime = function(data, x, y) {
      if (data === void 0) {
        data = this.sparkline.dataSource;
      }
      if (x === void 0) {
        x = this.sparkline.xName;
      }
      if (y === void 0) {
        y = this.sparkline.yName;
      }
      var temp = [];
      data.forEach(function(value) {
        var currentData = {};
        currentData[x] = value[x].getTime();
        currentData[y] = value[y];
        temp.push(currentData);
      });
      this.sparkline.sparklineData = temp;
    };
    SparklineRenderer2.prototype.renderSeries = function() {
      var _this = this;
      var spark = this.sparkline;
      this.clipId = spark.element.id + "_sparkline_clip_path";
      this.drawAxis();
      var argsData = {
        name: "seriesRendering",
        cancel: false,
        lineWidth: spark.lineWidth,
        border: spark.border,
        fill: spark.fill,
        sparkline: spark
      };
      var seriesRenderingSuccess = function(args) {
        if (!_this.visiblePoints || args.cancel) {
          return;
        }
        if (spark.type !== "Pie" && spark.type !== "WinLoss" && spark.rangeBandSettings.length) {
          var group = _this.sparkline.renderer.createGroup({
            id: _this.sparkline.element.id + "_sparkline_rangeband_g"
          });
          for (var i = 0; i < spark.rangeBandSettings.length; i++) {
            if (spark.axisSettings.minY <= spark.rangeBandSettings[i].startRange || spark.axisSettings.maxY >= spark.rangeBandSettings[i].endRange) {
              _this.rangeBand(spark.rangeBandSettings[i], group, i);
            }
          }
          _this.sparkline.svgObject.appendChild(group);
        }
        _this["render" + spark.type](_this.visiblePoints, args);
        _this.renderMarker(_this.visiblePoints);
        _this.renderLabel(_this.visiblePoints);
      };
      seriesRenderingSuccess.bind(this);
      spark.trigger("seriesRendering", argsData, seriesRenderingSuccess);
    };
    SparklineRenderer2.prototype.rangeBand = function(rangeBandSettings, group, index) {
      var model = this.sparkline;
      var height = model.availableSize.height - model.padding.top * 2;
      var width = model.availableSize.width - model.padding.left * 2;
      var stValue = rangeBandSettings.startRange;
      var edValue = rangeBandSettings.endRange;
      var stHeight = height - height / this.unitY * (stValue - this.min) + model.padding.top;
      var edHeight = height - height / this.unitY * (edValue - this.min) + model.padding.top;
      var color = rangeBandSettings.color || this.sparkline.sparkTheme.rangeBandColor;
      if (edHeight > height + model.padding.top) {
        edHeight = height + model.padding.top;
      } else if (edHeight < 0 + model.padding.top) {
        edHeight = 0 + model.padding.top;
      }
      if (stHeight > height + model.padding.top) {
        stHeight = height + model.padding.top;
      } else if (stHeight < 0 + model.padding.top) {
        stHeight = 0 + model.padding.top;
      }
      var path = "M " + model.padding.left + " " + stHeight + " L " + (width + model.padding.left) + " " + stHeight + " L " + (width + model.padding.left) + " " + edHeight + " L " + model.padding.left + " " + edHeight + " Z ";
      var pathOption = {
        "id": model.element.id + "_rangeBand_" + index,
        "fill": color,
        "opacity": rangeBandSettings.opacity,
        "stroke": "transparent",
        "stroke-width": model.lineWidth,
        "d": path,
        "stroke-dasharray": ""
      };
      drawPath(this.sparkline, pathOption, group);
    };
    SparklineRenderer2.prototype.renderLine = function(points, args) {
      var spark = this.sparkline;
      var g = this.sparkline.renderer.createGroup({
        id: spark.element.id + "_sparkline_g",
        "clip-path": "url(#" + this.clipId + ")"
      });
      var color = this.sparkline.fill;
      color = this.sparkline.fill === "#00bdae" && this.sparkline.theme === "Bootstrap4" ? this.sparkline.sparkTheme.axisLineColor : color;
      var pathOption = new PathOption3(spark.element.id + "_sparkline_line", "transparent", args.lineWidth, color, spark.opacity);
      var d = "";
      for (var i = 0, len = points.length; i < len; i++) {
        if (i === 0) {
          d = "M " + points[0].x + " " + points[i].y + " ";
        }
        d += "L " + points[i].x + " " + points[i].y + " ";
      }
      pathOption.d = d;
      pathOption["aria-label"] = "Line series with" + points.length + "data points";
      pathOption["tabindex"] = "0";
      drawPath(this.sparkline, pathOption, g);
      this.sparkline.svgObject.appendChild(g);
    };
    SparklineRenderer2.prototype.renderPie = function(points, args) {
      var spark = this.sparkline;
      var height = spark.availableSize.height - (spark.padding.top + spark.padding.bottom);
      var width = spark.availableSize.width - (spark.padding.left + spark.padding.right);
      var area = height <= width ? height / 2 : width / 2;
      var X = spark.availableSize.width / 2;
      var Y = spark.availableSize.height / 2;
      var deg = 0;
      var stRad;
      var edRad;
      var stroke = args.border.color;
      var opacity = spark.opacity;
      var strokeWidth = args.border.width;
      var colors = spark.palette.length ? spark.palette : getSeriesColor3(this.sparkline.theme);
      var group = this.sparkline.renderer.createGroup({
        id: spark.element.id + "_sparkline_g"
      });
      var low;
      var high;
      var locations = extend([], [], points);
      if (spark.highPointColor || spark.lowPointColor) {
        var pointsYvalues = locations.map(function(a) {
          return a.yVal;
        });
        low = Math.min.apply(null, pointsYvalues);
        high = Math.max.apply(null, pointsYvalues);
      }
      this.negativePointIndexes = [];
      for (var i = 0, stDeg = 90, edDeg = void 0, flag = void 0; i < points.length; i++) {
        stDeg += deg;
        deg = points[i]["degree"];
        deg = deg === 360 ? deg - 1e-3 : deg;
        edDeg = stDeg + deg;
        stRad = (stDeg - 90) * Math.PI / 180;
        edRad = (edDeg - 90) * Math.PI / 180;
        points[i]["stAng"] = stRad;
        points[i]["endAng"] = edRad;
        flag = deg < 180 ? "0" : "1";
        var temp = points[i]["coordinates"] = {
          sX: X + area * Math.cos(stRad),
          sY: Y + area * Math.sin(stRad),
          eX: X + area * Math.cos(edRad),
          eY: Y + area * Math.sin(edRad)
        };
        var pathArc = "M " + X + " " + Y + " L " + temp["eX"] + " " + temp["eY"] + " A " + area + " " + area + " 0 " + flag + ",0 " + temp["sX"] + " " + temp["sY"] + " Z";
        var pathOption = {
          "id": spark.element.id + "_sparkline_pie_" + i,
          "opacity": opacity,
          "fill": colors[i % colors.length],
          "stroke": stroke,
          "stroke-width": strokeWidth,
          "d": pathArc,
          "stroke-dasharray": ""
        };
        this.getPieSpecialPoint(points[i], spark, pathOption, i, high, low, points.length);
        var pointArgs = this.triggerPointRender("pointRendering", i, pathOption.fill, {
          color: stroke,
          width: strokeWidth
        });
        pathOption.fill = pointArgs.fill;
        pathOption.stroke = pointArgs.border.color;
        pathOption["stroke-width"] = pointArgs.border.width;
        if (!pointArgs.cancel) {
          var element = drawPath(this.sparkline, pathOption, group);
          element.setAttribute("role", "img");
          element.setAttribute("aria-label", spark.dataSource[i][spark.xName] + " : " + points[i].yVal);
          element.setAttribute("tabindex", i === 0 ? "0" : "-1");
          element.style.outline = "none";
        }
        var diffRadian = edRad - stRad;
        var mid = {
          x: X + area / 2 * Math.cos(stRad + diffRadian / 2),
          y: Y + area / 2 * Math.sin(stRad + diffRadian / 2)
        };
        points[i].location.x = mid.x;
        points[i].location.y = mid.y;
      }
      this.sparkline.svgObject.appendChild(group);
    };
    SparklineRenderer2.prototype.getPieSpecialPoint = function(temp, spark, option, i, high, low, length) {
      if (temp.yVal < 0 && spark.negativePointColor) {
        option.fill = spark.negativePointColor;
        this.negativePointIndexes.push(i);
      }
      if (i === 0 && spark.startPointColor) {
        option.fill = spark.startPointColor;
        this.startPointIndex = i;
      } else if (i === length - 1 && spark.endPointColor) {
        option.fill = spark.endPointColor;
        this.endPointIndex = i;
      }
      if (temp.yVal === high && spark.highPointColor) {
        option.fill = spark.highPointColor;
        this.highPointIndex = i;
      } else if (temp.yVal === low && spark.lowPointColor) {
        option.fill = spark.lowPointColor;
        this.lowPointIndex = i;
      }
    };
    SparklineRenderer2.prototype.renderArea = function(points, args) {
      var spark = this.sparkline;
      var group = this.sparkline.renderer.createGroup({
        id: spark.element.id + "_sparkline_g",
        "clip-path": "url(#" + this.clipId + ")"
      });
      var pathOption = new PathOption3(spark.element.id + "_sparkline_area", args.fill, 0, "transparent", spark.opacity);
      var d = "";
      var str = "";
      for (var i = 0, len = points.length; i < len; i++) {
        if (i !== 0) {
          str += "L " + points[i].x + " " + points[i].y + " ";
        } else {
          d = "M " + points[i].x + " " + this.axisHeight + " ";
          str = "M " + points[i].x + " " + points[i].y + " ";
        }
        d += "L " + points[i].x + " " + points[i].y + " ";
        if (i === len - 1) {
          d += "L " + points[i].x + " " + this.axisHeight + " Z";
        }
      }
      pathOption.d = d;
      pathOption["aria-label"] = "Area series with" + points.length + "data points";
      drawPath(this.sparkline, pathOption, group);
      pathOption = new PathOption3(spark.element.id + "_sparkline_area_str", "transparent", args.border.width, args.border.color, spark.opacity, "", str);
      drawPath(this.sparkline, pathOption, group);
      this.sparkline.svgObject.appendChild(group);
    };
    SparklineRenderer2.prototype.renderColumn = function(points, args) {
      var _this = this;
      var spark = this.sparkline;
      var locations = extend([], [], points);
      var group = this.sparkline.renderer.createGroup({
        id: spark.element.id + "_sparkline_g",
        "clip-path": "url(#" + this.clipId + ")"
      });
      var lowPos;
      var highPos;
      if (this.sparkline.highPointColor || this.sparkline.lowPointColor) {
        var pointsYPos = locations.map(function(a) {
          return a.markerPosition;
        });
        highPos = Math.min.apply(null, pointsYPos);
        lowPos = Math.max.apply(null, pointsYPos);
      }
      var id = spark.element.id + "_sparkline_column_";
      var rectOptions = new RectOption3(id, "", args.border, spark.opacity, null);
      var temp;
      var len = points.length;
      this.negativePointIndexes = [];
      var colors = spark.palette.length ? spark.palette : getSeriesColor3(this.sparkline.theme);
      var _loop_1 = function(i2) {
        temp = points[i2];
        rectOptions.id = id + i2;
        rectOptions.fill = spark.fill !== "#00bdae" ? spark.fill : colors[0];
        rectOptions.rect = new Rect2(temp.x, temp.y, temp.width, temp.height);
        this_1.getSpecialPoint(true, temp, spark, rectOptions, i2, highPos, lowPos, len);
        temp.location.y = temp.markerPosition <= this_1.axisHeight ? temp.y : temp.y + temp.height;
        temp.location.x = temp.x + temp.width / 2;
        rectOptions.stroke = args.border.color ? args.border.color : rectOptions.fill;
        var pointArgs = {
          name: "pointRendering",
          cancel: false,
          pointIndex: i2,
          fill: rectOptions.fill,
          border: {
            color: rectOptions.stroke,
            width: args.border.width
          }
        };
        this_1.sparkline.trigger("pointRendering", pointArgs, function() {
          temp = points[i2];
          rectOptions.id = id + i2;
          rectOptions.rect = new Rect2(temp.x, temp.y, temp.width, temp.height);
          _this.getSpecialPoint(true, temp, spark, rectOptions, i2, highPos, lowPos, len);
          rectOptions.fill = pointArgs.fill;
          rectOptions.stroke = pointArgs.border.color;
          temp.location.y = temp.markerPosition <= _this.axisHeight ? temp.y : temp.y + temp.height;
          rectOptions["stroke-width"] = pointArgs.border.width;
          temp.location.x = temp.x + temp.width / 2;
          if (!pointArgs.cancel) {
            var element = drawRectangle(spark, rectOptions, group);
            element.setAttribute("role", "img");
            element.setAttribute("aria-label", spark.dataSource[i2][spark.xName] + " : " + points[i2].yVal);
            element.setAttribute("tabindex", i2 === 0 ? "0" : "-1");
            element.style.outline = "none";
            group.appendChild(element);
          }
        });
      };
      var this_1 = this;
      for (var i = 0; i < len; i++) {
        _loop_1(i);
      }
      this.sparkline.svgObject.appendChild(group);
    };
    SparklineRenderer2.prototype.renderWinLoss = function(points, args) {
      var spark = this.sparkline;
      var group = this.sparkline.renderer.createGroup({
        id: spark.element.id + "_sparkline_g",
        "clip-path": "url(#" + this.clipId + ")"
      });
      var id = spark.element.id + "_sparkline_winloss_";
      var options = new RectOption3(id, "", args.border, spark.opacity, null);
      var temp;
      var len = points.length;
      var paletteLength = spark.palette.length;
      var colors = spark.palette.length ? spark.palette : getSeriesColor3(this.sparkline.theme);
      for (var i = 0; i < len; i++) {
        temp = points[i];
        options.id = id + i;
        options.fill = paletteLength ? spark.palette[i % paletteLength] : temp.yVal === this.axisValue ? this.sparkline.tiePointColor || "#a216f3" : temp.yVal > this.axisValue ? args.fill || colors[i % colors.length] : spark.negativePointColor || "#e20f07";
        options.stroke = args.border.color ? args.border.color : options.fill;
        options.rect = new Rect2(temp.x, temp.y, temp.width, temp.height);
        temp.location.x = temp.x + temp.width / 2;
        temp.location.y = temp.yVal >= this.axisValue ? temp.y : temp.y + temp.height;
        var pointArgs = this.triggerPointRender("pointRendering", i, options.fill, {
          color: options.stroke,
          width: args.border.width
        });
        options.fill = pointArgs.fill;
        options.stroke = pointArgs.border.color;
        options["stroke-width"] = pointArgs.border.width;
        if (!pointArgs.cancel) {
          var element = drawRectangle(spark, options, group);
          element.setAttribute("role", "img");
          element.setAttribute("aria-label", spark.dataSource[i][spark.xName] + " : " + points[i].yVal);
          element.setAttribute("tabindex", i === 0 ? "0" : "-1");
          element.style.outline = "none";
        }
      }
      this.sparkline.svgObject.appendChild(group);
    };
    SparklineRenderer2.prototype.renderMarker = function(points) {
      var _this = this;
      var spark = this.sparkline;
      var marker = spark.markerSettings;
      if (spark.type === "Pie" || spark.type === "WinLoss" || !marker.visible.length) {
        return;
      }
      var locations = extend([], [], points);
      var group = this.sparkline.renderer.createGroup({
        id: spark.element.id + "_sparkline_marker_g",
        "clip-path": "url(#" + this.clipId + ")"
      });
      var temp;
      var id = spark.element.id + "_sparkline_marker_";
      var option = new CircleOption3("", marker.fill, marker.border, marker.opacity, 0, 0, marker.size / 2, "");
      var highPos;
      var lowPos;
      var visible = marker.visible.join();
      if (visible.toLowerCase().indexOf("high") > -1 || visible.toLowerCase().indexOf("low") > -1) {
        var pointsYPos = locations.map(function(a) {
          return a.markerPosition;
        });
        highPos = Math.min.apply(null, pointsYPos);
        lowPos = Math.max.apply(null, pointsYPos);
      }
      this.negativePointIndexes = [];
      var _loop_2 = function(i2, length_12) {
        temp = points[i2];
        option.id = id + i2;
        option.cx = temp.location.x;
        option.cy = temp.location.y;
        option.fill = marker.fill;
        var render = visible.toLowerCase().indexOf("all") > -1;
        render = this_2.getSpecialPoint(render, temp, spark, option, i2, highPos, lowPos, length_12, visible.toLowerCase());
        option.stroke = marker.border.color || option.fill;
        var markerArgs = {
          name: "markerRendering",
          cancel: false,
          border: {
            color: option.stroke,
            width: marker.border.width
          },
          fill: option.fill,
          pointIndex: i2,
          sparkline: this_2.sparkline,
          x: option.cx,
          y: option.cy,
          size: marker.size
        };
        this_2.sparkline.trigger("markerRendering", markerArgs, function() {
          if (render && !markerArgs.cancel) {
            option.id = id + i2;
            option.cx = markerArgs.x;
            option.cy = markerArgs.y;
            option.fill = markerArgs.fill;
            option.stroke = markerArgs.border.color;
            option["stroke-width"] = markerArgs.border.width;
            option.r = markerArgs.size / 2;
            var element = drawCircle(spark, option, group);
            element.setAttribute("role", "img");
            element.setAttribute("aria-label", spark.dataSource[i2][spark.xName] + " : " + points[i2].yVal);
            if (_this.sparkline.type.indexOf("Line") > -1 || _this.sparkline.type.indexOf("Area") > -1) {
              element.setAttribute("tabindex", i2 === 0 ? "0" : "-1");
              element.style.outline = "none";
            }
            group.appendChild(element);
          }
        });
      };
      var this_2 = this;
      for (var i = 0, length_1 = points.length; i < length_1; i++) {
        _loop_2(i, length_1);
      }
      this.sparkline.svgObject.appendChild(group);
    };
    SparklineRenderer2.prototype.getSpecialPoint = function(render, temp, spark, option, i, highPos, lowPos, length, visible) {
      if (visible === void 0) {
        visible = "";
      }
      if (temp.markerPosition > this.axisHeight) {
        option.fill = spark.negativePointColor || option.fill;
        this.negativePointIndexes.push(i);
        render = render || visible.indexOf("negative") > -1;
      }
      if (i === 0) {
        option.fill = spark.startPointColor || option.fill;
        this.startPointIndex = i;
        render = render || visible.indexOf("start") > -1;
      } else if (i === length - 1) {
        option.fill = spark.endPointColor || option.fill;
        this.endPointIndex = i;
        render = render || visible.indexOf("end") > -1;
      }
      if (temp.markerPosition === highPos) {
        option.fill = spark.highPointColor || option.fill;
        this.highPointIndex = i;
        render = render || visible.indexOf("high") > -1;
      } else if (temp.markerPosition === lowPos) {
        option.fill = spark.lowPointColor || option.fill;
        this.lowPointIndex = i;
        render = render || visible.indexOf("low") > -1;
      }
      if (visible.indexOf("none") > -1) {
        render = false;
      }
      return render;
    };
    SparklineRenderer2.prototype.renderLabel = function(points) {
      var _this = this;
      var spark = this.sparkline;
      var dataLabel = spark.dataLabelSettings;
      var color = dataLabel.textStyle.color || spark.sparkTheme.dataLabelColor;
      if (spark.type === "WinLoss" || !dataLabel.visible.length) {
        return;
      }
      var locations = extend([], [], points);
      var id = spark.element.id + "_sparkline_label_";
      var group = this.sparkline.renderer.createGroup({
        id: spark.element.id + "_sparkline_label_g",
        style: "pointer-events: none;"
      });
      group.setAttribute("aria-hidden", "true");
      var g;
      var temp;
      var textId = id + "text_";
      var rectId = id + "rect_";
      var option = new TextOption3("", 0, 0, "middle", "", "middle");
      var labelStyle = dataLabel.textStyle;
      var pointsYPos = locations.map(function(a) {
        return a.markerPosition;
      });
      var highPos = Math.min.apply(null, pointsYPos);
      var lowPos = Math.max.apply(null, pointsYPos);
      var space = 1;
      var padding = dataLabel.fill !== "transparent" || dataLabel.border.width ? 2 : 0;
      var size = measureText3("sparkline_measure_text", labelStyle, this.sparkline.sparkTheme.dataLabelFont);
      var rectOptions = new RectOption3("", dataLabel.fill, dataLabel.border, dataLabel.opacity, null);
      var edgeLabelOption;
      var _loop_3 = function(i2, length_22) {
        temp = points[i2];
        option.id = textId + i2;
        option.x = temp.location.x + dataLabel.offset.x;
        option.y = (spark.type === "Pie" ? temp.location.y : temp.markerPosition > this_3.axisHeight ? temp.location.y + size.height / 2 + space + 2 + padding : temp.location.y - size.height / 2 - space - padding) + dataLabel.offset.y;
        option.text = dataLabel.format !== "" ? this_3.formatter(dataLabel.format, this_3.sparkline.dataSource[i2]) : temp.yVal.toString();
        var labelArgs = {
          name: "dataLabelRendering",
          cancel: false,
          border: dataLabel.border,
          fill: dataLabel.fill,
          pointIndex: i2,
          sparkline: this_3.sparkline,
          x: option.x,
          y: option.y,
          text: option.text,
          color
        };
        this_3.sparkline.trigger("dataLabelRendering", labelArgs, function() {
          size = measureText3(labelArgs.text, labelStyle, _this.sparkline.sparkTheme.dataLabelFont);
          option.text = labelArgs.text;
          var renderLabel = dataLabel.visible.join().toLowerCase().indexOf("all") > -1;
          renderLabel = _this.getLabelVisible(renderLabel, temp, i2, dataLabel, length_22, highPos, lowPos);
          edgeLabelOption = _this.arrangeLabelPosition(dataLabel.edgeLabelMode, renderLabel, labelArgs.x, i2, length_22, size, padding);
          if (renderLabel && !labelArgs.cancel && edgeLabelOption.render) {
            rectOptions.id = rectId + i2;
            rectOptions.fill = labelArgs.fill;
            rectOptions.stroke = labelArgs.border.color;
            rectOptions["stroke-width"] = labelArgs.border.width;
            option.y = labelArgs.y;
            option.x = edgeLabelOption.x;
            rectOptions.rect = new Rect2(option.x - (size.width / 2 + padding), option.y - padding - size.height / 1.75, size.width + padding * 2, size.height + padding * 2);
            g = _this.sparkline.renderer.createGroup({
              id: id + "g" + i2
            });
            drawRectangle(spark, rectOptions, g);
            renderTextElement2(option, labelStyle, labelArgs.color, g, _this.sparkline.sparkTheme.dataLabelFont);
            group.appendChild(g);
          }
        });
      };
      var this_3 = this;
      for (var i = 0, length_2 = points.length; i < length_2; i++) {
        _loop_3(i, length_2);
      }
      this.sparkline.svgObject.appendChild(group);
    };
    SparklineRenderer2.prototype.arrangeLabelPosition = function(edgeLabel, render, x, index, length, size, padding) {
      if (edgeLabel === "None") {
        return {
          x,
          render
        };
      }
      if (index === 0 && x - size.width / 2 - padding <= 0) {
        if (edgeLabel === "Hide") {
          render = false;
        } else {
          x = this.sparkline.padding.left + padding + size.width / 2;
        }
      } else if (index === length - 1 && x + size.width / 2 + padding >= this.sparkline.availableSize.width) {
        if (edgeLabel === "Hide") {
          render = false;
        } else {
          x -= size.width / 2 + padding;
        }
      }
      return {
        x,
        render
      };
    };
    SparklineRenderer2.prototype.getLabelVisible = function(render, temp, i, label, length, highPos, lowPos) {
      var labelVisible = label.visible.join().toLowerCase();
      if (temp.markerPosition > this.axisHeight) {
        render = render || labelVisible.indexOf("negative") > -1;
      }
      if (i === 0) {
        render = render || labelVisible.indexOf("start") > -1;
      } else if (i === length - 1) {
        render = render || labelVisible.indexOf("end") > -1;
      }
      if (temp.markerPosition === highPos) {
        render = render || labelVisible.indexOf("high") > -1;
      } else if (temp.markerPosition === lowPos) {
        render = render || labelVisible.indexOf("low") > -1;
      }
      if (label.visible.join().toLowerCase().indexOf("none") > -1) {
        render = false;
      }
      return render;
    };
    SparklineRenderer2.prototype.formatter = function(format, data) {
      if (isNullOrUndefined(format)) {
        return null;
      }
      var keys = Object.keys(data);
      for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        format = format.split("${" + key + "}").join(data[key]);
      }
      return format;
    };
    SparklineRenderer2.prototype.axisCalculation = function() {
      this.findRanges(this.sparkline.sparklineData);
    };
    SparklineRenderer2.prototype.getInterval = function(data, x) {
      var interval = 1;
      var x1 = data[0][x];
      var x2 = isNullOrUndefined(data[1]) ? void 0 : data[1][x];
      if (!isNullOrUndefined(x1) && !isNullOrUndefined(x2)) {
        var temp = extend([], data);
        var validData_1 = [];
        temp.forEach(function(value) {
          if (!isNullOrUndefined(value[x])) {
            validData_1.push(value);
          }
        });
        validData_1.sort(function(a, b) {
          if (isNullOrUndefined(a[x]) || isNullOrUndefined(b[x])) {
            return 0;
          }
          return a[x] - b[x];
        });
        validData_1 = this.sparkline.enableRtl ? validData_1.reverse() : validData_1;
        interval = validData_1[1][x] - validData_1[0][x];
      }
      return interval;
    };
    SparklineRenderer2.prototype.getPaddingInterval = function(data, x, type, delta) {
      var interval = 1;
      var size = this.sparkline.availableSize.height;
      var intervalCount = interval * data.length;
      intervalCount = Math.max(size * (intervalCount / 100), 1);
      var niceInterval = delta / intervalCount;
      for (var _i = 0, _a = this.sparkline.intervalDivs; _i < _a.length; _i++) {
        var intervalVal = _a[_i];
        var currentInterval = interval * intervalVal;
        if (intervalCount < delta / currentInterval) {
          break;
        }
        niceInterval = currentInterval;
      }
      return niceInterval;
    };
    SparklineRenderer2.prototype.findRanges = function(data) {
      var model = this.sparkline;
      var max;
      var min;
      var minX;
      var maxX;
      var maxPointsLength = data.length;
      var temp;
      var sumofValues = 0;
      var isNumericArray = Array.isArray(data) && typeof data[0] !== "object";
      if (isNumericArray) {
        if (model.type === "Pie") {
          for (var i = 0; i < maxPointsLength; i++) {
            sumofValues += Math.abs(data[i]);
          }
        } else {
          max = Math.max.apply(null, data);
          min = Math.min.apply(null, data);
          minX = 0;
          maxX = maxPointsLength - 1;
        }
      } else {
        if (model.type === "Pie") {
          for (var i = 0; i < maxPointsLength; i++) {
            sumofValues += Math.abs(data[i][model.yName]);
          }
        } else {
          if (isNullOrUndefined(data[0][model.xName])) {
            var x_1 = data.map(function(z2) {
              return z2[model.yName];
            });
            max = Math.max.apply(null, x_1);
            min = Math.min.apply(null, x_1);
          } else {
            temp = extend([], data);
            temp = temp.sort(function(a, b) {
              return a[model.yName] - b[model.yName];
            });
            max = temp[temp.length - 1][model.yName];
            min = temp[0][model.yName];
          }
          if (!isNullOrUndefined(data[0][model.xName])) {
            temp = temp.sort(function(a, b) {
              return a[model.xName] - b[model.xName];
            });
            temp = this.sparkline.enableRtl ? temp.reverse() : temp;
            maxX = temp[temp.length - 1][model.xName];
            minX = temp[0][model.xName];
          } else {
            minX = 0;
            maxX = maxPointsLength - 1;
          }
        }
      }
      var y2;
      var height;
      var width;
      var x1 = 0;
      var y1;
      var padding = model.padding;
      var point;
      var axis = model.axisSettings;
      var value = axis.value;
      if (model.type !== "Pie") {
        this.maxLength = maxPointsLength;
        height = model.availableSize.height - (padding.bottom + padding.top);
        width = model.availableSize.width - (padding.left + padding.right);
        maxX = isNullOrUndefined(axis.maxX) ? maxX : axis.maxX;
        minX = isNullOrUndefined(axis.minX) ? minX : axis.minX;
        max = isNullOrUndefined(axis.maxY) ? max : axis.maxY;
        min = isNullOrUndefined(axis.minY) ? min : axis.minY;
        var color = axis.lineSettings.color || this.sparkline.sparkTheme.axisLineColor;
        var eventArgs = {
          name: "axisRendering",
          cancel: false,
          sparkline: model,
          maxX,
          minX,
          maxY: max,
          minY: min,
          value: axis.value,
          lineColor: color,
          lineWidth: axis.lineSettings.width
        };
        model.trigger("axisRendering", eventArgs);
        if (eventArgs.cancel) {
          this.visiblePoints = [];
          return;
        }
        maxX = eventArgs.maxX;
        minX = eventArgs.minX;
        max = eventArgs.maxY;
        min = eventArgs.minY;
        value = this.axisValue = eventArgs.value;
        this.axisColor = eventArgs.lineColor;
        this.axisWidth = eventArgs.lineWidth;
      }
      var unitX = maxX - minX;
      var unitY = max - min;
      unitX = unitX === 0 ? 1 : unitX;
      unitY = unitY === 0 ? 1 : unitY;
      this.unitX = unitX;
      this.unitY = unitY;
      this.min = min;
      x1 = 0;
      y1 = height - height / unitY * -min;
      y1 = min < 0 && max <= 0 ? 0 : min < 0 && max > 0 ? y1 : height;
      if (value >= min && value <= max) {
        y1 = height - Math.round(height * ((value - min) / this.unitY));
      }
      this.axisHeight = y1 + padding.top;
      var percent;
      var x;
      var y;
      var visiblePoints = [];
      var delta = max - min;
      var interval = this.getInterval(data, model.xName);
      var interVal = this.getPaddingInterval(data, model.xName, model.valueType, delta);
      for (var i = 0; i < maxPointsLength; i++) {
        if (isNullOrUndefined(data[i][model.xName]) && isNullOrUndefined(data[i][model.yName]) && data[i][model.yName] !== 0 && isNumericArray) {
          x = i;
          y = data[i];
        } else if (isNullOrUndefined(data[i][model.xName])) {
          x = i;
          y = data[i][model.yName];
        } else {
          x = data[i][model.xName];
          y = data[i][model.yName];
        }
        if (isNullOrUndefined(x) || isNullOrUndefined(y)) {
          continue;
        }
        if (model.type === "Line" || model.type === "Area") {
          y2 = min !== max && maxPointsLength !== 1 ? height - Math.round(height * ((y - min) / this.unitY)) : padding.top;
          point = {
            x: minX !== maxX ? Math.round(width * ((x - minX) / this.unitX)) : width / 2,
            y: y2,
            markerPosition: y2
          };
        } else if (model.type === "Column" || model.type === "WinLoss") {
          var colWidth = width / ((maxX - minX) / interval + 1);
          var calSpace = 0.5;
          var space = calSpace * 2;
          colWidth -= space;
          x1 = (x - minX) / interval * (colWidth + space) + space / 2;
          if (model.type === "WinLoss") {
            var winLossFactor = 0.5;
            var drawHeightFactor = 40;
            y2 = y > value ? height / 4 : y < value ? height * winLossFactor : height * winLossFactor - height / drawHeightFactor;
            point = {
              x: x1,
              y: y2,
              height: y !== value ? height / 4 : height / 20,
              width: colWidth,
              markerPosition: y2 > y1 ? y1 + Math.abs(y2 - y1) : y2
            };
          } else {
            if (i === 0 && model.rangePadding !== "None") {
              min -= model.rangePadding === "Additional" ? interVal + padding.top : interVal;
              max += model.rangePadding === "Additional" ? interVal + padding.top : interVal;
              unitX = maxX - minX;
              unitY = max - min;
              unitX = unitX === 0 ? 1 : unitX;
              unitY = unitY === 0 ? 1 : unitY;
              this.unitX = unitX;
              this.unitY = unitY;
              this.min = min;
            }
            var z = height / this.unitY * (y - min);
            var z1 = y === min && y > value ? maxPointsLength !== 1 && this.unitY !== 1 ? height / this.unitY * (min / 2) : z | 1 : y === max && y < value && maxPointsLength !== 1 && this.unitY !== 1 ? height / this.unitY * (-max / 2) : z;
            y2 = Math.abs(height - z1);
            point = {
              x: x1,
              y: y2 > y1 ? y1 : y2,
              height: Math.abs(y2 - y1),
              width: colWidth,
              markerPosition: y2 > y1 ? y1 + Math.abs(y2 - y1) : y2
            };
          }
        } else if (model.type === "Pie") {
          percent = Math.abs(y) / sumofValues * 100;
          point = {
            percent,
            degree: Math.abs(y) / sumofValues * 360
          };
        }
        if (model.type !== "Pie") {
          point.x += padding.left;
          point.y += padding.top;
        }
        if (model.type !== "WinLoss") {
          point.markerPosition += padding.top;
        }
        point.location = {
          x: point.x,
          y: point.y
        };
        point.xVal = x;
        point.yVal = y;
        visiblePoints.push(point);
      }
      visiblePoints.sort(function(a, b) {
        return a.x - b.x;
      });
      this.visiblePoints = visiblePoints;
    };
    SparklineRenderer2.prototype.drawAxis = function() {
      var spark = this.sparkline;
      var height = this.axisHeight;
      if (spark.type !== "WinLoss" && spark.type !== "Pie" && spark.axisSettings.lineSettings.visible) {
        var xAxis = {
          "id": spark.element.id + "_Sparkline_XAxis",
          "x1": spark.padding.left,
          "y1": height,
          "x2": spark.availableSize.width - spark.padding.right,
          "y2": height,
          "stroke": this.axisColor,
          "opacity": spark.axisSettings.lineSettings.opacity,
          "stroke-dasharray": spark.axisSettings.lineSettings.dashArray,
          "stroke-width": this.axisWidth,
          "clip-path": "url(#" + this.clipId + ")"
        };
        spark.svgObject.appendChild(spark.renderer.drawLine(xAxis));
      }
    };
    SparklineRenderer2.prototype.triggerPointRender = function(name, i, fill, border) {
      var args = {
        name,
        cancel: false,
        border,
        fill,
        sparkline: this.sparkline,
        pointIndex: i
      };
      this.sparkline.trigger(name, args);
      return args;
    };
    return SparklineRenderer2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/sparkline/sparkline.js
var __extends97 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate24 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Sparkline = (
  /** @class */
  function(_super) {
    __extends97(Sparkline2, _super);
    function Sparkline2(options, element) {
      var _this = _super.call(this, options, element) || this;
      _this.isDevice = Browser.isDevice;
      _this.intervalDivs = [10, 5, 2, 1];
      _this.previousTargetId = "";
      _this.currentPointIndex = 0;
      return _this;
    }
    Sparkline2.prototype.preRender = function() {
      this.allowServerDataBinding = false;
      this.unWireEvents();
      this.trigger("load", {
        sparkline: this
      });
      this.sparkTheme = getThemeColor3(this.theme);
      this.sparklineRenderer = new SparklineRenderer(this);
      this.setTheme();
      this.createSVG();
      this.wireEvents();
      this.setCulture();
    };
    Sparkline2.prototype.render = function() {
      this.sparklineRenderer.processDataManager();
      this.renderComplete();
      this.allowServerDataBinding = true;
    };
    Sparkline2.prototype.processSparklineData = function() {
      this.sparklineRenderer.processData();
      this.renderSparkline();
      this.element.appendChild(this.svgObject);
      this.setSecondaryElementPosition();
      this.trigger("loaded", {
        sparkline: this
      });
    };
    Sparkline2.prototype.renderSparkline = function() {
      this.renderBorder();
      this.createDiv();
      this.sparklineRenderer.renderSeries();
    };
    Sparkline2.prototype.createDiv = function() {
      var tooltipDiv = document.createElement("div");
      tooltipDiv.id = this.element.id + "_Secondary_Element";
      tooltipDiv.style.position = "relative";
      this.element.appendChild(tooltipDiv);
      this.element.setAttribute("tabindex", "0");
      this.element.style.outline = "none";
      this.element.style.display = "block";
      this.element.style.position = "relative";
    };
    Sparkline2.prototype.setSecondaryElementPosition = function() {
      var element = getIdElement(this.element.id + "_Secondary_Element");
      if (!element) {
        return;
      }
      var rect = this.element.getBoundingClientRect();
      var svgRect = getIdElement(this.element.id + "_svg").getBoundingClientRect();
      element.style.left = Math.max(svgRect.left - rect.left, 0) + "px";
      element.style.top = Math.max(svgRect.top - rect.top, 0) + "px";
    };
    Sparkline2.prototype.renderBorder = function() {
      var width = this.containerArea.border.width;
      var borderRect;
      if (width > 0 || this.containerArea.background !== "transparent") {
        borderRect = new RectOption3(this.element.id + "_SparklineBorder", this.sparkTheme.background, this.containerArea.border, 1, new Rect2(width / 2, width / 2, this.availableSize.width - width, this.availableSize.height - width));
        this.svgObject.appendChild(drawRectangle(this, borderRect));
      }
      var padding = this.padding;
      if (this.markerSettings.visible.length) {
        padding.left = 0;
        padding.right = 0;
        padding.bottom = 0;
        padding.top = 0;
      }
      borderRect = new RectOption3(this.element.id + "_sparkline_clip_rect", "transparent", {
        color: "transparent",
        width: 0
      }, 1, new Rect2(padding.left, padding.top, this.availableSize.width - (padding.left + padding.right), this.availableSize.height - (padding.top + padding.bottom)));
      var clipPath = this.renderer.createClipPath({
        id: this.element.id + "_sparkline_clip_path"
      });
      drawRectangle(this, borderRect, clipPath);
      this.svgObject.appendChild(clipPath);
    };
    Sparkline2.prototype.createSVG = function() {
      this.removeSvg();
      createSvg3(this);
    };
    Sparkline2.prototype.removeSvg = function() {
      if (this.svgObject) {
        while (this.svgObject.childNodes.length > 0) {
          this.svgObject.removeChild(this.svgObject.firstChild);
        }
        if (!this.svgObject.hasChildNodes() && this.svgObject.parentNode) {
          remove(this.svgObject);
        }
      }
      removeElement4(this.element.id + "_Secondary_Element");
      if (this.sparklineTooltipModule) {
        this.sparklineTooltipModule.removeTooltipElements();
      }
    };
    Sparkline2.prototype.setCulture = function() {
      this.intl = new Internationalization();
      this.localeObject = new L10n(this.getModuleName(), this.defaultLocalConstants, this.locale);
    };
    Sparkline2.prototype.setTheme = function() {
      this.sparkTheme = getThemeColor3(this.theme);
    };
    Sparkline2.prototype.requiredModules = function() {
      var modules = [];
      if (this.tooltipSettings.visible || this.tooltipSettings.trackLineSettings.visible) {
        modules.push({
          member: "SparklineTooltip",
          args: [this]
        });
      }
      return modules;
    };
    Sparkline2.prototype.unWireEvents = function() {
      var cancel = Browser.isPointer ? "pointerleave" : "mouseleave";
      EventHandler.remove(this.element, Browser.touchMoveEvent, this.sparklineMove);
      EventHandler.remove(this.element, cancel, this.sparklineMouseLeave);
      EventHandler.remove(this.element, Browser.touchEndEvent, this.sparklineMouseEnd);
      EventHandler.remove(this.element, "keyup", this.chartKeyUp);
      EventHandler.remove(this.element, "keydown", this.chartKeyDown);
      window.removeEventListener(Browser.isTouch && "orientation" in window && "onorientationchange" in window ? "orientationchange" : "resize", this.sparklineResize);
    };
    Sparkline2.prototype.wireEvents = function() {
      var cancel = Browser.isPointer ? "pointerleave" : "mouseleave";
      EventHandler.add(this.element, Browser.touchMoveEvent, this.sparklineMove, this);
      EventHandler.add(this.element, "click", this.sparklineClick, this);
      EventHandler.add(this.element, cancel, this.sparklineMouseLeave, this);
      EventHandler.add(this.element, Browser.touchEndEvent, this.sparklineMouseEnd, this);
      EventHandler.add(this.element, "keyup", this.chartKeyUp, this);
      EventHandler.add(this.element, "keydown", this.chartKeyDown, this);
      window.addEventListener(Browser.isTouch && "orientation" in window && "onorientationchange" in window ? "orientationchange" : "resize", this.sparklineResize.bind(this));
      new Touch(this.element);
    };
    Sparkline2.prototype.sparklineResize = function() {
      var _this = this;
      var args = {
        name: "resize",
        previousSize: this.availableSize,
        sparkline: this,
        currentSize: new Size2(0, 0)
      };
      if (this.resizeTo) {
        clearTimeout(this.resizeTo);
      }
      this.resizeTo = +setTimeout(function() {
        if (_this.isDestroyed) {
          clearTimeout(_this.resizeTo);
          return;
        }
        _this.unWireEvents();
        _this.createSVG();
        _this.refreshing = true;
        _this.wireEvents();
        args.currentSize = _this.availableSize;
        _this.trigger("resize", args);
        _this.render();
        _this.refreshing = false;
      }, 500);
      return false;
    };
    Sparkline2.prototype.sparklineMove = function(e) {
      this.setSparklineMouseXY(e);
      this.notify(Browser.touchMoveEvent, e);
      var args = {
        name: "sparklineMouseMove",
        cancel: false,
        sparkline: this,
        event: e
      };
      this.trigger(args.name, args);
      var pointClick2 = this.isPointRegion(e);
      if (pointClick2.isPointRegion) {
        var pointArgs = {
          name: "pointRegionMouseMove",
          cancel: false,
          event: e,
          sparkline: this,
          pointIndex: pointClick2.pointIndex
        };
        this.trigger(pointArgs.name, pointArgs);
      }
      return false;
    };
    Sparkline2.prototype.sparklineClick = function(e) {
      this.setSparklineMouseXY(e);
      var args = {
        name: "sparklineMouseClick",
        cancel: false,
        sparkline: this,
        event: e
      };
      this.trigger(args.name, args);
      var pointClick2 = this.isPointRegion(e);
      if (pointClick2.isPointRegion) {
        var pointArgs = {
          name: "pointRegionMouseClick",
          cancel: false,
          event: e,
          sparkline: this,
          pointIndex: pointClick2.pointIndex
        };
        this.trigger(pointArgs.name, pointArgs);
      }
      this.removeNavigationStyle();
      return false;
    };
    Sparkline2.prototype.isPointRegion = function(e) {
      var _this = this;
      var startId = this.element.id + "_";
      var id = e.target.id.replace(startId, "").split("_");
      if (id[1] === this.type.toLowerCase()) {
        var index_1 = parseInt(id[2], 10);
        if ((isNullOrUndefined(index_1) || isNaN(index_1)) && (this.type === "Line" || this.type === "Area")) {
          this.sparklineRenderer.visiblePoints.forEach(function(point, i) {
            if (withInBounds2(_this.mouseX, _this.mouseY, new Rect2(point.x - 5, point.y - 5, 10, 10))) {
              index_1 = i;
              return;
            }
          });
        }
        return {
          isPointRegion: true,
          pointIndex: index_1
        };
      }
      return {
        isPointRegion: false,
        pointIndex: null
      };
    };
    Sparkline2.prototype.sparklineMouseEnd = function(e) {
      this.setSparklineMouseXY(e);
      this.notify(Browser.touchEndEvent, e);
      return false;
    };
    Sparkline2.prototype.sparklineMouseLeave = function(e) {
      this.setSparklineMouseXY(e);
      this.notify(Browser.isPointer ? "pointerleave" : "mouseleave", e);
      return false;
    };
    Sparkline2.prototype.chartKeyDown = function(e) {
      var actionKey = "";
      if (this.tooltipSettings.visible && (e.code === "Tab" && this.previousTargetId.indexOf("_sparkline_") > -1 || e.code === "Escape")) {
        actionKey = "ESC";
      }
      if (actionKey !== "") {
        this.sparklineKeyboardNavigations(e, e.target.id, actionKey);
      }
      if (e.code === "Tab" || e.code === "Enter" || e.code.indexOf("Arrow") > -1) {
        this.removeNavigationStyle();
      }
      return false;
    };
    Sparkline2.prototype.chartKeyUp = function(e) {
      var actionKey = "";
      var targetId = e.target["id"];
      var groupElement;
      var targetElement = e.target;
      var seriesElement = getElement2(this.element.id + "_sparkline_g");
      var seriesChildElement = getElement2(this.element.id + "_sparkline_line");
      this.removeNavigationStyle();
      this.setNavigationStyle(targetId);
      if (seriesChildElement) {
        seriesChildElement.removeAttribute("tabindex");
      }
      if (seriesElement && seriesElement.firstElementChild) {
        var firstChild = seriesElement.firstElementChild;
        var className = firstChild.getAttribute("class");
        if (className && className.indexOf("e-sparkline-focused") === -1) {
          className = className + " e-sparkline-focused";
        } else if (!className) {
          className = "e-sparkline-focused";
        }
        firstChild.setAttribute("class", className);
      }
      if (e.code === "Tab") {
        if (this.previousTargetId !== "") {
          if (this.previousTargetId.indexOf("_sparkline_") > -1 && targetId.indexOf("_sparkline_") === -1) {
            groupElement = getElement2(this.element.id + "_sparkline_g");
            this.setTabIndex(groupElement.children[this.currentPointIndex], groupElement.firstElementChild);
          }
        }
        this.previousTargetId = targetId;
        actionKey = this.tooltipSettings.visible ? "Tab" : "";
      } else if (e.code.indexOf("Arrow") > -1) {
        e.preventDefault();
        this.previousTargetId = targetId;
        if (targetId.indexOf("_sparkline_") > -1) {
          groupElement = targetElement.parentElement;
          var currentPoint = e.target;
          targetElement.removeAttribute("tabindex");
          targetElement.blur();
          if (e.code === "ArrowUp" || e.code === "ArrowDown") {
            this.currentPointIndex += e.code === "ArrowUp" ? 1 : -1;
          }
          if (targetId.indexOf("_marker") > -1) {
            this.currentPointIndex = this.getActualIndex(this.currentPointIndex, getElement2(this.element.id + "_sparkline_marker_g").childElementCount);
            currentPoint = getElement2(this.element.id + "_sparkline_marker_" + this.currentPointIndex);
          } else if (targetId.indexOf("_column") > -1) {
            this.currentPointIndex = this.getActualIndex(this.currentPointIndex, getElement2(this.element.id + "_sparkline_g").childElementCount);
            currentPoint = getElement2(this.element.id + "_sparkline_column_" + this.currentPointIndex);
          } else if (targetId.indexOf("_winloss") > -1) {
            this.currentPointIndex = this.getActualIndex(this.currentPointIndex, getElement2(this.element.id + "_sparkline_g").childElementCount);
            currentPoint = getElement2(this.element.id + "_sparkline_winloss_" + this.currentPointIndex);
          } else if (targetId.indexOf("_pie") > -1) {
            this.currentPointIndex = this.getActualIndex(this.currentPointIndex, getElement2(this.element.id + "_sparkline_g").childElementCount);
            currentPoint = getElement2(this.element.id + "_sparkline_pie_" + this.currentPointIndex);
          }
          targetId = this.focusChild(currentPoint);
          actionKey = this.tooltipSettings.visible ? "ArrowMove" : "";
        }
      }
      if (actionKey !== "") {
        this.sparklineKeyboardNavigations(e, targetId, actionKey);
      }
      return false;
    };
    Sparkline2.prototype.setNavigationStyle = function(target) {
      var currentElement = document.getElementById(target);
      if (currentElement) {
        currentElement.style.setProperty("outline", "1.5px solid " + this.sparkTheme.tabColor);
      }
    };
    Sparkline2.prototype.removeNavigationStyle = function() {
      var currentElement = document.querySelectorAll("path[id*=_sparkline_], [id*=" + this.element.id + "]");
      if (currentElement) {
        currentElement.forEach(function(element) {
          if (element instanceof HTMLElement || element instanceof SVGElement) {
            element.style.setProperty("outline", "none");
            element.style.setProperty("margin", "");
          }
        });
      }
    };
    Sparkline2.prototype.sparklineKeyboardNavigations = function(e, targetId, actionKey) {
      switch (actionKey) {
        case "Tab":
        case "ArrowMove":
          if (targetId.indexOf("_sparkline_") > -1) {
            var pointIndex = void 0;
            if (this.type.indexOf("Line") > -1 || this.type.indexOf("Area") > -1) {
              pointIndex = +targetId.split("_sparkline_")[1].split("marker_")[1];
            } else if (this.type.indexOf("WinLoss") > -1) {
              pointIndex = +targetId.split("_sparkline_")[1].split("winloss_")[1];
            } else if (this.type.indexOf("Pie") > -1) {
              pointIndex = +targetId.split("_sparkline_")[1].split("pie_")[1];
            } else {
              pointIndex = +targetId.split("_sparkline_")[1].split("column_")[1];
            }
            if (this.sparklineTooltipModule) {
              this.sparklineTooltipModule.renderTooltip(this.sparklineRenderer.visiblePoints[pointIndex]);
            }
          }
          break;
        case "ESC":
          this.sparklineTooltipModule.removeTooltipElements();
          break;
      }
    };
    Sparkline2.prototype.setTabIndex = function(previousElement, currentElement) {
      if (previousElement) {
        previousElement.removeAttribute("tabindex");
      }
      if (currentElement) {
        currentElement.setAttribute("tabindex", "0");
      }
    };
    Sparkline2.prototype.getActualIndex = function(index, totalLength) {
      return index > totalLength - 1 ? 0 : index < 0 ? totalLength - 1 : index;
    };
    Sparkline2.prototype.focusChild = function(element) {
      element.setAttribute("tabindex", "0");
      var className = element.getAttribute("class");
      element.setAttribute("tabindex", "0");
      if (className && className.indexOf("e-sparkline-focused") === -1) {
        className = "e-sparkline-focused " + className;
      } else if (!className) {
        className = "e-sparkline-focused";
      }
      element.setAttribute("class", className);
      element.focus();
      return element.id;
    };
    Sparkline2.prototype.setSparklineMouseXY = function(e) {
      var pageY;
      var pageX;
      if (e.type.indexOf("touch") > -1) {
        this.isTouch = true;
        var touchArg = e;
        pageX = touchArg.changedTouches[0].clientX;
        pageY = touchArg.changedTouches[0].clientY;
      } else {
        this.isTouch = e.pointerType === "touch" || e.pointerType === "2";
        pageY = e.clientY;
        pageX = e.clientX;
      }
      var rect = this.element.getBoundingClientRect();
      var svgRect = getIdElement(this.element.id + "_svg").getBoundingClientRect();
      this.mouseY = pageY - rect.top - Math.max(svgRect.top - rect.top, 0);
      this.mouseX = pageX - rect.left - Math.max(svgRect.left - rect.left, 0);
    };
    Sparkline2.prototype.onPropertyChanged = function(newProp) {
      var render = false;
      var refresh = false;
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "xName":
          case "yName":
          case "axisSettings":
          case "rangeBandSettings":
          case "type":
          case "valueType":
          case "enableRtl":
            refresh = true;
            break;
          case "dataSource":
            refresh = true;
            break;
          case "border":
          case "markerSettings":
          case "dataLabelSettings":
          case "tooltipSettings":
          case "startPointColor":
          case "highPointColor":
          case "lowPointColor":
          case "endPointColor":
          case "negativePointColor":
          case "theme":
            render = true;
            break;
        }
      }
      if (refresh) {
        this.createSVG();
        this.sparklineRenderer.processData();
        this.refreshSparkline();
      } else if (render) {
        this.createSVG();
        this.refreshSparkline();
      }
    };
    Sparkline2.prototype.refreshSparkline = function() {
      this.renderSparkline();
      this.element.appendChild(this.svgObject);
      this.setSecondaryElementPosition();
    };
    Sparkline2.prototype.getModuleName = function() {
      return "sparkline";
    };
    Sparkline2.prototype.destroy = function() {
      this.sparklineData = [];
      var element = document.getElementById(this.element.id + "Keyboard_sparkline_focus");
      if (element) {
        element.remove();
      }
      removeElement4("sparklinesmeasuretext");
      if (this.element) {
        this.unWireEvents();
        _super.prototype.destroy.call(this);
        this.removeSvg();
        this.svgObject = null;
      }
    };
    Sparkline2.prototype.getPersistData = function() {
      return "";
    };
    __decorate24([Property(null)], Sparkline2.prototype, "width", void 0);
    __decorate24([Property(null)], Sparkline2.prototype, "height", void 0);
    __decorate24([Complex({}, SparklineBorder)], Sparkline2.prototype, "border", void 0);
    __decorate24([Property("Line")], Sparkline2.prototype, "type", void 0);
    __decorate24([Property("None")], Sparkline2.prototype, "rangePadding", void 0);
    __decorate24([Property(null)], Sparkline2.prototype, "dataSource", void 0);
    __decorate24([Property(null)], Sparkline2.prototype, "query", void 0);
    __decorate24([Property("Numeric")], Sparkline2.prototype, "valueType", void 0);
    __decorate24([Property(null)], Sparkline2.prototype, "xName", void 0);
    __decorate24([Property(null)], Sparkline2.prototype, "yName", void 0);
    __decorate24([Property("#00bdae")], Sparkline2.prototype, "fill", void 0);
    __decorate24([Property("")], Sparkline2.prototype, "highPointColor", void 0);
    __decorate24([Property("")], Sparkline2.prototype, "lowPointColor", void 0);
    __decorate24([Property("")], Sparkline2.prototype, "startPointColor", void 0);
    __decorate24([Property("")], Sparkline2.prototype, "endPointColor", void 0);
    __decorate24([Property("")], Sparkline2.prototype, "negativePointColor", void 0);
    __decorate24([Property("")], Sparkline2.prototype, "tiePointColor", void 0);
    __decorate24([Property([])], Sparkline2.prototype, "palette", void 0);
    __decorate24([Property(1)], Sparkline2.prototype, "lineWidth", void 0);
    __decorate24([Property(1)], Sparkline2.prototype, "opacity", void 0);
    __decorate24([Property(null)], Sparkline2.prototype, "format", void 0);
    __decorate24([Property(false)], Sparkline2.prototype, "useGroupingSeparator", void 0);
    __decorate24([Complex({}, SparklineTooltipSettings)], Sparkline2.prototype, "tooltipSettings", void 0);
    __decorate24([Complex({}, ContainerArea)], Sparkline2.prototype, "containerArea", void 0);
    __decorate24([Collection([], RangeBandSettings)], Sparkline2.prototype, "rangeBandSettings", void 0);
    __decorate24([Complex({}, AxisSettings)], Sparkline2.prototype, "axisSettings", void 0);
    __decorate24([Complex({}, SparklineMarkerSettings)], Sparkline2.prototype, "markerSettings", void 0);
    __decorate24([Complex({}, SparklineDataLabelSettings)], Sparkline2.prototype, "dataLabelSettings", void 0);
    __decorate24([Complex({}, Padding)], Sparkline2.prototype, "padding", void 0);
    __decorate24([Property("Material")], Sparkline2.prototype, "theme", void 0);
    __decorate24([Event()], Sparkline2.prototype, "loaded", void 0);
    __decorate24([Event()], Sparkline2.prototype, "load", void 0);
    __decorate24([Event()], Sparkline2.prototype, "tooltipInitialize", void 0);
    __decorate24([Event()], Sparkline2.prototype, "seriesRendering", void 0);
    __decorate24([Event()], Sparkline2.prototype, "axisRendering", void 0);
    __decorate24([Event()], Sparkline2.prototype, "pointRendering", void 0);
    __decorate24([Event()], Sparkline2.prototype, "pointRegionMouseMove", void 0);
    __decorate24([Event()], Sparkline2.prototype, "pointRegionMouseClick", void 0);
    __decorate24([Event()], Sparkline2.prototype, "sparklineMouseMove", void 0);
    __decorate24([Event()], Sparkline2.prototype, "sparklineMouseClick", void 0);
    __decorate24([Event()], Sparkline2.prototype, "dataLabelRendering", void 0);
    __decorate24([Event()], Sparkline2.prototype, "markerRendering", void 0);
    __decorate24([Event()], Sparkline2.prototype, "resize", void 0);
    Sparkline2 = __decorate24([NotifyPropertyChanges], Sparkline2);
    return Sparkline2;
  }(Component)
);

// node_modules/@syncfusion/ej2-charts/src/sparkline/rendering/sparkline-tooltip.js
var __rest = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") {
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
  }
  return t;
};
var SparklineTooltip = (
  /** @class */
  function() {
    function SparklineTooltip2(sparkline) {
      this.sparkline = sparkline;
      this.addEventListener();
    }
    SparklineTooltip2.prototype.addEventListener = function() {
      if (this.sparkline.isDestroyed) {
        return;
      }
      this.sparkline.on(Browser.isPointer ? "pointerleave" : "mouseleave", this.mouseLeaveHandler, this);
      this.sparkline.on(Browser.touchMoveEvent, this.mouseMoveHandler, this);
      this.sparkline.on(Browser.touchEndEvent, this.mouseUpHandler, this);
    };
    SparklineTooltip2.prototype.mouseLeaveHandler = function() {
      this.removeTooltipElements();
    };
    SparklineTooltip2.prototype.mouseUpHandler = function(e) {
      if (!this.sparkline.isTouch) {
        return;
      }
      this.processTooltip(e);
      this.fadeOut();
    };
    SparklineTooltip2.prototype.fadeOut = function() {
      clearTimeout(this.clearTooltip);
      this.clearTooltip = +setTimeout(this.removeTooltipElements.bind(this), 5e3);
    };
    SparklineTooltip2.prototype.removeTooltipElements = function() {
      this.removeTooltip();
      this.removeTracker();
    };
    SparklineTooltip2.prototype.mouseMoveHandler = function(e) {
      this.processTooltip(e);
    };
    SparklineTooltip2.prototype.processTooltip = function(e) {
      var pointIndex;
      var spark = this.sparkline;
      var visiblePoints = spark.sparklineRenderer.visiblePoints;
      var mouseX = spark.mouseX;
      var mouseY = spark.mouseY;
      if (spark.type !== "Pie") {
        var locations = extend([], [], visiblePoints);
        var trackerPositions = locations.map(function(point) {
          return point.location.x;
        });
        var temp = Infinity;
        for (var i = 0, diff = void 0, len = trackerPositions.length; i < len; i++) {
          diff = Math.abs(mouseX - trackerPositions[i]);
          if (temp > diff) {
            temp = diff;
            pointIndex = i;
          }
        }
      } else {
        var target = e.target.id;
        pointIndex = parseInt(target.split("_pie_")[1], 10);
      }
      if (isNaN(pointIndex) || !withInBounds2(mouseX, mouseY, new Rect2(0, 0, spark.availableSize.width, spark.availableSize.height))) {
        this.removeTracker();
        this.removeTooltip();
        return;
      }
      if (this.pointIndex === pointIndex) {
        return;
      }
      this.pointIndex = pointIndex;
      this.renderTrackerLine(visiblePoints[pointIndex]);
      this.renderTooltip(visiblePoints[pointIndex]);
    };
    SparklineTooltip2.prototype.renderTrackerLine = function(points) {
      var spark = this.sparkline;
      var tracker = spark.tooltipSettings.trackLineSettings;
      var color = spark.sparkTheme.trackerLineColor ? spark.sparkTheme.trackerLineColor : tracker.color;
      if (!tracker.visible || spark.type === "Pie") {
        return;
      }
      var group = getIdElement(spark.element.id + "_sparkline_tracker_g");
      if (isNullOrUndefined(group)) {
        group = spark.renderer.createGroup({
          id: spark.element.id + "_sparkline_tracker_g"
        });
        spark.svgObject.appendChild(group);
      }
      var pathEle = getIdElement(spark.element.id + "_sparkline_tracker");
      var d = "M " + points.location.x + " " + spark.padding.top + " L " + points.location.x + " " + (spark.availableSize.height - spark.padding.bottom);
      if (isNullOrUndefined(pathEle)) {
        var pathOption = new PathOption3(spark.element.id + "_sparkline_tracker", color, tracker.width, color, 1);
        pathOption.d = d;
        drawPath(spark, pathOption, group);
      } else {
        pathEle.setAttribute("d", d);
        pathEle.setAttribute("stroke-width", tracker.width.toString());
        pathEle.setAttribute("stroke", color);
      }
    };
    SparklineTooltip2.prototype.renderTooltip = function(points) {
      var _this = this;
      var spark = this.sparkline;
      var tooltip = spark.tooltipSettings;
      if (!tooltip.visible) {
        return;
      }
      var div = getIdElement(spark.element.id + "_sparkline_tooltip_div");
      if (isNullOrUndefined(div)) {
        div = createElement("div", {
          id: spark.element.id + "_sparkline_tooltip_div",
          styles: "pointer-events: none; position: absolute;z-index:1;"
        });
        getIdElement(spark.element.id + "_Secondary_Element").appendChild(div);
      }
      var x = points.xVal.toString();
      if (spark.valueType === "Category") {
        x = spark.dataSource[points.xVal][spark.xName];
      } else if (spark.valueType === "DateTime") {
        x = new Date(points.xVal).toDateString();
      }
      var text = this.getFormat(spark.tooltipSettings.format, spark, x, this.formatValue(points.yVal, spark).toString());
      var location = {
        x: points.location.x,
        y: points.location.y
      };
      location = spark.type === "Pie" ? {
        x: points.location.x,
        y: points.location.y
      } : location;
      var textColor = tooltip.textStyle.color || spark.sparkTheme.tooltipFontColor;
      var backgroundColor = tooltip.fill === "" ? spark.sparkTheme.tooltipFill : tooltip.fill;
      var tooltipEvent = {
        name: "tooltipInitialize",
        cancel: false,
        text,
        textStyle: {
          size: tooltip.textStyle.size,
          opacity: spark.sparkTheme.tooltipTextOpacity || tooltip.textStyle.opacity,
          fontWeight: tooltip.textStyle.fontWeight || spark.sparkTheme.tooltipFontWeight,
          fontStyle: tooltip.textStyle.fontStyle,
          fontFamily: tooltip.textStyle.fontFamily || spark.sparkTheme.tooltipFontFamily,
          color: textColor
        }
      };
      spark.trigger("tooltipInitialize", tooltipEvent, function() {
        _this.addTooltip(tooltipEvent, spark, backgroundColor, tooltip, location, div);
      });
    };
    SparklineTooltip2.prototype.addTooltip = function(tooltipEvent, spark, backgroundColor, tooltip, location, div, eventArgs) {
      var cancel;
      var arg;
      var tootipArgs;
      if (!isNullOrUndefined(tooltipEvent)) {
        var c = tooltipEvent.cancel, otherArgs = __rest(tooltipEvent, ["cancel"]);
        cancel = c;
        tootipArgs = tooltipEvent;
      } else {
        cancel = eventArgs.cancel;
        arg = eventArgs;
        tootipArgs = eventArgs;
      }
      if (tooltipEvent.cancel) {
        return;
      }
      var element = new Tooltip({
        content: tootipArgs.text,
        border: tooltip.border,
        template: tooltip.template,
        data: spark.dataSource[this.pointIndex],
        fill: backgroundColor,
        textStyle: tootipArgs.textStyle,
        enableAnimation: false,
        location: {
          x: location.x,
          y: location.y
        },
        shared: false,
        availableSize: this.sparkline.availableSize,
        areaBounds: new Rect2(0, 0, spark.availableSize.width, spark.availableSize.height),
        theme: spark.theme
      });
      element.opacity = spark.sparkTheme.tooltipFillOpacity || element.opacity;
      element.appendTo(div);
    };
    SparklineTooltip2.prototype.getFormat = function(format, spark, x, y) {
      if (isNullOrUndefined(format) || format === "") {
        return [y];
      }
      var text = format;
      text = text.split("${" + spark.xName + "}").join(x).split("${" + spark.yName + "}").join(y);
      return [text];
    };
    SparklineTooltip2.prototype.formatValue = function(value, sparkline) {
      var formatValue;
      var formatFunction;
      if (sparkline.format && !isNaN(Number(value))) {
        formatFunction = sparkline.intl.getNumberFormat({
          format: sparkline.format,
          useGrouping: sparkline.useGroupingSeparator
        });
        formatValue = formatFunction(value);
      } else {
        formatValue = value;
      }
      return formatValue;
    };
    SparklineTooltip2.prototype.removeTracker = function() {
      var tracker = this.sparkline.element.querySelector("#" + this.sparkline.element.id + "_sparkline_tracker_g");
      return tracker ? remove(tracker) : null;
    };
    SparklineTooltip2.prototype.removeTooltip = function() {
      this.pointIndex = null;
      var tooltip = this.sparkline.element.querySelector("#" + this.sparkline.element.id + "_sparkline_tooltip_div");
      return tooltip ? remove(tooltip) : null;
    };
    SparklineTooltip2.prototype.getModuleName = function() {
      return "SparklineTooltip";
    };
    SparklineTooltip2.prototype.destroy = function() {
    };
    return SparklineTooltip2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart3d/model/chart3d-Interface.js
var __extends98 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate25 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Chart3DTextFont = (
  /** @class */
  function(_super) {
    __extends98(Chart3DTextFont2, _super);
    function Chart3DTextFont2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate25([Property("Normal")], Chart3DTextFont2.prototype, "fontStyle", void 0);
    __decorate25([Property("16px")], Chart3DTextFont2.prototype, "size", void 0);
    __decorate25([Property("Normal")], Chart3DTextFont2.prototype, "fontWeight", void 0);
    __decorate25([Property("")], Chart3DTextFont2.prototype, "color", void 0);
    __decorate25([Property("Segoe UI")], Chart3DTextFont2.prototype, "fontFamily", void 0);
    __decorate25([Property(1)], Chart3DTextFont2.prototype, "opacity", void 0);
    return Chart3DTextFont2;
  }(ChildProperty)
);
var TitleBorder = (
  /** @class */
  function(_super) {
    __extends98(TitleBorder2, _super);
    function TitleBorder2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate25([Property("transparent")], TitleBorder2.prototype, "color", void 0);
    __decorate25([Property(0)], TitleBorder2.prototype, "width", void 0);
    __decorate25([Property(0.8)], TitleBorder2.prototype, "cornerRadius", void 0);
    return TitleBorder2;
  }(ChildProperty)
);
var TitleSettings = (
  /** @class */
  function(_super) {
    __extends98(TitleSettings2, _super);
    function TitleSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate25([Property("Normal")], TitleSettings2.prototype, "fontStyle", void 0);
    __decorate25([Property("15px")], TitleSettings2.prototype, "size", void 0);
    __decorate25([Property("500")], TitleSettings2.prototype, "fontWeight", void 0);
    __decorate25([Property("")], TitleSettings2.prototype, "color", void 0);
    __decorate25([Property("Center")], TitleSettings2.prototype, "textAlignment", void 0);
    __decorate25([Property("Segoe UI")], TitleSettings2.prototype, "fontFamily", void 0);
    __decorate25([Property(1)], TitleSettings2.prototype, "opacity", void 0);
    __decorate25([Property("Wrap")], TitleSettings2.prototype, "textOverflow", void 0);
    __decorate25([Property("Top")], TitleSettings2.prototype, "position", void 0);
    __decorate25([Property(0)], TitleSettings2.prototype, "x", void 0);
    __decorate25([Property(0)], TitleSettings2.prototype, "y", void 0);
    __decorate25([Property("transparent")], TitleSettings2.prototype, "background", void 0);
    __decorate25([Complex({}, TitleBorder)], TitleSettings2.prototype, "border", void 0);
    return TitleSettings2;
  }(ChildProperty)
);

// node_modules/@syncfusion/ej2-charts/src/chart3d/axis/cartesian-panel.js
var axisPadding2 = 10;
var CartesianAxisLayoutPanel2 = (
  /** @class */
  function() {
    function CartesianAxisLayoutPanel3(chartModule) {
      this.chart = chartModule;
    }
    CartesianAxisLayoutPanel3.prototype.measureAxis = function(rect) {
      var chart = this.chart;
      this.seriesClipRect = new Rect(rect.x, rect.y, rect.width, rect.height);
      this.initialClipRect = rect;
      this.leftSize = 0;
      this.rightSize = 0;
      this.topSize = 0;
      this.bottomSize = 0;
      this.measureRowAxis(chart, this.initialClipRect);
      this.initialClipRect = subtractThickness(this.initialClipRect, new Thickness(this.leftSize, this.rightSize, 0, 0));
      this.measureColumnAxis(chart, this.initialClipRect);
      this.initialClipRect = subtractThickness(this.initialClipRect, new Thickness(0, 0, this.topSize, this.bottomSize));
      if (!this.chart.delayRedraw) {
        this.calculateAxisSize(this.initialClipRect);
      }
      this.leftSize = 0;
      this.rightSize = 0;
      this.topSize = 0;
      this.bottomSize = 0;
      this.measureRowAxis(chart, this.initialClipRect);
      this.seriesClipRect = subtractThickness(this.seriesClipRect, new Thickness(this.leftSize, this.rightSize, 0, 0));
      this.measureColumnAxis(chart, this.initialClipRect);
      this.seriesClipRect = subtractThickness(this.seriesClipRect, new Thickness(0, 0, this.topSize, this.bottomSize));
      if (!this.chart.delayRedraw) {
        chart.refreshAxis();
        this.calculateAxisSize(this.seriesClipRect);
      }
    };
    CartesianAxisLayoutPanel3.prototype.measureRowAxis = function(chart, rect) {
      var row;
      this.calculateRowSize(rect);
      for (var _i = 0, _a = chart.rows; _i < _a.length; _i++) {
        var item = _a[_i];
        row = item;
        row.nearSizes = [];
        row.farSizes = [];
        this.arrangeAxis(row);
        this.measureDefinition(row, chart, new Size(chart.availableSize.width, row.computedHeight));
        if (this.leftSize < sum(row.nearSizes)) {
          this.leftSize = sum(row.nearSizes);
        }
        if (this.rightSize < sum(row.farSizes)) {
          this.rightSize = sum(row.farSizes);
        }
      }
    };
    CartesianAxisLayoutPanel3.prototype.measureColumnAxis = function(chart, rect) {
      var column;
      this.calculateColumnSize(rect);
      for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {
        var item = _a[_i];
        column = item;
        column.farSizes = [];
        column.nearSizes = [];
        this.arrangeAxis(column);
        this.measureDefinition(column, chart, new Size(column.computedWidth, chart.availableSize.height));
        if (this.bottomSize < sum(column.nearSizes)) {
          this.bottomSize = sum(column.nearSizes);
        }
        if (this.topSize < sum(column.farSizes)) {
          this.topSize = sum(column.farSizes);
        }
      }
    };
    CartesianAxisLayoutPanel3.prototype.measureDefinition = function(definition, chart, size) {
      for (var _i = 0, _a = definition.axes; _i < _a.length; _i++) {
        var axis = _a[_i];
        axis.getModule(chart);
        axis.baseModule.calculateRangeAndInterval(size, axis);
        definition.computeSize(axis, chart);
      }
      if (definition.farSizes.length > 0) {
        definition.farSizes[definition.farSizes.length - 1] -= axisPadding2;
      }
      if (definition.nearSizes.length > 0) {
        definition.nearSizes[definition.nearSizes.length - 1] -= axisPadding2;
      }
    };
    CartesianAxisLayoutPanel3.prototype.calculateAxisSize = function(rect) {
      var chart = this.chart;
      var row;
      var column;
      var definition;
      var axis;
      var nearCount = 0;
      var farCount = 0;
      var size = 0;
      var x;
      var y;
      var axisOffset;
      this.calculateRowSize(rect);
      for (var i = 0, len = chart.rows.length; i < len; i++) {
        row = chart.rows[i];
        nearCount = 0;
        farCount = 0;
        for (var j = 0, len_1 = row.axes.length; j < len_1; j++) {
          axis = row.axes[j];
          axisOffset = axis.plotOffset;
          if (axis.rect.height === 0) {
            axis.rect.height = row.computedHeight;
            size = 0;
            for (var k = i + 1, len_2 = i + axis.span; k < len_2; k++) {
              definition = chart.rows[k];
              size += definition.computedHeight;
            }
            axis.rect.y = row.computedTop - size + (axis.plotOffsetTop ? axis.plotOffsetTop : axisOffset);
            axis.rect.height = axis.rect.height + size - this.getAxisOffsetValue(axis.plotOffsetTop, axis.plotOffsetBottom, axis.plotOffset);
            axis.rect.width = 0;
          }
          if (axis.isAxisOpposedPosition) {
            x = rect.x + rect.width + sum(subArray(row.farSizes, farCount));
            axis.rect.x = axis.rect.x >= x ? axis.rect.x : x;
            farCount++;
          } else {
            x = rect.x - sum(subArray(row.nearSizes, nearCount));
            axis.rect.x = axis.rect.x <= x ? axis.rect.x : x;
            nearCount++;
          }
        }
      }
      this.calculateColumnSize(rect);
      for (var i = 0, len = chart.columns.length; i < len; i++) {
        column = chart.columns[i];
        nearCount = 0;
        farCount = 0;
        for (var j = 0, len_3 = column.axes.length; j < len_3; j++) {
          axis = column.axes[j];
          axisOffset = axis.plotOffset;
          if (axis.rect.width === 0) {
            for (var k = i, len_4 = i + axis.span; k < len_4; k++) {
              definition = chart.columns[k];
              axis.rect.width += definition.computedWidth;
            }
            axis.rect.x = column.computedLeft + (axis.plotOffsetLeft ? axis.plotOffsetLeft : axisOffset);
            axis.rect.width -= this.getAxisOffsetValue(axis.plotOffsetLeft, axis.plotOffsetRight, axis.plotOffset);
            axis.rect.height = 0;
          }
          if (axis.isAxisOpposedPosition) {
            y = rect.y - sum(subArray(column.farSizes, farCount));
            axis.rect.y = axis.rect.y <= y ? axis.rect.y : y;
            farCount++;
          } else {
            y = rect.y + rect.height + sum(subArray(column.nearSizes, nearCount));
            axis.rect.y = axis.rect.y >= y ? axis.rect.y : y;
            nearCount++;
          }
        }
      }
    };
    CartesianAxisLayoutPanel3.prototype.measure = function() {
      var chart = this.chart;
      var row;
      var column;
      var definition;
      var actualIndex;
      var span;
      for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {
        var axis = _a[_i];
        if (axis.orientation === "Vertical") {
          chart.verticalAxes.push(axis);
          actualIndex = this.getActualRow(axis);
          row = chart.rows[actualIndex];
          this.pushAxis(row, axis);
          span = actualIndex + axis.span > chart.rows.length ? chart.rows.length : actualIndex + axis.span;
          for (var j = actualIndex + 1; j < span; j++) {
            definition = chart.rows[j];
            definition.axes[row.axes.length - 1] = axis;
            chart.rows[j] = definition;
          }
          chart.rows[actualIndex] = row;
        } else {
          chart.horizontalAxes.push(axis);
          actualIndex = this.getActualColumn(axis);
          column = chart.columns[actualIndex];
          this.pushAxis(column, axis);
          span = actualIndex + axis.span > chart.columns.length ? chart.columns.length : actualIndex + axis.span;
          for (var j = actualIndex + 1; j < span; j++) {
            definition = chart.columns[j];
            definition.axes[column.axes.length - 1] = axis;
            chart.columns[j] = definition;
          }
          chart.columns[actualIndex] = column;
        }
        axis.isRTLEnabled = chart.enableRtl;
        axis.setIsInversedAndOpposedPosition();
      }
    };
    CartesianAxisLayoutPanel3.prototype.getAxisOffsetValue = function(position1, position2, plotOffset) {
      var rangeOffset = position1 ? position1 + (position2 ? position2 : plotOffset) : position2 ? position2 + plotOffset : 2 * plotOffset;
      return rangeOffset;
    };
    CartesianAxisLayoutPanel3.prototype.pushAxis = function(definition, axis) {
      for (var i = 0, len = definition.axes.length; i <= len; i++) {
        if (!definition.axes[i]) {
          definition.axes[i] = axis;
          break;
        }
      }
    };
    CartesianAxisLayoutPanel3.prototype.arrangeAxis = function(definition) {
      var axisCollection = [];
      for (var i = 0, len = definition.axes.length; i <= len; i++) {
        if (definition.axes[i]) {
          axisCollection.push(definition.axes[i]);
        }
      }
      definition.axes = axisCollection;
    };
    CartesianAxisLayoutPanel3.prototype.getActualColumn = function(axis) {
      var actualLength = this.chart.columns.length;
      var pos = axis.columnIndex;
      var result = pos >= actualLength ? actualLength - 1 : pos < 0 ? 0 : pos;
      return result;
    };
    CartesianAxisLayoutPanel3.prototype.getActualRow = function(axis) {
      var actualLength = this.chart.rows.length;
      var pos = axis.rowIndex;
      var result = pos >= actualLength ? actualLength - 1 : pos < 0 ? 0 : pos;
      return result;
    };
    CartesianAxisLayoutPanel3.prototype.calculateRowSize = function(rect) {
      var chart = this.chart;
      var row;
      var rowTop = rect.y + rect.height;
      var height = 0;
      var remainingHeight = Math.max(0, rect.height);
      for (var i = 0, len = chart.rows.length; i < len; i++) {
        row = chart.rows[i];
        if (row.height.indexOf("%") !== -1) {
          height = Math.min(remainingHeight, rect.height * parseInt(row.height, 10) / 100);
        } else {
          height = Math.min(remainingHeight, parseInt(row.height, 10));
        }
        height = i !== len - 1 ? height : remainingHeight;
        row.computedHeight = height;
        rowTop -= height;
        row.computedTop = rowTop;
        remainingHeight -= height;
      }
    };
    CartesianAxisLayoutPanel3.prototype.calculateColumnSize = function(rect) {
      var chart = this.chart;
      var column;
      var columnLeft = rect.x;
      var width = 0;
      var remainingWidth = Math.max(0, rect.width);
      for (var i = 0, len = chart.columns.length; i < len; i++) {
        column = chart.columns[i];
        if (column.width.indexOf("%") !== -1) {
          width = Math.min(remainingWidth, rect.width * parseInt(column.width, 10) / 100);
        } else {
          width = Math.min(remainingWidth, parseInt(column.width, 10));
        }
        width = i !== len - 1 ? width : remainingWidth;
        column.computedWidth = width;
        column.computedLeft = columnLeft;
        columnLeft += width;
        remainingWidth -= width;
      }
    };
    return CartesianAxisLayoutPanel3;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart3d/model/theme.js
function get3DThemeColor(theme) {
  var style;
  switch (theme) {
    case "HighContrastLight":
    case "HighContrast":
      style = {
        axisLabel: "#969696",
        axisTitle: "#969696",
        majorGridLine: "#BFBFBF",
        minorGridLine: "#969696",
        majorTickLine: "#BFBFBF",
        minorTickLine: "#969696",
        chartTitle: "#ffffff",
        legendLabel: "#ffffff",
        background: "transparent",
        tooltipFill: "#ffffff",
        tooltipBoldLabel: "#000000",
        tooltipLightLabel: "#000000",
        tooltipHeaderLine: "#969696",
        tabColor: "#FFD939",
        backWallColor: "#222222",
        leftWallColor: "#272727",
        chartTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: "#969696",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#969696",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#000000",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#000000",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        datalabelFont: {
          color: "#969696",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "MaterialDark":
    case "FabricDark":
    case "BootstrapDark":
      style = {
        axisLabel: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.6)" : theme === "FabricDark" ? "#A19F9D" : "#676767",
        axisTitle: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.6)" : theme === "FabricDark" ? "#A19F9D" : "#676767",
        majorGridLine: "#414040",
        minorGridLine: "#514F4F",
        majorTickLine: "#414040",
        minorTickLine: "#4A4848",
        chartTitle: "#ffffff",
        legendLabel: "#DADADA",
        background: "transparent",
        tooltipFill: "#F4F4F4",
        tooltipBoldLabel: "#282727",
        tooltipLightLabel: "#333232",
        tooltipHeaderLine: "#9A9A9A",
        backWallColor: "#222222",
        leftWallColor: "#272727",
        tabColor: theme === "MaterialDark" ? "#00B0FF" : theme === "FabricDark" ? "#0074CC" : "#0070F0",
        chartTitleFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.87)" : theme === "FabricDark" ? "#DADADA" : "#FFFFFF",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.6)" : theme === "FabricDark" ? "#A19F9D" : "#676767",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.87)" : theme === "FabricDark" ? "#DADADA" : "#FFFFFF",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.6)" : theme === "FabricDark" ? "#A19F9D" : "#676767",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: theme === "MaterialDark" ? "rgba(18, 18, 18, 1)" : theme === "FabricDark" ? "#DADADA" : "#1A1A1A",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.6)" : theme === "FabricDark" ? "#A19F9D" : "#676767",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        datalabelFont: {
          color: theme === "MaterialDark" ? "#000000" : theme === "FabricDark" ? "#000000" : "#FFFFFF",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.87)" : theme === "FabricDark" ? "#DADADA" : "#FFFFFF",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Bootstrap4":
      style = {
        axisLabel: "#222222",
        axisTitle: "#212529",
        majorGridLine: "#CED4DA",
        minorGridLine: "#DEE2E6",
        majorTickLine: "#ADB5BD",
        minorTickLine: "#CED4DA",
        chartTitle: "#212529",
        legendLabel: "#212529",
        background: "transparent",
        tooltipFill: "#020202",
        tooltipBoldLabel: "rgba(255,255,255)",
        tooltipLightLabel: "rgba(255,255,255, 0.9)",
        tooltipHeaderLine: "rgba(255,255,255, 0.2)",
        tabColor: "#007BFF",
        backWallColor: "#F9F9F9",
        leftWallColor: "#EBEBEB",
        chartTitleFont: {
          color: "#212529",
          fontFamily: "Helvetica",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: "#222222",
          fontFamily: "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#212529",
          fontFamily: "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#666666",
          fontFamily: "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#F9FAFB",
          fontFamily: "Helvetica",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#212529",
          fontFamily: "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        datalabelFont: {
          color: "#222222",
          fontFamily: "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#212529",
          fontFamily: "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Tailwind3":
      style = {
        axisLabel: "#4B5563",
        axisTitle: "#6B7280",
        majorGridLine: "#E5E7EB",
        minorGridLine: "#E5E7EB",
        majorTickLine: "#D1D5DB",
        minorTickLine: "#D1D5DB",
        chartTitle: "#111827",
        legendLabel: "#6B7280",
        background: "transparent",
        tooltipFill: "#111827",
        tooltipBoldLabel: "#F9FAFB",
        tooltipLightLabel: "#F9FAFB",
        tooltipHeaderLine: "#D1D5DB",
        tabColor: "#4F46E5",
        backWallColor: "rgba(209, 213, 219, 0.03)",
        leftWallColor: "#EBEBEB",
        chartTitleFont: {
          color: "#111827",
          fontFamily: "Inter",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: "#4B5563",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#374151",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        legendLabelFont: {
          color: "#6B7280",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        tooltipLabelFont: {
          color: "#F9FAFB",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#6B7280",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        datalabelFont: {
          color: "#111827",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#6B7280",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "500"
        }
      };
      break;
    case "Tailwind3Dark":
      style = {
        axisLabel: "#D1D5DB",
        axisTitle: "#9CA3AF",
        majorGridLine: "#374151",
        minorGridLine: "#374151",
        majorTickLine: "#4B5563",
        minorTickLine: "#4B5563",
        chartTitle: "#FFFFFF",
        legendLabel: "#9CA3AF",
        background: "transparent",
        tooltipFill: "#F9FAFB",
        tooltipBoldLabel: "#1F2937",
        tooltipLightLabel: "#1F2937",
        tooltipHeaderLine: "#374151",
        tabColor: "#22D3EE",
        backWallColor: "rgb(55,65,81, 0.3)",
        leftWallColor: "rgb(255,255,255,0.1)",
        chartTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Inter",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#E5E7EB",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        legendLabelFont: {
          color: "#9CA3AF",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        tooltipLabelFont: {
          color: "#1F2937",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#9CA3AF",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        datalabelFont: {
          color: "#FFFFFF",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#9CA3AF",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "500"
        }
      };
      break;
    case "Tailwind":
      style = {
        axisLabel: "#222222",
        axisTitle: "#374151",
        majorGridLine: "#E5E7EB",
        minorGridLine: "#E5E7EB",
        majorTickLine: "#D1D5DB",
        minorTickLine: "#D1D5DB",
        chartTitle: "#374151",
        legendLabel: "#374151",
        background: "transparent",
        tooltipFill: "#111827",
        tooltipBoldLabel: "#D1D5DB",
        tooltipLightLabel: "#F9FAFB",
        tooltipHeaderLine: "#6B7280",
        tabColor: "#4F46E5",
        backWallColor: "#F9F9F9",
        leftWallColor: "#EBEBEB",
        chartTitleFont: {
          color: "#374151",
          fontFamily: "Inter",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: "#222222",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#374151",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#374151",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#F9FAFB",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#374151",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        datalabelFont: {
          color: "#FFFFFF",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#374151",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "TailwindDark":
      style = {
        axisLabel: "#D1D5DB",
        axisTitle: "#D1D5DB",
        majorGridLine: "#374151",
        minorGridLine: "#374151",
        majorTickLine: "#4B5563",
        minorTickLine: "#4B5563",
        chartTitle: "#D1D5DB",
        legendLabel: "#D1D5DB",
        background: "transparent",
        tooltipFill: "#F9FAFB",
        tooltipBoldLabel: "#6B7280",
        tooltipLightLabel: "#1F2937",
        tooltipHeaderLine: "#9CA3AF",
        tabColor: "#22D3EE",
        backWallColor: "#222222",
        leftWallColor: "#272727",
        chartTitleFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#1F2937",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        datalabelFont: {
          color: "#9CA3AF",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Bootstrap5":
      style = {
        axisLabel: "#212529",
        axisTitle: "#212529",
        majorGridLine: "#DEE2E6",
        minorGridLine: "#DEE2E6",
        majorTickLine: "#DEE2E6",
        minorTickLine: "#DEE2E6",
        chartTitle: "#212529",
        legendLabel: "#212529",
        background: "transparent",
        tooltipFill: "#000000E5",
        tooltipBoldLabel: "#FFFFFF",
        tooltipLightLabel: "#FFFFFF",
        tooltipHeaderLine: "#FFFFFF",
        tabColor: "#0D6EFD",
        backWallColor: "#DEE2E6",
        leftWallColor: "#DEE2E6",
        chartTitleFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#343A40",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "700"
        },
        datalabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "10px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#21252980",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        }
      };
      break;
    case "Bootstrap5Dark":
      style = {
        axisLabel: "#DEE2E6",
        axisTitle: "#DEE2E6",
        majorGridLine: "#495057",
        minorGridLine: "#495057",
        majorTickLine: "#495057",
        minorTickLine: "#495057",
        chartTitle: "#DEE2E6",
        legendLabel: "#DEE2E6",
        background: "transparent",
        tooltipFill: "#FFFFFFE5",
        tooltipBoldLabel: "#212529",
        tooltipLightLabel: "#212529",
        tooltipHeaderLine: "#212529",
        tabColor: "#0D6EFD",
        backWallColor: "#495057",
        leftWallColor: "#495057",
        chartTitleFont: {
          color: "#DEE2E6",
          fontFamily: "Segoe UI",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: "#DEE2E6",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#DEE2E6",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#DEE2E6",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "700"
        },
        datalabelFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "10px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#DEE2E680",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        }
      };
      break;
    case "Fluent":
      style = {
        axisLabel: "#222222",
        axisTitle: "#201F1E",
        majorGridLine: "#DDDDDD",
        minorGridLine: "#DDDDDD",
        majorTickLine: "#DDDDDD",
        minorTickLine: "#DDDDDD",
        chartTitle: "#201F1E",
        legendLabel: "#323130",
        background: "transparent",
        tooltipFill: "#FFFFFF",
        tooltipBoldLabel: "#323130",
        tooltipLightLabel: "#323130",
        tooltipHeaderLine: "#D2D0CE",
        tabColor: "#0078D4",
        backWallColor: "#F9F9F9",
        leftWallColor: "#EBEBEB",
        chartTitleFont: {
          color: "#201F1E",
          fontFamily: "Segoe UI",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: "#222222",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#201F1E",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#49454E",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#323130",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#201F1E",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        datalabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#323129",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "FluentDark":
      style = {
        axisLabel: "#D2D0CE",
        axisTitle: "#D2D0CE",
        majorGridLine: "#414040",
        minorGridLine: "#414040",
        majorTickLine: "#3B3A39",
        minorTickLine: "#3B3A39",
        chartTitle: "#F3F2F1",
        legendLabel: "#D2D0CE",
        background: "transparent",
        tooltipFill: "#252423",
        tooltipBoldLabel: "#F3F2F1",
        tooltipLightLabel: "#F3F2F1",
        tooltipHeaderLine: "#3B3A39",
        tabColor: "#0078D4",
        backWallColor: "#222222",
        leftWallColor: "#272727",
        chartTitleFont: {
          color: "#C8C6C4",
          fontFamily: "Segoe UI",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: "#D2D0CE",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#F3F2F1",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#D2D0CE",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#F3F2F1",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#F3F2F2",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        datalabelFont: {
          color: "#000000",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#F3F2F1",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Fluent2":
      style = {
        axisLabel: "#616161",
        axisTitle: "#242424",
        majorGridLine: "#EDEBE9",
        minorGridLine: "#EDEBE9",
        majorTickLine: "#D2D0CE",
        minorTickLine: "#D2D0CE",
        chartTitle: "#242424",
        legendLabel: "#242424",
        background: "transparent",
        tooltipFill: "#FFFFFF",
        tooltipBoldLabel: "#242424",
        tooltipLightLabel: "#242424",
        tooltipHeaderLine: "#D2D0CE",
        tabColor: "#0078D4",
        backWallColor: "#F9F9F9",
        leftWallColor: "#EBEBEB",
        chartTitleFont: {
          color: "#242424",
          fontFamily: "Segoe UI",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: "#616161",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#242424",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#242424",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#242424",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#242424",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        datalabelFont: {
          color: "#242424",
          fontFamily: "Segoe UI",
          size: "10px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#616161",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        }
      };
      break;
    case "Fluent2Dark":
      style = {
        axisLabel: "#FFFFFF",
        axisTitle: "#FFFFFF",
        majorGridLine: "#3B3A39",
        minorGridLine: "#3B3A39",
        majorTickLine: "#292827",
        minorTickLine: "#292827",
        chartTitle: "#FFFFFF",
        legendLabel: "#FFFFFF",
        background: "transparent",
        tooltipFill: "#292929",
        tooltipBoldLabel: "#FFFFFF",
        tooltipLightLabel: "#FFFFFF",
        tooltipHeaderLine: "#3B3A39",
        tabColor: "#0078D4",
        backWallColor: "#222222",
        leftWallColor: "#272727",
        chartTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#ADADAD",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        datalabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "10px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#ADADAD",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        }
      };
      break;
    case "Fluent2HighContrast":
      style = {
        axisLabel: "#FFFFFF",
        axisTitle: "#FFFFFF",
        majorGridLine: "#292827",
        minorGridLine: "#3B3A39",
        majorTickLine: "#292827",
        minorTickLine: "#3B3A39",
        chartTitle: "#FFFFFF",
        legendLabel: "#FFFFFF",
        background: "transparent",
        tooltipFill: "#000000",
        tooltipBoldLabel: "#FFFFFF",
        tooltipLightLabel: "#FFFFFF",
        tooltipHeaderLine: "#3B3A39",
        tabColor: "#0078D4",
        backWallColor: "#222222",
        leftWallColor: "#272727",
        chartTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        datalabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "10px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        }
      };
      break;
    case "Material3":
      style = {
        axisLabel: "#222222",
        axisTitle: "#1C1B1F",
        majorGridLine: "#DDDDDD",
        minorGridLine: "#DDDDDD",
        majorTickLine: "#DDDDDD",
        minorTickLine: "#DDDDDD",
        chartTitle: "#1C1B1F",
        legendLabel: "#49454E",
        background: "transparent",
        tooltipFill: "#313033",
        tooltipBoldLabel: "#F4EFF4",
        tooltipLightLabel: "#F4EFF4",
        tooltipHeaderLine: "#F4EFF4",
        tabColor: "#49454E",
        backWallColor: "#F9F9F9",
        leftWallColor: "#EBEBEB",
        chartTitleFont: {
          color: "#1C1B1F",
          fontFamily: "Roboto",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: "#222222",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#1C1B1F",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#49454E",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#F4EFF4",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#1C1B1F",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        datalabelFont: {
          color: "#FFFFFF",
          fontFamily: "Roboto",
          size: "10px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#49454E",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Material3Dark":
      style = {
        axisLabel: "#CAC4D0",
        axisTitle: "#CAC4D0",
        majorGridLine: "#444746",
        minorGridLine: "#444746",
        majorTickLine: "#444746",
        minorTickLine: "#444746",
        chartTitle: "#E6E1E5",
        legendLabel: "#CAC4D0",
        background: "transparent",
        tooltipFill: "#E6E1E5",
        tooltipBoldLabel: "#313033",
        tooltipLightLabel: "#313033",
        tooltipHeaderLine: "#313033",
        tabColor: "#CAC4D0",
        backWallColor: "#222222",
        leftWallColor: "#272727",
        chartTitleFont: {
          color: "#E6E1E5",
          fontFamily: "Roboto",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: "#CAC4D0",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: "#E6E1E5",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#CAC4D0",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#313033",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: "#E6E1E5",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        datalabelFont: {
          color: "#000000",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#CAC4D0",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    default:
      style = {
        axisLabel: "#222222",
        axisTitle: "#424242",
        majorGridLine: "#dbdbdb",
        minorGridLine: "#eaeaea",
        majorTickLine: "#b5b5b5",
        minorTickLine: "#d6d6d6",
        chartTitle: "#424242",
        legendLabel: "#353535",
        background: "transparent",
        tooltipFill: "#000816",
        tooltipBoldLabel: "#ffffff",
        tooltipLightLabel: "#dbdbdb",
        tooltipHeaderLine: "#ffffff",
        backWallColor: "#F9F9F9",
        leftWallColor: "#EBEBEB",
        tabColor: theme === "Material" ? "#ff4081" : theme === "Fabric" ? "#0078D6" : "#317AB9",
        chartTitleFont: {
          color: theme === "Material" ? "rgba(0, 0, 0, 1)" : theme === "Fabric" ? "#333333" : "#212529",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Fabric" ? "Segoe UI" : "Helvetica",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        axisLabelFont: {
          color: "#222222",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Fabric" ? "Segoe UI" : "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        legendTitleFont: {
          color: theme === "Material" ? "rgba(0, 0, 0, 1)" : theme === "Fabric" ? "#333333" : "#212529",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Fabric" ? "Segoe UI" : "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: theme === "Material" ? "rgba(97, 97, 97, 1)" : theme === "Fabric" ? "#666666" : "#666666",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Fabric" ? "Segoe UI" : "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: theme === "Material" ? "rgba(249, 250, 251, 1)" : theme === "Fabric" ? "#333333" : "#F9FAFB",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Fabric" ? "Segoe UI" : "Helvetica",
          size: "12px",
          fontStyle: "Normal"
        },
        axisTitleFont: {
          color: theme === "Material" ? "rgba(0, 0, 0, 1)" : theme === "Fabric" ? "#333333" : "#212529",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Fabric" ? "Segoe UI" : "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        datalabelFont: {
          color: "#FFFFFF",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Fabric" ? "Segoe UI" : "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: theme === "Material" ? "rgba(0, 0, 0, 1)" : theme === "Fabric" ? "#333333" : "#212529",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Fabric" ? "Segoe UI" : "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
  }
  return style;
}
function get3DSeriesColor(theme) {
  var palette;
  switch (theme) {
    case "Fabric":
      palette = ["#06DCFF", "#EF36BB", "#ffc000", "#70ad47", "#5b9bd5", "#c1c1c1", "#6f6fe2", "#e269ae", "#9e480e", "#997300"];
      break;
    case "Bootstrap4":
      palette = ["#9B43F4", "#F7523F", "#55a5c2", "#7ddf1e", "#ff6ea6", "#7953ac", "#b99b4f", "#407c92", "#5ea716", "#b91c52"];
      break;
    case "Bootstrap":
      palette = ["#6355C7", "#FFB400", "#55a5c2", "#7ddf1e", "#ff6ea6", "#7953ac", "#b99b4f", "#407c92", "#5ea716", "#b91c52"];
      break;
    case "HighContrastLight":
    case "HighContrast":
      palette = ["#41E4FF", "#FF5B5B", "#DFE6B6", "#C6E773", "#BA98FF", "#FA83C3", "#00C27A", "#43ACEF", "#D681EF", "#D8BC6E"];
      break;
    case "MaterialDark":
      palette = ["#55C75A", "#FFB400", "#C57AFF", "#61EAA9", "#EBBB3E", "#F45C5C", "#8A77FF", "#63C7FF", "#FF84B0", "#F7C928"];
      break;
    case "FabricDark":
      palette = ["#41E4FF", "#FD7400", "#ffc000", "#70ad47", "#5b9bd5", "#c1c1c1", "#6f6fe2", "#e269ae", "#9e480e", "#997300"];
      break;
    case "BootstrapDark":
      palette = ["#BC43F4", "#FFC539", "#55a5c2", "#7ddf1e", "#ff6ea6", "#7953ac", "#b99b4f", "#407c92", "#5ea716", "#b91c52"];
      break;
    case "Tailwind3":
      palette = ["#2F4074", "#03B4B4", "#0D72DE", "#FF5733", "#D63384", "#F39C12", "#EF291F", "#91C822"];
      break;
    case "Tailwind3Dark":
      palette = ["#8029F1", "#1ABC9C", "#0D72DE", "#FF5733", "#D63384", "#F39C12", "#EF291F", "#91C822"];
      break;
    case "Tailwind":
      palette = ["#5C43F4", "#FFB400", "#334155", "#14B8A6", "#8B5CF6", "#0369A1", "#F97316", "#9333EA", "#F59E0B", "#15803D"];
      break;
    case "TailwindDark":
      palette = ["#00C2FF", "#FD7400", "#F87171", "#4ADE80", "#E879F9", "#FCD34D", "#F97316", "#2DD4BF", "#F472B6", "#10B981"];
      break;
    case "Bootstrap5Dark":
    case "Bootstrap5":
      palette = ["#FD7E14", "#6610F2", "#6F42C1", "#D63384", "#DC3545", "#FFC107", "#198754", "#0DCAF0"];
      break;
    case "FluentDark":
      palette = ["#41E4FF", "#FF7E6F", "#EDBB40", "#AF4BCF", "#FF7266", "#1BD565", "#EE993D", "#5887FF", "#EC548D", "#7D39C0"];
      break;
    case "Fluent":
      palette = ["#2196F5", "#FC7400", "#EDBB40", "#AF4BCF", "#FF7266", "#1BD565", "#EE993D", "#5887FF", "#EC548D", "#7D39C0"];
      break;
    case "Fluent2":
      palette = ["#6200EE", "#09AF74", "#0076E5", "#CB3587", "#E7910F", "#0364DE", "#66CD15", "#F3A93C", "#107C10", "#C19C00"];
      break;
    case "Fluent2Dark":
      palette = ["#9BB449", "#2A72D5", "#43B786", "#3F579A", "#584EC6", "#E85F9C", "#6E7A89", "#EA6266", "#0B6A0B", "#C19C00"];
      break;
    case "Fluent2HighContrast":
      palette = ["#9BB449", "#2A72D5", "#43B786", "#3F579A", "#584EC6", "#E85F9C", "#6E7A89", "#EA6266", "#0B6A0B", "#C19C00"];
      break;
    case "Material3":
      palette = ["#6A56FF", "#00DBFF", "#FFB400", "#F7523F", "#963C70", "#FD7400", "#4BE0BC", "#2196F5", "#DE3D8A", "#162F88"];
      break;
    case "Material3Dark":
      palette = ["#00C2FF", "#FFB400", "#FFF500", "#17EA58", "#38FFE7", "#FF9E45", "#B3F32F", "#B93CE4", "#FC5664", "#9B55FF"];
      break;
    default:
      palette = ["#6355C7", "#00AEE0", "#357cd2", "#e56590", "#f8b883", "#70ad47", "#dd8abd", "#7f84e8", "#7bb4eb", "#ea7a57"];
      break;
  }
  return palette;
}

// node_modules/@syncfusion/ej2-charts/src/chart3d/utils/chart3dRender.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var Chart3DRender = (
  /** @class */
  /* @__PURE__ */ function() {
    function Chart3DRender2() {
      this.transform = null;
    }
    return Chart3DRender2;
  }()
);
var chart3DRender = new Chart3DRender();
var Vector3D = (
  /** @class */
  function() {
    function Vector3D2(pointX, vy, vz) {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.epsilon = 1e-5;
      this.x = pointX;
      this.y = vy || 0;
      this.z = vz || 0;
    }
    Vector3D2.prototype.isValid = function(point) {
      return !isNaN(point.x) && !isNaN(point.y) && !isNaN(point.z);
    };
    Vector3D2.prototype.vector3D = function(vx, vy, vz) {
      this.x = vx;
      this.y = vy;
      this.z = vz;
      return {
        x: this.x,
        y: this.y,
        z: this.z
      };
    };
    Vector3D2.prototype.vector3DMinus = function(v1, v2) {
      return this.vector3D(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);
    };
    Vector3D2.prototype.vector3DPlus = function(v1, v2) {
      return this.vector3D(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);
    };
    Vector3D2.prototype.vector3DMultiply = function(v1, v2) {
      var x = v1.y * v2.z - v2.y * v1.z;
      var y = v1.z * v2.x - v2.z * v1.x;
      var z = v1.x * v2.y - v2.x * v1.y;
      return this.vector3D(x, y, z);
    };
    Vector3D2.prototype.vector3DAdd = function(v1, v2) {
      return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
    };
    Vector3D2.prototype.vector3DStarMultiply = function(v1, value) {
      var x = v1.x * value;
      var y = v1.y * value;
      var z = v1.z * value;
      return this.vector3D(x, y, z);
    };
    Vector3D2.prototype.getLength = function(vector3) {
      var sqt = this.vector3DAdd(vector3, vector3);
      return Math.sqrt(sqt);
    };
    Vector3D2.prototype.normalize = function() {
      var length = this.getLength(this);
      this.x /= length;
      this.y /= length;
      this.z /= length;
    };
    Vector3D2.prototype.getNormal = function(v1, v2, v3) {
      var vector4 = this.vector3DMinus(v1, v2);
      var vector5 = this.vector3DMinus(v3, v2);
      var n = this.vector3DMultiply(vector4, vector5);
      var length = this.getLength(n);
      if (length < this.epsilon) {
        return this.vector3D(0, 0, 0);
      }
      return this.vector3D(n.x / length, n.y / length, n.z / length);
    };
    return Vector3D2;
  }()
);
var Matrix3D = (
  /** @class */
  function() {
    function Matrix3D2() {
      this.matrixSize = 4;
    }
    Matrix3D2.prototype.matrix3D = function(size) {
      var matrixData = [];
      for (var i = 0; i < size; i++) {
        matrixData[i] = this.createArray(size);
      }
      return matrixData;
    };
    Matrix3D2.prototype.isAffine = function(matrixData) {
      return matrixData[0][3] === 0 && matrixData[1][3] === 0 && matrixData[2][3] === 0 && matrixData[3][3] === 1;
    };
    Matrix3D2.prototype.createArray = function(initialSize) {
      var matrixData = [];
      for (var index = 0; index < initialSize; ++index) {
        matrixData[index] = 0;
      }
      return matrixData;
    };
    Matrix3D2.prototype.getIdentity = function() {
      var matrixData = this.matrix3D(this.matrixSize);
      for (var i = 0; i < this.matrixSize; i++) {
        matrixData[i][i] = 1;
      }
      return matrixData;
    };
    Matrix3D2.prototype.getInterval = function(matrix) {
      var matrixData = this.getIdentity();
      for (var i = 0; i < this.matrixSize; i++) {
        for (var j = 0; j < this.matrixSize; j++) {
          matrixData[i][j] = this.getMinor(matrix, i, j);
        }
      }
      matrixData = this.transposed(matrixData);
      matrixData = this.getMatrixMultiple(1 / this.getDeterminant(matrix), matrixData);
      return matrixData;
    };
    Matrix3D2.prototype.getMatrixMultiple = function(factor, matrix) {
      for (var i = 0; i < matrix.length; i++) {
        for (var j = 0; j < matrix[i].length; j++) {
          matrix[i][j] = matrix[i][j] * factor;
        }
      }
      return matrix;
    };
    Matrix3D2.prototype.getMatrixVectorMultiple = function(matrix, point) {
      var x = matrix[0][0] * point.x + matrix[1][0] * point.y + matrix[2][0] * point.z + matrix[3][0];
      var y = matrix[0][1] * point.x + matrix[1][1] * point.y + matrix[2][1] * point.z + matrix[3][1];
      var z = matrix[0][2] * point.x + matrix[1][2] * point.y + matrix[2][2] * point.z + matrix[3][2];
      if (!this.isAffine(matrix)) {
        var c = 1 / (matrix[0][3] * point.x + matrix[1][3] * point.y + matrix[2][3] * point.z + matrix[3][3]);
        x *= c;
        y *= c;
        z *= c;
      }
      return {
        x,
        y,
        z
      };
    };
    Matrix3D2.prototype.getMatrixVectorAnd = function(matrix, vector3) {
      var x = matrix[0][0] * vector3.x + matrix[1][0] * vector3.y + matrix[2][0] * vector3.z;
      var y = matrix[0][1] * vector3.x + matrix[1][1] * vector3.y + matrix[2][1] * vector3.z;
      var z = matrix[0][2] * vector3.x + matrix[1][2] * vector3.y + matrix[2][2] * vector3.z;
      return new Vector3D(x, y, z);
    };
    Matrix3D2.prototype.getMatrixMultiplication = function(matrix1, matrix2) {
      var result = this.getIdentity();
      for (var i = 0; i < this.matrixSize; i++) {
        for (var j = 0; j < this.matrixSize; j++) {
          var value = 0;
          for (var k = 0; k < this.matrixSize; k++) {
            value += matrix1[k][j] * matrix2[i][k];
          }
          result[i][j] = value;
        }
      }
      return result;
    };
    Matrix3D2.prototype.getMinor = function(matrix, columnIndex, rowIndex) {
      return ((columnIndex + rowIndex) % 2 === 0 ? 1 : -1) * this.getDeterminant(this.getMatrix(matrix, columnIndex, rowIndex));
    };
    Matrix3D2.prototype.getMatrix = function(matrix, columnIndex, rowIndex) {
      var count = matrix.length - 1;
      var subMatrix = this.createArray(count);
      for (var i = 0; i < count; i++) {
        var matrixColumn = i >= columnIndex ? i + 1 : i;
        subMatrix[i] = this.createArray(count);
        for (var j = 0; j < count; j++) {
          var matrixRow = j >= rowIndex ? j + 1 : j;
          subMatrix[i][j] = matrix[matrixColumn][matrixRow];
        }
      }
      return subMatrix;
    };
    Matrix3D2.prototype.getDeterminant = function(matrix) {
      var count = matrix.length;
      var determinant = 0;
      if (count < 2) {
        determinant = matrix[0][0];
      } else {
        var k = 1;
        for (var i = 0; i < count; i++) {
          var submatrix = this.getMatrix(matrix, i, 0);
          determinant += k * matrix[i][0] * this.getDeterminant(submatrix);
          k = k > 0 ? -1 : 1;
        }
      }
      return determinant;
    };
    Matrix3D2.prototype.transform = function(x, y, z) {
      var transformedMatrix = this.getIdentity();
      transformedMatrix[3][0] = x;
      transformedMatrix[3][1] = y;
      transformedMatrix[3][2] = z;
      return transformedMatrix;
    };
    Matrix3D2.prototype.turn = function(angle) {
      var rotatedMatrix = this.getIdentity();
      rotatedMatrix[0][0] = Math.cos(angle);
      rotatedMatrix[2][0] = -Math.sin(angle);
      rotatedMatrix[0][2] = Math.sin(angle);
      rotatedMatrix[2][2] = Math.cos(angle);
      return rotatedMatrix;
    };
    Matrix3D2.prototype.tilt = function(angle) {
      var rotatedMatrix = this.getIdentity();
      rotatedMatrix[1][1] = Math.cos(angle);
      rotatedMatrix[2][1] = Math.sin(angle);
      rotatedMatrix[1][2] = -Math.sin(angle);
      rotatedMatrix[2][2] = Math.cos(angle);
      return rotatedMatrix;
    };
    Matrix3D2.prototype.transposed = function(matrix3D) {
      var transposedMatrix = this.getIdentity();
      for (var i = 0; i < this.matrixSize; i++) {
        for (var j = 0; j < this.matrixSize; j++) {
          transposedMatrix[i][j] = matrix3D[j][i];
        }
      }
      return transposedMatrix;
    };
    return Matrix3D2;
  }()
);
var ChartTransform3D = (
  /** @class */
  function() {
    function ChartTransform3D2() {
      this.toRadial = Math.PI / 180;
      this.vector = new Vector3D(0, 0, 0);
      this.matrixObj = new Matrix3D();
    }
    ChartTransform3D2.prototype.transform3D = function(size) {
      return {
        viewingArea: size,
        rotation: 0,
        tilt: 0,
        depth: 0,
        perspectiveAngle: 0,
        needUpdate: true,
        centeredMatrix: this.matrixObj.getIdentity(),
        perspective: this.matrixObj.getIdentity(),
        resultMatrix: this.matrixObj.getIdentity(),
        viewMatrix: this.matrixObj.getIdentity()
      };
    };
    ChartTransform3D2.prototype.transform = function(transform) {
      this.setCenter(this.vector.vector3D(transform.viewingArea.width / 2, transform.viewingArea.height / 2, transform.depth / 2), transform);
      this.setViewMatrix(this.matrixObj.transform(0, 0, transform.depth), transform);
      this.setViewMatrix(this.matrixObj.getMatrixMultiplication(transform.viewMatrix, this.matrixObj.turn(-this.toRadial * transform.rotation)), transform);
      this.setViewMatrix(this.matrixObj.getMatrixMultiplication(transform.viewMatrix, this.matrixObj.tilt(-this.toRadial * transform.tilt)), transform);
      this.updatePerspective(transform.perspectiveAngle, transform);
      transform.needUpdate = true;
    };
    ChartTransform3D2.prototype.updatePerspective = function(angle, transform) {
      var width = (transform.viewingArea.width + transform.viewingArea.height) * Math.tan(this.degreeToRadianConverter((180 - Math.abs(angle % 181)) / 2)) + transform.depth * 2 / 2;
      transform.perspective[0][0] = width;
      transform.perspective[1][1] = width;
      transform.perspective[2][3] = 1;
      transform.perspective[3][3] = width;
    };
    ChartTransform3D2.prototype.degreeToRadianConverter = function(angle) {
      return angle * Math.PI / 180;
    };
    ChartTransform3D2.prototype.toScreen = function(vector3D, transform, chartObj) {
      if (!chartObj) {
        transform.chartObj = this.matrixObj;
        vector3D = this.matrixObj.getMatrixVectorMultiple(this.result(transform), vector3D);
      } else {
        this.matrixObj = chartObj;
        vector3D = chartObj.getMatrixVectorMultiple(this.result(transform, chartObj), vector3D);
      }
      return {
        x: vector3D.x,
        y: vector3D.y
      };
    };
    ChartTransform3D2.prototype.setViewMatrix = function(matrix, transform) {
      if (transform.viewMatrix === matrix) {
        return;
      }
      transform.viewMatrix = matrix;
      transform.needUpdate = true;
    };
    ChartTransform3D2.prototype.result = function(transform, matrixobj) {
      var chartObj = transform.chartObj ? transform.chartObj : this.matrixObj;
      if (!chartObj) {
        chartObj = matrixobj;
      }
      if (!transform.needUpdate) {
        return transform.resultMatrix;
      }
      var matrixObj3 = this.matrixObj ? this.matrixObj : matrixobj;
      transform.resultMatrix = chartObj.getMatrixMultiplication(matrixObj3.getInterval(transform.centeredMatrix), transform.perspective);
      transform.resultMatrix = chartObj.getMatrixMultiplication(transform.resultMatrix, transform.viewMatrix);
      transform.resultMatrix = chartObj.getMatrixMultiplication(transform.resultMatrix, transform.centeredMatrix);
      transform.needUpdate = false;
      return transform.resultMatrix;
    };
    ChartTransform3D2.prototype.setCenter = function(center, transform) {
      transform.centeredMatrix = this.matrixObj.transform(-center.x, -center.y, -center.z);
      transform.needUpdate = true;
    };
    return ChartTransform3D2;
  }()
);
var Graphics3D = (
  /** @class */
  function() {
    function Graphics3D2() {
      this.vector = new Vector3D(0, 0, 0);
    }
    Graphics3D2.prototype.addVisual = function(polygon, chart) {
      if (polygon == null || polygonObj.test()) {
        return -1;
      }
      return bspTreeObj.add(polygon, chart);
    };
    Graphics3D2.prototype.prepareView = function(perspectiveAngle, depth, rotation, tilt, size, chart) {
      if (chart3DRender.transform == null) {
        chart3DRender.transform = chart.transform3D.transform3D(size);
      } else {
        chart3DRender.transform.viewingArea = size;
      }
      if (!chart3DRender.tree) {
        chart3DRender.tree = [];
      }
      chart3DRender.transform.rotation = rotation;
      chart3DRender.transform.tilt = tilt;
      chart3DRender.transform.depth = depth;
      chart3DRender.transform.perspectiveAngle = perspectiveAngle;
      chart.transform3D.transform(chart3DRender.transform);
      chart3DRender.tree[chart.chart3D.id] = bspTreeObj.build();
    };
    Graphics3D2.prototype.view = function(panel, chart, rotation, tilt, size, perspectiveAngle, depth) {
      var MaxValue = 32767;
      if (arguments.length === 2) {
        if (panel == null) {
          return;
        }
        var eyeVector = this.vector.vector3D(0, 0, MaxValue);
        this.drawNode3D(chart3DRender.tree[chart.chart3D.id], eyeVector, panel, chart);
      } else {
        if (panel == null) {
          return;
        }
        if (chart3DRender.transform == null) {
          chart3DRender.transform = chart.transform3D.transform3D(size);
        } else {
          chart3DRender.transform.viewingArea = size;
        }
        chart3DRender.transform.rotation = rotation;
        chart3DRender.transform.tilt = tilt;
        chart3DRender.transform.depth = depth;
        chart3DRender.transform.perspectiveAngle = perspectiveAngle;
        chart.transform3D.transform(chart3DRender.transform);
        var eye = this.vector.vector3D(0, 0, MaxValue);
        this.drawNode3D(chart3DRender.tree[chart.chart3D.id], eye, panel, chart);
      }
    };
    Graphics3D2.prototype.draw3DElement = function(bspElement, chart) {
      if (bspElement.plane.element) {
        if (bspElement.plane.element.tag === "text" || bspElement.plane.element.tag === "dataLabel") {
          polygonObj.drawText(bspElement.plane, chart);
        } else if (bspElement.plane.element.tag === "template") {
          polygonObj.drawTemplate(bspElement.plane, chart);
        } else {
          polygonObj.drawLine(bspElement.plane, chart);
        }
      } else {
        polygonObj.draw(bspElement.plane, chart);
      }
    };
    Graphics3D2.prototype.drawNode3D = function(bspElement, eyeVector, panel, chart) {
      if (bspElement === null || chart3DRender.transform == null) {
        return;
      }
      var isVector = true;
      while (isVector) {
        var r = vector.vector3DAdd(polygonObj.getNormal(chart.transform3D.result(chart3DRender.transform), bspElement.plane.vectorPoints), eyeVector);
        if (r > bspElement.plane.d) {
          if (bspElement.front != null) {
            this.drawNode3D(bspElement.front, eyeVector, panel, chart);
          }
          this.draw3DElement(bspElement, chart);
          if (bspElement.back != null) {
            bspElement = bspElement.back;
            continue;
          }
        } else {
          if (bspElement.back != null) {
            this.drawNode3D(bspElement.back, eyeVector, panel, chart);
          }
          this.draw3DElement(bspElement, chart);
          if (bspElement.front != null) {
            bspElement = bspElement.front;
            continue;
          }
        }
        break;
      }
    };
    return Graphics3D2;
  }()
);
var BinaryTreeBuilder = (
  /** @class */
  function() {
    function BinaryTreeBuilder2(chart) {
      this.epsilon = 5e-4;
      this.chart = chart;
    }
    BinaryTreeBuilder2.prototype.add = function(polygon, chart) {
      this.chart = chart;
      chart.polygons.push(polygon);
      return chart.polygons.length - 1;
    };
    BinaryTreeBuilder2.prototype.getNext = function(index, count) {
      if (index >= count) {
        return index - count;
      }
      if (index < 0) {
        return index + count;
      }
      return index;
    };
    BinaryTreeBuilder2.prototype.vector3DIndexClassification = function(point, index, result) {
      return {
        index,
        result,
        vector: point,
        isCuttingBackPoint: false,
        cuttingBackPairIndex: null,
        alreadyCutBack: false,
        isCuttingFrontPoint: false,
        cuttingFrontPairIndex: null,
        alreadyCutFront: false
      };
    };
    BinaryTreeBuilder2.prototype.classifyPoint = function(point, polygon) {
      var result = "OnPlane";
      var signedDistance = -polygon.d - vector.vector3DAdd(point, polygon.normal);
      if (signedDistance > this.epsilon) {
        result = "OnBack";
      } else if (signedDistance < -this.epsilon) {
        result = "OnFront";
      }
      return result;
    };
    BinaryTreeBuilder2.prototype.classifyPolygon = function(refPolygon, classPolygon) {
      var result = "Unknown";
      var points = classPolygon.points;
      if (points == null) {
        return result;
      }
      var onBack = 0;
      var onFront = 0;
      var onPlane = 0;
      var normal = refPolygon.normal;
      var polygonValue = refPolygon.d;
      for (var i = 0, len = points.length; i < len; i++) {
        var value = -polygonValue - vector.vector3DAdd(points[i], normal);
        if (value > this.epsilon) {
          onBack++;
        } else if (value < -this.epsilon) {
          onFront++;
        } else {
          onPlane++;
        }
        if (onBack > 0 && onFront > 0) {
          break;
        }
      }
      if (onPlane === points.length) {
        result = "OnPlane";
      } else if (onFront + onPlane === points.length) {
        result = "ToRight";
      } else if (onBack + onPlane === points.length) {
        result = "ToLeft";
      } else {
        result = "Unknown";
      }
      return result;
    };
    BinaryTreeBuilder2.prototype.splitPolygon = function(splitPolygon, refPolygon) {
      var backPoint = [];
      var frontPoint = [];
      if (splitPolygon.points != null) {
        var polyPoints = [];
        var backPartPoints = [];
        var frontPartPoints = [];
        var outputs = void 0;
        var inputs = void 0;
        var count = splitPolygon.points.length;
        for (var i = 0; i < count; i++) {
          var pointB = splitPolygon.points[i];
          var pointC = splitPolygon.points[this.getNext(i + 1, count)];
          var sideB = this.classifyPoint(pointB, refPolygon);
          var sideC = this.classifyPoint(pointC, refPolygon);
          var attributeB = this.vector3DIndexClassification(pointB, polyPoints.length, sideB);
          polyPoints.push(attributeB);
          if (sideB !== sideC && sideB !== "OnPlane" && sideC !== "OnPlane") {
            var vectorValue = vector.vector3DMinus(pointB, pointC);
            var direction = vector.vector3DMinus(vector.vector3DStarMultiply(refPolygon.normal, -refPolygon.d), pointC);
            var signedDistance = vector.vector3DAdd(direction, refPolygon.normal);
            var intersectionParameter = signedDistance / vector.vector3DAdd(refPolygon.normal, vectorValue);
            var intersectionPoint = vector.vector3DPlus(pointC, vector.vector3DStarMultiply(vectorValue, intersectionParameter));
            var attributeIntersection = this.vector3DIndexClassification(intersectionPoint, polyPoints.length, "OnPlane");
            polyPoints.push(attributeIntersection);
            backPartPoints.push(attributeIntersection);
            frontPartPoints.push(attributeIntersection);
          } else if (sideB === "OnPlane") {
            var pointA = splitPolygon.points[this.getNext(i - 1, count)];
            var sideA = this.classifyPoint(pointA, refPolygon);
            if (sideA === sideC) {
              continue;
            }
            if (sideA !== "OnPlane" && sideC !== "OnPlane") {
              backPartPoints.push(attributeB);
              frontPartPoints.push(attributeB);
            } else if (sideA === "OnPlane") {
              switch (sideC) {
                case "OnBack":
                  backPartPoints.push(attributeB);
                  break;
                case "OnFront":
                  frontPartPoints.push(attributeB);
                  break;
              }
            } else if (sideC === "OnPlane") {
              switch (sideA) {
                case "OnBack":
                  backPartPoints.push(attributeB);
                  break;
                case "OnFront":
                  frontPartPoints.push(attributeB);
                  break;
              }
            }
          }
        }
        if (frontPartPoints.length !== 0 || backPartPoints.length !== 0) {
          for (var i = 0; i < backPartPoints.length - 1; i += 2) {
            var backAttribute1 = backPartPoints[i];
            var backAttribute2 = backPartPoints[i + 1];
            backAttribute1.cuttingBackPoint = true;
            backAttribute2.cuttingBackPoint = true;
            backAttribute1.alterCuttingBackPairIndex = backAttribute2.index;
            backAttribute2.alterCuttingBackPairIndex = backAttribute1.index;
          }
          for (var i = 0; i < frontPartPoints.length - 1; i += 2) {
            var frontAttribute1 = frontPartPoints[i];
            var frontAttribute2 = frontPartPoints[i + 1];
            frontAttribute1.cuttingFrontPoint = true;
            frontAttribute2.cuttingFrontPoint = true;
            frontAttribute1.alterCuttingFrontPairIndex = frontAttribute2.index;
            frontAttribute2.alterCuttingFrontPairIndex = frontAttribute1.index;
          }
          for (var i = 0; i < backPartPoints.length - 1; i++) {
            var backAttribute1 = backPartPoints[i];
            if (backAttribute1.alreadyCutBack) {
              continue;
            }
            outputs = this.cutOutBackPolygon(polyPoints, backAttribute1);
            if (outputs.length > 2) {
              var polygon1 = polygonObj.polygon3D(outputs, splitPolygon);
              backPoint.push(__assign({}, polygon1));
            }
          }
          for (var i = 0; i < frontPartPoints.length - 1; i++) {
            var backAttribute2 = frontPartPoints[i];
            if (backAttribute2.alreadyCutFront) {
              continue;
            }
            inputs = this.cutOutFrontPolygon(polyPoints, backAttribute2);
            if (inputs.length > 2) {
              var polygon2 = polygonObj.polygon3D(inputs, splitPolygon);
              frontPoint.push(__assign({}, polygon2));
            }
          }
        }
      } else {
        backPoint.push(splitPolygon);
        frontPoint.push(splitPolygon);
      }
      return {
        backPolygon: backPoint,
        frontPolygon: frontPoint
      };
    };
    BinaryTreeBuilder2.prototype.cutOutFrontPolygon = function(polyPoints, initialVertex) {
      var points = [];
      var currentVertex = initialVertex;
      var isVector = true;
      while (isVector) {
        currentVertex.alreadyCutFront = true;
        points.push(currentVertex.vector);
        var currentVertexPair = polyPoints[currentVertex.alterCuttingFrontPairIndex];
        if (currentVertex.cuttingFrontPoint) {
          if (!currentVertexPair.alreadyCutFront) {
            currentVertex = currentVertexPair;
          } else {
            var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];
            var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];
            if (previousVertexOnBack.result === "OnFront" && !previousVertexOnBack.alreadyCutFront) {
              currentVertex = previousVertexOnBack;
            } else if (nextVertexOnBack.result === "OnFront" && !nextVertexOnBack.alreadyCutFront) {
              currentVertex = nextVertexOnBack;
            } else {
              return points;
            }
          }
        } else {
          var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];
          var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];
          if (previousVertexOnBack.result !== "OnBack" && !previousVertexOnBack.alreadyCutFront) {
            currentVertex = previousVertexOnBack;
          } else if (nextVertexOnBack.result !== "OnBack" && !nextVertexOnBack.alreadyCutFront) {
            currentVertex = nextVertexOnBack;
          } else {
            return points;
          }
        }
      }
      return null;
    };
    BinaryTreeBuilder2.prototype.cutOutBackPolygon = function(polyPoints, initialVertex) {
      var points = [];
      var currentVertex = initialVertex;
      var isVector = true;
      while (isVector) {
        currentVertex.alreadyCutBack = true;
        points.push(currentVertex.vector);
        var currentVertexPair = polyPoints[currentVertex.alterCuttingBackPairIndex];
        if (currentVertex.cuttingBackPoint) {
          if (!currentVertexPair.alreadyCutBack) {
            currentVertex = currentVertexPair;
          } else {
            var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];
            var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];
            if (previousVertexOnBack.result === "OnBack" && !previousVertexOnBack.alreadyCutBack) {
              currentVertex = previousVertexOnBack;
            } else if (nextVertexOnBack.result === "OnBack" && !nextVertexOnBack.alreadyCutBack) {
              currentVertex = nextVertexOnBack;
            } else {
              return points;
            }
          }
        } else {
          var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];
          var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];
          if (previousVertexOnBack.result !== "OnFront" && !previousVertexOnBack.alreadyCutBack) {
            currentVertex = previousVertexOnBack;
          } else if (nextVertexOnBack.result !== "OnFront" && !nextVertexOnBack.alreadyCutBack) {
            currentVertex = nextVertexOnBack;
          } else {
            return points;
          }
        }
      }
      return null;
    };
    BinaryTreeBuilder2.prototype.build = function(points) {
      if (!points) {
        return this.build(this.chart.polygons);
      } else {
        var inputPolygons = points;
        if (inputPolygons.length < 1) {
          return null;
        }
        var bspNode = {
          back: null,
          front: null,
          plane: null
        };
        var plane = inputPolygons[0];
        bspNode.plane = plane;
        var polygonsToLeft = [];
        var polygonsToRight = [];
        for (var i = 1, len = inputPolygons.length; i < len; i++) {
          var currentPolygon = inputPolygons[i];
          if (currentPolygon === plane) {
            continue;
          }
          var classificationResult = this.classifyPolygon(plane, currentPolygon);
          switch (classificationResult) {
            case "OnPlane":
            case "ToRight":
              polygonsToRight.push(currentPolygon);
              break;
            case "ToLeft":
              polygonsToLeft.push(currentPolygon);
              break;
            case "Unknown":
              if (currentPolygon.element && (currentPolygon.element.tag === "line" || currentPolygon.element.tag === "text")) {
                polygonsToLeft.push(currentPolygon);
              } else {
                var result = this.splitPolygon(currentPolygon, plane);
                for (var k = 0; k < result.backPolygon.length; k++) {
                  result.backPolygon[k].name = result.backPolygon[k].name + "-back";
                  polygonsToLeft.push(result.backPolygon[k]);
                }
                for (var j = 0; j < result.frontPolygon.length; j++) {
                  result.frontPolygon[j].name = result.frontPolygon[j].name + "-front";
                  polygonsToRight.push(result.frontPolygon[j]);
                }
              }
              break;
          }
        }
        if (polygonsToLeft.length > 0) {
          bspNode.back = this.build(polygonsToLeft);
        }
        if (polygonsToRight.length > 0) {
          bspNode.front = this.build(polygonsToRight);
        }
        return bspNode;
      }
    };
    return BinaryTreeBuilder2;
  }()
);
var Svg3DRenderer = (
  /** @class */
  function() {
    function Svg3DRenderer2() {
    }
    Svg3DRenderer2.prototype.getStringBuilder = function() {
      var data = [];
      var counter = 0;
      return {
        append: function(text) {
          data[counter++] = text;
          return this;
        },
        remove: function(i, j) {
          data.splice(i, j || 1);
          return this;
        },
        insert: function(i, text) {
          data.splice(i, 0, text);
          return this;
        },
        toString: function(text) {
          return data.join(text || "");
        }
      };
    };
    Svg3DRenderer2.prototype.hexToValue = function(hexColorCode) {
      var result;
      var values;
      if (hexColorCode.indexOf("rgba(") === 0) {
        values = hexColorCode.slice(5, -1).split(",");
        return values ? {
          red: parseInt(values[0], 10),
          green: parseInt(values[1], 10),
          blue: parseInt(values[2], 10),
          alpha: parseFloat(values[3])
        } : null;
      } else if (hexColorCode.indexOf("rgb(") === 0) {
        values = hexColorCode.slice(4, -1).split(",");
        return values ? {
          red: parseInt(values[0], 10),
          green: parseInt(values[1], 10),
          blue: parseInt(values[2], 10)
        } : null;
      } else {
        result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hexColorCode);
        return result ? {
          red: parseInt(result[1], 16),
          green: parseInt(result[2], 16),
          blue: parseInt(result[3], 16)
        } : null;
      }
    };
    Svg3DRenderer2.prototype.hexColor = function(color) {
      var redValue = color.red;
      var greenValue = color.green;
      var blueValue = color.blue;
      if (color.alpha) {
        var returnColor = "rgba(" + redValue.toString() + "," + greenValue.toString() + "," + blueValue.toString() + "," + color.alpha + ")";
        return returnColor;
      } else {
        var hex_1 = [redValue.toString(16), greenValue.toString(16), blueValue.toString(16)];
        hex_1.forEach(function(val, nr) {
          if (val.length === 1) {
            hex_1[nr] = "0" + val;
          }
        });
        return "#" + hex_1.join("").toUpperCase();
      }
    };
    Svg3DRenderer2.prototype.checkColorFormat = function(color) {
      if (color.indexOf("rgba(") === 0 || color.indexOf("rgb(") === 0) {
        var rgbaValues = color.substring(color.indexOf("(") + 1, color.lastIndexOf(")")).split(",");
        if (rgbaValues.length === 3 || rgbaValues.length === 4) {
          return rgbaValues.every(function(val) {
            var num = parseFloat(val);
            return !isNaN(num) && num >= 0 && num <= 255;
          });
        }
      } else if (color.indexOf("#") === 0) {
        var hex = color.substring(1);
        return (hex.length === 3 || hex.length === 6) && /^[0-9A-Fa-f]{3,6}$/.test(hex);
      }
      return false;
    };
    Svg3DRenderer2.prototype.drawText = function(options, label, font, chart) {
      var text = document.getElementById(options.id);
      if (text === null) {
        text = document.createElementNS("http://www.w3.org/2000/svg", "text");
      }
      if (label.length > 1 && typeof label !== "string") {
        var dy = 0;
        for (var i = 0; i < label.length; i++) {
          var tspanElement = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
          tspanElement.textContent = label[i];
          tspanElement.setAttribute("x", String(options.x));
          tspanElement.setAttribute("dy", String(dy));
          text.appendChild(tspanElement);
          dy = measureText(label[i], font, chart.themeStyle.axisLabelFont).height;
        }
      } else {
        text.textContent = label;
      }
      text = chart.svgRenderer.setElementAttributes(options, text);
      return text;
    };
    Svg3DRenderer2.prototype.transform3DToVisible = function(currentSeries, x, y, chart) {
      if (currentSeries.xAxis != null && currentSeries.yAxis != null) {
        var valueType = currentSeries.xAxis.valueType;
        var xlogarithmicBase = 10;
        var xIsLogarithmic = valueType === "Logarithmic";
        if (xIsLogarithmic && x > 0) {
          x = Math.log(x) / Math.log(xlogarithmicBase);
        }
        var ylogarithmicBase = currentSeries.yAxis.logBase;
        var yIsLogarithmic = currentSeries.yAxis.valueType === "Logarithmic";
        if (yIsLogarithmic && y > 0) {
          y = Math.log(y) / Math.log(ylogarithmicBase);
        }
        if (chart.requireInvertedAxis) {
          var left = chart.chartAxisLayoutPanel.seriesClipRect.x;
          var top_1 = chart.chartAxisLayoutPanel.seriesClipRect.y;
          var pointX = left + currentSeries.yAxis.rect.width * valueToCoefficients(y, currentSeries.yAxis);
          var pointY = top_1 + currentSeries.xAxis.rect.height * (1 - valueToCoefficients(x, currentSeries.xAxis));
          return {
            x: pointX,
            y: pointY
          };
        } else {
          var left = currentSeries.xAxis.rect.x;
          var top_2 = currentSeries.yAxis.rect.y;
          var newX = left + Math.round(currentSeries.xAxis.rect.width * valueToCoefficients(x, currentSeries.xAxis));
          var newY = top_2 + Math.round(currentSeries.yAxis.rect.height * (1 - valueToCoefficients(y, currentSeries.yAxis)));
          return {
            x: newX,
            y: newY
          };
        }
      }
      return {
        x: 0,
        y: 0
      };
    };
    return Svg3DRenderer2;
  }()
);
var Polygon3D = (
  /** @class */
  function() {
    function Polygon3D2() {
      this.epsilon = 1e-5;
      this.normal = {
        x: 0,
        y: 0,
        z: 0
      };
      this.vector = new Vector3D(0, 0, 0);
      this.vectorPoints = [];
      this.matrixObj = new Matrix3D();
      this.tabIndex = true;
    }
    Polygon3D2.prototype.polygon3D = function(points, tag, index, stroke, strokeThickness, opacity, fill, name, parent, text) {
      if (arguments.length === 3) {
        this.calculateNormal(points, tag, index);
        return null;
      } else if (arguments.length === 2) {
        this.calculateNormal(points[0], points[1], points[2]);
        this.vectorPoints = points;
        this.calculateNormal(this.vectorPoints);
        var polygon = tag;
        polygon.normal = this.normal;
        polygon.points = points;
        polygon.vectorPoints = this.vectorPoints;
        polygon.isSplit = true;
        polygon.d = this.d;
        return polygon;
      } else {
        this.calculateNormal(points[0], points[1], points[2]);
        this.vectorPoints = points;
        this.calculateNormal(this.vectorPoints);
        var element = {
          tag: "path",
          parent
        };
        var polygon = {
          normal: this.normal,
          points,
          vectorPoints: this.vectorPoints,
          index,
          tag,
          name: name ? name : null,
          strokeThickness,
          opacity,
          fill,
          d: this.d,
          text: text ? text : "",
          polygonElement: element
        };
        if (arguments.length !== 1) {
          polygon.polygonElement = element;
        }
        return polygon;
      }
    };
    Polygon3D2.prototype.createLine = function(line, x1, y1, x2, y2, depth) {
      var strokeThickness = line.width;
      var vectorCollection = [];
      vectorCollection[0] = this.vector.vector3D(x1, y1, depth);
      vectorCollection[1] = this.vector.vector3D(x1 + strokeThickness, y2 + strokeThickness, depth);
      vectorCollection[2] = this.vector.vector3D(x2, y2, depth);
      return this.line3D(line, vectorCollection);
    };
    Polygon3D2.prototype.line3D = function(element, points) {
      var plane = this.polygon3D(points);
      plane.element = element;
      return plane;
    };
    Polygon3D2.prototype.text3D = function(element, points) {
      var plane = this.polygon3D(points);
      plane.element = element;
      return plane;
    };
    Polygon3D2.prototype.createCylinder = function(v1, v2, chart, index, type, stroke, fill, strokeThickness, opacity, name, parent) {
      var i = 0;
      var offsetX;
      var offsetY;
      var offsetZ;
      var vectorCollection;
      var pathCount = 24;
      var theta = 360 / pathCount;
      var degreeToRadian2 = Math.PI / 180;
      var centerZ = (v1.z + v2.z) / 2;
      var result = [];
      var outPoints = [];
      var topVector = [];
      var bottomVector = [];
      var radiusB = v2.y - v1.y < v2.z - v1.z ? (v2.y - v1.y) / 2 : (v2.z - v1.z) / 2;
      var radiusC = v2.x - v1.x < v2.z - v1.z ? (v2.x - v1.x) / 2 : (v2.z - v1.z) / 2;
      var centerX = (v1.x + v2.x) / 2;
      var centerY = (v1.y + v2.y) / 2;
      switch (type) {
        case "Bar":
        case "StackingBar":
        case "StackingBar100":
          pathCount++;
          while (pathCount--) {
            offsetY = centerY + radiusB * Math.cos(i * theta * degreeToRadian2);
            offsetZ = centerZ + radiusB * Math.sin(i * theta * degreeToRadian2);
            outPoints[i] = {
              Y: offsetY,
              Z: offsetZ
            };
            topVector.push(this.vector.vector3D(v1.x, outPoints[i].Y, outPoints[i].Z));
            bottomVector.push(this.vector.vector3D(v2.x, outPoints[i].Y, outPoints[i].Z));
            if (i > 0) {
              vectorCollection = [this.vector.vector3D(v1.x, outPoints[i - 1].Y, outPoints[i - 1].Z), this.vector.vector3D(v2.x, outPoints[i - 1].Y, outPoints[i - 1].Z), this.vector.vector3D(v2.x, outPoints[i].Y, outPoints[i].Z), this.vector.vector3D(v1.x, outPoints[i].Y, outPoints[i].Z)];
              result[i + 1] = this.polygon3D(vectorCollection, chart, index, fill, 0, opacity, fill, "-" + (i + 1).toString() + "-" + name, parent);
              graphics.addVisual(result[i + 1], chart);
            }
            i++;
          }
          break;
        case "Column":
        case "StackingColumn":
        case "StackingColumn100":
          pathCount++;
          while (pathCount--) {
            offsetX = centerX + radiusC * Math.cos(i * theta * degreeToRadian2);
            offsetZ = centerZ + radiusC * Math.sin(i * theta * degreeToRadian2);
            outPoints[i] = {
              Y: offsetX,
              Z: offsetZ
            };
            topVector.push(this.vector.vector3D(outPoints[i].Y, v1.y, outPoints[i].Z));
            bottomVector.push(this.vector.vector3D(outPoints[i].Y, v2.y, outPoints[i].Z));
            if (i > 0) {
              vectorCollection = [this.vector.vector3D(outPoints[i - 1].Y, v1.y, outPoints[i - 1].Z), this.vector.vector3D(outPoints[i - 1].Y, v2.y, outPoints[i - 1].Z), this.vector.vector3D(outPoints[i].Y, v2.y, outPoints[i].Z), this.vector.vector3D(outPoints[i].Y, v1.y, outPoints[i].Z)];
              result[i + 1] = this.polygon3D(vectorCollection, chart, index, fill, 0, opacity, fill, "-" + (i + 1).toString() + "-" + name, parent);
              graphics.addVisual(result[i + 1], chart);
            }
            i++;
          }
          break;
      }
      result[0] = this.polygon3D(bottomVector, chart, index, stroke, 0, opacity, fill, "-0-" + name, parent);
      result[1] = this.polygon3D(topVector, chart, index, stroke, strokeThickness, opacity, fill, "-1-" + name, parent);
      graphics.addVisual(result[0], chart);
      graphics.addVisual(result[1], chart);
      return result;
    };
    Polygon3D2.prototype.createBox = function(v1, v2, chart, index, stroke, fill, strokeThickness, opacity, inverse, name, parent, text) {
      var result = [];
      var point1 = [this.vector.vector3D(v1.x, v1.y, v1.z), this.vector.vector3D(v2.x, v1.y, v1.z), this.vector.vector3D(v2.x, v2.y, v1.z), this.vector.vector3D(v1.x, v2.y, v1.z)];
      var point2 = [this.vector.vector3D(v1.x, v1.y, v2.z), this.vector.vector3D(v2.x, v1.y, v2.z), this.vector.vector3D(v2.x, v2.y, v2.z), this.vector.vector3D(v1.x, v2.y, v2.z)];
      var point3 = [this.vector.vector3D(v1.x, v1.y, v2.z), this.vector.vector3D(v2.x, v1.y, v2.z), this.vector.vector3D(v2.x, v1.y, v1.z), this.vector.vector3D(v1.x, v1.y, v1.z)];
      var point4 = [this.vector.vector3D(v1.x, v2.y, v2.z), this.vector.vector3D(v2.x, v2.y, v2.z), this.vector.vector3D(v2.x, v2.y, v1.z), this.vector.vector3D(v1.x, v2.y, v1.z)];
      var point5 = [this.vector.vector3D(v1.x, v1.y, v1.z), this.vector.vector3D(v1.x, v1.y, v2.z), this.vector.vector3D(v1.x, v2.y, v2.z), this.vector.vector3D(v1.x, v2.y, v1.z)];
      var point6 = [this.vector.vector3D(v2.x, v1.y, v1.z), this.vector.vector3D(v2.x, v1.y, v2.z), this.vector.vector3D(v2.x, v2.y, v2.z), this.vector.vector3D(v2.x, v2.y, v1.z)];
      if (name) {
        result[0] = this.polygon3D(point1, chart, index, stroke, strokeThickness, opacity, fill, "-0-" + name, parent, text);
        result[1] = this.polygon3D(point2, chart, index, stroke, strokeThickness, opacity, fill, "-1-" + name, parent, text);
        result[2] = this.polygon3D(point3, chart, index, stroke, strokeThickness, opacity, fill, "-2-" + name, parent, text);
        result[3] = this.polygon3D(point4, chart, index, stroke, strokeThickness, opacity, fill, "-3-" + name, parent, text);
        result[4] = this.polygon3D(point5, chart, index, stroke, strokeThickness, opacity, fill, "-4-" + name, parent, text);
        result[5] = this.polygon3D(point6, chart, index, stroke, strokeThickness, opacity, fill, "-5-" + name, parent, text);
      } else {
        result[0] = this.polygon3D(point1, chart, index, stroke, strokeThickness, opacity, fill, "-0-" + index, parent, text);
        result[1] = this.polygon3D(point2, chart, index, stroke, strokeThickness, opacity, fill, "-1-" + index, parent, text);
        result[2] = this.polygon3D(point3, chart, index, stroke, strokeThickness, opacity, fill, "-2-" + index, parent, text);
        result[3] = this.polygon3D(point4, chart, index, stroke, strokeThickness, opacity, fill, "-3-" + index, parent, text);
        result[4] = this.polygon3D(point5, chart, index, stroke, strokeThickness, opacity, fill, "-4-" + index, parent, text);
        result[5] = this.polygon3D(point6, chart, index, stroke, strokeThickness, opacity, fill, "-5-" + index, parent, text);
      }
      if (inverse) {
        graphics.addVisual(result[0], chart);
        graphics.addVisual(result[1], chart);
        graphics.addVisual(result[2], chart);
        graphics.addVisual(result[3], chart);
        graphics.addVisual(result[4], chart);
        graphics.addVisual(result[5], chart);
      } else {
        graphics.addVisual(result[5], chart);
        graphics.addVisual(result[4], chart);
        graphics.addVisual(result[0], chart);
        graphics.addVisual(result[1], chart);
        graphics.addVisual(result[2], chart);
        graphics.addVisual(result[3], chart);
      }
      return result;
    };
    Polygon3D2.prototype.calculateNormal = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (args.length >= 3) {
        var vector1 = args[0];
        var vector22 = args[1];
        var vector3 = args[2];
        var vector4 = this.vector.vector3DMinus(vector1, vector22);
        var vector5 = this.vector.vector3DMinus(vector3, vector22);
        var normal = this.vector.vector3DMultiply(vector4, vector5);
        var length_1 = this.vector.getLength(normal);
        if (length_1 < this.epsilon) {
          length_1 = 1;
        }
        this.normal = this.vector.vector3D(normal.x / length_1, normal.y / length_1, normal.z / length_1);
        this.d = -(this.normal.x * vector1.x + this.normal.y * vector1.y + this.normal.z * vector1.z);
        if (args[3]) {
          args[3].normal = this.normal;
          args[3].d = this.d;
        }
      } else {
        var Points2 = args[0];
        this.calculateNormal(Points2[0], Points2[1], Points2[2], args[1]);
        for (var i = 3; i < Points2.length && this.test(); i++) {
          this.calculateNormal(Points2[i], Points2[0], Points2[i / 2]);
        }
      }
    };
    Polygon3D2.prototype.test = function() {
      return !this.vector.isValid(this.normal);
    };
    Polygon3D2.prototype.transform = function(matrix, polygon) {
      if (polygon.points != null) {
        for (var i = 0; i < polygon.points.length; i++) {
          polygon.vectorPoints[i] = polygon.points[i] = matrixObj.getMatrixVectorMultiple(matrix, polygon.points[i]);
        }
        this.calculateNormal(polygon.vectorPoints, polygon);
      }
    };
    Polygon3D2.prototype.getNormal = function(transform, vectorPoints) {
      var normal;
      if (vectorPoints != null) {
        normal = this.vector.getNormal(this.matrixObj.getMatrixVectorMultiple(transform, vectorPoints[0]), matrixObj.getMatrixVectorMultiple(transform, vectorPoints[1]), this.matrixObj.getMatrixVectorMultiple(transform, vectorPoints[2]));
        for (var i = 3; i < vectorPoints.length && !this.vector.isValid(normal) && vectorPoints[i / 2]; i++) {
          var v1 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[i]);
          var v2 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[0]);
          var v3 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[i / 2]);
          normal = this.vector.getNormal(v1, v2, v3);
        }
      } else {
        normal = matrixObj.getMatrixVectorAnd(transform);
        this.vector.normalize();
      }
      return normal;
    };
    Polygon3D2.prototype.createTextElement = function(position, element, xLength, yLength) {
      var vectorCollection = [];
      var x = position.x;
      var y = position.y;
      var desiredWidth = element.width;
      var desiredHeight = element.height;
      vectorCollection[0] = this.vector.vector3D(x, y, position.z);
      vectorCollection[1] = this.vector.vector3D(x + desiredWidth, y + desiredHeight + yLength, position.z);
      vectorCollection[2] = this.vector.vector3D(x + desiredWidth + xLength, y + desiredHeight + yLength, position.z);
      return this.text3D(element, vectorCollection);
    };
    Polygon3D2.prototype.drawLine = function(panel, chart) {
      var transform = chart3DRender.transform;
      if (transform == null) {
        return;
      }
      var actual3DPosition1 = chart.transform3D.toScreen(panel.vectorPoints[0], transform);
      var actual3DPosition2 = chart.transform3D.toScreen(panel.vectorPoints[2], transform);
      var optionsLine = {
        "id": panel.element.id,
        "x1": actual3DPosition1.x,
        "y1": actual3DPosition1.y,
        "x2": actual3DPosition2.x,
        "y2": actual3DPosition2.y,
        "stroke-dasharray": "",
        "stroke-width": panel.element.width,
        "stroke": panel.element.stroke,
        "opacity": panel.element.opacity
      };
      chart.chart3D.appendChild(chart.svgRenderer.drawLine(optionsLine));
      if (chart.previousID && chart.isTouch) {
        var previousElement = document.getElementById(chart.previousID);
        var currentElement = document.getElementById(optionsLine.id);
        if (previousElement && currentElement) {
          currentElement.parentNode.insertBefore(currentElement, previousElement.nextSibling);
        }
      }
      chart.previousID = optionsLine.id;
    };
    Polygon3D2.prototype.drawTemplate = function(panel, chart) {
      var element = panel.element;
      var transform = chart3DRender.transform;
      if (transform == null) {
        return;
      }
      var label = element.label;
      var actual3DPosition = chart.transform3D.toScreen(panel.vectorPoints[0], transform);
      chart.dataLabel3DModule.createDataLabelTemplate(label.series.dataLabelElement, label.series, label.series.dataLabel, label.series.visiblePoints[label.pointIndex], element.argsData, label.pointIndex, false, actual3DPosition);
    };
    Polygon3D2.prototype.drawText = function(panel, chart) {
      var element = panel.element;
      var transform = chart3DRender.transform;
      if (transform == null) {
        return;
      }
      var actual3DPosition = chart.transform3D.toScreen(panel.vectorPoints[0], transform);
      var x = actual3DPosition.x;
      var y = actual3DPosition.y;
      if (element.tag === "text") {
        var options = {
          "id": element.id,
          "x": x,
          "y": y,
          "fill": element.font.color || element.fill,
          "font-size": element.font.size,
          "font-family": element.font.fontFamily,
          "font-style": element.font.fontStyle,
          "font-weight": element.font.fontWeight,
          "opacity": element.font.opacity,
          "text-anchor": element.textAnchor,
          "cursor": "default",
          "transform": element.angle ? "rotate(" + element.angle + "," + x + "," + y + ")" : ""
        };
        var textElement3 = chart.svg3DRenderer.drawText(options, element.label.text, panel.element.font, chart);
        if (element.id.indexOf("-axis-title") > -1) {
          textElement3.setAttribute("aria-hidden", "true");
        }
        chart.chart3D.append(textElement3);
      } else {
        var series = element.series;
        var labelFormat = series.yAxis && series.yAxis.labelFormat ? series.yAxis.labelFormat : "";
        var pointText = element.point.text ? element.point.text : element.point.y + labelFormat.substring(labelFormat.indexOf("}") + 1);
        var textOffset = measureText(pointText, series.dataLabel.font, chart.themeStyle.datalabelFont);
        var margin = series.dataLabel.margin;
        var width = textOffset.width + margin.left + margin.right;
        var height = textOffset.height + margin.top + margin.bottom;
        var location_1 = {
          x: actual3DPosition.x,
          y: actual3DPosition.y
        };
        var xXalue = location_1.x - margin.left / 2 + margin.right / 2;
        var yValue = location_1.y - margin.top / 2 - height / margin.top + margin.bottom / 2;
        var seriesIndex = series.index;
        this.dataLabelSymbol(seriesIndex, series, element.pointIndex, xXalue, yValue, width, height, chart);
      }
    };
    Polygon3D2.prototype.dataLabelSymbol = function(seriesIndex, series, pointIndex, x, y, width, height, chart) {
      var path = "M " + (x + -width / 2) + " " + (y + -height / 2) + " L " + (x + width / 2) + " " + (y + -height / 2) + " L " + (x + width / 2) + " " + (y + height / 2) + " L " + (x + -width / 2) + " " + (y + height / 2) + " L " + (x + -width / 2) + " " + (y + -height / 2) + " z";
      var Rectoptions = {
        id: chart.element.id + "-svg-data-label-series-" + seriesIndex + "-point-" + pointIndex,
        fill: series.dataLabel.fill,
        "stroke-width": series.dataLabel.border.width,
        "stroke-dasharray": series.dataLabel.border.dashArray,
        stroke: series.dataLabel.border.color,
        opacity: series.dataLabel.opacity,
        visibility: "",
        d: path
      };
      var element = chart.svgRenderer.drawPath(Rectoptions);
      chart.chart3D.append(element);
    };
    Polygon3D2.prototype.draw = function(panel, chart) {
      if (panel.vectorPoints == null || panel.vectorPoints.length <= 0) {
        return;
      }
      var transform = chart3DRender.transform;
      var pathDirection = chart.svg3DRenderer.getStringBuilder();
      var color = panel.fill;
      var format = chart.svg3DRenderer.checkColorFormat(color);
      if (!format) {
        if (color !== "transparent") {
          color = colorNameToHex(color);
        }
      }
      var figure = {
        StartPoint: null
      };
      if (transform != null) {
        figure.StartPoint = chart.transform3D.toScreen(panel.vectorPoints[0], transform);
        pathDirection.append("M " + figure.StartPoint.x + " " + figure.StartPoint.y + " ");
        for (var i = 0; i < panel.vectorPoints.length; i++) {
          var lineSegment = chart.transform3D.toScreen(panel.vectorPoints[i], transform);
          pathDirection.append("L " + lineSegment.x + " " + lineSegment.y + " ");
        }
      }
      var direction = pathDirection.toString();
      var name = "Light";
      var lightCoefficientZ = 2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(0, 0, 1))) - 1);
      var lightCoefficientY = 2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(0, 1, 0))) - 1);
      var lightCoefficientX = 2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(1, 0, 0))) - 1);
      if (panel.name && !(panel.name.indexOf("-wall-brush") > -1)) {
        if (lightCoefficientZ === lightCoefficientX) {
          name = "ZLight";
          color = this.applyZLight(color, chart);
        } else if (lightCoefficientY === lightCoefficientZ || lightCoefficientZ !== 0 && lightCoefficientY < lightCoefficientZ) {
          name = "XLight";
          color = this.applyXLight(color, chart);
        } else if (lightCoefficientZ < 0) {
          name = "ZLight";
          color = this.applyZLight(color, chart);
        } else {
          name = "Light";
        }
      }
      var options = {
        "id": chart.element.id + "-svg" + panel.name,
        "name": name,
        "fill": color,
        "stroke": "",
        "stroke-width": panel.strokeThickness,
        "opacity": panel.opacity,
        "d": direction
      };
      var element = chart.svgRenderer.drawPath(options);
      if (panel.text) {
        element.setAttribute("aria-label", panel.text);
        element.setAttribute("role", "img");
      }
      if (panel.name && panel.name.indexOf("-wall-brush") > -1) {
        element.setAttribute("aria-hidden", "true");
      }
      if (element.id.indexOf("0-region-series-0-point-0") > -1) {
        if (this.tabIndex) {
          element.setAttribute("tabindex", "0");
        } else {
          var elements = panel.polygonElement.parent.querySelectorAll('[id*="0-region-series-0-point-0"]');
          if (elements.length > 0) {
            elements[elements.length - 1].removeAttribute("tabindex");
          }
          element.setAttribute("tabindex", "0");
        }
        this.tabIndex = false;
      }
      appendChildElement(false, panel.polygonElement.parent, element, chart.redraw, true, "x", "y", null, direction);
      if (chart.previousID && chart.isTouch) {
        var previousElement = document.getElementById(chart.previousID);
        var currentElement = document.getElementById(options.id);
        if (previousElement && currentElement) {
          currentElement.parentNode.insertBefore(currentElement, previousElement.nextSibling);
        }
      }
      chart.previousID = options.id;
    };
    Polygon3D2.prototype.applyXLight = function(color, chart) {
      var RGB = chart.svg3DRenderer.hexToValue(color);
      RGB.red = parseInt((RGB.red * 0.7).toString(), 10);
      RGB.green = parseInt((RGB.green * 0.7).toString(), 10);
      RGB.blue = parseInt((RGB.blue * 0.7).toString(), 10);
      return chart.svg3DRenderer.hexColor(RGB);
    };
    Polygon3D2.prototype.applyZLight = function(color, chart) {
      var RGB = chart.svg3DRenderer.hexToValue(color);
      RGB.red = parseInt((RGB.red * 0.9).toString(), 10);
      RGB.green = parseInt((RGB.green * 0.9).toString(), 10);
      RGB.blue = parseInt((RGB.blue * 0.9).toString(), 10);
      return chart.svg3DRenderer.hexColor(RGB);
    };
    return Polygon3D2;
  }()
);
var vector = new Vector3D(0, 0, 0);
var matrixObj = new Matrix3D();
var bspTreeObj = new BinaryTreeBuilder();
var polygonObj = new Polygon3D();
var graphics = new Graphics3D();
function getMinPointsDeltaValue(axis, seriesCollection) {
  var minDelta = Number.MAX_VALUE;
  var xValues;
  var minVal;
  var seriesMin;
  for (var index = 0; index < seriesCollection.length; index++) {
    var series = seriesCollection[index];
    xValues = [];
    if (series.visible && (axis.name === series.xAxisName || axis.name === "primaryXAxis" && series.xAxisName === null)) {
      xValues = series.points.map(function(point) {
        return point.xValue;
      });
      xValues.sort(function(first, second) {
        return first - second;
      });
      if (xValues.length === 1) {
        seriesMin = axis.valueType === "DateTime" && series.xMin === series.xMax ? series.xMin - 2592e4 : series.xMin;
        minVal = xValues[0] - (!isNullOrUndefined(seriesMin) ? seriesMin : axis.visibleRange.min);
        if (minVal !== 0) {
          minDelta = Math.min(minDelta, minVal);
        }
      } else {
        for (var index_1 = 0; index_1 < xValues.length; index_1++) {
          var value = xValues[index_1];
          if (index_1 > 0 && value) {
            minVal = value - xValues[index_1 - 1];
            if (minVal !== 0) {
              minDelta = Math.min(minDelta, minVal);
            }
          }
        }
      }
    }
  }
  if (minDelta === Number.MAX_VALUE) {
    minDelta = 1;
  }
  return minDelta;
}
function valueToCoefficients(value, axis) {
  var range = axis.visibleRange;
  var result = (value - range.min) / range.delta;
  var isInverse = axis.isAxisInverse;
  return isInverse ? 1 - result : result;
}

// node_modules/@syncfusion/ej2-charts/src/chart3d/utils/renderer.js
var WallRenderer = (
  /** @class */
  function() {
    function WallRenderer2() {
    }
    WallRenderer2.prototype.update3DWall = function(chart) {
      this.updateBackWall(chart);
      for (var i = 0; i < chart.axisCollections.length; i++) {
        var axis = chart.axisCollections[i];
        var opposedPosition = axis.opposedPosition || axis.isAxisOpposedPosition;
        if (axis.orientation.toLowerCase() === "vertical") {
          if (!opposedPosition) {
            this.updateLeftWall(chart);
          } else {
            this.updateRightWall(chart);
          }
        } else {
          if (!opposedPosition) {
            this.updateBottomWall(chart);
          } else {
            this.updateTopWall(chart);
          }
        }
      }
    };
    WallRenderer2.prototype.updateTopWall = function(chart) {
      var offset = 0;
      var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;
      var y = areaBounds.y;
      if (chart.wallSize < y) {
        offset = y - chart.wallSize;
      } else {
        offset = -(chart.wallSize - y);
      }
      var topLeftFrontVector = chart.vector.vector3D(areaBounds.x + areaBounds.width, -chart.depth, y - 0.1);
      var bottomRightBackVector = chart.vector.vector3D(areaBounds.x, -0.1, offset);
      var topSideWallPlans = chart.polygon.createBox(topLeftFrontVector, bottomRightBackVector, chart, 0, chart.wallColor || chart.themeStyle.leftWallColor, chart.wallColor || chart.themeStyle.leftWallColor, 0, chart.theme.indexOf("Fluent2") > -1 ? 0.3 : chart.theme.indexOf("Bootstrap5") > -1 ? 0.1 : 0.5, false, "top-wall-brush", chart.chart3D);
      for (var i = 0; i < topSideWallPlans.length; i++) {
        chart.polygon.transform(chart.matrixObj.tilt(Math.PI / 2), topSideWallPlans[i]);
      }
    };
    WallRenderer2.prototype.updateRightWall = function(chart) {
      var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;
      var x = areaBounds.x + areaBounds.width;
      var rightRect = {
        left: -chart.depth,
        top: areaBounds.y,
        bottom: areaBounds.height + areaBounds.y,
        right: 0
      };
      var topLeftFrontVector = chart.vector.vector3D(rightRect.left, rightRect.top, x + 1.5);
      var bottomRightBackVector = chart.vector.vector3D(rightRect.right, rightRect.bottom, x + chart.wallSize);
      var rightSideWallPlans = chart.polygon.createBox(topLeftFrontVector, bottomRightBackVector, chart, 0, chart.wallColor || chart.themeStyle.leftWallColor, chart.wallColor || chart.themeStyle.leftWallColor, 0, chart.theme.indexOf("Fluent2") > -1 ? 0.3 : chart.theme.indexOf("Bootstrap5") > -1 ? 0.1 : 0.5, false, "right-wall-brush", chart.chart3D);
      for (var i = 0; i < rightSideWallPlans.length; i++) {
        chart.polygon.transform(chart.matrixObj.turn(-Math.PI / 2), rightSideWallPlans[i]);
      }
    };
    WallRenderer2.prototype.updateBackWall = function(chart) {
      var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;
      var topLeftFrontVector = chart.vector.vector3D(areaBounds.x, areaBounds.y, chart.depth === 0 ? 1.5 : chart.depth + chart.wallSize);
      var bottomRightBackVector = chart.vector.vector3D(areaBounds.x + areaBounds.width, areaBounds.y + areaBounds.height, chart.depth === 0 ? 1.5 : chart.depth);
      chart.polygon.createBox(topLeftFrontVector, bottomRightBackVector, chart, 0, chart.wallColor || chart.themeStyle.backWallColor, chart.wallColor || chart.themeStyle.backWallColor, 0, chart.theme.indexOf("Fluent2") > -1 ? 0.3 : chart.theme.indexOf("Bootstrap5") > -1 ? 0.1 : 0.25, false, "back-wall-brush", chart.chart3D);
    };
    WallRenderer2.prototype.updateLeftWall = function(chart) {
      var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;
      var leftRect = {
        left: -chart.depth,
        top: areaBounds.y,
        bottom: areaBounds.height + areaBounds.y,
        right: 0
      };
      var offset = areaBounds.x;
      var topLeftFrontVector = chart.vector.vector3D(leftRect.left, leftRect.top, offset - 0.1);
      var bottomRightBackVector = chart.vector.vector3D(leftRect.right, leftRect.bottom, offset - chart.wallSize);
      var leftSideWallPlans = chart.polygon.createBox(topLeftFrontVector, bottomRightBackVector, chart, 0, chart.wallColor || chart.themeStyle.leftWallColor, chart.wallColor || chart.themeStyle.leftWallColor, 0, chart.theme.indexOf("Fluent2") > -1 ? 0.3 : chart.theme.indexOf("Bootstrap5") > -1 ? 0.1 : 0.5, false, "left-wall-brush", chart.chart3D);
      for (var i = 0; i < leftSideWallPlans.length; i++) {
        chart.polygon.transform(chart.matrixObj.turn(-Math.PI / 2), leftSideWallPlans[i]);
      }
    };
    WallRenderer2.prototype.updateBottomWall = function(chart) {
      var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;
      var y = areaBounds.y + areaBounds.height;
      var topLeftFrontVector = chart.vector.vector3D(areaBounds.x + areaBounds.width, -chart.depth, chart.wallSize + y);
      var bottomRightBackVector = chart.vector.vector3D(areaBounds.x, -0.1, y + 1);
      var bottomSideWallPlans = chart.polygon.createBox(bottomRightBackVector, topLeftFrontVector, chart, 0, chart.wallColor || chart.themeStyle.leftWallColor, chart.wallColor || chart.themeStyle.leftWallColor, 0, chart.theme.indexOf("Fluent2") > -1 ? 0.3 : chart.theme.indexOf("Bootstrap5") > -1 ? 0.1 : 0.5, false, "bottom-wall-brush", chart.chart3D);
      for (var i = 0; i < bottomSideWallPlans.length; i++) {
        chart.polygon.transform(chart.matrixObj.tilt(Math.PI / 2), bottomSideWallPlans[i]);
      }
    };
    return WallRenderer2;
  }()
);
var AxisRenderer = (
  /** @class */
  function() {
    function AxisRenderer2() {
    }
    AxisRenderer2.prototype.drawAxes = function(index, axis, chart) {
      if (axis.majorGridLines.width) {
        this.drawGridLines3D(axis, chart, index);
      }
      if (axis.visible && axis.internalVisibility && axis.majorTickLines.width) {
        this.renderTicks3D(axis, axis.majorTickLines.height, axis.majorTickLines.width, chart, index);
      }
      if (axis.visible && axis.internalVisibility) {
        this.drawAxisLabel(axis, chart, index);
        this.drawAxisTitle(axis, chart, index);
      }
    };
    AxisRenderer2.prototype.drawAxisTitle = function(axis, chart, index) {
      if (axis.title) {
        var font = {
          size: axis.titleStyle.size || chart.themeStyle.axisTitleFont.size,
          fontWeight: axis.titleStyle.fontWeight || chart.themeStyle.axisTitleFont.fontWeight,
          fontStyle: axis.titleStyle.fontStyle || chart.themeStyle.axisTitleFont.fontStyle,
          fontFamily: axis.titleStyle.fontFamily || chart.themeStyle.axisTitleFont.fontFamily,
          color: axis.titleStyle.color,
          opacity: axis.titleStyle.opacity
        };
        var opposedPosition = axis.opposedPosition || axis.isAxisOpposedPosition;
        var size = {
          width: chart.availableSize.width,
          height: chart.availableSize.height
        };
        var transform = chart.transform3D.transform3D(size);
        transform.viewingArea = size;
        transform.rotation = 0;
        transform.tilt = 0;
        transform.depth = 100;
        transform.perspectiveAngle = 90;
        chart.transform3D.transform(transform);
        var orientation_1 = axis.orientation.toLowerCase();
        var elementSpacing = 10;
        if (orientation_1 === "horizontal") {
          var padding = 0;
          var titlesize = measureText(axis.title, axis.titleStyle, chart.themeStyle.axisTitleFont).height / 2;
          if (axis.titleRotation) {
            padding = axis.titlePadding + elementSpacing + axis.labelPadding + axis.titleSize.height / 2;
          } else {
            padding = axis.titlePadding + titlesize + axis.labelPadding + elementSpacing;
          }
          var xtitleLocation = axis.maxLabelSize.height + padding;
          var data = {
            text: axis.title,
            location: {
              x: axis.rect.width / 2,
              y: xtitleLocation + axis.majorTickLines.height + chart.wallSize
            }
          };
          var x1 = data.location.x + axis.rect.x;
          var y1 = opposedPosition ? axis.rect.y - data.location.y : data.location.y + axis.rect.y;
          var element = {
            width: 0,
            height: 0,
            angle: axis.titleRotation ? axis.titleRotation : 0,
            label: data,
            textAnchor: "middle",
            tag: "text",
            font,
            id: chart.element.id + "-svg-axis-title-" + index,
            child: chart.chart3D
          };
          element.font.color = element.font.color ? element.font.color : chart.themeStyle.axisTitle;
          element.font.fontFamily = element.font.fontFamily ? element.font.fontFamily : chart.themeStyle.axisTitleFont.fontFamily;
          chart.graphics.addVisual(chart.polygon.createTextElement(chart.vector.vector3D(x1, y1, 0), element, 10, 10), chart);
        } else {
          var titleSize = measureText(axis.title, axis.titleStyle, chart.themeStyle.axisTitleFont);
          var padding = 0;
          if (axis.titleRotation) {
            padding = axis.labelPadding + axis.titlePadding + axis.titleSize.width / 2;
          } else {
            padding = axis.titlePadding + axis.labelPadding;
          }
          var x1 = opposedPosition ? axis.rect.x + (elementSpacing + axis.maxLabelSize.width + axis.majorTickLines.height + chart.wallSize + padding) : axis.rect.x - (elementSpacing + axis.maxLabelSize.width + axis.majorTickLines.height + chart.wallSize + padding);
          var angle = (axis.titleRotation == null ? opposedPosition ? 90 : -90 : axis.titleRotation) % 360;
          var data = {
            text: axis.title,
            location: {
              x: titleSize.width / 2,
              y: 0
            }
          };
          var y1 = data.location.y + (axis.rect.y + axis.rect.height) + axis.rect.height / 2 * -1;
          var element = {
            width: titleSize.width,
            height: titleSize.height,
            angle,
            label: data,
            textAnchor: "middle",
            tag: "text",
            font,
            id: chart.element.id + "-svg-axis-title-" + index,
            child: chart.chart3D
          };
          element.font.color = element.font.color ? element.font.color : chart.themeStyle.axisTitle;
          element.font.fontFamily = element.font.fontFamily ? element.font.fontFamily : chart.themeStyle.axisTitleFont.fontFamily;
          chart.graphics.addVisual(chart.polygon.createTextElement(chart.vector.vector3D(x1, y1, 0), element, 10, 10), chart);
        }
      }
    };
    AxisRenderer2.prototype.textTrim = function(maxWidth, text, labelStyle, font) {
      var textLength = text.length;
      var trimmedSize;
      var label;
      var textSize = measureText(text, labelStyle, font);
      if (textSize.width > maxWidth) {
        for (var k = textLength - 1; k >= 0; --k) {
          label = text.substring(0, k) + "...";
          trimmedSize = measureText(label, labelStyle, font);
          if (trimmedSize.width <= maxWidth) {
            return label;
          }
        }
        return "";
      } else {
        return text;
      }
    };
    AxisRenderer2.prototype.multipleRows = function(length, currentX, currentLabel, axis, font) {
      var label;
      var pointX;
      var labelSize;
      var store = [];
      var isMultiRows;
      for (var i = length - 1; i >= 0; i--) {
        label = axis.visibleLabels[i];
        labelSize = measureText(label.text, axis.labelStyle, font);
        pointX = valueToCoefficients(i, axis) * axis.rect.width + axis.rect.x;
        isMultiRows = currentX < pointX + labelSize.width / 2;
        if (isMultiRows) {
          label.index = label.index ? label.index : 0;
          store.push(label.index);
          currentLabel.index = currentLabel.index > label.index ? currentLabel.index : label.index + 1;
        } else {
          currentLabel.index = store.indexOf(label.index) > -1 ? currentLabel.index : label.index;
        }
      }
    };
    AxisRenderer2.prototype.drawAxisLabel = function(axis, chart, index) {
      var labels = [];
      var angleValue;
      var labelsCount = axis.visibleLabels.length;
      var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;
      var opposedPosition = axis.opposedPosition || axis.isAxisOpposedPosition;
      var elementSpacing = axis.angle ? 5 : 10;
      var y = areaBounds.y + (!opposedPosition && areaBounds.height);
      var x = areaBounds.x + (opposedPosition && areaBounds.width);
      for (var i = 0; i < labelsCount; i++) {
        if (!isNullOrUndefined(axis.visibleLabels[i].text)) {
          var x1 = 0;
          var y1 = 0;
          var pointX = void 0;
          axis.visibleLabels[i].originalText = axis.visibleLabels[i].text;
          var textAnchor = void 0;
          var textSize = measureText(axis.visibleLabels[i].text, axis.labelStyle, chart.themeStyle.axisLabelFont);
          var value = (axis.visibleLabels[i].value - axis.visibleRange.min) / axis.visibleRange.delta;
          value = axis.isInversed || axis.isAxisInverse ? 1 - value : value;
          value = isNaN(value) ? 0 : value;
          if (axis.orientation.toLowerCase() === "horizontal") {
            x1 = Math.round(axis.rect.width * value) + areaBounds.x + axis.plotOffset;
            y1 = opposedPosition ? y - chart.wallSize - axis.majorTickLines.height - axis.labelPadding - elementSpacing / 2 : y + chart.wallSize + axis.majorTickLines.height + elementSpacing + axis.labelPadding;
            textAnchor = "middle";
          } else {
            y1 = Math.round(axis.plotOffset + axis.rect.y + textSize.height / 4 + axis.rect.height * (1 - value));
            var padding = 0;
            if (axis.labelRotation === 90 || axis.labelRotation === -90 || axis.labelRotation === 270 || axis.labelRotation === -270) {
              padding = elementSpacing * 2;
            } else {
              padding = elementSpacing;
            }
            x1 = opposedPosition ? axis.rect.x + axis.majorTickLines.height + padding + axis.labelPadding : x - chart.wallSize - axis.majorTickLines.height - padding + axis.labelPadding;
            textAnchor = opposedPosition ? axis.isRTLEnabled ? "end" : "start" : axis.isRTLEnabled ? "start" : "end";
          }
          labels.push({
            x: x1,
            y: y1,
            size: textSize
          });
          var maxWidth = axis.rect.width / axis.visibleLabels.length - 5;
          var label = labels[i];
          if ((label.x > axis.rect.x && i === 0 || label.x + label.size.width / 2 > axis.rect.x + axis.rect.width && i === axis.visibleLabels.length - 1) && axis.labelIntersectAction !== "Trim" && axis.labelIntersectAction.indexOf("wrap") < 0) {
            if (axis.edgeLabelPlacement === "Hide") {
              continue;
            } else if (axis.edgeLabelPlacement === "Shift") {
              if (i === 0) {
                label.x = x1 = axis.rect.x + label.size.width / 2;
              } else if (i === axis.visibleLabels.length - 1) {
                label.x = x1 = axis.rect.x + axis.rect.width - label.size.width / 2;
              }
            }
          }
          if (axis.orientation.toLowerCase() === "horizontal") {
            if (axis.labelRotation) {
              angleValue = axis.labelRotation;
              var rotatedSize = rotateTextSize(axis.labelStyle, axis.visibleLabels[i].text, angleValue, chart, chart.themeStyle.axisLabelFont);
              y1 += rotatedSize.height / 2;
            } else {
              if (axis.labelIntersectAction === "Trim") {
                axis.visibleLabels[i].text = this.textTrim(maxWidth, axis.visibleLabels[i].text, axis.labelStyle, chart.themeStyle.axisLabelFont);
              } else if (axis.angle && (axis.labelIntersectAction === "Rotate45" || axis.labelIntersectAction === "Rotate90")) {
                var rotatedSize = rotateTextSize(axis.labelStyle, axis.visibleLabels[i].text, axis.angle, chart, chart.themeStyle.axisLabelFont);
                y1 += rotatedSize.height / 2;
              } else if (axis.labelIntersectAction === "MultipleRows") {
                pointX = label.x;
                pointX -= textSize.width / 2;
                this.multipleRows(i, pointX, axis.visibleLabels[i], axis, chart.themeStyle.axisLabelFont);
                y1 = axis.visibleLabels[i].index ? y1 + axis.visibleLabels[i].index * (textSize.height + 5) : y1;
              } else if (axis.labelIntersectAction === "Hide") {
                var isAxisLabelHidden = false;
                for (var j = 0; j < i; j++) {
                  if (labels[j].x + labels[j].size.width / 2 >= labels[i].x - labels[i].size.width / 2) {
                    isAxisLabelHidden = true;
                    break;
                  }
                }
                if (isAxisLabelHidden) {
                  continue;
                }
              }
            }
          }
          var font = {
            size: axis.visibleLabels[i].labelStyle.size,
            fontWeight: axis.visibleLabels[i].labelStyle.fontWeight,
            fontStyle: axis.visibleLabels[i].labelStyle.fontStyle,
            fontFamily: axis.visibleLabels[i].labelStyle.fontFamily,
            color: axis.visibleLabels[i].labelStyle.color,
            opacity: axis.visibleLabels[i].labelStyle.opacity
          };
          var element = {
            width: textSize.width,
            height: textSize.height,
            label: axis.visibleLabels[i],
            textAnchor,
            tag: "text",
            font,
            id: chart.element.id + "-" + index + "-axis-label-" + i,
            child: chart.chart3D,
            angle: axis.angle
          };
          element.font.color = element.font.color ? element.font.color : chart.themeStyle.axisLabel;
          element.font.fontFamily = element.font.fontFamily ? element.font.fontFamily : chart.themeStyle.axisLabelFont.fontFamily;
          chart.graphics.addVisual(chart.polygon.createTextElement(chart.vector.vector3D(x1, y1, 0), element, 10, 10), chart);
        }
      }
    };
    AxisRenderer2.prototype.renderTicks3D = function(axis, size, width, chart, index) {
      var labelsCount = axis.visibleLabels.length;
      var minorTicks;
      var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;
      var ticksbwtLabel = axis.valueType === "Category" && axis.labelPlacement === "BetweenTicks" ? 0.5 : 0;
      labelsCount += axis.valueType === "Category" && labelsCount > 0 && axis.labelPlacement === "BetweenTicks" ? 1 : 0;
      var labelValue;
      for (var i = 0; i < labelsCount; i++) {
        if (axis.valueType !== "DateTimeCategory") {
          labelValue = axis.visibleLabels[i] ? axis.visibleLabels[i].value - ticksbwtLabel : axis.visibleLabels[i - 1].value + axis.visibleRange.interval - ticksbwtLabel;
        } else {
          labelValue = axis.visibleLabels[i].value ? axis.visibleLabels[i].value - ticksbwtLabel : axis.visibleRange.max;
        }
        var x1 = 0;
        var x2 = 0;
        var y1 = 0;
        var y2 = 0;
        var value = (labelValue - axis.visibleRange.min) / axis.visibleRange.delta;
        value = axis.isInversed || axis.isAxisInverse ? 1 - value : value;
        value = isNaN(value) ? 0 : value;
        if (axis.orientation.toLowerCase() === "horizontal") {
          x2 = x1 = Math.round(axis.rect.width * value) + areaBounds.x + axis.plotOffset;
        } else {
          y1 = y2 = Math.round(axis.plotOffset + axis.rect.height * (1 - value)) + axis.rect.y;
        }
        var position = this.calculatePosition3D(axis, size, width, x1, y1, x2, y2, chart);
        var line = {
          width: axis.majorTickLines.width,
          opacity: 1,
          stroke: axis.majorTickLines.color || chart.themeStyle.majorTickLine,
          child: chart.chart3D,
          tag: "line",
          id: ""
        };
        line.id = chart.element.id + "-" + index + "-major-tick-lines-" + i;
        chart.graphics.addVisual(chart.polygon.createLine(line, position.x1, position.y1, position.x2, position.y2, 0), chart);
        if (axis.minorGridLines.width && axis.minorTicksPerInterval > 0 && i < labelsCount - 1) {
          minorTicks = axis.visibleRange.interval / (axis.minorTicksPerInterval + 1);
          for (var k = 0; k < axis.minorTicksPerInterval; k++) {
            value = valueToCoefficients(axis.visibleLabels[i].value + minorTicks * (k + 1), axis);
            value = isNaN(value) ? 0 : value;
            if (axis.orientation.toLowerCase() === "horizontal") {
              x1 = x2 = Math.round(axis.plotOffset + areaBounds.width * value + areaBounds.x);
            } else {
              y1 = y2 = Math.round(axis.plotOffset + areaBounds.height * (1 - value)) + axis.rect.y;
            }
            var position_1 = this.calculatePosition3D(axis, size, width, x1, y1, x2, y2, chart);
            var line_1 = {
              width: axis.minorTickLines.width,
              opacity: 0.6,
              stroke: axis.minorTickLines.color || chart.themeStyle.minorTickLine,
              child: chart.chart3D,
              tag: "line",
              id: ""
            };
            line_1.id = chart.element.id + "-" + index + "-minor-tick-lines-" + i + "-" + k;
            chart.graphics.addVisual(chart.polygon.createLine(line_1, position_1.x1, position_1.y1, position_1.x2, position_1.y2, 0), chart);
          }
        }
      }
    };
    AxisRenderer2.prototype.calculatePosition3D = function(axis, tickSize, width, x1, y1, x2, y2, chart) {
      var isOpposed = axis.opposedPosition || axis.isAxisOpposedPosition;
      var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;
      var y = areaBounds.y + (!isOpposed && areaBounds.height);
      var x = areaBounds.x + (isOpposed && areaBounds.width);
      if (axis.orientation.toLowerCase() === "horizontal") {
        y1 = 0;
        y2 = isOpposed ? tickSize : y1 + tickSize;
        var screenPositionTop = isOpposed ? y - chart.wallSize - tickSize : y + chart.wallSize - tickSize / 2;
        y1 += screenPositionTop;
        y2 += screenPositionTop;
        x1 = x2 = x1;
      } else {
        x1 = 0;
        x2 = isOpposed ? x1 + tickSize : tickSize;
        var screenPositionLeft = isOpposed ? x + chart.wallSize : x - chart.wallSize - tickSize;
        x1 += screenPositionLeft;
        x2 += screenPositionLeft;
        y1 = y2 = y1;
      }
      return {
        x1,
        y1,
        x2,
        y2
      };
    };
    AxisRenderer2.prototype.drawGridLines3D = function(axis, chart, index) {
      if (axis == null) {
        return;
      }
      var labelsCount = axis.visibleLabels.length;
      var minorTicks;
      var opposedPosition = axis.opposedPosition || axis.isAxisOpposedPosition;
      var orientation = axis.orientation;
      var x1;
      var x2;
      var y1;
      var y2;
      var labelValue;
      var ticksbwtLabel = axis.valueType === "Category" && axis.labelPlacement === "BetweenTicks" ? 0.5 : 0;
      labelsCount += axis.valueType === "Category" && labelsCount > 0 && axis.labelPlacement === "BetweenTicks" ? 1 : 0;
      var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;
      if (orientation.toLowerCase() === "horizontal") {
        var i = void 0;
        for (i = 0; i < labelsCount; i++) {
          if (axis.valueType !== "DateTimeCategory") {
            labelValue = axis.visibleLabels[i] ? axis.visibleLabels[i].value - ticksbwtLabel : axis.visibleLabels[i - 1].value + axis.visibleRange.interval - ticksbwtLabel;
          } else {
            labelValue = axis.visibleLabels[i].value ? axis.visibleLabels[i].value - ticksbwtLabel : axis.visibleRange.max;
          }
          var value = valueToCoefficients(labelValue, axis);
          value = isNaN(value) ? 0 : value;
          x2 = x1 = Math.round(axis.rect.width * value) + areaBounds.x + axis.plotOffset;
          y1 = areaBounds.y;
          y2 = areaBounds.y + areaBounds.height;
          var depth = chart.depth > 2 ? chart.depth - 2 : 1;
          var bottom = areaBounds.y + (!opposedPosition && areaBounds.height);
          var line = {
            opacity: 1,
            width: axis.majorGridLines.width,
            stroke: axis.majorGridLines.color || chart.themeStyle.majorGridLine,
            child: chart.chart3D,
            tag: "line",
            id: ""
          };
          line.id = chart.element.id + "-" + index + "-grid-lines-" + i;
          chart.graphics.addVisual(chart.polygon.createLine(line, x1, y1, x2, y2, depth), chart);
          var parallelLine = {
            opacity: line.opacity,
            width: line.width,
            stroke: line.stroke,
            child: line.child,
            tag: line.tag,
            id: ""
          };
          parallelLine.id = line.id + "-parallel";
          parallelLine.id = chart.element.id + "-" + index + "-parallel-grid-lines-" + i;
          var line3D = chart.polygon.createLine(parallelLine, x2, 0, x2, -depth, bottom);
          chart.polygon.transform(chart.matrixObj.tilt(Math.PI / 2), line3D);
          chart.graphics.addVisual(line3D, chart);
          if (axis.minorGridLines.width && axis.minorTicksPerInterval > 0 && i < labelsCount - 1) {
            minorTicks = axis.visibleRange.interval / (axis.minorTicksPerInterval + 1);
            for (var k = 0; k < axis.minorTicksPerInterval; k++) {
              value = valueToCoefficients(axis.visibleLabels[i].value + minorTicks * (k + 1), axis);
              value = isNaN(value) ? 0 : value;
              x2 = x1 = Math.round(areaBounds.width * value) + areaBounds.x;
              y1 = areaBounds.y;
              y2 = areaBounds.y + areaBounds.height;
              var line_2 = {
                opacity: 0.6,
                width: axis.minorGridLines.width,
                stroke: axis.minorGridLines.color || chart.themeStyle.minorGridLine,
                child: chart.chart3D,
                tag: "line",
                id: ""
              };
              line_2.id = chart.element.id + "-" + index + "-minor-grid-lines-" + i + "-" + k;
              chart.graphics.addVisual(chart.polygon.createLine(line_2, x1, y1, x2, y2, depth), chart);
              var parallelLine_1 = {
                opacity: line_2.opacity,
                width: line_2.width,
                stroke: line_2.stroke,
                child: line_2.child,
                tag: line_2.tag,
                id: ""
              };
              parallelLine_1.id = chart.element.id + "-" + index + "-parallel-minor-grid-lines-" + i + "-" + k;
              var line3D_1 = chart.polygon.createLine(parallelLine_1, x2, 0, x2, -depth, bottom);
              chart.polygon.transform(chart.matrixObj.tilt(Math.PI / 2), line3D_1);
              chart.graphics.addVisual(line3D_1, chart);
            }
          }
        }
      } else {
        for (var i = 0; i < labelsCount; i++) {
          labelValue = axis.visibleLabels[i] ? axis.visibleLabels[i].value - ticksbwtLabel : axis.visibleLabels[i - 1].value + axis.visibleRange.interval - ticksbwtLabel;
          var value = (labelValue - axis.visibleRange.min) / axis.visibleRange.delta;
          x1 = areaBounds.x;
          y1 = Math.round(axis.rect.height * (1 - value)) + 0.5;
          y1 += axis.rect.y;
          x2 = x1 + areaBounds.width;
          y2 = y1;
          var depth = chart.depth > 2 ? chart.depth - 2 : 1;
          var line = {
            opacity: 1,
            width: axis.majorGridLines.width,
            stroke: axis.majorGridLines.color || chart.themeStyle.majorGridLine,
            axisName: axis.name,
            child: chart.chart3D,
            tag: "line",
            id: ""
          };
          line.id = chart.element.id + "-" + index + "-grid-lines-" + i;
          chart.graphics.addVisual(chart.polygon.createLine(line, x1, y1, x2, y2, depth), chart);
          var depthD = areaBounds.x + (opposedPosition && areaBounds.width + 1);
          var sideLine = {
            opacity: line.opacity,
            width: line.width,
            stroke: line.stroke,
            child: line.child,
            tag: line.tag,
            id: ""
          };
          sideLine.id = chart.element.id + "-" + index + "-parallel-grid-lines-" + i;
          var line3D = chart.polygon.createLine(sideLine, -depth, y2, 0, y2, depthD);
          chart.polygon.transform(chart.matrixObj.turn(-Math.PI / 2), line3D);
          chart.graphics.addVisual(line3D, chart);
          if (axis.minorGridLines.width && axis.minorTicksPerInterval > 0 && i < labelsCount - 1) {
            minorTicks = axis.visibleRange.interval / (axis.minorTicksPerInterval + 1);
            for (var k = 0; k < axis.minorTicksPerInterval; k++) {
              var value_1 = valueToCoefficients(axis.visibleLabels[i].value + minorTicks * (k + 1), axis);
              x1 = areaBounds.x;
              y1 = Math.round(axis.rect.height * (1 - value_1)) + 0.5;
              y1 += axis.rect.y;
              x2 = x1 + areaBounds.width;
              y2 = y1;
              var line_3 = {
                opacity: 0.6,
                width: axis.minorGridLines.width,
                stroke: axis.minorGridLines.color || chart.themeStyle.minorGridLine,
                axisName: axis.name,
                child: chart.chart3D,
                tag: "line",
                id: ""
              };
              line_3.id = chart.element.id + "-" + index + "-minor-grid-lines-" + i + "-" + k;
              chart.graphics.addVisual(chart.polygon.createLine(line_3, x1, y1, x2, y2, depth), chart);
              var sideLine_1 = {
                opacity: line_3.opacity,
                width: line_3.width,
                stroke: line_3.stroke,
                child: line_3.child,
                tag: line_3.tag,
                id: ""
              };
              sideLine_1.id = chart.element.id + "-" + index + "-parallel-minor-grid-lines-" + i + k;
              var line3D_2 = chart.polygon.createLine(sideLine_1, -depth, y2, 0, y2, depthD);
              chart.polygon.transform(chart.matrixObj.turn(-Math.PI / 2), line3D_2);
              chart.graphics.addVisual(line3D_2, chart);
            }
          }
        }
      }
    };
    return AxisRenderer2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart3d/utils/doubleRange.js
var DoubleRange2 = (
  /** @class */
  function() {
    function DoubleRange3(start, end) {
      if (start < end) {
        this.mStart = start;
        this.mEnd = end;
      } else {
        this.mStart = end;
        this.mEnd = start;
      }
    }
    Object.defineProperty(DoubleRange3.prototype, "start", {
      /**
       * The start value.
       *
       * @private
       * @returns {number} - The start value.
       */
      get: function() {
        return this.mStart;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DoubleRange3.prototype, "end", {
      /**
       * The end value.
       *
       * @private
       * @returns {number} - The end value.
       */
      get: function() {
        return this.mEnd;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DoubleRange3.prototype, "delta", {
      /**
       * The delta between the start and end values.
       *
       * @private
       * @returns {number} - The delta value.
       */
      get: function() {
        return this.mEnd - this.mStart;
      },
      enumerable: true,
      configurable: true
    });
    return DoubleRange3;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart3d/axis/double-axis.js
var Double3D = (
  /** @class */
  function() {
    function Double3D2(chart) {
      this.isColumn = 0;
      this.isStacking = false;
      this.chart = chart;
    }
    Double3D2.prototype.calculateNumericNiceInterval = function(axis, delta, size) {
      var actualDesiredIntervalsCount = getActualDesiredIntervalsCount(size, axis);
      var niceInterval = delta / actualDesiredIntervalsCount;
      if (!isNullOrUndefined(axis.desiredIntervals)) {
        return niceInterval;
      }
      var minInterval = Math.pow(10, Math.floor(logBase(niceInterval, 10)));
      for (var _i = 0, _a = axis.intervalDivs; _i < _a.length; _i++) {
        var interval = _a[_i];
        var currentInterval = minInterval * interval;
        if (actualDesiredIntervalsCount < delta / currentInterval) {
          break;
        }
        niceInterval = currentInterval;
      }
      return niceInterval;
    };
    Double3D2.prototype.getActualRange = function(axis, size) {
      this.initializeDoubleRange(axis);
      if (!axis.startFromZero && this.isColumn > 0) {
        axis.actualRange.interval = axis.interval || this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);
        axis.actualRange.max = axis.doubleRange.end + axis.actualRange.interval;
        if (axis.doubleRange.start - axis.actualRange.interval < 0 && axis.doubleRange.start > 0) {
          axis.actualRange.min = 0;
        } else {
          axis.actualRange.min = axis.doubleRange.start - (this.isStacking ? 0 : axis.actualRange.interval);
        }
      } else {
        axis.actualRange.interval = axis.interval || this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);
        axis.actualRange.min = axis.doubleRange.start;
        axis.actualRange.max = axis.doubleRange.end;
      }
    };
    Double3D2.prototype.initializeDoubleRange = function(axis) {
      if (axis.minimum !== null) {
        this.min = axis.minimum;
      } else if (this.min === null || this.min === Number.POSITIVE_INFINITY) {
        this.min = 0;
      }
      if (axis.maximum !== null) {
        this.max = axis.maximum;
      } else if (this.max === null || this.max === Number.NEGATIVE_INFINITY) {
        this.max = 5;
      }
      if (this.min === this.max) {
        this.max = axis.valueType.indexOf("Category") > -1 ? this.max : this.min + 1;
      }
      axis.doubleRange = new DoubleRange2(this.min, this.max);
      axis.actualRange = {};
    };
    Double3D2.prototype.calculateRangeAndInterval = function(size, axis) {
      this.calculateRange(axis);
      this.getActualRange(axis, size);
      this.applyRangePadding(axis, size);
      this.calculateVisibleLabels(axis, this.chart);
    };
    Double3D2.prototype.calculateRange = function(axis) {
      this.min = null;
      this.max = null;
      if (!setRange(axis)) {
        for (var _i = 0, _a = axis.series; _i < _a.length; _i++) {
          var series = _a[_i];
          if (!series.visible) {
            continue;
          }
          this.paddingInterval = 0;
          if (!isNullOrUndefined(series.points)) {
            axis.maxPointLength = series.points.length;
          }
          axis.maxPointLength = series.points.length;
          if (series.type.indexOf("Column") > -1 && axis.orientation === "Horizontal" || series.type.indexOf("Bar") > -1 && axis.orientation === "Vertical") {
            if ((series.xAxis.valueType === "Double" || series.xAxis.valueType === "DateTime") && series.xAxis.rangePadding === "Auto") {
              this.paddingInterval = getMinPointsDeltaValue(series.xAxis, axis.series) * 0.5;
            }
          }
          if (axis.orientation === "Horizontal") {
            if (this.chart.requireInvertedAxis) {
              this.yAxisRange(axis, series);
            } else {
              this.findMinMax(series.xMin - this.paddingInterval, series.xMax + this.paddingInterval);
            }
          }
          if (axis.orientation === "Vertical") {
            this.isColumn += series.type.indexOf("Column") !== -1 || series.type.indexOf("Bar") !== -1 ? 1 : 0;
            this.isStacking = series.type.indexOf("Stacking") !== -1;
            if (this.chart.requireInvertedAxis) {
              this.findMinMax(series.xMin - this.paddingInterval, series.xMax + this.paddingInterval);
            } else {
              this.yAxisRange(axis, series);
            }
          }
        }
      }
    };
    Double3D2.prototype.yAxisRange = function(axis, series) {
      this.findMinMax(series.yMin, series.yMax);
    };
    Double3D2.prototype.findMinMax = function(min, max) {
      if (this.min === null || this.min > min) {
        this.min = min;
      }
      if (this.max === null || this.max < max) {
        this.max = max;
      }
      if (this.max === this.min && this.max < 0 && this.min < 0) {
        this.max = 0;
      }
    };
    Double3D2.prototype.applyRangePadding = function(axis, size) {
      var start = axis.actualRange.min;
      var end = axis.actualRange.max;
      if (!setRange(axis)) {
        var interval = axis.actualRange.interval;
        var padding = axis.getRangePadding(this.chart);
        if (padding === "Additional" || padding === "Round") {
          this.findAdditional(axis, start, end, interval, size);
        } else if (padding === "Normal") {
          this.findNormal(axis, start, end, interval, size);
        } else {
          this.updateActualRange(axis, start, end, interval);
        }
      }
      axis.actualRange.delta = axis.actualRange.max - axis.actualRange.min;
      this.calculateVisibleRange(size, axis);
    };
    Double3D2.prototype.updateActualRange = function(axis, minimum, maximum, interval) {
      axis.actualRange = {
        min: axis.minimum != null ? axis.minimum : minimum,
        max: axis.maximum != null ? axis.maximum : maximum,
        interval: axis.interval != null ? axis.interval : interval,
        delta: axis.actualRange.delta
      };
    };
    Double3D2.prototype.findAdditional = function(axis, start, end, interval, size) {
      var minimum;
      var maximum;
      minimum = Math.floor(start / interval) * interval;
      maximum = Math.ceil(end / interval) * interval;
      if (axis.rangePadding === "Additional") {
        minimum -= interval;
        maximum += interval;
      }
      if (!isNullOrUndefined(axis.desiredIntervals)) {
        var delta = maximum - minimum;
        interval = this.calculateNumericNiceInterval(axis, delta, size);
      }
      this.updateActualRange(axis, minimum, maximum, interval);
    };
    Double3D2.prototype.findNormal = function(axis, start, end, interval, size) {
      var remaining;
      var minimum;
      var maximum;
      var startValue = start;
      if (start < 0) {
        startValue = 0;
        minimum = start + start * 0.05;
        remaining = interval + minimum % interval;
        if (0.365 * interval >= remaining) {
          minimum -= interval;
        }
        if (minimum % interval < 0) {
          minimum = minimum - interval - minimum % interval;
        }
      } else {
        minimum = start < 5 / 6 * end ? 0 : start - (end - start) * 0.5;
        if (minimum % interval > 0) {
          minimum -= minimum % interval;
        }
      }
      maximum = end > 0 ? end + (end - startValue) * 0.05 : end - (end - startValue) * 0.05;
      remaining = interval - maximum % interval;
      if (0.365 * interval >= remaining) {
        maximum += interval;
      }
      if (maximum % interval > 0) {
        maximum = maximum + interval - maximum % interval;
      }
      axis.doubleRange = new DoubleRange2(minimum, maximum);
      if (minimum === 0 || minimum < 0 && maximum < 0) {
        interval = this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);
        maximum = Math.ceil(maximum / interval) * interval;
      }
      this.updateActualRange(axis, minimum, maximum, interval);
    };
    Double3D2.prototype.calculateVisibleRange = function(size, axis) {
      axis.visibleRange = {
        max: axis.actualRange.max,
        min: axis.actualRange.min,
        delta: axis.actualRange.delta,
        interval: axis.actualRange.interval
      };
      if (axis.maximum && axis.orientation === "Vertical" && axis.rangePadding === "Auto") {
        var duplicateTempInterval = void 0;
        var tempInterval = axis.visibleRange.min;
        for (; tempInterval <= axis.visibleRange.max && duplicateTempInterval !== tempInterval; tempInterval += axis.visibleRange.interval) {
          duplicateTempInterval = tempInterval;
        }
        if (duplicateTempInterval < axis.visibleRange.max) {
          axis.visibleRange.max = duplicateTempInterval + axis.visibleRange.interval;
        }
      }
      axis.triggerRangeRender(this.chart, axis.visibleRange.min, axis.visibleRange.max, axis.visibleRange.interval);
    };
    Double3D2.prototype.calculateVisibleLabels = function(axis, chart) {
      axis.visibleLabels = [];
      var tempInterval = axis.visibleRange.min;
      var labelStyle;
      var format = this.getFormat(axis);
      var isCustom = format.match("{value}") !== null;
      var intervalDigits = 0;
      var formatDigits = 0;
      if (axis.labelFormat && axis.labelFormat.indexOf("n") > -1) {
        formatDigits = parseInt(axis.labelFormat.substring(1, axis.labelFormat.length), 10);
      }
      axis.format = chart.intl.getNumberFormat({
        format: isCustom ? "" : format,
        useGrouping: chart.useGroupingSeparator
      });
      axis.startLabel = axis.format(axis.visibleRange.min);
      axis.endLabel = axis.format(axis.visibleRange.max);
      if (axis.visibleRange.interval && (axis.visibleRange.interval + "").indexOf(".") >= 0) {
        intervalDigits = (axis.visibleRange.interval + "").split(".")[1].length;
      }
      var duplicateTempInterval;
      for (; tempInterval <= axis.visibleRange.max && duplicateTempInterval !== tempInterval; tempInterval += axis.visibleRange.interval) {
        duplicateTempInterval = tempInterval;
        labelStyle = extend({}, getValue("properties", axis.labelStyle), null, true);
        if (withIn(tempInterval, axis.visibleRange)) {
          triggerLabelRender(chart, tempInterval, this.formatValue(axis, isCustom, format, tempInterval), labelStyle, axis);
        }
      }
      if (tempInterval && (tempInterval + "").indexOf(".") >= 0 && (tempInterval + "").split(".")[1].length > 10) {
        tempInterval = (tempInterval + "").split(".")[1].length > (formatDigits || intervalDigits) ? +tempInterval.toFixed(formatDigits || intervalDigits) : tempInterval;
        if (tempInterval <= axis.visibleRange.max) {
          triggerLabelRender(chart, tempInterval, this.formatValue(axis, isCustom, format, tempInterval), labelStyle, axis);
        }
      }
      if (axis.getMaxLabelWidth) {
        axis.getMaxLabelWidth(this.chart);
      }
    };
    Double3D2.prototype.getFormat = function(axis) {
      if (axis.labelFormat) {
        if (axis.labelFormat.indexOf("p") === 0 && axis.labelFormat.indexOf("{value}") === -1 && axis.isStack100) {
          return "{value}%";
        }
        return axis.labelFormat;
      }
      return axis.isStack100 ? "{value}%" : "";
    };
    Double3D2.prototype.formatValue = function(axis, isCustom, format, tempInterval) {
      var labelValue = !(tempInterval % 1) ? tempInterval : Number(tempInterval.toLocaleString().split(",").join(""));
      return isCustom ? format.replace("{value}", axis.format(labelValue)) : format ? axis.format(tempInterval) : axis.format(labelValue);
    };
    Double3D2.prototype.getModuleName = function() {
      return "Double3D";
    };
    return Double3D2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart3d/axis/axis.js
var __extends99 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate26 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Chart3DRow = (
  /** @class */
  function(_super) {
    __extends99(Chart3DRow2, _super);
    function Chart3DRow2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.axes = [];
      _this.nearSizes = [];
      _this.farSizes = [];
      return _this;
    }
    Chart3DRow2.prototype.computeSize = function(axis, chart) {
      var width = 0;
      var innerPadding = 5;
      if (axis.visible && axis.internalVisibility) {
        width += axis.majorTickLines.height + axis.findLabelSize(innerPadding, chart);
      }
      if (axis.isAxisOpposedPosition) {
        this.farSizes.push(width);
      } else {
        this.nearSizes.push(width);
      }
    };
    __decorate26([Property("100%")], Chart3DRow2.prototype, "height", void 0);
    return Chart3DRow2;
  }(ChildProperty)
);
var Chart3DColumn = (
  /** @class */
  function(_super) {
    __extends99(Chart3DColumn2, _super);
    function Chart3DColumn2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.axes = [];
      _this.nearSizes = [];
      _this.farSizes = [];
      return _this;
    }
    Chart3DColumn2.prototype.computeSize = function(axis, chart) {
      var height = 0;
      var innerPadding = 5;
      if (axis.visible && axis.internalVisibility) {
        height += axis.majorTickLines.height + axis.findLabelSize(innerPadding, chart);
      }
      if (axis.isAxisOpposedPosition) {
        this.farSizes.push(height);
      } else {
        this.nearSizes.push(height);
      }
    };
    __decorate26([Property("100%")], Chart3DColumn2.prototype, "width", void 0);
    return Chart3DColumn2;
  }(ChildProperty)
);
var Chart3DMajorGridLines = (
  /** @class */
  function(_super) {
    __extends99(Chart3DMajorGridLines2, _super);
    function Chart3DMajorGridLines2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate26([Property(1)], Chart3DMajorGridLines2.prototype, "width", void 0);
    __decorate26([Property(null)], Chart3DMajorGridLines2.prototype, "color", void 0);
    return Chart3DMajorGridLines2;
  }(ChildProperty)
);
var Chart3DMinorGridLines = (
  /** @class */
  function(_super) {
    __extends99(Chart3DMinorGridLines2, _super);
    function Chart3DMinorGridLines2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate26([Property(0.7)], Chart3DMinorGridLines2.prototype, "width", void 0);
    __decorate26([Property(null)], Chart3DMinorGridLines2.prototype, "color", void 0);
    return Chart3DMinorGridLines2;
  }(ChildProperty)
);
var Chart3DMajorTickLines = (
  /** @class */
  function(_super) {
    __extends99(Chart3DMajorTickLines2, _super);
    function Chart3DMajorTickLines2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate26([Property(0)], Chart3DMajorTickLines2.prototype, "width", void 0);
    __decorate26([Property(5)], Chart3DMajorTickLines2.prototype, "height", void 0);
    __decorate26([Property(null)], Chart3DMajorTickLines2.prototype, "color", void 0);
    return Chart3DMajorTickLines2;
  }(ChildProperty)
);
var Chart3DMinorTickLines = (
  /** @class */
  function(_super) {
    __extends99(Chart3DMinorTickLines2, _super);
    function Chart3DMinorTickLines2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate26([Property(0)], Chart3DMinorTickLines2.prototype, "width", void 0);
    __decorate26([Property(5)], Chart3DMinorTickLines2.prototype, "height", void 0);
    __decorate26([Property(null)], Chart3DMinorTickLines2.prototype, "color", void 0);
    return Chart3DMinorTickLines2;
  }(ChildProperty)
);
var Chart3DAxis = (
  /** @class */
  function(_super) {
    __extends99(Chart3DAxis2, _super);
    function Chart3DAxis2(parent, propName, defaultValue, isArray) {
      var _this = _super.call(this, parent, propName, defaultValue, isArray) || this;
      _this.visibleLabels = [];
      _this.series = [];
      _this.rect = new Rect(void 0, void 0, 0, 0);
      _this.isStack100 = false;
      _this.updatedRect = null;
      _this.isIntervalInDecimal = true;
      _this.intervalDivs = [10, 5, 2, 1];
      _this.titleCollection = [];
      _this.titleSize = new Size(0, 0);
      _this.internalVisibility = true;
      _this.isRTLEnabled = false;
      _this.angle = _this.labelRotation;
      return _this;
    }
    Chart3DAxis2.prototype.findLabelSize = function(innerPadding, chart) {
      var titleSize = 0;
      var isHorizontal = this.orientation === "Horizontal";
      if (this.title) {
        var angle = this.titleRotation;
        if (isNullOrUndefined(angle)) {
          this.titleSize = measureText(this.title, this.titleStyle, chart.themeStyle.axisTitleFont);
          titleSize = this.titleSize.height + innerPadding;
        } else {
          this.titleSize = rotateTextSize(this.titleStyle, this.title, angle, chart, chart.themeStyle.axisTitleFont);
          titleSize = (this.orientation === "Vertical" ? this.titleSize.width : this.titleSize.height) + innerPadding;
        }
        if (this.rect.width || this.rect.height) {
          var length_1 = isHorizontal ? this.rect.width : this.rect.height;
          this.titleCollection = getTitle(this.title, this.titleStyle, length_1, chart.enableRtl, chart.themeStyle.axisTitleFont);
          titleSize = titleSize * this.titleCollection.length;
        }
      }
      var labelSize = titleSize + innerPadding + this.titlePadding + this.labelPadding + (this.orientation === "Vertical" ? this.maxLabelSize.width : this.maxLabelSize.height);
      return labelSize;
    };
    Chart3DAxis2.prototype.triggerRangeRender = function(chart, minimum, maximum, interval) {
      var argsData = {
        cancel: false,
        axis: this,
        minimum,
        maximum,
        interval
      };
      chart.trigger(axisRangeCalculated, argsData);
      if (!argsData.cancel) {
        this.visibleRange = {
          min: argsData.minimum,
          max: argsData.maximum,
          interval: argsData.interval,
          delta: argsData.maximum - argsData.minimum
        };
      }
    };
    Chart3DAxis2.prototype.getRangePadding = function(chart) {
      var padding = this.rangePadding;
      if (padding !== "Auto") {
        return padding;
      }
      switch (this.orientation) {
        case "Horizontal":
          if (chart.requireInvertedAxis) {
            padding = this.isStack100 ? "Round" : "Normal";
          } else {
            padding = "None";
          }
          break;
        case "Vertical":
          if (!chart.requireInvertedAxis) {
            padding = this.isStack100 ? "Round" : "Normal";
          } else {
            padding = "None";
          }
          break;
      }
      return padding;
    };
    Chart3DAxis2.prototype.getMaxLabelWidth = function(chart) {
      var pointX;
      var previousEnd = 0;
      var isIntersect = false;
      var isAxisLabelBreak;
      this.angle = this.labelRotation;
      this.maxLabelSize = new Size(0, 0);
      var action = this.labelIntersectAction;
      var label;
      for (var i = 0, len = this.visibleLabels.length; i < len; i++) {
        label = this.visibleLabels[i];
        isAxisLabelBreak = isBreakLabel(label.originalText);
        if (isAxisLabelBreak) {
          label.size = measureText(label.originalText.replace(/<br>/g, " "), this.labelStyle, chart.themeStyle.axisLabelFont);
          label.breakLabelSize = measureText(this.enableTrim ? label.text.join("<br>") : label.originalText, this.labelStyle, chart.themeStyle.axisLabelFont);
        } else {
          label.size = measureText(label.text, this.labelStyle, chart.themeStyle.axisLabelFont);
        }
        var width = isAxisLabelBreak ? label.breakLabelSize.width : label.size.width;
        if (width > this.maxLabelSize.width) {
          this.maxLabelSize.width = width;
          this.rotatedLabel = label.text;
        }
        var height = isAxisLabelBreak ? label.breakLabelSize.height : label.size.height;
        if (height > this.maxLabelSize.height) {
          this.maxLabelSize.height = height;
        }
        if (isAxisLabelBreak) {
          label.text = this.enableTrim ? label.text : label.originalText.split("<br>");
        }
        if (action === "None" || action === "Hide" || action === "Trim") {
          continue;
        }
        if ((action !== "None" || this.angle % 360 === 0) && this.orientation === "Horizontal" && this.rect.width > 0 && !isIntersect) {
          var width1 = isAxisLabelBreak ? label.breakLabelSize.width : label.size.width;
          pointX = valueToCoefficients(label.value, this) * this.rect.width + this.rect.x;
          pointX -= width1 / 2;
          if (this.edgeLabelPlacement === "Shift") {
            if (i === 0 && pointX < this.rect.x) {
              pointX = this.rect.x;
            }
            if (i === this.visibleLabels.length - 1 && pointX + width1 > this.rect.x + this.rect.width) {
              pointX = this.rect.x + this.rect.width - width1;
            }
          }
          switch (action) {
            case "MultipleRows":
              if (i > 0) {
                this.findMultiRows(i, pointX, label, isAxisLabelBreak);
              }
              break;
            case "Rotate45":
            case "Rotate90":
              if (i > 0 && (!this.isAxisInverse ? pointX <= previousEnd : pointX + width1 >= previousEnd)) {
                this.angle = action === "Rotate45" ? 45 : 90;
                isIntersect = true;
              }
              break;
            default: {
              if (isAxisLabelBreak) {
                var result = void 0;
                var result1 = [];
                var str = void 0;
                for (var index = 0; index < label.text.length; index++) {
                  result = textWrap(label.text[index], this.rect.width / this.visibleLabels.length, this.labelStyle, chart.enableRtl, null, null, chart.themeStyle.axisLabelFont);
                  if (result.length > 1) {
                    for (var j = 0; j < result.length; j++) {
                      str = result[j];
                      result1.push(str);
                    }
                  } else {
                    result1.push(result[0]);
                  }
                }
                label.text = result1;
              } else {
                label.text = textWrap(label.text, this.rect.width / this.visibleLabels.length, this.labelStyle, chart.enableRtl, null, null, chart.themeStyle.axisLabelFont);
              }
              var height_1 = label.size.height * label.text.length;
              if (height_1 > this.maxLabelSize.height) {
                this.maxLabelSize.height = height_1;
              }
              break;
            }
          }
          previousEnd = this.isAxisInverse ? pointX : pointX + width1;
        }
      }
      if (this.angle !== 0 && this.orientation === "Horizontal") {
        this.rotatedLabel = isNullOrUndefined(this.rotatedLabel) ? "" : this.rotatedLabel;
        var isHorizontalAngle = this.angle === -360 || this.angle === 0 || this.angle === -180 || this.angle === 180 || this.angle === 360;
        if (!isHorizontalAngle && isBreakLabel(this.rotatedLabel)) {
          this.maxLabelSize = new Size(this.maxLabelSize.height, this.maxLabelSize.width);
        }
        this.maxLabelSize = rotateTextSize(this.labelStyle, this.rotatedLabel, this.angle, chart, chart.themeStyle.axisLabelFont);
      } else if (this.angle !== 0 && this.orientation === "Vertical") {
        this.rotatedLabel = isNullOrUndefined(this.rotatedLabel) ? "" : this.rotatedLabel;
        var isHorizontalAngle = this.angle === -360 || this.angle === 0 || this.angle === -180 || this.angle === 180 || this.angle === 360;
        if (!isHorizontalAngle && isBreakLabel(this.rotatedLabel)) {
          this.maxLabelSize = new Size(this.maxLabelSize.height, this.maxLabelSize.width);
        }
        this.maxLabelSize = rotateTextSize(this.labelStyle, this.rotatedLabel, this.angle, chart, chart.themeStyle.axisLabelFont);
      }
    };
    Chart3DAxis2.prototype.findMultiRows = function(length, currentX, currentLabel, isBreakLabels) {
      var label;
      var pointX;
      var width2;
      var store = [];
      var isMultiRows;
      for (var i = length - 1; i >= 0; i--) {
        label = this.visibleLabels[i];
        width2 = isBreakLabels ? label.breakLabelSize.width : label.size.width;
        pointX = valueToCoefficients(label.value, this) * this.rect.width + this.rect.x;
        isMultiRows = !this.isAxisInverse ? currentX < pointX + width2 * 0.5 : currentX + currentLabel.size.width > pointX - width2 * 0.5;
        if (isMultiRows) {
          store.push(label.index);
          currentLabel.index = currentLabel.index > label.index ? currentLabel.index : label.index + 1;
        } else {
          currentLabel.index = store.indexOf(label.index) > -1 ? currentLabel.index : label.index;
        }
      }
      var height = (isBreakLabels ? currentLabel.breakLabelSize.height : currentLabel.size.height) * currentLabel.index + 5 * (currentLabel.index - 1);
      if (height > this.maxLabelSize.height) {
        this.maxLabelSize.height = height;
      }
    };
    Chart3DAxis2.prototype.getModule = function(chart) {
      if (this.valueType === "Double") {
        this.baseModule = new Double3D(chart);
      } else {
        this.baseModule = chart[firstToLowerCase(this.valueType) + "3DModule"];
      }
    };
    Chart3DAxis2.prototype.setIsInversedAndOpposedPosition = function() {
      this.isAxisOpposedPosition = this.opposedPosition || this.isRTLEnabled && this.orientation === "Vertical";
      this.isAxisInverse = this.isInversed || this.isRTLEnabled && this.orientation === "Horizontal";
    };
    __decorate26([Complex({
      fontFamily: null,
      size: "12px",
      fontStyle: "Normal",
      fontWeight: "400",
      color: null
    }, Chart3DTextFont)], Chart3DAxis2.prototype, "labelStyle", void 0);
    __decorate26([Property("")], Chart3DAxis2.prototype, "title", void 0);
    __decorate26([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, Chart3DTextFont)], Chart3DAxis2.prototype, "titleStyle", void 0);
    __decorate26([Property("")], Chart3DAxis2.prototype, "labelFormat", void 0);
    __decorate26([Property("")], Chart3DAxis2.prototype, "skeleton", void 0);
    __decorate26([Property("DateTime")], Chart3DAxis2.prototype, "skeletonType", void 0);
    __decorate26([Property(0)], Chart3DAxis2.prototype, "plotOffset", void 0);
    __decorate26([Property(null)], Chart3DAxis2.prototype, "plotOffsetLeft", void 0);
    __decorate26([Property(null)], Chart3DAxis2.prototype, "plotOffsetTop", void 0);
    __decorate26([Property(null)], Chart3DAxis2.prototype, "plotOffsetRight", void 0);
    __decorate26([Property(null)], Chart3DAxis2.prototype, "plotOffsetBottom", void 0);
    __decorate26([Property(false)], Chart3DAxis2.prototype, "isIndexed", void 0);
    __decorate26([Property(10)], Chart3DAxis2.prototype, "logBase", void 0);
    __decorate26([Property(0)], Chart3DAxis2.prototype, "columnIndex", void 0);
    __decorate26([Property(0)], Chart3DAxis2.prototype, "rowIndex", void 0);
    __decorate26([Property(1)], Chart3DAxis2.prototype, "span", void 0);
    __decorate26([Property(null)], Chart3DAxis2.prototype, "desiredIntervals", void 0);
    __decorate26([Property(3)], Chart3DAxis2.prototype, "maximumLabels", void 0);
    __decorate26([Property(false)], Chart3DAxis2.prototype, "opposedPosition", void 0);
    __decorate26([Property("Auto")], Chart3DAxis2.prototype, "rangePadding", void 0);
    __decorate26([Property("Double")], Chart3DAxis2.prototype, "valueType", void 0);
    __decorate26([Property("None")], Chart3DAxis2.prototype, "edgeLabelPlacement", void 0);
    __decorate26([Property("Auto")], Chart3DAxis2.prototype, "intervalType", void 0);
    __decorate26([Property("OnTicks")], Chart3DAxis2.prototype, "labelPlacement", void 0);
    __decorate26([Property("")], Chart3DAxis2.prototype, "name", void 0);
    __decorate26([Property(true)], Chart3DAxis2.prototype, "visible", void 0);
    __decorate26([Property(0)], Chart3DAxis2.prototype, "minorTicksPerInterval", void 0);
    __decorate26([Property(0)], Chart3DAxis2.prototype, "labelRotation", void 0);
    __decorate26([Property(null)], Chart3DAxis2.prototype, "titleRotation", void 0);
    __decorate26([Property(null)], Chart3DAxis2.prototype, "minimum", void 0);
    __decorate26([Property(null)], Chart3DAxis2.prototype, "maximum", void 0);
    __decorate26([Property(null)], Chart3DAxis2.prototype, "interval", void 0);
    __decorate26([Property(34)], Chart3DAxis2.prototype, "maximumLabelWidth", void 0);
    __decorate26([Property(false)], Chart3DAxis2.prototype, "enableTrim", void 0);
    __decorate26([Property(5)], Chart3DAxis2.prototype, "labelPadding", void 0);
    __decorate26([Property(5)], Chart3DAxis2.prototype, "titlePadding", void 0);
    __decorate26([Complex({}, Chart3DMajorTickLines)], Chart3DAxis2.prototype, "majorTickLines", void 0);
    __decorate26([Complex({}, Chart3DMinorTickLines)], Chart3DAxis2.prototype, "minorTickLines", void 0);
    __decorate26([Complex({}, Chart3DMajorGridLines)], Chart3DAxis2.prototype, "majorGridLines", void 0);
    __decorate26([Complex({}, Chart3DMinorGridLines)], Chart3DAxis2.prototype, "minorGridLines", void 0);
    __decorate26([Property(Browser.isDevice ? "Rotate45" : "Trim")], Chart3DAxis2.prototype, "labelIntersectAction", void 0);
    __decorate26([Property(false)], Chart3DAxis2.prototype, "isInversed", void 0);
    __decorate26([Property(true)], Chart3DAxis2.prototype, "startFromZero", void 0);
    return Chart3DAxis2;
  }(ChildProperty)
);
var Visible3DLabels = (
  /** @class */
  /* @__PURE__ */ function() {
    function Visible3DLabels2(text, value, labelStyle, originalText, size, breakLabelSize, index) {
      if (size === void 0) {
        size = new Size(0, 0);
      }
      if (breakLabelSize === void 0) {
        breakLabelSize = new Size(0, 0);
      }
      if (index === void 0) {
        index = 1;
      }
      this.text = text;
      this.originalText = originalText;
      this.value = value;
      this.labelStyle = labelStyle;
      this.size = size;
      this.breakLabelSize = breakLabelSize;
      this.index = index;
    }
    return Visible3DLabels2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart3d/series/chart-series.js
var __extends100 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate27 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Chart3DDataLabelSettings = (
  /** @class */
  function(_super) {
    __extends100(Chart3DDataLabelSettings2, _super);
    function Chart3DDataLabelSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate27([Property(false)], Chart3DDataLabelSettings2.prototype, "visible", void 0);
    __decorate27([Property(null)], Chart3DDataLabelSettings2.prototype, "name", void 0);
    __decorate27([Property("transparent")], Chart3DDataLabelSettings2.prototype, "fill", void 0);
    __decorate27([Property(null)], Chart3DDataLabelSettings2.prototype, "format", void 0);
    __decorate27([Property(1)], Chart3DDataLabelSettings2.prototype, "opacity", void 0);
    __decorate27([Property(0)], Chart3DDataLabelSettings2.prototype, "angle", void 0);
    __decorate27([Property(false)], Chart3DDataLabelSettings2.prototype, "enableRotation", void 0);
    __decorate27([Property("Middle")], Chart3DDataLabelSettings2.prototype, "position", void 0);
    __decorate27([Complex({
      width: null,
      color: null
    }, Border)], Chart3DDataLabelSettings2.prototype, "border", void 0);
    __decorate27([Complex({
      left: 5,
      right: 5,
      top: 5,
      bottom: 5
    }, Margin)], Chart3DDataLabelSettings2.prototype, "margin", void 0);
    __decorate27([Complex({
      size: null,
      color: null,
      fontStyle: null,
      fontWeight: null,
      fontFamily: null
    }, Chart3DTextFont)], Chart3DDataLabelSettings2.prototype, "font", void 0);
    __decorate27([Property(null)], Chart3DDataLabelSettings2.prototype, "template", void 0);
    return Chart3DDataLabelSettings2;
  }(ChildProperty)
);
var Chart3DEmptyPointSettings = (
  /** @class */
  function(_super) {
    __extends100(Chart3DEmptyPointSettings2, _super);
    function Chart3DEmptyPointSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate27([Property(null)], Chart3DEmptyPointSettings2.prototype, "fill", void 0);
    __decorate27([Property("Gap")], Chart3DEmptyPointSettings2.prototype, "mode", void 0);
    return Chart3DEmptyPointSettings2;
  }(ChildProperty)
);
var Chart3DPoint = (
  /** @class */
  /* @__PURE__ */ function() {
    function Chart3DPoint2() {
      this.symbolLocations = null;
      this.percentage = null;
      this.isSelect = false;
    }
    return Chart3DPoint2;
  }()
);
var Chart3DSeries = (
  /** @class */
  function(_super) {
    __extends100(Chart3DSeries2, _super);
    function Chart3DSeries2(parent, propName, defaultValue, isArray) {
      var _this = _super.call(this, parent, propName, defaultValue, isArray) || this;
      _this.currentViewData = [];
      _this.clipRect = new Rect(0, 0, 0, 0);
      _this.visibleSeriesCount = 0;
      _this.category = "Series";
      _this.isRectSeries = false;
      _this.all = false;
      return _this;
    }
    Chart3DSeries2.prototype.processJsonData = function() {
      var i = 0;
      var point = new Chart3DPoint();
      var xName = this.xName;
      var textMappingName = this instanceof Chart3DSeries2 && this.dataLabel.name ? this.dataLabel.name : "";
      var len = (this.currentViewData || []).length;
      this.points = [];
      this.xMin = Infinity;
      this.xMax = -Infinity;
      this.yMin = Infinity;
      this.yMax = -Infinity;
      this.sizeMax = -Infinity;
      if (this.xAxis.valueType === "Category") {
        while (i < len) {
          point = this.dataPoint(i, textMappingName, xName);
          this.pushCategoryData(point, i, point.x);
          this.pushData(point, i);
          this.setEmptyPoint(point, i);
          i++;
        }
      } else if (this.xAxis.valueType.indexOf("DateTime") > -1) {
        var option = {
          skeleton: "full",
          type: "dateTime"
        };
        var dateParser = this.chart.intl.getDateParser(option);
        var dateFormatter = this.chart.intl.getDateFormat(option);
        while (i < len) {
          point = this.dataPoint(i, textMappingName, xName);
          if (!isNullOrUndefined(point.x) && point.x !== "") {
            point.x = new Date(DataUtil.parse.parseJson({
              val: point.x
            }).val);
            if (this.xAxis.valueType === "DateTime") {
              point.xValue = Date.parse(point.x.toString());
            } else {
              this.pushCategoryData(point, i, Date.parse(dateParser(dateFormatter(point.x))).toString());
            }
            this.pushData(point, i);
            this.setEmptyPoint(point, i);
          } else {
            point.visible = false;
          }
          i++;
        }
      } else {
        while (i < len) {
          point = this.dataPoint(i, textMappingName, xName);
          point.xValue = point.x;
          this.pushData(point, i);
          this.setEmptyPoint(point, i);
          i++;
        }
      }
    };
    Chart3DSeries2.prototype.pushData = function(point, i) {
      point.index = i;
      point.yValue = point.y;
      point.series = this;
      this.xMin = Math.min(this.xMin, point.xValue);
      this.xMax = Math.max(this.xMax, point.xValue);
      this.xData.push(point.xValue);
    };
    Chart3DSeries2.prototype.dataPoint = function(i, textMappingName, xName) {
      this.points[i] = new Chart3DPoint();
      var point = this.points[i];
      var currentViewData = this.currentViewData[i];
      var getObjectValueByMappingString = this.get3DObjectValue;
      point.x = getObjectValueByMappingString(xName, currentViewData);
      point.interior = getObjectValueByMappingString(this.pointColorMapping, currentViewData);
      if (this instanceof Chart3DSeries2) {
        point.y = getObjectValueByMappingString(this.yName, currentViewData);
        point.size = getObjectValueByMappingString(this.size, currentViewData);
        point.text = getObjectValueByMappingString(textMappingName, currentViewData);
        point.tooltip = getObjectValueByMappingString(this.tooltipMappingName, currentViewData);
      }
      return point;
    };
    Chart3DSeries2.prototype.get3DObjectValue = function(mappingName, data) {
      return data[mappingName];
    };
    Chart3DSeries2.prototype.setEmptyPoint = function(point, i) {
      if (!this.findVisibility(point)) {
        point.visible = true;
        return null;
      }
      point.isEmpty = true;
      var series = this instanceof Chart3DSeries2 && this;
      var mode = series.emptyPointSettings.mode;
      switch (mode) {
        case "Zero":
          point.visible = true;
          point.y = point.yValue = this.yData[i] = 0;
          break;
        case "Average":
          if (this instanceof Chart3DSeries2) {
            point.y = point.yValue = this.yData[i] = this.getAverage(this.yName, i);
          }
          point.visible = true;
          break;
        case "Drop":
        case "Gap":
          this.yData[i] = null;
          point.visible = false;
          break;
      }
    };
    Chart3DSeries2.prototype.findVisibility = function(point) {
      this.setXYMinMax(point.yValue);
      this.yData.push(point.yValue);
      return isNullOrUndefined(point.x) || isNullOrUndefined(point.y) || isNaN(+point.y);
    };
    Chart3DSeries2.prototype.setXYMinMax = function(yValue) {
      var isLogAxis = this.yAxis.valueType === "Logarithmic" || this.xAxis.valueType === "Logarithmic";
      var isNegativeValue = yValue < 0 || this.yAxis.rangePadding === "None";
      var seriesMinY;
      if (!setRange(this.yAxis)) {
        seriesMinY = isLogAxis ? yValue : isNegativeValue ? yValue : 0;
      } else {
        seriesMinY = yValue;
      }
      this.yMin = isLogAxis ? Math.min(this.yMin, isNullOrUndefined(seriesMinY) || isNaN(seriesMinY) || seriesMinY === 0 || seriesMinY.toString() === "0" || seriesMinY.toString() === "" ? this.yMin : seriesMinY) : Math.min(this.yMin, isNullOrUndefined(seriesMinY) || isNaN(seriesMinY) ? this.yMin : seriesMinY);
      this.yMax = Math.max(this.yMax, isNullOrUndefined(yValue) || isNaN(yValue) ? this.yMax : yValue);
    };
    Chart3DSeries2.prototype.pushCategoryData = function(point, index, pointX) {
      if (this.chart.tooltip) {
        if (!this.visible) {
          return null;
        }
      }
      if (!this.xAxis.isIndexed) {
        if (this.xAxis.indexLabels[pointX] === void 0) {
          this.xAxis.indexLabels[pointX] = this.xAxis.labels.length;
          this.xAxis.labels.push(pointX);
        }
        point.xValue = this.xAxis.indexLabels[pointX];
      } else {
        if (this.xAxis.labels[index]) {
          this.xAxis.labels[index] += ", " + pointX;
        } else {
          this.xAxis.labels.push(pointX);
        }
        point.xValue = index;
      }
    };
    Chart3DSeries2.prototype.getAverage = function(member, i, data) {
      if (data === void 0) {
        data = this.currentViewData;
      }
      var previous = data[i - 1] ? data[i - 1][member] || 0 : 0;
      var next = data[i + 1] ? data[i + 1][member] || 0 : 0;
      return (previous + next) / 2;
    };
    Chart3DSeries2.prototype.refreshDataManager = function(chart) {
      var _this = this;
      this.chart = chart;
      var dataSource;
      var isAngular = "isAngular";
      if (chart[isAngular]) {
        dataSource = Object.keys(this.dataSource).length ? this.dataSource : chart.dataSource;
      } else {
        dataSource = this.dataSource || chart.dataSource;
      }
      if (!(dataSource instanceof DataManager) && isNullOrUndefined(this.query)) {
        this.dataManagerSuccess({
          result: dataSource,
          count: dataSource.length
        }, false);
        return;
      }
      var dataManager = this.dataModule.getData(this.dataModule.generateQuery().requiresCount());
      dataManager.then(function(e) {
        return _this.dataManagerSuccess(e);
      });
    };
    Chart3DSeries2.prototype.dataManagerSuccess = function(e, isRemoteData) {
      if (isRemoteData === void 0) {
        isRemoteData = true;
      }
      this.currentViewData = e.count ? e.result : [];
      this.chart.allowServerDataBinding = false;
      if (this instanceof Chart3DSeries2) {
        var argsData = {
          series: this,
          data: this.currentViewData,
          fill: this.interior
        };
        this.chart.trigger(seriesRender, argsData);
        this.interior = argsData.fill;
        this.currentViewData = argsData.data;
      }
      this.processJsonData();
      this.refreshChart(isRemoteData);
      this.currentViewData = null;
    };
    Chart3DSeries2.prototype.refreshChart = function(isRemoteData) {
      var chart = this.chart;
      if (this instanceof Chart3DSeries2) {
        chart.visibleSeriesCount += isRemoteData ? 1 : 0;
      }
      if (chart.visibleSeries.length === chart.visibleSeriesCount) {
        chart.refreshBound();
        chart.trigger("loaded", {
          chart
        });
      }
      if (this instanceof Chart3DSeries2) {
        chart.visibleSeriesCount += isRemoteData ? 0 : 1;
      }
    };
    Chart3DSeries2.prototype.refreshAxisLabel = function() {
      if (this.xAxis.valueType !== "Category") {
        return null;
      }
      this.xAxis.labels = [];
      this.xAxis.indexLabels = {};
      for (var _i = 0, _a = this.xAxis.series; _i < _a.length; _i++) {
        var item = _a[_i];
        if (item.visible) {
          item.xMin = Infinity;
          item.xMax = -Infinity;
          for (var _b = 0, _c = item.points; _b < _c.length; _b++) {
            var point = _c[_b];
            item.pushCategoryData(point, point.index, point.x);
            item.xMin = Math.min(item.xMin, point.xValue);
            item.xMax = Math.max(item.xMax, point.xValue);
          }
        }
      }
    };
    Chart3DSeries2.prototype.findSeriesCollection = function(column, row, isStack) {
      var seriesCollection = [];
      for (var _i = 0, _a = row.axes; _i < _a.length; _i++) {
        var rowAxis = _a[_i];
        for (var _b = 0, _c = rowAxis.series; _b < _c.length; _b++) {
          var rowSeries = _c[_b];
          for (var _d = 0, _e = column.axes; _d < _e.length; _d++) {
            var axis = _e[_d];
            for (var _f = 0, _g = axis.series; _f < _g.length; _f++) {
              var series = _g[_f];
              if (series === rowSeries && series.visible && this.rectSeriesInChart(series, isStack)) {
                seriesCollection.push(series);
              }
            }
          }
        }
      }
      return seriesCollection;
    };
    Chart3DSeries2.prototype.rectSeriesInChart = function(series, isStack) {
      var type = series.type.toLowerCase();
      return type.indexOf("column") !== -1 || type.indexOf("bar") !== -1 || isStack;
    };
    Chart3DSeries2.prototype.calculateStackedValue = function(isStacking100, chart) {
      for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {
        var columnItem = _a[_i];
        for (var _b = 0, _c = chart.rows; _b < _c.length; _b++) {
          var item = _c[_b];
          this.calculateStackingValues(this.findSeriesCollection(columnItem, item, true), isStacking100);
        }
      }
    };
    Chart3DSeries2.prototype.calculateStackingValues = function(seriesCollection, isStacking100) {
      var startValues;
      var endValues;
      var yValues = [];
      var lastPositive = [];
      var lastNegative = [];
      var stackingGroup;
      var lastValue;
      var value;
      var frequencies = [];
      if (isStacking100) {
        frequencies = this.findFrequencies(seriesCollection);
      }
      var groupingValues = [];
      var visiblePoints = [];
      for (var i = 0; i < seriesCollection.length; i++) {
        var series = seriesCollection[i];
        if (!groupingValues[series.stackingGroup]) {
          groupingValues[series.stackingGroup] = [];
          groupingValues[series.stackingGroup].push(series);
        } else if (groupingValues[series.stackingGroup] !== void 0) {
          groupingValues[series.stackingGroup].push(series);
        }
      }
      var keys = Object.keys(groupingValues);
      for (var k = 0; k < keys.length; k++) {
        var stackingSeies = [];
        var stackedValues = [];
        var seriesCollection_2 = groupingValues[keys[k]];
        for (var _i = 0, seriesCollection_1 = seriesCollection_2; _i < seriesCollection_1.length; _i++) {
          var series = seriesCollection_1[_i];
          if (series.type.indexOf("Stacking") !== -1) {
            stackingGroup = series.stackingGroup;
            if (!lastPositive[stackingGroup]) {
              lastPositive[stackingGroup] = [];
              lastNegative[stackingGroup] = [];
            }
            yValues = series.yData;
            startValues = [];
            endValues = [];
            stackingSeies.push(series);
            visiblePoints = getVisiblePoints(series);
            for (var j = 0, pointsLength = visiblePoints.length; j < pointsLength; j++) {
              lastValue = 0;
              value = +yValues[j];
              if (lastPositive[stackingGroup][visiblePoints[j].xValue] === void 0) {
                lastPositive[stackingGroup][visiblePoints[j].xValue] = 0;
              }
              if (lastNegative[stackingGroup][visiblePoints[j].xValue] === void 0) {
                lastNegative[stackingGroup][visiblePoints[j].xValue] = 0;
              }
              if (isStacking100) {
                value = value / frequencies[stackingGroup][visiblePoints[j].xValue] * 100;
                value = !isNaN(value) ? value : 0;
                visiblePoints[j].percentage = +value.toFixed(2);
              } else {
                stackedValues[j] = stackedValues[j] ? stackedValues[j] + Math.abs(value) : Math.abs(value);
              }
              if (value >= 0) {
                lastValue = lastPositive[stackingGroup][visiblePoints[j].xValue];
                lastPositive[stackingGroup][visiblePoints[j].xValue] += value;
              } else {
                lastValue = lastNegative[stackingGroup][visiblePoints[j].xValue];
                lastNegative[stackingGroup][visiblePoints[j].xValue] += value;
              }
              startValues.push(lastValue);
              endValues.push(value + lastValue);
              if (isStacking100 && endValues[j] > 100) {
                endValues[j] = 100;
              }
            }
            series.stackedValues = new StackValues(startValues, endValues);
            var isLogAxis = series.yAxis.valueType === "Logarithmic";
            var isColumnBarType = series.type.indexOf("Column") !== -1 || series.type.indexOf("Bar") !== -1;
            series.yMin = isLogAxis && isColumnBarType && series.yMin < 1 ? series.yMin : series.yAxis.startFromZero && series.type.indexOf("100") > -1 && series.yAxis.rangePadding === "Auto" && series.yMin >= 0 ? 0 : parseFloat(Math.min.apply(0, isStacking100 ? startValues : endValues).toFixed(10));
            series.yMax = Math.max.apply(0, endValues);
            if (series.yMin > Math.min.apply(0, endValues)) {
              series.yMin = isStacking100 ? -100 : isLogAxis && isColumnBarType && series.yMin < 1 ? series.yMin : Math.min.apply(0, endValues);
            }
            if (series.yMax < Math.max.apply(0, startValues)) {
              series.yMax = 0;
            }
          }
        }
        this.findPercentageOfStacking(stackingSeies, stackedValues, isStacking100);
      }
    };
    Chart3DSeries2.prototype.findPercentageOfStacking = function(stackingSeries, values, isStacking100) {
      for (var _i = 0, stackingSeries_1 = stackingSeries; _i < stackingSeries_1.length; _i++) {
        var item = stackingSeries_1[_i];
        if (isStacking100) {
          return null;
        }
        for (var _a = 0, _b = getVisiblePoints(item); _a < _b.length; _a++) {
          var point = _b[_a];
          point.percentage = Math.abs(+(point.y / values[point.index] * 100).toFixed(2));
        }
      }
    };
    Chart3DSeries2.prototype.findFrequencies = function(seriesCollection) {
      var frequencies = [];
      var stackingGroup;
      var visiblePoints = [];
      for (var _i = 0, seriesCollection_3 = seriesCollection; _i < seriesCollection_3.length; _i++) {
        var series = seriesCollection_3[_i];
        series.yAxis.isStack100 = series.type.indexOf("100") !== -1 ? true : false;
        visiblePoints = this.getVisiblePoints();
        if (series.type.indexOf("Stacking") !== -1) {
          stackingGroup = series.stackingGroup;
          if (!frequencies[stackingGroup]) {
            frequencies[stackingGroup] = [];
          }
          for (var j = 0, pointsLength = visiblePoints.length; j < pointsLength; j++) {
            if (frequencies[stackingGroup][visiblePoints[j].xValue] === void 0) {
              frequencies[stackingGroup][visiblePoints[j].xValue] = 0;
            }
            if (series.yData[j] > 0) {
              frequencies[stackingGroup][visiblePoints[j].xValue] += series.yData[j];
            } else {
              frequencies[stackingGroup][visiblePoints[j].xValue] -= series.yData[j];
            }
          }
        }
      }
      return frequencies;
    };
    Chart3DSeries2.prototype.renderSeries = function(chart) {
      var seriesType = firstToLowerCase(this.type);
      seriesType = seriesType.replace("100", "");
      if (chart[seriesType + "Series3DModule"]) {
        this.visiblePoints = this.getVisiblePoints();
        chart[seriesType + "Series3DModule"].draw(this, chart);
        if (this.dataLabel.visible && this.visible) {
          chart.dataLabel3DModule.render(this, this.chart, this.dataLabel);
        }
      }
    };
    Chart3DSeries2.prototype.getVisiblePoints = function() {
      var points = extend([], this.points, null, true);
      var tempPoints = [];
      var tempPoint;
      var pointIndex = 0;
      for (var i = 0; i < points.length; i++) {
        tempPoint = points[i];
        if (isNullOrUndefined(tempPoint.x)) {
          continue;
        } else {
          tempPoint.index = pointIndex++;
          tempPoints.push(tempPoint);
        }
      }
      return tempPoints;
    };
    Chart3DSeries2.prototype.setPointColor = function(point, color) {
      color = point.interior || color;
      return point.isEmpty ? this.emptyPointSettings.fill || color : color;
    };
    Chart3DSeries2.prototype.getYValues = function(points) {
      var values = [];
      var length = points.length;
      for (var i = 0; i < length; i++) {
        values.push(points[i].yValue);
      }
      return values;
    };
    Chart3DSeries2.prototype.getXValues = function(points) {
      var values = [];
      var length = points.length;
      for (var i = 0; i < length; i++) {
        values.push(points[i].xValue);
      }
      return values;
    };
    Chart3DSeries2.prototype.getSegmentDepth = function(series) {
      var actualDepth = this.chart.depth;
      var start;
      var end;
      if (this.chart.enableSideBySidePlacement) {
        var space = actualDepth / 4;
        start = space;
        end = space * (series.columnFacet === "Rectangle" ? 2.5 : 3);
      } else {
        var index = series.position - 1;
        var count = series.rectCount;
        var space = actualDepth / (count * 2 + count + 1);
        start = space + space * index * 3;
        end = start + space * (series.columnFacet === "Rectangle" ? 1.5 : 2);
      }
      return {
        start,
        end,
        delta: end - start
      };
    };
    Chart3DSeries2.prototype.getSideBySidePositions = function(series) {
      var chart = series.chart;
      for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {
        var columnItem = _a[_i];
        for (var _b = 0, _c = chart.rows; _b < _c.length; _b++) {
          var item = _c[_b];
          this.findRectPosition(series.findSeriesCollection(columnItem, item, false));
        }
      }
    };
    Chart3DSeries2.prototype.findRectPosition = function(seriesCollection) {
      var groupingValues = [];
      var vSeries = {
        rectCount: 0,
        position: null
      };
      for (var i = 0; i < seriesCollection.length; i++) {
        var value = seriesCollection[i];
        if (value.type.indexOf("Stacking") !== -1 || value.groupName !== "") {
          var groupName = value.type.indexOf("Stacking") !== -1 ? value.stackingGroup : value.type + value.groupName;
          if (groupName) {
            if (groupingValues[groupName] === void 0) {
              value.position = vSeries.rectCount;
              groupingValues[groupName] = vSeries.rectCount++;
            } else {
              value.position = groupingValues[groupName];
            }
          } else {
            if (vSeries.position === null) {
              vSeries.rectCount++;
              value.position = vSeries.rectCount;
              vSeries.position = vSeries.rectCount;
            } else {
              value.position = vSeries.position;
            }
          }
        } else {
          vSeries.rectCount++;
          value.position = vSeries.rectCount;
        }
      }
      for (var i = 0; i < seriesCollection.length; i++) {
        var value = seriesCollection[i];
        value.rectCount = vSeries.rectCount;
      }
    };
    Chart3DSeries2.prototype.getDoubleRange = function(start, end) {
      var mstart;
      var mend;
      if (start > end) {
        mstart = end;
        mend = start;
      } else {
        mstart = start;
        mend = end;
      }
      var mdelta = mend - mstart;
      var mmedian = (mstart + mend) / 2;
      var misEmpty = isNaN(mstart) || isNaN(mend);
      return {
        start: mstart,
        end: mend,
        delta: mdelta,
        median: mmedian,
        isEmpty: misEmpty
      };
    };
    Chart3DSeries2.prototype.setStyle = function(series) {
      var options = {
        interior: series.interior,
        opacity: series.opacity,
        dashArray: ""
      };
      return options;
    };
    Chart3DSeries2.prototype.getSideBySideInfo = function(series) {
      this.chart.currentSeries = series;
      var minimumPointDelta = getMinPointsDeltaValue(series.xAxis, this.chart.visibleSeries);
      var spacing = series.columnSpacing;
      var columnWidth = series.columnWidth === null || isNaN(+series.columnWidth) ? 0.7 : Math.min(series.columnWidth, 1);
      this.getSideBySidePositions(series);
      var pos = series.position;
      var all = series.rectCount;
      var width = minimumPointDelta * columnWidth;
      var loc = (pos - (series.stackingGroup === "" ? 1 : 0)) / all - 0.5;
      var range = this.getDoubleRange(loc, loc + 1 / all);
      if (!this.chart.enableSideBySidePlacement) {
        return this.getDoubleRange(-width / 2, width / 2);
      }
      if (!range.isEmpty) {
        range = this.getDoubleRange(range.start * width, range.end * width);
        var radius = spacing * range.delta;
        range = this.getDoubleRange(range.start + radius / 2, range.end - radius / 2);
      }
      return range;
    };
    __decorate27([Property("")], Chart3DSeries2.prototype, "xName", void 0);
    __decorate27([Property("")], Chart3DSeries2.prototype, "pointColorMapping", void 0);
    __decorate27([Property(true)], Chart3DSeries2.prototype, "visible", void 0);
    __decorate27([Property(null)], Chart3DSeries2.prototype, "xAxisName", void 0);
    __decorate27([Property(null)], Chart3DSeries2.prototype, "yAxisName", void 0);
    __decorate27([Complex({
      duration: 2e3
    }, Animation2)], Chart3DSeries2.prototype, "animation", void 0);
    __decorate27([Property(null)], Chart3DSeries2.prototype, "fill", void 0);
    __decorate27([Property("")], Chart3DSeries2.prototype, "dataSource", void 0);
    __decorate27([Property()], Chart3DSeries2.prototype, "query", void 0);
    __decorate27([Complex({}, Chart3DDataLabelSettings)], Chart3DSeries2.prototype, "dataLabel", void 0);
    __decorate27([Property("")], Chart3DSeries2.prototype, "name", void 0);
    __decorate27([Property("")], Chart3DSeries2.prototype, "yName", void 0);
    __decorate27([Property("")], Chart3DSeries2.prototype, "size", void 0);
    __decorate27([Property("")], Chart3DSeries2.prototype, "stackingGroup", void 0);
    __decorate27([Property(1)], Chart3DSeries2.prototype, "opacity", void 0);
    __decorate27([Property("")], Chart3DSeries2.prototype, "groupName", void 0);
    __decorate27([Property("Column")], Chart3DSeries2.prototype, "type", void 0);
    __decorate27([Property(true)], Chart3DSeries2.prototype, "enableTooltip", void 0);
    __decorate27([Property("")], Chart3DSeries2.prototype, "tooltipFormat", void 0);
    __decorate27([Property("")], Chart3DSeries2.prototype, "tooltipMappingName", void 0);
    __decorate27([Property("SeriesType")], Chart3DSeries2.prototype, "legendShape", void 0);
    __decorate27([Property("")], Chart3DSeries2.prototype, "legendImageUrl", void 0);
    __decorate27([Complex(null, Chart3DEmptyPointSettings)], Chart3DSeries2.prototype, "emptyPointSettings", void 0);
    __decorate27([Property(null)], Chart3DSeries2.prototype, "columnWidth", void 0);
    __decorate27([Property("Rectangle")], Chart3DSeries2.prototype, "columnFacet", void 0);
    __decorate27([Property(0.1)], Chart3DSeries2.prototype, "columnSpacing", void 0);
    return Chart3DSeries2;
  }(ChildProperty)
);

// node_modules/@syncfusion/ej2-charts/src/chart3d/user-interaction/tooltip.js
var __extends101 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate28 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Chart3DTooltipSettings = (
  /** @class */
  function(_super) {
    __extends101(Chart3DTooltipSettings2, _super);
    function Chart3DTooltipSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate28([Property(false)], Chart3DTooltipSettings2.prototype, "enable", void 0);
    __decorate28([Property(true)], Chart3DTooltipSettings2.prototype, "enableMarker", void 0);
    __decorate28([Property(null)], Chart3DTooltipSettings2.prototype, "fill", void 0);
    __decorate28([Property(null)], Chart3DTooltipSettings2.prototype, "header", void 0);
    __decorate28([Property(null)], Chart3DTooltipSettings2.prototype, "opacity", void 0);
    __decorate28([Complex({
      fontFamily: null,
      size: "12px",
      fontStyle: "Normal",
      fontWeight: null,
      color: null
    }, Font)], Chart3DTooltipSettings2.prototype, "textStyle", void 0);
    __decorate28([Property(null)], Chart3DTooltipSettings2.prototype, "format", void 0);
    __decorate28([Property(null)], Chart3DTooltipSettings2.prototype, "template", void 0);
    __decorate28([Property(true)], Chart3DTooltipSettings2.prototype, "enableAnimation", void 0);
    __decorate28([Property(300)], Chart3DTooltipSettings2.prototype, "duration", void 0);
    __decorate28([Property(1e3)], Chart3DTooltipSettings2.prototype, "fadeOutDuration", void 0);
    __decorate28([Property("Move")], Chart3DTooltipSettings2.prototype, "fadeOutMode", void 0);
    __decorate28([Property(false)], Chart3DTooltipSettings2.prototype, "enableTextWrap", void 0);
    __decorate28([Complex({
      color: null,
      width: null
    }, Border)], Chart3DTooltipSettings2.prototype, "border", void 0);
    __decorate28([Complex({
      x: null,
      y: null
    }, Location)], Chart3DTooltipSettings2.prototype, "location", void 0);
    return Chart3DTooltipSettings2;
  }(ChildProperty)
);
var Tooltip3D = (
  /** @class */
  function(_super) {
    __extends101(Tooltip3D2, _super);
    function Tooltip3D2(chart) {
      var _this = _super.call(this, chart) || this;
      _this.chart3D = chart;
      _this.commonXvalues = [];
      _this.addEventListener();
      return _this;
    }
    Tooltip3D2.prototype.addEventListener = function() {
      if (this.chart.isDestroyed) {
        return;
      }
      var cancelEvent = Browser.isPointer ? "pointerleave" : "mouseleave";
      this.chart.on(cancelEvent, this.mouseLeaveHandler, this);
      this.chart.on("tapHold", this.longPress, this);
      this.chart.on(Browser.touchMoveEvent, this.mouseMoveHandler, this);
      this.chart.on(Browser.touchEndEvent, this.mouseUpHandler, this);
    };
    Tooltip3D2.prototype.removeEventListener = function() {
      if (this.chart.isDestroyed) {
        return;
      }
      this.chart.off("pointerleave", this.mouseLeaveHandler);
      this.chart.off("tapHold", this.longPress);
      this.chart.off(Browser.touchMoveEvent, this.mouseLeaveHandler);
      this.chart.off(Browser.touchMoveEvent, this.mouseMoveHandler);
      this.chart.off(Browser.touchEndEvent, this.mouseUpHandler);
    };
    Tooltip3D2.prototype.mouseUpHandler = function(event2) {
      var _this = this;
      var chart = this.control;
      var data = this.get3dData(event2);
      if (chart.isTouch) {
        this.tooltip(event2);
        if (chart.tooltip.fadeOutMode === "Move") {
          this.removeTooltip(chart.tooltip.fadeOutDuration);
          clearTimeout(this.timerId);
          this.timerId = +setTimeout(function() {
            _this.removeBlurEffect();
          }, 500);
        }
        if (chart.startMove && chart.tooltip.fadeOutMode === "Move") {
          this.removeTooltip(2e3);
          this.removeBlurEffect();
        }
      } else if (!this.findData(data, this.previousPoints[0]) && chart.tooltip.fadeOutMode === "Click") {
        this.removeTooltip(0);
        this.removeBlurEffect();
      }
    };
    Tooltip3D2.prototype.mouseLeaveHandler = function() {
      this.removeTooltip(this.chart.tooltip.fadeOutDuration);
      this.removeBlurEffect();
    };
    Tooltip3D2.prototype.mouseMoveHandler = function(event2) {
      var chart = this.chart3D;
      chart.mouseX = chart.mouseX / chart.scaleX;
      chart.mouseY = chart.mouseY / chart.scaleY;
      if (!chart.disableTrackTooltip && !chart.rotateActivate) {
        if (!chart.isTouch || chart.startMove) {
          this.tooltip(event2);
        }
      }
    };
    Tooltip3D2.prototype.longPress = function() {
      return false;
    };
    Tooltip3D2.prototype.seriesStyles = function() {
      if (!this.styleAdded) {
        var style = document.createElement("style");
        style.setAttribute("id", this.element.id + "_ej2_chart_tooltip");
        style.innerText += " ." + this.element.id + "_ej2_tooltipDeselected { opacity:" + 0.2 + ";} ";
        document.body.appendChild(style);
        this.styleAdded = true;
      }
    };
    Tooltip3D2.prototype.tooltip = function(e) {
      var elementId = this.element.id + "_tooltip_svg";
      var svgElement = this.getElement(elementId);
      var isTooltip = svgElement && parseInt(svgElement.getAttribute("opacity"), 10) > 0;
      var tooltipDiv = this.getTooltipElement(isTooltip);
      if (this.chart3D.tooltip3DModule) {
        this.renderSeriesTooltip(this.chart3D, !isTooltip, tooltipDiv, e);
      }
    };
    Tooltip3D2.prototype.findHeader = function(data) {
      if (this.header === "") {
        return "";
      }
      this.header = this.parseTemplate(data.point, data.series, this.header, data.series.xAxis, data.series.yAxis);
      if (this.header.replace(/<b>/g, "").replace(/<\/b>/g, "").trim() !== "") {
        return this.header;
      }
      return "";
    };
    Tooltip3D2.prototype.renderSeriesTooltip = function(chart, isFirst, tooltipDiv, e) {
      var data = this.get3dData(e);
      this.currentPoints = [];
      if (this.findData(data, this.previousPoints[0]) && (this.previousPoints[0] && !(this.previousPoints[0].point.index === data.point.index && this.previousPoints[0].series.index === data.series.index && this.chart3D.isRemove) || !this.previousPoints[0])) {
        if (this.pushData(data, isFirst, tooltipDiv, true)) {
          this.triggerTooltipRender(data, isFirst, this.getTooltipText(data), this.findHeader(data));
        }
      } else if (!data.point && this.chart3D.isRemove && chart.tooltip.fadeOutMode === "Move") {
        this.removeTooltip(this.chart.tooltip.fadeOutDuration);
        this.removeBlurEffect();
        this.chart3D.isRemove = false;
      }
      if (data && data.point) {
        this.findMouseValue(data, chart);
      }
    };
    Tooltip3D2.prototype.triggerTooltipRender = function(point, isFirst, textCollection, headerText) {
      var _this = this;
      var tooltipTemplate;
      var argsData = {
        cancel: false,
        text: textCollection,
        headerText,
        template: tooltipTemplate,
        textStyle: this.textStyle,
        data: {
          pointX: point.point.x,
          pointY: point.point.y,
          seriesIndex: point.series.index,
          seriesName: point.series.name,
          pointIndex: point.point.index,
          pointText: point.point.text
        }
      };
      var borderWidth = this.chart.border.width;
      var padding = 3;
      var chartTooltipSuccess = function(argsData2) {
        if (!argsData2.cancel) {
          _this.headerText = argsData2.headerText;
          _this.formattedText = _this.formattedText.concat(argsData2.text);
          _this.text = _this.formattedText;
          _this.createTooltip(_this.chart, isFirst, _this.getSymbolLocation(point), point.series.clipRect, point.point, _this.chart3D.tooltip.enableMarker ? ["Circle"] : [], 0, new Rect(borderWidth, borderWidth, _this.chart.availableSize.width - padding - borderWidth * 2, _this.chart.availableSize.height - padding - borderWidth * 2), false, null, _this.getTemplateText(point), _this.template ? argsData2.template : "");
          _this.blurEffect(_this.chart3D.visibleSeries, point.series);
        } else {
          _this.removeHighlight();
          remove(_this.getElement(_this.element.id + "_tooltip"));
        }
        _this.chart3D.isRemove = true;
      };
      chartTooltipSuccess.bind(this, point);
      this.chart.trigger(tooltipRender, argsData, chartTooltipSuccess);
    };
    Tooltip3D2.prototype.blurEffect = function(visibleSeries, tooltipSeries) {
      if (!this.chart3D.highlight3DModule || this.chart3D.legendSettings.enableHighlight && this.chart3D.highlightMode === "None") {
        var pointElements_1 = [];
        for (var _i = 0, visibleSeries_1 = visibleSeries; _i < visibleSeries_1.length; _i++) {
          var series = visibleSeries_1[_i];
          if (series.visible && series.index !== tooltipSeries.index) {
            var elements = document.querySelectorAll('[id*="region-series-' + series.index + '"]');
            elements.forEach(function(el) {
              pointElements_1.push(el);
            });
          } else if (series.visible) {
            var tooltipElements = document.querySelectorAll('[id*="region-series-' + series.index + '"]');
            for (var i = 0; i < tooltipElements.length; i++) {
              var element = tooltipElements[i];
              var elementClassName = element.getAttribute("class") || "";
              if (elementClassName.indexOf(this.element.id + "_ej2_tooltipDeselected") > -1) {
                element.setAttribute("class", elementClassName.replace(this.element.id + "_ej2_tooltipDeselected", ""));
              }
              this.chart3D.stopElementAnimation(element, series.index);
            }
          }
        }
        for (var i = 0; i < pointElements_1.length; i++) {
          if (pointElements_1[i]) {
            var elementClassName = pointElements_1[i].getAttribute("class") || "";
            elementClassName += elementClassName !== "" ? " " : "";
            if (elementClassName.indexOf("_selection_") === -1 && elementClassName.indexOf(this.element.id + "_ej2_tooltipDeselected") === -1) {
              pointElements_1[i].setAttribute("class", elementClassName + this.element.id + "_ej2_tooltipDeselected");
            }
          }
        }
      }
    };
    Tooltip3D2.prototype.removeBlurEffect = function() {
      if (!this.chart3D.highlight3DModule || this.chart3D.legendSettings.enableHighlight && this.chart3D.highlightMode === "None") {
        var elements = document.getElementsByClassName(this.element.id + "_ej2_tooltipDeselected");
        while (elements.length > 0) {
          var element = elements[0];
          var elementClassName = element.getAttribute("class") || "";
          if (elementClassName.indexOf(this.element.id + "_ej2_tooltipDeselected") > -1) {
            element.setAttribute("class", elementClassName.replace(this.element.id + "_ej2_tooltipDeselected", ""));
            var index = parseFloat(element.id.split("-series-")[1].split("-point-")[0]);
            this.chart3D.highlightAnimation(element, index, 700, 0.2);
          }
        }
      }
    };
    Tooltip3D2.prototype.getSymbolLocation = function(point) {
      var rect = document.getElementById(this.element.id + "_svg").getBoundingClientRect();
      var upperElement;
      if (point.series.columnFacet === "Cylinder") {
        upperElement = document.querySelectorAll('[id*="' + this.element.id + "-svg-" + (point.series.type.indexOf("Column") === -1 ? "0" : "1") + "-region-series-" + point.series.index + "-point-" + point.point.index + '"]');
      } else {
        upperElement = document.querySelectorAll('[id*="' + this.element.id + "-svg-" + (point.series.type.indexOf("Column") === -1 ? "5" : "2") + "-region-series-" + point.series.index + "-point-" + point.point.index + '"]');
      }
      var tooltipElement;
      if (upperElement) {
        if (upperElement.length === 1) {
          tooltipElement = upperElement[0].getBoundingClientRect();
        } else {
          for (var i = 0; i < upperElement.length; i++) {
            var element = upperElement[i];
            if (element.id.indexOf("-" + point.point.index + "-back-front") !== -1 || element.id.indexOf("-" + point.point.index + "-front-back") !== -1) {
              tooltipElement = element.getBoundingClientRect();
              break;
            }
          }
        }
        if (upperElement.length !== 0 && !tooltipElement) {
          tooltipElement = upperElement[0].getBoundingClientRect();
        }
      }
      var location = new ChartLocation(this.chart3D.tooltip.location.x !== null ? this.chart3D.tooltip.location.x : tooltipElement.left - rect.left + tooltipElement.width / 2, this.chart3D.tooltip.location.y !== null ? this.chart3D.tooltip.location.y : tooltipElement.top - rect.top + tooltipElement.height / 2);
      return location;
    };
    Tooltip3D2.prototype.getTooltipText = function(pointData) {
      return this.parseTemplate(pointData.point, pointData.series, this.getFormat(this.chart3D, pointData.series), pointData.series.xAxis, pointData.series.yAxis);
    };
    Tooltip3D2.prototype.getTemplateText = function(data) {
      if (this.template) {
        var point = extend({}, data.point);
        point.x = this.formatPointValue(data.point, data.series.xAxis, "x", true, false);
        point.y = this.formatPointValue(data.point, data.series.yAxis, "y", false, true);
        return point;
      } else {
        return data.point;
      }
    };
    Tooltip3D2.prototype.findMouseValue = function(data, chart) {
      if (!chart.requireInvertedAxis) {
        this.valueX = valueToCoefficients(data.point.xValue, data.series.xAxis) * data.series.xAxis.rect.width + data.series.xAxis.rect.x;
        this.valueY = chart.mouseY;
      } else {
        this.valueY = (1 - valueToCoefficients(data.point.xValue, data.series.xAxis)) * data.series.xAxis.rect.height + data.series.xAxis.rect.y;
        this.valueX = chart.mouseX;
      }
    };
    Tooltip3D2.prototype.parseTemplate = function(point, series, format, xAxis, yAxis) {
      var val;
      var textValue;
      var regExp = RegExp;
      for (var _i = 0, _a = Object.keys(point); _i < _a.length; _i++) {
        var dataValue = _a[_i];
        val = new regExp("${point." + dataValue + "}", "gm");
        format = format.replace(val.source, this.formatPointValue(point, val.source === "${point.x}" ? xAxis : yAxis, dataValue, val.source === "${point.x}", val.source === "${point.y}"));
      }
      for (var _b = 0, _c = Object.keys(Object.getPrototypeOf(series)); _b < _c.length; _b++) {
        var dataValue = _c[_b];
        val = new regExp("${series." + dataValue + "}", "gm");
        textValue = series[dataValue];
        format = format.replace(val.source, textValue);
      }
      return format;
    };
    Tooltip3D2.prototype.formatPointValue = function(point, axis, dataValue, isXPoint, isYPoint) {
      var textValue;
      var customLabelFormat;
      var value;
      if (axis.valueType !== "Category" && isXPoint) {
        customLabelFormat = axis.labelFormat && axis.labelFormat.match("{value}") !== null;
        textValue = customLabelFormat ? axis.labelFormat.replace("{value}", axis.format(point[dataValue])) : axis.format(point[dataValue]);
      } else if (isYPoint && !isNullOrUndefined(point[dataValue])) {
        customLabelFormat = axis.labelFormat && axis.labelFormat.match("{value}") !== null;
        value = axis.format(point[dataValue]);
        textValue = customLabelFormat ? axis.labelFormat.replace("{value}", value) : value;
      } else {
        textValue = point[dataValue];
      }
      return textValue;
    };
    Tooltip3D2.prototype.getFormat = function(chart, series) {
      if (series.tooltipFormat) {
        return series.tooltipFormat;
      }
      if (!series.tooltipFormat && chart.tooltip.format) {
        return chart.tooltip.format;
      }
      var textX = "${point.x}";
      var format = textX;
      return format + " : " + (chart.theme.indexOf("Tailwind3") > -1 ? "${point.y}" : "<b>${point.y}</b>");
    };
    Tooltip3D2.prototype.get3dData = function(event2) {
      var chart = this.chart3D;
      var point = null;
      var series = null;
      var currentX = this.chart3D.mouseX;
      var currentY = this.chart3D.mouseY;
      var rect = this.chart3D.chartAxisLayoutPanel.seriesClipRect;
      var index;
      var pointIndex;
      var seriesIndex;
      var targetElement = event2.target;
      if (targetElement && currentX > rect.x && currentX < rect.x + rect.width && currentY > rect.y && currentY < rect.y + rect.height) {
        var nodeName = targetElement.nodeName;
        if ((nodeName === "shape" || nodeName === "path") && targetElement.id.indexOf("region") > 1) {
          index = targetElement.id.match(/(\d+)/g);
          pointIndex = parseInt(index[index.length - 1].toString(), 10);
          seriesIndex = parseInt(index[index.length - 2].toString(), 10);
        }
      }
      if (!isNullOrUndefined(seriesIndex)) {
        series = chart.visibleSeries[seriesIndex];
      }
      if (series) {
        if (series.visible) {
          point = series.points[pointIndex];
        }
        if (point) {
          return new Point3D(point, series);
        }
      }
      return new Point3D(point, series);
    };
    Tooltip3D2.prototype.findData = function(data, previous) {
      return data.point && (!previous || previous.point !== data.point || previous.point === data.point);
    };
    Tooltip3D2.prototype.getModuleName = function() {
      return "Tooltip3D";
    };
    Tooltip3D2.prototype.destroy = function() {
      this.removeEventListener();
    };
    return Tooltip3D2;
  }(BaseTooltip)
);

// node_modules/@syncfusion/ej2-charts/src/chart3d/legend/legend.js
var __extends102 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate29 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Chart3DLegendSettings = (
  /** @class */
  function(_super) {
    __extends102(Chart3DLegendSettings2, _super);
    function Chart3DLegendSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate29([Property(true)], Chart3DLegendSettings2.prototype, "visible", void 0);
    __decorate29([Property(null)], Chart3DLegendSettings2.prototype, "height", void 0);
    __decorate29([Property(null)], Chart3DLegendSettings2.prototype, "width", void 0);
    __decorate29([Complex({
      x: 0,
      y: 0
    }, Location)], Chart3DLegendSettings2.prototype, "location", void 0);
    __decorate29([Property("Auto")], Chart3DLegendSettings2.prototype, "position", void 0);
    __decorate29([Property("Series")], Chart3DLegendSettings2.prototype, "mode", void 0);
    __decorate29([Property(8)], Chart3DLegendSettings2.prototype, "padding", void 0);
    __decorate29([Property(null)], Chart3DLegendSettings2.prototype, "itemPadding", void 0);
    __decorate29([Property("Center")], Chart3DLegendSettings2.prototype, "alignment", void 0);
    __decorate29([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, Font)], Chart3DLegendSettings2.prototype, "textStyle", void 0);
    __decorate29([Property(10)], Chart3DLegendSettings2.prototype, "shapeHeight", void 0);
    __decorate29([Property(10)], Chart3DLegendSettings2.prototype, "shapeWidth", void 0);
    __decorate29([Complex({}, Border)], Chart3DLegendSettings2.prototype, "border", void 0);
    __decorate29([Complex({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, Margin)], Chart3DLegendSettings2.prototype, "margin", void 0);
    __decorate29([Complex({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, ContainerPadding)], Chart3DLegendSettings2.prototype, "containerPadding", void 0);
    __decorate29([Property(8)], Chart3DLegendSettings2.prototype, "shapePadding", void 0);
    __decorate29([Property("transparent")], Chart3DLegendSettings2.prototype, "background", void 0);
    __decorate29([Property(1)], Chart3DLegendSettings2.prototype, "opacity", void 0);
    __decorate29([Property(true)], Chart3DLegendSettings2.prototype, "toggleVisibility", void 0);
    __decorate29([Property(false)], Chart3DLegendSettings2.prototype, "enableHighlight", void 0);
    __decorate29([Property(null)], Chart3DLegendSettings2.prototype, "description", void 0);
    __decorate29([Property(3)], Chart3DLegendSettings2.prototype, "tabIndex", void 0);
    __decorate29([Property(null)], Chart3DLegendSettings2.prototype, "title", void 0);
    __decorate29([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, Font)], Chart3DLegendSettings2.prototype, "titleStyle", void 0);
    __decorate29([Property("Top")], Chart3DLegendSettings2.prototype, "titlePosition", void 0);
    __decorate29([Property("Normal")], Chart3DLegendSettings2.prototype, "textWrap", void 0);
    __decorate29([Property("Ellipsis")], Chart3DLegendSettings2.prototype, "textOverflow", void 0);
    __decorate29([Property(100)], Chart3DLegendSettings2.prototype, "maximumTitleWidth", void 0);
    __decorate29([Property(null)], Chart3DLegendSettings2.prototype, "maximumLabelWidth", void 0);
    __decorate29([Property(true)], Chart3DLegendSettings2.prototype, "enablePages", void 0);
    __decorate29([Property(false)], Chart3DLegendSettings2.prototype, "isInversed", void 0);
    __decorate29([Property(false)], Chart3DLegendSettings2.prototype, "reverse", void 0);
    return Chart3DLegendSettings2;
  }(ChildProperty)
);
var Legend3D = (
  /** @class */
  function(_super) {
    __extends102(Legend3D2, _super);
    function Legend3D2(chart) {
      var _this = _super.call(this, chart) || this;
      _this.library = _this;
      _this.addEventListener();
      return _this;
    }
    Legend3D2.prototype.addEventListener = function() {
      if (this.chart.isDestroyed) {
        return;
      }
      this.chart.on(Browser.touchMoveEvent, this.mouseMove, this);
      this.chart.on("click", this.click, this);
      this.chart.on(Browser.touchEndEvent, this.mouseEnd, this);
    };
    Legend3D2.prototype.removeEventListener = function() {
      if (this.chart.isDestroyed) {
        return;
      }
      this.chart.off(Browser.touchMoveEvent, this.mouseMove);
      this.chart.off("click", this.click);
      this.chart.off(Browser.touchEndEvent, this.mouseEnd);
    };
    Legend3D2.prototype.mouseMove = function(e) {
      if (this.chart.legendSettings.visible && !this.chart.isTouch) {
        this.move(e);
        if (this.chart.highlight3DModule && (this.chart.highlightMode !== "None" || this.chart.legendSettings.enableHighlight)) {
          var legendItemsId = [this.legendID + "_text_", this.legendID + "_shape_marker_", this.legendID + "_shape_", this.legendID + "_g_"];
          var targetId = e.target.id;
          var index = void 0;
          for (var _i = 0, legendItemsId_1 = legendItemsId; _i < legendItemsId_1.length; _i++) {
            var id = legendItemsId_1[_i];
            if (targetId.indexOf(id) > -1) {
              index = parseInt(targetId.split(id)[1], 10);
              this.chart.highlight3DModule.legendSelection(this.chart, index, e.target, e.type);
              break;
            }
          }
        }
      }
    };
    Legend3D2.prototype.mouseEnd = function(e) {
      if (this.chart.legendSettings.visible && this.chart.isTouch) {
        this.move(e);
      }
    };
    Legend3D2.prototype.getLegendOptions = function(visibleSeriesCollection, chart) {
      this.legendCollections = [];
      var seriesType;
      var fill;
      this.isRtlEnable = chart.enableRtl;
      this.isReverse = !this.isRtlEnable && chart.legendSettings.reverse;
      if (visibleSeriesCollection.length > 1) {
        this.legend.mode = "Series";
      }
      for (var _i = 0, visibleSeriesCollection_1 = visibleSeriesCollection; _i < visibleSeriesCollection_1.length; _i++) {
        var series = visibleSeriesCollection_1[_i];
        if (this.legend.mode === "Series") {
          seriesType = series.type;
          fill = series.pointColorMapping && series.points.length > 0 ? series.points[0].interior ? series.points[0].interior : series.interior : series.interior;
          this.legendCollections.push(new LegendOptions(series.name, fill, series.legendShape, series.visible, seriesType, series.legendImageUrl ? series.legendImageUrl : "", "None", false, null, null));
        } else if (this.legend.mode === "Point") {
          var _loop_1 = function(points2) {
            seriesType = series.type;
            fill = points2.interior ? points2.interior : series.interior;
            if (this_1.legendCollections.filter(function(i) {
              return i.text === points2.x.toString();
            }).length === 0) {
              this_1.legendCollections.push(new LegendOptions(points2.x.toString(), fill, series.legendShape, points2.visible, seriesType, "", "None", false));
            }
          };
          var this_1 = this;
          for (var _a = 0, _b = series.points; _a < _b.length; _a++) {
            var points = _b[_a];
            _loop_1(points);
          }
        }
      }
      if (this.isReverse) {
        this.legendCollections.reverse();
      }
    };
    Legend3D2.prototype.get3DLegendBounds = function(availableSize, legendBounds, legend) {
      this.calculateLegendTitle(legend, legendBounds);
      this.isTitle = legend.title ? true : false;
      this.chartRowCount = 1;
      this.rowHeights = [];
      this.columnHeights = [];
      this.pageHeights = [];
      var padding = legend.padding;
      var titlePosition = legend.titlePosition;
      var extraHeight = 0;
      var legendOption;
      var extraWidth = 0;
      var arrowWidth = this.arrowWidth;
      var arrowHeight = this.arrowHeight;
      var verticalArrowSpace = this.isVertical && !legend.enablePages ? arrowHeight : 0;
      var titleSpace = this.isTitle && titlePosition === "Top" ? this.legendTitleSize.height + this.fivePixel : 0;
      titleSpace = this.isTitle && this.isVertical && titlePosition !== "Top" ? this.legendTitleSize.height + this.fivePixel : titleSpace;
      if (!this.isVertical) {
        extraHeight = !legend.height ? availableSize.height / 100 * 5 : 0;
      } else {
        extraWidth = !legend.width ? availableSize.width / 100 * 5 : 0;
      }
      legendBounds.height += extraHeight;
      legendBounds.width += extraWidth;
      var shapeWidth = legend.shapeWidth;
      var shapePadding = legend.shapePadding;
      var maximumWidth = 0;
      var rowWidth = 0;
      var legendWidth = 0;
      var columnHeight = 0;
      var columnCount = 0;
      var rowCount = 0;
      var titlePlusArrowSpace = 0;
      var legendEventArgs;
      var render = false;
      this.maxItemHeight = Math.max(measureText("MeasureText", legend.textStyle, this.chart.themeStyle.legendLabelFont).height, legend.shapeHeight);
      for (var i = 0; i < this.legendCollections.length; i++) {
        legendOption = this.legendCollections[i];
        if (regSub.test(legendOption.text)) {
          legendOption.text = getUnicodeText(legendOption.text, regSub);
        }
        if (regSup.test(legendOption.text)) {
          legendOption.text = getUnicodeText(legendOption.text, regSup);
        }
        legendEventArgs = {
          fill: legendOption.fill,
          text: legendOption.text,
          shape: legendOption.shape,
          cancel: false
        };
        this.chart.trigger(legendRender, legendEventArgs);
        legendOption.render = !legendEventArgs.cancel;
        legendOption.text = legendEventArgs.text;
        legendOption.fill = legendEventArgs.fill;
        legendOption.shape = legendEventArgs.shape;
        legendOption.markerShape = "None";
        legendOption.textSize = measureText(legendOption.text, legend.textStyle, this.chart.themeStyle.legendLabelFont);
        shapeWidth = legendOption.text ? legend.shapeWidth : 0;
        shapePadding = legendOption.text ? legend.shapePadding : 0;
        if (legendOption.render && legendOption.text) {
          render = true;
          legendWidth = shapeWidth + shapePadding + (legend.maximumLabelWidth ? legend.maximumLabelWidth : legendOption.textSize.width) + (!this.isVertical ? i === 0 ? padding : this.itemPadding : padding);
          rowWidth = rowWidth + legendWidth;
          if (!legend.enablePages && !this.isVertical) {
            titlePlusArrowSpace = this.isTitle && titlePosition !== "Top" ? this.legendTitleSize.width + this.fivePixel : 0;
            titlePlusArrowSpace += arrowWidth;
          }
          this.getLegendHeight(legendOption, legend, legendBounds, rowWidth, this.maxItemHeight, padding);
          if (legendBounds.width < padding + rowWidth + titlePlusArrowSpace || this.isVertical) {
            maximumWidth = Math.max(maximumWidth, rowWidth + padding + titlePlusArrowSpace - (this.isVertical ? 0 : legendWidth));
            if (rowCount === 0 && legendWidth !== rowWidth) {
              rowCount = 1;
            }
            rowWidth = this.isVertical ? 0 : legendWidth;
            rowCount++;
            columnCount = 0;
            columnHeight = verticalArrowSpace;
          }
          var len = rowCount > 0 ? rowCount - 1 : 0;
          this.rowHeights[len] = Math.max(this.rowHeights[len] ? this.rowHeights[len] : 0, legendOption.textSize.height);
          this.columnHeights[columnCount] = (this.columnHeights[columnCount] ? this.columnHeights[columnCount] : 0) + legendOption.textSize.height + (this.isVertical ? i === 0 ? padding : this.itemPadding : padding);
          columnCount++;
        }
      }
      columnHeight = Math.max.apply(null, this.columnHeights) + padding + titleSpace;
      columnHeight = Math.max(columnHeight, this.maxItemHeight + padding + padding + titleSpace);
      this.isPaging = legendBounds.height < columnHeight;
      if (this.isPaging && !legend.enablePages) {
        if (this.isVertical) {
          columnHeight += columnHeight;
        } else {
          columnHeight = this.maxItemHeight + padding + padding + (titlePosition === "Top" ? titleSpace : 0);
        }
      }
      this.totalPages = rowCount;
      if (!this.isPaging && !this.isVertical) {
        rowWidth += this.isTitle && titlePosition !== "Top" ? this.fivePixel + this.legendTitleSize.width + this.fivePixel : 0;
      }
      if (render) {
        this.setBounds(Math.max(rowWidth + padding, maximumWidth), columnHeight, legend, legendBounds);
      } else {
        this.setBounds(0, 0, legend, legendBounds);
      }
    };
    Legend3D2.prototype.getLegendHeight = function(legendOption, legend, legendBounds, rowWidth, legendHeight, padding) {
      var legendWidth = legendOption.textSize.width;
      var textPadding = legend.shapePadding + padding * 2 + legend.shapeWidth;
      switch (legend.textWrap) {
        case "Wrap":
        case "AnyWhere":
          if (legendWidth > legend.maximumLabelWidth || legendWidth + rowWidth > legendBounds.width) {
            legendOption.textCollection = textWrap(legendOption.text, legend.maximumLabelWidth ? Math.min(legend.maximumLabelWidth, legendBounds.width - textPadding) : legendBounds.width - textPadding, legend.textStyle, this.chart.enableRtl, null, null, this.chart.themeStyle.legendLabelFont);
          } else {
            legendOption.textCollection.push(legendOption.text);
          }
          legendOption.textSize.height = legendHeight * legendOption.textCollection.length;
          break;
      }
    };
    Legend3D2.prototype.getRenderPoint = function(legendOption, start, textPadding, prevLegend, rect, count, firstLegend) {
      var padding = this.legend.padding;
      var textWidth = textPadding + (this.legend.maximumLabelWidth ? this.legend.maximumLabelWidth : prevLegend.textSize.width);
      var previousBound = prevLegend.location.x + (!this.isRtlEnable ? textWidth : -textWidth);
      if (this.isWithinBounds(previousBound, (this.legend.maximumLabelWidth ? this.legend.maximumLabelWidth : legendOption.textSize.width) + textPadding - this.itemPadding, rect) || this.isVertical) {
        legendOption.location.x = start.x;
        if (count !== firstLegend) {
          this.chartRowCount++;
        }
        legendOption.location.y = count === firstLegend ? prevLegend.location.y : prevLegend.location.y + (this.isVertical ? prevLegend.textSize.height : this.rowHeights[this.chartRowCount - 2]) + (this.isVertical ? this.itemPadding : padding);
      } else {
        legendOption.location.x = count === firstLegend ? prevLegend.location.x : previousBound;
        legendOption.location.y = prevLegend.location.y;
      }
      var availwidth = !this.isRtlEnable ? this.legendBounds.x + this.legendBounds.width - (legendOption.location.x + textPadding - this.itemPadding - this.legend.shapeWidth / 2) : legendOption.location.x - textPadding + this.itemPadding + this.legend.shapeWidth / 2 - this.legendBounds.x;
      if (!this.isVertical && this.isPaging && !this.legend.enablePages) {
        availwidth = this.legendBounds.width - legendOption.location.x - this.fivePixel;
      }
      availwidth = this.legend.maximumLabelWidth ? Math.min(this.legend.maximumLabelWidth, availwidth) : availwidth;
      if (this.legend.textOverflow === "Ellipsis" && this.legend.textWrap === "Normal") {
        legendOption.text = textTrim(+availwidth.toFixed(4), legendOption.text, this.legend.textStyle, this.chart.enableRtl, this.chart.themeStyle.legendLabelFont);
      }
    };
    Legend3D2.prototype.isWithinBounds = function(previousBound, textWidth, rect) {
      if (!this.isRtlEnable) {
        return previousBound + textWidth > rect.x + rect.width + this.legend.shapeWidth / 2;
      } else {
        return previousBound - textWidth < rect.x - this.legend.shapeWidth / 2;
      }
    };
    Legend3D2.prototype.LegendClick = function(index, event2) {
      var chart = this.chart;
      var seriesIndex = chart.legendSettings.mode === "Series" ? index : 0;
      var legendIndex = !this.isReverse ? index : this.legendCollections.length - 1 - index;
      var series = chart.visibleSeries[seriesIndex];
      var legend = this.legendCollections[legendIndex];
      var changeDetection = "isProtectedOnChange";
      if (chart.legendSettings.mode === "Series") {
        var legendClickArgs = {
          legendText: legend.text,
          legendShape: legend.shape,
          series,
          cancel: false
        };
        this.chart.trigger(legendClick, legendClickArgs);
        series.legendShape = legendClickArgs.legendShape;
        if (!legendClickArgs.cancel) {
          if (series.fill !== null) {
            chart.visibleSeries[index].interior = series.fill;
          }
          if (chart.legendSettings.toggleVisibility) {
            series.chart[changeDetection] = true;
            this.changeSeriesVisiblity(series, series.visible);
            legend.visible = series.visible;
            this.refreshLegendToggle(chart, series);
          } else if (chart.highlight3DModule) {
            chart.highlight3DModule.legendSelection(chart, index, event2.target, event2.type);
          } else if (chart.selection3DModule) {
            chart.selection3DModule.legendSelection(chart, index, event2.target, event2.type);
          }
          series.chart[changeDetection] = false;
        }
      } else if (chart.legendSettings.mode === "Point") {
        var point = series.points[index];
        var legendClickArgs = {
          legendText: legend.text,
          legendShape: legend.shape,
          series,
          cancel: false
        };
        this.chart.trigger(legendClick, legendClickArgs);
        if (chart.legendSettings.toggleVisibility && !legendClickArgs.cancel) {
          point.visible = !point.visible;
          var legendOption = this.legendCollections[index];
          legendOption.visible = point.visible;
          this.refreshLegendToggle(chart, series);
        }
      }
    };
    Legend3D2.prototype.refreshLegendToggle = function(chart, series) {
      var selectedDataIndexes = [];
      if (chart.selection3DModule) {
        selectedDataIndexes = extend([], chart.selection3DModule.selectedDataIndexes, null, true);
      }
      if (chart.svgObject.childNodes.length > 0) {
        while (chart.svgObject.lastChild) {
          chart.svgObject.removeChild(chart.svgObject.lastChild);
        }
        remove(chart.svgObject);
      }
      chart.animateSeries = false;
      removeElement2(getElement(chart.element.id + "_Secondary_Element").querySelectorAll(".ejSVGTooltip")[0]);
      this.redrawSeriesElements(series, chart);
      chart.removeSvg();
      chart.refreshAxis();
      series.refreshAxisLabel();
      this.refreshSeries(chart.visibleSeries);
      chart.polygons = [];
      chart.refreshBound();
      chart.trigger("loaded", {
        chart
      });
      if (selectedDataIndexes.length > 0) {
        chart.selection3DModule.selectedDataIndexes = selectedDataIndexes;
        chart.selection3DModule.redrawSelection(chart, chart.selectionMode);
      }
      if (chart.highlight3DModule && chart.highlightMode !== "None" || chart.legendSettings.enableHighlight) {
        chart.highlight3DModule.redrawSelection(chart, chart.highlightMode);
      }
      chart.redraw = false;
    };
    Legend3D2.prototype.changeSeriesVisiblity = function(series, visibility) {
      series.visible = !visibility;
      if (this.isSecondaryAxis(series.xAxis)) {
        series.xAxis.internalVisibility = series.xAxis.series.some(function(value) {
          return value.visible;
        });
      }
      if (this.isSecondaryAxis(series.yAxis)) {
        series.yAxis.internalVisibility = series.yAxis.series.some(function(value) {
          return value.visible;
        });
      }
    };
    Legend3D2.prototype.isSecondaryAxis = function(axis) {
      return this.chart.axes.indexOf(axis) > -1;
    };
    Legend3D2.prototype.redrawSeriesElements = function(series, chart) {
      if (!chart.redraw) {
        return null;
      }
      removeElement2(chart.element.id + "_Series_" + (series.index === void 0 ? series.category : series.index) + "_DataLabelCollections");
    };
    Legend3D2.prototype.refreshSeries = function(seriesCollection) {
      for (var _i = 0, seriesCollection_1 = seriesCollection; _i < seriesCollection_1.length; _i++) {
        var series = seriesCollection_1[_i];
        series.position = void 0;
      }
    };
    Legend3D2.prototype.click = function(event2) {
      if (!this.chart.legendSettings.visible) {
        return;
      }
      var targetId = event2.target.id.indexOf("_chart_legend_g_") > -1 ? event2.target.firstChild["id"] : event2.target.id;
      var legendItemsId = [this.legendID + "_text_", this.legendID + "_shape_marker_", this.legendID + "_shape_"];
      var seriesIndex;
      for (var _i = 0, legendItemsId_2 = legendItemsId; _i < legendItemsId_2.length; _i++) {
        var id = legendItemsId_2[_i];
        if (targetId.indexOf(id) > -1) {
          seriesIndex = parseInt(targetId.split(id)[1], 10);
          this.LegendClick(seriesIndex, event2);
          break;
        }
      }
      if (targetId.indexOf(this.legendID + "_pageup") > -1) {
        this.changePage(event2, true);
      } else if (targetId.indexOf(this.legendID + "_pagedown") > -1) {
        this.changePage(event2, false);
      }
    };
    Legend3D2.prototype.getModuleName = function() {
      return "Legend3D";
    };
    Legend3D2.prototype.destroy = function() {
      this.removeEventListener();
    };
    return Legend3D2;
  }(BaseLegend)
);

// node_modules/@syncfusion/ej2-charts/src/chart3d/chart3D.js
var __extends103 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate30 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Chart3D = (
  /** @class */
  function(_super) {
    __extends103(Chart3D2, _super);
    function Chart3D2(options, element) {
      var _this = _super.call(this, options, element) || this;
      _this.previousTargetId = "";
      _this.currentPointIndex = 0;
      _this.currentSeriesIndex = 0;
      _this.currentLegendIndex = 0;
      _this.animated = false;
      _this.isPointMouseDown = false;
      _this.visible = 0;
      _this.clickCount = 0;
      _this.maxPointCount = 0;
      _this.singleClickTimer = 0;
      _this.isRtlEnabled = false;
      _this.scaleX = 1;
      _this.scaleY = 1;
      _this.chartId = 57723;
      _this.isLegendClicked = false;
      _this.rotateActivate = false;
      _this.isRemove = false;
      _this.polygons = [];
      return _this;
    }
    Chart3D2.prototype.isIdHasSpecialCharacter = function(elementId) {
      var regex = /^[A-Za-z ]+$/;
      var numberRegex = /^[0-9 ]+$/;
      var childElementId = "";
      if (!regex.test(elementId)) {
        var start = 0;
        if (numberRegex.test(elementId[0])) {
          childElementId += "\\3" + elementId[0];
          start = 1;
        }
        for (var i = start; i < elementId.length; i++) {
          if (!regex.test(elementId[i]) && elementId.indexOf("-") === -1 && elementId.indexOf("_") === -1 && elementId.indexOf("\\") === -1 && !numberRegex.test(elementId[i])) {
            childElementId += "\\" + elementId[i];
          } else {
            childElementId += elementId[i];
          }
        }
        return childElementId;
      } else {
        return elementId;
      }
    };
    Chart3D2.prototype.preRender = function() {
      this.element.id = this.isIdHasSpecialCharacter(this.element.id);
      this.allowServerDataBinding = false;
      this.unWireEvents();
      this.initPrivateVariable();
      this.setCulture();
      this.wireEvents();
      this.element.setAttribute("dir", this.enableRtl ? "rtl" : "");
    };
    Chart3D2.prototype.initPrivateVariable = function() {
      this.delayRedraw = false;
      this.animateSeries = true;
      this.horizontalAxes = [];
      this.verticalAxes = [];
      this.polygons = [];
      this.vector = new Vector3D(0, 0, 0);
      this.wallRender = new WallRenderer();
      this.matrixObj = new Matrix3D();
      this.bspTreeObj = new BinaryTreeBuilder();
      this.polygon = new Polygon3D();
      this.graphics = new Graphics3D();
      this.transform3D = new ChartTransform3D();
      this.svg3DRenderer = new Svg3DRenderer();
      this.axisRender = new AxisRenderer();
      this.chart3DRender = new Chart3DRender();
      this.chartAxisLayoutPanel = new CartesianAxisLayoutPanel2(this);
      this.refreshAxis();
      this.refreshDefinition(this.rows);
      this.refreshDefinition(this.columns);
      if (this.tooltip3DModule) {
        this.tooltip3DModule.previousPoints = [];
      }
      this.element.setAttribute("role", "region");
      this.element.setAttribute("tabindex", "0");
      this.element.style.outline = "none";
      this.element.setAttribute("aria-label", this.description || this.title + ". Syncfusion interactive chart.");
      if (!this.element.classList.contains("e-chart-focused")) {
        this.element.setAttribute("class", this.element.getAttribute("class") + " e-chart-focused");
      }
      if (this.element.id === "") {
        var collection = document.getElementsByClassName("e-chart").length;
        this.element.id = "chart_" + this.chartId + "_" + collection;
      }
      this.svgId = this.element.id + "_svg";
    };
    Chart3D2.prototype.setCulture = function() {
      this.intl = new Internationalization();
      this.localeObject = new L10n(this.getModuleName(), this.defaultLocalConstants, this.locale);
    };
    Chart3D2.prototype.render = function() {
      var _this = this;
      this.svgRenderer = new SvgRenderer(this.element.id);
      var loadEventData = {
        chart: this,
        theme: this.theme,
        cancel: false
      };
      this.trigger(load, loadEventData, function() {
        if (!loadEventData.cancel) {
          _this.cartesianChartRendering();
        }
      });
    };
    Chart3D2.prototype.cartesianChartRendering = function() {
      this.setTheme();
      this.createChartSvg();
      this.calculateVisibleSeries();
      this.calculateVisibleAxis();
      this.processData();
      this.renderComplete();
      this.allowServerDataBinding = true;
    };
    Chart3D2.prototype.createChartSvg = function() {
      this.removeSvg();
      createSvg(this);
    };
    Chart3D2.prototype.removeSvg = function() {
      if (this.redraw) {
        return null;
      }
      removeElement(this.element.id + "_Secondary_Element");
      if (this.isReact) {
        this.clearTemplate();
      }
      var removeLength = 0;
      if (this.svgObject) {
        while (this.svgObject.childNodes.length > removeLength) {
          this.svgObject.removeChild(this.svgObject.firstChild);
        }
        if (!this.svgObject.hasChildNodes() && this.svgObject.parentNode) {
          remove(this.svgObject);
        }
      }
    };
    Chart3D2.prototype.processData = function(render) {
      if (render === void 0) {
        render = true;
      }
      this.visibleSeriesCount = 0;
      var check = true;
      for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
        var series = _a[_i];
        if (!series.visible && !this.legendSettings.visible) {
          this.visibleSeriesCount++;
          continue;
        }
        this.initializeDataModule(series);
      }
      if (render && (!this.visibleSeries.length || this.visibleSeriesCount === this.visibleSeries.length && check)) {
        this.refreshBound();
        this.trigger("loaded", {
          chart: this
        });
      }
    };
    Chart3D2.prototype.initializeDataModule = function(series) {
      series.xData = [];
      series.yData = [];
      var dataSource;
      var isAngular = "isAngular";
      if (this[isAngular]) {
        dataSource = Object.keys(series.dataSource).length ? series.dataSource : this.dataSource;
      } else {
        dataSource = series.dataSource || this.dataSource;
      }
      series.dataModule = new Data(dataSource, series.query);
      series.points = [];
      series.refreshDataManager(this);
    };
    Chart3D2.prototype.animate = function(duration) {
      this.redraw = true;
      this.animated = true;
      this.duration = duration ? duration : 1e3;
    };
    Chart3D2.prototype.refreshBound = function() {
      if (this.legend3DModule && this.legendSettings.visible) {
        this.legend3DModule.getLegendOptions(this.visibleSeries, this);
      }
      if (this.tooltip.enable && this.tooltip3DModule) {
        this.tooltip3DModule.previousPoints = [];
      }
      this.calculateStackValues();
      this.calculateBounds();
      this.renderElements();
      removeElement("chartmeasuretext");
      this.removeSelection();
    };
    Chart3D2.prototype.removeSelection = function() {
      for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
        var series = _a[_i];
        if (series.visible) {
          for (var _b = 0, _c = series.points; _b < _c.length; _b++) {
            var point = _c[_b];
            point.isSelect = false;
          }
        }
      }
    };
    Chart3D2.prototype.calculateStackValues = function() {
      var series;
      var isCalculateStacking = false;
      for (var i = 0, len = this.visibleSeries.length; i < len; i++) {
        series = this.visibleSeries[i];
        series.position = series.rectCount = void 0;
        if (series.type.indexOf("Stacking") !== -1 && !isCalculateStacking) {
          series.calculateStackedValue(series.type.indexOf("100") > -1, this);
          isCalculateStacking = true;
        }
      }
    };
    Chart3D2.prototype.calculateBounds = function() {
      var margin = this.margin;
      var titleHeight = 0;
      var subTitleHeight = 0;
      var titleWidth = 0;
      var padding = this.titleStyle.position === "Top" || this.titleStyle.position === "Bottom" ? 15 : 5;
      var left = margin.left + this.border.width;
      var width = this.availableSize.width - left - margin.right - this.border.width;
      var elementSpacing = 0;
      var top = margin.top + this.border.width;
      var height = this.availableSize.height - top - this.border.width - margin.bottom;
      this.titleCollection = [];
      this.subTitleCollection = [];
      if (this.title) {
        this.titleCollection = getTitle(this.title, this.titleStyle, this.titleStyle.position === "Left" || this.titleStyle.position === "Right" ? height : width, this.enableRtl, this.themeStyle.chartTitleFont);
        titleHeight = measureText(this.title, this.titleStyle, this.themeStyle.chartTitleFont).height * this.titleCollection.length + padding;
        if (this.subTitle) {
          var maxWidth = 0;
          for (var _i = 0, _a = this.titleCollection; _i < _a.length; _i++) {
            var titleText = _a[_i];
            titleWidth = measureText(titleText, this.titleStyle, this.themeStyle.chartSubTitleFont).width;
            maxWidth = titleWidth > maxWidth ? titleWidth : maxWidth;
          }
          this.subTitleCollection = getTitle(this.subTitle, this.subTitleStyle, maxWidth, this.enableRtl, this.themeStyle.chartSubTitleFont);
          subTitleHeight = measureText(this.subTitle, this.subTitleStyle, this.themeStyle.chartSubTitleFont).height * this.subTitleCollection.length + padding;
        }
      } else if (this.legendSettings.position !== "Top" && this.border.width) {
        elementSpacing = 10;
      }
      top = margin.top + elementSpacing + this.border.width;
      height = this.availableSize.height - top - this.border.width - margin.bottom;
      var marginTotal = subTitleHeight + titleHeight + this.titleStyle.border.width + this.subTitleStyle.border.width;
      switch (this.titleStyle.position) {
        case "Top":
          top += marginTotal;
          height -= marginTotal;
          break;
        case "Bottom":
          height -= marginTotal;
          break;
        case "Left":
          left += marginTotal;
          width -= marginTotal;
          break;
        case "Right":
          left -= this.titleStyle.border.width + this.subTitleStyle.border.width;
          width -= marginTotal;
          break;
      }
      this.initialClipRect = new Rect(left, top, width, height);
      if (this.legend3DModule && this.legendSettings.visible) {
        this.legend3DModule.calculateLegendBounds(this.initialClipRect, this.availableSize, null);
      }
      this.chartAxisLayoutPanel.measureAxis(this.initialClipRect);
    };
    Chart3D2.prototype.renderElements = function() {
      this.renderBorder();
      this.renderTitle();
      this.createSeriesElements();
      this.render3DChart();
      this.renderLegend();
      this.performSelection();
      this.setSecondaryElementPosition();
      this.doAnimation();
    };
    Chart3D2.prototype.animateRect = function(element, series, point, dataLabelElement, shapeElement, templateElement) {
      var option = series.animation;
      var duration = series.chart.animated ? series.chart.duration : option.duration;
      var effect = getAnimationFunction("Linear");
      var elementHeight = element.getAttribute("height") ? +element.getAttribute("height") : 0;
      var elementWidth = element.getAttribute("width") ? +element.getAttribute("width") : 0;
      var isPlot = point.yValue < 0;
      var centerX;
      var centerY;
      var x = +element.getAttribute("x");
      var y = +element.getAttribute("y");
      if (!series.chart.requireInvertedAxis) {
        centerY = isPlot !== series.yAxis.isAxisInverse ? y : y + elementHeight;
        centerX = isPlot ? x : x + elementWidth;
      } else {
        if (series.type.indexOf("Stacking") > -1) {
          centerX = x;
          centerY = y;
        } else {
          centerY = isPlot ? y : y + elementHeight;
          centerX = isPlot !== series.yAxis.isAxisInverse ? x + elementWidth : x;
        }
      }
      var value;
      if (!isNullOrUndefined(element)) {
        element.style.visibility = "hidden";
        if (dataLabelElement) {
          dataLabelElement.style.visibility = "hidden";
        }
        if (shapeElement) {
          shapeElement.style.visibility = "hidden";
        }
        if (templateElement) {
          templateElement.style.visibility = "hidden";
        }
        new Animation({}).animate(element, {
          duration: duration === 0 && animationMode === "Enable" ? 1e3 : duration,
          delay: option.delay,
          progress: function(args) {
            if (args.timeStamp >= args.delay) {
              element.style.visibility = "visible";
              if (!series.chart.requireInvertedAxis) {
                elementHeight = elementHeight ? elementHeight : 1;
                value = effect(args.timeStamp - args.delay, 0, elementHeight, args.duration);
                element.setAttribute("transform", "translate(" + centerX + " " + centerY + ") scale(1," + value / elementHeight + ") translate(" + -centerX + " " + -centerY + ")");
              } else {
                elementWidth = elementWidth ? elementWidth : 1;
                value = effect(args.timeStamp - args.delay, 0, elementWidth, args.duration);
                element.setAttribute("transform", "translate(" + centerX + " " + centerY + ") scale(" + value / elementWidth + ", 1) translate(" + -centerX + " " + -centerY + ")");
              }
            }
          },
          end: function() {
            element.setAttribute("transform", "translate(0,0)");
            if (dataLabelElement) {
              dataLabelElement.style.visibility = "visible";
            }
            if (shapeElement) {
              shapeElement.style.visibility = "visible";
            }
            if (templateElement) {
              templateElement.style.visibility = "visible";
            }
            series.chart.trigger("animationComplete", {
              series
            });
          }
        });
      }
    };
    Chart3D2.prototype.doAnimation = function() {
      var _this = this;
      var _loop_1 = function(i2) {
        var series = this_1.visibleSeries[i2];
        if (series.visible && series.animation.enable && this_1.animateSeries && !this_1.rotateActivate) {
          var dataLabelElement = void 0;
          var shapeElement = void 0;
          var templateElement = void 0;
          var options = new RectOption(this_1.element.id + "_ChartSeriesClipRect_" + i2, "transparent", {
            width: 1,
            color: "Gray"
          }, 1, {
            x: 0,
            y: 0,
            width: this_1.availableSize.width,
            height: this_1.availableSize.height
          });
          var clipRectElement = appendClipElement(this_1.redraw, options, this_1.svgRenderer);
          appendChildElement(false, this_1.chart3D, clipRectElement.children[0], this_1.redraw);
          for (var k = 0; series.visiblePoints && k < series.visiblePoints.length; k++) {
            var point = series.visiblePoints[k];
            var elements = document.querySelectorAll('[id*="region-series-' + i2 + '"]');
            elements.forEach(function(element) {
              element.setAttribute("clip-path", "url(#" + _this.element.id + "_ChartSeriesClipRect_" + i2 + ")");
            });
            if (series.dataLabel.visible) {
              dataLabelElement = getElement2(this_1.element.id + "-svg-series-" + series.index + "-point-" + k + "-data-label");
              shapeElement = getElement2(this_1.element.id + "-svg-data-label-series-" + series.index + "-point-" + k);
              templateElement = getElement2(this_1.element.id + "-series-" + series.index + "-data-label-" + k);
            }
            this_1.animateRect(document.getElementById(this_1.element.id + "_ChartSeriesClipRect_" + i2).children[0], series, point, dataLabelElement, shapeElement, templateElement);
          }
        }
      };
      var this_1 = this;
      for (var i = 0; i < this.visibleSeries.length; i++) {
        _loop_1(i);
      }
    };
    Chart3D2.prototype.performSelection = function() {
      var selectedDataIndexes = [];
      if (this.selection3DModule) {
        selectedDataIndexes = extend([], this.selection3DModule.selectedDataIndexes, null, true);
        this.selection3DModule.invokeSelection(this);
      }
      if (this.highlight3DModule) {
        this.highlight3DModule.invokeHighlight(this);
      }
      if ((!this.highlight3DModule || this.legendSettings.enableHighlight && this.highlightMode === "None") && this.tooltip3DModule) {
        this.tooltip3DModule.seriesStyles();
      }
      if (selectedDataIndexes.length > 0) {
        this.selection3DModule.selectedDataIndexes = selectedDataIndexes;
        this.selection3DModule.redrawSelection(this, this.selectionMode);
      }
    };
    Chart3D2.prototype.renderLegend = function() {
      if (this.legend3DModule && this.legend3DModule.legendCollections.length && this.legendSettings.visible) {
        this.legend3DModule.calTotalPage = true;
        var bounds = this.legend3DModule.legendBounds;
        this.legend3DModule.renderLegend(this, this.legendSettings, bounds);
      }
      if (!this.redraw) {
        this.element.appendChild(this.svgObject);
      }
    };
    Chart3D2.prototype.setSecondaryElementPosition = function() {
      var element = getElement2(this.element.id + "_Secondary_Element");
      if (!element) {
        return;
      }
      var rect = this.element.getBoundingClientRect();
      var svgRect = getElement2(this.svgId).getBoundingClientRect();
      element.style.left = Math.max(svgRect.left - rect.left, 0) + "px";
      element.style.top = Math.max(svgRect.top - rect.top, 0) + "px";
    };
    Chart3D2.prototype.initializeModuleElements = function() {
      this.dataLabelCollections = [];
      var elementId = this.element.id;
      if (this.series.length) {
        this.seriesElements = this.svgRenderer.createGroup({
          id: elementId + "SeriesCollection"
        });
      }
      this.dataLabelElements = this.renderer.createGroup({
        id: elementId + "DataLabelCollection"
      });
    };
    Chart3D2.prototype.createSeriesElements = function() {
      this.initializeModuleElements();
      var elementId = this.element.id;
      var tooltipDiv = redrawElement(this.redraw, elementId + "_Secondary_Element") || this.createElement("div");
      tooltipDiv.id = elementId + "_Secondary_Element";
      tooltipDiv.style.cssText = "position: relative";
      appendChildElement(false, this.element, tooltipDiv, this.redraw);
      if (this.tooltip.enable) {
        appendChildElement(false, this.svgObject, this.renderer.createGroup({
          id: elementId + "_UserInteraction",
          style: "pointer-events:none;"
        }), this.redraw);
      }
    };
    Chart3D2.prototype.renderTitle = function() {
      var rect;
      var margin = this.margin;
      var elementSpacing = 5;
      if (this.title) {
        var getAnchor = getTextAnchor(this.titleStyle.textAlignment, this.enableRtl);
        var elementSize = measureText(this.title, this.titleStyle, this.themeStyle.chartTitleFont);
        rect = new Rect(margin.left, 0, this.availableSize.width - margin.left - margin.right, 0);
        var borderWidth = this.titleStyle.border.width;
        var positionY = this.margin.top + elementSize.height * 3 / 4;
        var positionX = titlePositionX(rect, this.titleStyle || this.themeStyle.chartTitleFont) + borderWidth;
        var rotation = void 0;
        var alignment = this.titleStyle.textAlignment;
        var subtitleSize = measureText(this.subTitle, this.subTitleStyle, this.themeStyle.chartSubTitleFont);
        switch (this.titleStyle.position) {
          case "Top":
            positionY += borderWidth * 0.5;
            positionX += getAnchor === "start" ? borderWidth * 0.5 + this.border.width : getAnchor === "end" ? -borderWidth * 2 - this.border.width : 0;
            break;
          case "Bottom":
            positionX += getAnchor === "start" ? borderWidth * 0.5 + this.border.width : getAnchor === "end" ? -borderWidth * 2 - this.border.width : 0;
            positionY = this.availableSize.height - this.margin.bottom - subtitleSize.height - elementSize.height / 2 - borderWidth * 0.5 - this.subTitleStyle.border.width * 0.5;
            break;
          case "Left":
            positionX = this.margin.left + elementSize.height * 3 / 4 + borderWidth * 0.5;
            positionY = alignment === "Near" ? margin.bottom + borderWidth * 0.5 + this.border.width : alignment === "Far" ? this.availableSize.height - margin.bottom - borderWidth * 0.5 - this.border.width : this.availableSize.height / 2;
            getAnchor = alignment === "Near" ? "end" : alignment === "Far" ? "start" : "middle";
            getAnchor = this.enableRtl ? getAnchor === "end" ? "start" : getAnchor === "start" ? "end" : getAnchor : getAnchor;
            rotation = "rotate(-90," + positionX + "," + positionY + ")";
            break;
          case "Right":
            positionX = this.availableSize.width - this.margin.right - elementSize.height * 3 / 4 - borderWidth * 0.5;
            positionY = alignment === "Near" ? margin.bottom + borderWidth * 0.5 + this.border.width : alignment === "Far" ? this.availableSize.height - margin.bottom - borderWidth * 0.5 - this.border.width : this.availableSize.height / 2;
            getAnchor = alignment === "Near" ? "start" : alignment === "Far" ? "end" : "middle";
            getAnchor = this.enableRtl ? getAnchor === "end" ? "start" : getAnchor === "start" ? "end" : getAnchor : getAnchor;
            rotation = "rotate(90," + positionX + "," + positionY + ")";
            break;
          case "Custom":
            positionX = this.titleStyle.x;
            positionY = this.titleStyle.y;
            getAnchor = "middle";
            break;
        }
        var borderOptions = {
          "id": this.element.id + "-chart-title-border",
          "x": positionX - (getAnchor === "middle" ? elementSize.width / 2 + elementSpacing : getAnchor === "end" ? elementSize.width + elementSpacing : elementSpacing),
          "y": positionY - elementSize.height + elementSize.height / 4,
          "rx": this.titleStyle.border.cornerRadius,
          "ry": this.titleStyle.border.cornerRadius,
          "width": elementSize.width + elementSpacing * 2,
          "height": elementSize.height * this.titleCollection.length,
          "fill": this.titleStyle.background,
          "stroke-width": borderWidth,
          "stroke": this.titleStyle.border.color,
          "transform": rotation ? rotation : ""
        };
        var htmlObject = redrawElement(this.redraw, this.element.id + "-chart-title-border", borderOptions, this.renderer) || this.renderer.drawRectangle(borderOptions);
        appendChildElement(false, this.svgObject, htmlObject, this.redraw);
        var options = new TextOption(this.element.id + "-chart-title", positionX, positionY, getAnchor, this.titleCollection, rotation, "auto");
        var element = redrawElement(this.redraw, this.element.id + "-chart-title", options, this.renderer) || textElement2(this.renderer, options, this.titleStyle, this.titleStyle.color || this.themeStyle.chartTitleFont.color, this.svgObject, null, null, null, null, null, null, null, null, false, null, this.themeStyle.chartTitleFont);
        if (element) {
          element.setAttribute("tabindex", "0");
          element.style.outline = "none";
          element.setAttribute("class", "e-chart-focused");
        }
        if (this.subTitle) {
          this.renderSubTitle(options);
        }
      }
    };
    Chart3D2.prototype.renderSubTitle = function(options) {
      var maxWidth = 0;
      var titleWidth = 0;
      var padding = 10;
      var alignment = this.titleStyle.textAlignment;
      for (var _i = 0, _a = this.titleCollection; _i < _a.length; _i++) {
        var titleText = _a[_i];
        titleWidth = measureText(titleText, this.titleStyle, this.themeStyle.chartTitleFont).width;
        maxWidth = titleWidth > maxWidth ? titleWidth : maxWidth;
      }
      var subTitleElementSize = measureText(this.subTitleCollection.reduce(function(a, b) {
        return a.length > b.length ? a : b;
      }), this.subTitleStyle, this.themeStyle.chartSubTitleFont);
      var getAnchor = getTextAnchor(this.subTitleStyle.textAlignment, this.enableRtl);
      var rect = new Rect(alignment === "Center" ? options.x - maxWidth * 0.5 : alignment === "Far" ? options.x - maxWidth : options.x, 0, maxWidth, 0);
      if (this.titleStyle.position === "Left") {
        rect.x = alignment === "Center" ? options.x - maxWidth * 0.5 : alignment === "Far" ? this.margin.left + subTitleElementSize.height * 3 / 4 : options.x - maxWidth;
      }
      var elementSize = measureText(this.title, this.titleStyle, this.themeStyle.chartTitleFont);
      var positionY = options.y * options.text.length + subTitleElementSize.height + padding / 2 + this.titleStyle.border.width + this.subTitleStyle.border.width * 0.5;
      if (this.titleStyle.position === "Bottom") {
        positionY = options.y * options.text.length + padding / 2 + elementSize.height / 2 + subTitleElementSize.height / 2;
      }
      var borderOptions = {
        "id": this.element.id + "-chart-sub-title-border",
        "x": titlePositionX(rect, this.subTitleStyle) - (getAnchor === "middle" ? subTitleElementSize.width / 2 + padding / 2 : getAnchor === "end" ? subTitleElementSize.width + padding / 2 : padding / 2),
        "y": positionY - subTitleElementSize.height + subTitleElementSize.height / 4,
        "rx": this.subTitleStyle.border.cornerRadius,
        "ry": this.subTitleStyle.border.cornerRadius,
        "width": subTitleElementSize.width + padding,
        "height": subTitleElementSize.height * this.subTitleCollection.length,
        "fill": this.subTitleStyle.background,
        "stroke-width": this.subTitleStyle.border.width,
        "stroke": this.subTitleStyle.border.color,
        "transform": options.transform
      };
      var htmlObject = redrawElement(this.redraw, this.element.id + "-chart-sub-title-border", borderOptions, this.renderer) || this.renderer.drawRectangle(borderOptions);
      appendChildElement(false, this.svgObject, htmlObject, this.redraw);
      var subTitleOptions = new TextOption(this.element.id + "-chart-sub-title", titlePositionX(rect, this.subTitleStyle), positionY, getTextAnchor(this.subTitleStyle.textAlignment, this.enableRtl), this.subTitleCollection, options.transform, "auto");
      var element = redrawElement(this.redraw, this.element.id + "-chart-sub-title", subTitleOptions, this.renderer) || textElement2(this.renderer, subTitleOptions, this.subTitleStyle, this.subTitleStyle.color || this.themeStyle.chartSubTitleFont.color, this.svgObject, null, null, null, null, null, null, null, null, false, null, this.themeStyle.chartSubTitleFont);
    };
    Chart3D2.prototype.renderBorder = function() {
      var x = 0;
      var y = 0;
      var width = this.border.width;
      var backGroundImage = this.backgroundImage;
      var fillColor = backGroundImage ? "transparent" : this.background || this.themeStyle.background;
      var rect = new RectOption(this.element.id + "-chart-border", fillColor, this.border, 1, new Rect(width * 0.5 + x, width * 0.5 + y, this.availableSize.width - width, this.availableSize.height - width), 0, 0, "", this.border.dashArray);
      this.htmlObject = redrawElement(this.redraw, this.element.id + "-chart-border", rect, this.renderer) || this.renderer.drawRectangle(rect);
      this.htmlObject.setAttribute("aria-hidden", "true");
      appendChildElement(false, this.svgObject, this.htmlObject, this.redraw);
      if (backGroundImage) {
        var image = new ImageOption(this.availableSize.height - width, this.availableSize.width - width, backGroundImage, 0, 0, this.element.id + "-chart-background", "visible", "none");
        this.htmlObject = redrawElement(this.redraw, this.element.id + "-chart-background", image, this.renderer) || this.renderer.drawImage(image);
        appendChildElement(false, this.svgObject, this.htmlObject, this.redraw);
      }
    };
    Chart3D2.prototype.requiredModules = function() {
      var _this = this;
      var modules = [];
      var series = this.series;
      var moduleName;
      var dataLabelEnable = false;
      if (this.tooltip.enable) {
        modules.push({
          member: "Tooltip3D",
          args: [this]
        });
      }
      series.map(function(value) {
        _this.isLegend = _this.legendSettings.visible && (value.name !== "" || !!_this.isLegend);
        moduleName = value.type.indexOf("100") !== -1 ? value.type.replace("100", "") + "Series3D" : value.type + "Series3D";
        dataLabelEnable = value.dataLabel.visible || dataLabelEnable;
        if (!modules.some(function(currentModule) {
          return currentModule.member === moduleName;
        })) {
          modules.push({
            member: moduleName,
            args: [_this, series]
          });
        }
      });
      if (dataLabelEnable) {
        modules.push({
          member: "DataLabel3D",
          args: [this, series]
        });
      }
      modules = this.findAxisModule(modules);
      if (this.isLegend) {
        modules.push({
          member: "Legend3D",
          args: [this]
        });
      }
      if (this.enableExport) {
        modules.push({
          member: "Export3D",
          args: [this]
        });
      }
      if (this.selectionMode !== "None") {
        modules.push({
          member: "Selection3D",
          args: [this]
        });
      }
      if (this.highlightMode !== "None" || this.legendSettings.enableHighlight) {
        modules.push({
          member: "Highlight3D",
          args: [this]
        });
      }
      return modules;
    };
    Chart3D2.prototype.findAxisModule = function(modules) {
      var axisCollections = [];
      axisCollections.push(this.primaryXAxis);
      axisCollections.push(this.primaryYAxis);
      axisCollections = axisCollections.concat(this.axes);
      var datetimeEnabled = false;
      var categoryEnabled = false;
      var logarithmicEnabled = false;
      var dateTimeCategoryEnabled = false;
      for (var _i = 0, axisCollections_1 = axisCollections; _i < axisCollections_1.length; _i++) {
        var axis = axisCollections_1[_i];
        datetimeEnabled = axis.valueType === "DateTime" || datetimeEnabled;
        categoryEnabled = axis.valueType === "Category" || categoryEnabled;
        logarithmicEnabled = axis.valueType === "Logarithmic" || logarithmicEnabled;
        dateTimeCategoryEnabled = axis.valueType === "DateTimeCategory" || dateTimeCategoryEnabled;
      }
      if (datetimeEnabled) {
        modules.push({
          member: "DateTime3D",
          args: [this]
        });
      }
      if (categoryEnabled) {
        modules.push({
          member: "Category3D",
          args: [this]
        });
      }
      if (logarithmicEnabled) {
        modules.push({
          member: "Logarithmic3D",
          args: [this]
        });
      }
      if (dateTimeCategoryEnabled) {
        modules.push({
          member: "DateTimeCategory3D",
          args: [this]
        });
      }
      return modules;
    };
    Chart3D2.prototype.setTheme = function() {
      this.themeStyle = get3DThemeColor(this.theme);
    };
    Chart3D2.prototype.setNavigationStyle = function(target) {
      var currentElement = document.getElementById(target);
      if (currentElement) {
        currentElement.style.setProperty("outline", "1.5px solid " + this.themeStyle.tabColor);
      }
    };
    Chart3D2.prototype.removeNavigationStyle = function() {
      var currentElement = document.querySelectorAll("[id*=_Point_], [id*=" + this.element.id + "], [id*=_ChartBorder], text[id*=_ChartTitle],g[id*=_chart_legend],  text[id*=_ChartSubTitle], div[id*=_Annotation]");
      if (currentElement) {
        currentElement.forEach(function(element) {
          if (element instanceof HTMLElement || element instanceof SVGElement) {
            element.style.setProperty("outline", "none");
          }
        });
      }
    };
    Chart3D2.prototype.render3DChart = function() {
      this.chart3D = this.svgRenderer.createGroup({
        "id": this.element.id + "-svg-chart-3d"
      });
      this.chart3D.setAttribute("role", "region");
      this.chart3D.setAttribute("aria-hidden", "false");
      this.draw3DAxis();
      this.wallRender.update3DWall(this);
      this.renderSeries();
      appendChildElement(false, this.svgObject, this.chart3D, this.redraw);
      var size = new Size(this.availableSize.width, this.availableSize.height);
      this.graphics.prepareView(this.perspectiveAngle, this.depth, this.rotation, this.tilt, size, this);
      this.graphics.view(this.svgObject, this);
    };
    Chart3D2.prototype.draw3DAxis = function() {
      for (var i = 0; i < this.axisCollections.length; i++) {
        this.axisRender.drawAxes(i, this.axisCollections[i], this);
      }
    };
    Chart3D2.prototype.renderSeries = function() {
      var visibility;
      for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
        var item = _a[_i];
        visibility = item.visible;
        if (visibility) {
          this.visible++;
          item.renderSeries(this);
        }
      }
      this.visible = 0;
    };
    Chart3D2.prototype.initAxis = function(series, axis, isSeries) {
      if (series.xAxisName === axis.name || series.xAxisName == null && axis.name === "primaryXAxis") {
        axis.orientation = this.requireInvertedAxis ? "Vertical" : "Horizontal";
        series.xAxis = axis;
        if (isSeries) {
          axis.series.push(series);
        }
      } else if (series.yAxisName === axis.name || series.yAxisName == null && axis.name === "primaryYAxis") {
        axis.orientation = this.requireInvertedAxis ? "Horizontal" : "Vertical";
        series.yAxis = axis;
        if (isSeries) {
          axis.series.push(series);
        }
      }
    };
    Chart3D2.prototype.calculateVisibleAxis = function() {
      var axis;
      var axes = [this.primaryXAxis, this.primaryYAxis];
      axes = axes.concat(this.axes);
      this.axisCollections = [];
      for (var i = 0, len = axes.length; i < len; i++) {
        axis = axes[i];
        axis.series = [];
        axis.labels = [];
        axis.indexLabels = {};
        axis.orientation = i === 0 ? this.requireInvertedAxis ? "Vertical" : "Horizontal" : i === 1 ? this.requireInvertedAxis ? "Horizontal" : "Vertical" : axis.orientation;
        for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
          var series = _a[_i];
          this.initAxis(series, axis, true);
        }
        if (axis.orientation != null) {
          this.axisCollections.push(axis);
        }
      }
      if (this.rows.length > 0 && this.columns.length > 0) {
        this.chartAxisLayoutPanel.measure();
      }
    };
    Chart3D2.prototype.unWireEvents = function() {
      var startEvent = Browser.touchStartEvent;
      var moveEvent = Browser.touchMoveEvent;
      var stopEvent = Browser.touchEndEvent;
      var cancelEvent = Browser.isPointer ? "pointerleave" : "mouseleave";
      EventHandler.remove(this.element, startEvent, this.chartOnMouseDown);
      EventHandler.remove(this.element, moveEvent, this.mouseMove);
      EventHandler.remove(this.element, stopEvent, this.mouseEnd);
      EventHandler.remove(this.element, "click", this.chartOnMouseClick);
      EventHandler.remove(this.element, cancelEvent, this.mouseLeave);
      EventHandler.remove(this.element, "keydown", this.chartKeyDown);
      EventHandler.remove(document.body, "keydown", this.documentKeyHandler);
      EventHandler.remove(this.element, "keyup", this.chartKeyUp);
      window.removeEventListener(Browser.isTouch && "orientation" in window && "onorientationchange" in window ? "orientationchange" : "resize", this.resizeBound);
      if (this.touchObject) {
        this.touchObject.destroy();
        this.touchObject = null;
      }
    };
    Chart3D2.prototype.wireEvents = function() {
      if (!this.element) {
        return;
      }
      var cancelEvent = Browser.isPointer ? "pointerleave" : "mouseleave";
      EventHandler.add(this.element, Browser.touchStartEvent, this.chartOnMouseDown, this);
      EventHandler.add(this.element, Browser.touchMoveEvent, this.mouseMove, this);
      EventHandler.add(this.element, Browser.touchEndEvent, this.mouseEnd, this);
      EventHandler.add(this.element, "click", this.chartOnMouseClick, this);
      EventHandler.add(this.element, cancelEvent, this.mouseLeave, this);
      EventHandler.add(this.element, "keydown", this.chartKeyDown, this);
      EventHandler.add(document.body, "keydown", this.documentKeyHandler, this);
      EventHandler.add(this.element, "keyup", this.chartKeyUp, this);
      this.resizeBound = this.chartResize.bind(this);
      window.addEventListener(Browser.isTouch && "orientation" in window && "onorientationchange" in window ? "orientationchange" : "resize", this.resizeBound);
      this.longPressBound = this.longPress.bind(this);
      this.touchObject = new Touch(this.element, {
        tapHold: this.longPressBound,
        tapHoldThreshold: 500
      });
      this.setStyle(this.element);
    };
    Chart3D2.prototype.longPress = function(e) {
      this.mouseX = e && e.originalEvent.changedTouches ? e.originalEvent.changedTouches[0].clientX : 0;
      this.mouseY = e && e.originalEvent.changedTouches ? e.originalEvent.changedTouches[0].clientY : 0;
      this.startMove = true;
      this.setMouseXY(this.mouseX, this.mouseY);
      this.notify("tapHold", e);
      return false;
    };
    Chart3D2.prototype.chartOnMouseClick = function(e) {
      var _this = this;
      var element = e.target;
      var chart = this;
      this.clickCount++;
      var timeInterval = 400;
      if (this.clickCount === 1) {
        this.singleClickTimer = +setTimeout(function() {
          chart.clickCount = 0;
          chart.trigger("chart3DMouseClick", {
            target: element.id,
            x: chart.mouseX,
            y: chart.mouseY
          });
        }, timeInterval);
      } else if (this.clickCount === 2) {
        clearTimeout(this.singleClickTimer);
        this.clickCount = 0;
      }
      var isAngular = "isAngular";
      if (this[isAngular]) {
        timeInterval = 0;
      } else {
        timeInterval = 0;
      }
      if (this.clickCount === 1 && this.pointClick) {
        this.singleClickTimer = +setTimeout(function() {
          _this.clickCount = 0;
          _this.triggerPointEvent(pointClick, e);
        }, timeInterval);
      }
      this.removeNavigationStyle();
      this.notify("click", e);
      return false;
    };
    Chart3D2.prototype.export = function(type, fileName) {
      if (this.export3DModule) {
        this.export3DModule.export(type, fileName);
        if (this.afterExport) {
          this.export3DModule.getDataUrl(this);
        }
      }
    };
    Chart3D2.prototype.chartResize = function() {
      var _this = this;
      this.animateSeries = false;
      var arg = {
        chart: this,
        currentSize: new Size(0, 0),
        previousSize: new Size(this.availableSize.width, this.availableSize.height)
      };
      var beforeResizeArgs = {
        cancel: false
      };
      if (this.resizeTo) {
        clearTimeout(this.resizeTo);
      }
      this.trigger(beforeResize, beforeResizeArgs);
      if (!beforeResizeArgs.cancel) {
        this.resizeTo = +setTimeout(function() {
          if (_this.isDestroyed) {
            clearTimeout(_this.resizeTo);
            return;
          }
          _this.createChartSvg();
          arg.currentSize = _this.availableSize;
          _this.trigger(resized, arg);
          _this.polygons = [];
          _this.refreshAxis();
          _this.refreshBound();
          _this.trigger("loaded", {
            chart: _this
          });
        }, 500);
      }
      return false;
    };
    Chart3D2.prototype.triggerPointEvent = function(event2, e) {
      var evt = e;
      var series = null;
      var point = null;
      var index;
      var pointIndex;
      var seriesIndex;
      var targetElement = evt.target;
      if (targetElement) {
        var nodeName = targetElement.nodeName;
        if ((nodeName === "path" || nodeName === "shape") && targetElement.id.indexOf("-region-") > 1) {
          index = targetElement.id.match(/(\d+)/g);
          pointIndex = parseInt(index[index.length - 1].toString(), 10);
          seriesIndex = parseInt(index[index.length - 2].toString(), 10);
        }
        if (!isNullOrUndefined(seriesIndex)) {
          series = this.visibleSeries[seriesIndex];
        }
        if (series && series.visible) {
          point = series.points[pointIndex];
        }
      }
      if (series && point) {
        this.trigger(event2, {
          series,
          point,
          seriesIndex,
          pointIndex,
          x: this.mouseX,
          y: this.mouseY
        });
      }
    };
    Chart3D2.prototype.chartOnMouseDown = function(e) {
      var pageX;
      var pageY;
      var touchArg;
      var rect = this.element.getBoundingClientRect();
      var element = e.target;
      this.trigger("chart3DMouseDown", {
        target: element.id,
        x: this.mouseX,
        y: this.mouseY
      });
      if (e.type === "touchstart") {
        this.isTouch = true;
        touchArg = e;
        pageX = touchArg.changedTouches[0].clientX;
        pageY = touchArg.changedTouches[0].clientY;
      } else {
        this.isTouch = e.pointerType === "touch";
        pageX = e.clientX;
        pageY = e.clientY;
      }
      var svgRect = getElement2(this.svgId).getBoundingClientRect();
      this.mouseDownX = this.previousMouseMoveX = pageX - rect.left - Math.max(svgRect.left - rect.left, 0);
      this.mouseDownY = this.previousMouseMoveY = pageY - rect.top - Math.max(svgRect.top - rect.top, 0);
      if (this.enableRotation) {
        if (this.isTouch && this.tooltip3DModule && this.tooltip3DModule.svgTooltip) {
          this.tooltip3DModule.svgTooltip.fadeOut();
        }
        this.rotateActivate = true;
        this.previousCoords = {
          x: this.mouseDownX,
          y: this.mouseDownY
        };
      }
      this.notify(Browser.touchStartEvent, e);
      return false;
    };
    Chart3D2.prototype.mouseMove = function(e) {
      var pageX;
      var pageY;
      var touchArg;
      if (e.type === "touchmove") {
        this.isTouch = true;
        touchArg = e;
        pageX = touchArg.changedTouches[0].clientX;
        pageY = touchArg.changedTouches[0].clientY;
      } else {
        this.isTouch = e.pointerType === "touch" || e.pointerType === "2" || this.isTouch;
        pageX = e.clientX;
        pageY = e.clientY;
      }
      if (getElement2(this.svgId)) {
        this.setMouseXY(pageX, pageY);
        this.chartOnMouseMove(e);
      }
      return false;
    };
    Chart3D2.prototype.mouseLeave = function(e) {
      var pageX;
      var pageY;
      var touchArg;
      if (e.type === "touchleave") {
        this.isTouch = true;
        touchArg = e;
        pageX = touchArg.changedTouches[0].clientX;
        pageY = touchArg.changedTouches[0].clientY;
      } else {
        this.isTouch = e.pointerType === "touch" || e.pointerType === "2";
        pageX = e.clientX;
        pageY = e.clientY;
      }
      this.setMouseXY(pageX, pageY);
      this.chartOnMouseLeave(e);
      return false;
    };
    Chart3D2.prototype.mouseEnd = function(e) {
      var pageY;
      var pageX;
      var touchArg;
      if (e.type === "touchend") {
        touchArg = e;
        pageX = touchArg.changedTouches[0].clientX;
        this.isTouch = true;
        pageY = touchArg.changedTouches[0].clientY;
      } else {
        pageY = e.clientY;
        pageX = e.clientX;
        this.isTouch = e.pointerType === "touch" || e.pointerType === "2";
      }
      this.setMouseXY(pageX, pageY);
      this.chartOnMouseUp(e);
      return false;
    };
    Chart3D2.prototype.chartOnMouseUp = function(e) {
      var element = e.target;
      this.trigger("chart3DMouseUp", {
        target: element.id,
        x: this.mouseX,
        y: this.mouseY
      });
      if (this.isTouch) {
        this.titleTooltip(e, this.mouseX, this.mouseY);
        this.axisTooltip(e, this.mouseX, this.mouseY, this.isTouch);
      }
      this.notify(Browser.touchEndEvent, e);
      this.rotateActivate = false;
      this.delayRedraw = false;
      return false;
    };
    Chart3D2.prototype.print = function(id) {
      var printChart = new PrintUtils(this);
      printChart.print(id);
    };
    Chart3D2.prototype.chartOnMouseMove = function(e) {
      var element = e.target;
      this.trigger("chart3DMouseMove", {
        target: element.id,
        x: this.mouseX,
        y: this.mouseY
      });
      if (this.pointMove) {
        this.triggerPointEvent(pointMove, e);
      }
      if (!this.isTouch) {
        this.titleTooltip(e, this.mouseX, this.mouseY);
        this.axisTooltip(e, this.mouseX, this.mouseY);
      }
      if (this.rotateActivate && withInBounds(this.mouseX, this.mouseY, this.chartAxisLayoutPanel.seriesClipRect)) {
        var difX = this.previousCoords.x - this.mouseX;
        var difY = this.previousCoords.y - this.mouseY;
        if (difX || difY) {
          this.tilt -= difY;
          this.rotation += difX;
          if (!this.isTouch) {
            var grpElement = document.getElementById(this.chart3D.id);
            grpElement.innerHTML = "";
            grpElement.remove();
          } else {
            document.querySelectorAll('[id*="axis-label-"]').forEach(function(axisElement) {
              return axisElement.remove();
            });
            this.delayRedraw = true;
          }
          var size = {
            width: this.availableSize.width,
            height: this.availableSize.height
          };
          this.graphics.view(this.svgObject, this, this.rotation, this.tilt, size, this.perspectiveAngle, this.depth);
          appendChildElement(false, this.svgObject, this.chart3D, this.redraw);
          this.previousCoords.y = this.mouseY;
          this.previousCoords.x = this.mouseX;
          this.isRemove = false;
        }
      }
      this.notify(Browser.touchMoveEvent, e);
      this.isTouch = false;
      return false;
    };
    Chart3D2.prototype.titleTooltip = function(event2, x, y, isTouch) {
      var targetId = event2.target.id;
      var id = targetId === this.element.id + "-chart-title" || targetId === this.element.id + "-chart-sub-title" || targetId.indexOf("-axis-title") > -1 || targetId.indexOf("_legend_title") > -1;
      var index = 0;
      if (targetId.indexOf("-axis-title") > -1) {
        index = parseInt(targetId.replace(this.element.id + "-svg", "").replace("-axis-title", "").split("-")[1], 10);
      }
      if (id && event2.target.textContent.indexOf("...") > -1) {
        var title = targetId === this.element.id + "-chart-title" ? this.title : targetId.indexOf("-axis-title") > -1 ? this.axisCollections[index].title : targetId.indexOf("-chart-sub-title") > -1 ? this.subTitle : this.legendSettings.title;
        showTooltip(title, x, y, this.element.offsetWidth, this.element.id + "-EJ2-title-tooltip", getElement2(this.element.id + "_Secondary_Element"), isTouch);
      } else {
        removeElement(this.element.id + "-EJ2-title-tooltip");
      }
    };
    Chart3D2.prototype.setMouseXY = function(pageX, pageY) {
      if (getElement2(this.svgId)) {
        var svgRect = getElement2(this.svgId).getBoundingClientRect();
        var rect = this.element.getBoundingClientRect();
        this.mouseY = pageY - rect.top - Math.max(svgRect.top - rect.top, 0) / this.scaleX;
        this.mouseX = pageX - rect.left - Math.max(svgRect.left - rect.left, 0) / this.scaleY;
      }
    };
    Chart3D2.prototype.chartOnMouseLeave = function(e) {
      var element = e.target;
      var cancelEvent = Browser.isPointer ? "pointerleave" : "mouseleave";
      this.trigger("chart3DMouseLeave", {
        target: element.id,
        x: this.mouseX,
        y: this.mouseY
      });
      removeElement(this.element.id + "-EJ2-axis-label-tooltip");
      this.isPointMouseDown = false;
      this.notify(cancelEvent, e);
      this.rotateActivate = false;
      this.delayRedraw = false;
      return false;
    };
    Chart3D2.prototype.chartKeyDown = function(e) {
      var actionKey = "";
      if (e.code === "Tab") {
        this.removeNavigationStyle();
      }
      if (e.code === "Space") {
        e.preventDefault();
      }
      if (this.tooltip.enable && (e.code === "Tab" && this.previousTargetId.indexOf("-series") > -1 || e.code === "Escape")) {
        actionKey = "ESC";
      }
      if (this.highlightMode !== "None" && e.code === "Tab" && this.previousTargetId.indexOf("_chart_legend_") > -1) {
        if (this.highlight3DModule) {
          this.highlight3DModule.removeLegendHighlightStyles();
        }
      }
      if (e.ctrlKey && e.key === "p") {
        e.preventDefault();
        actionKey = "CtrlP";
      }
      if (actionKey !== "") {
        this.chartKeyboardNavigations(e, e.target.id, actionKey);
      }
      return false;
    };
    Chart3D2.prototype.chartKeyUp = function(e) {
      var actionKey = "";
      var targetId = e.target["id"];
      var groupElement;
      var targetElement = e.target;
      var titleElement = getElement2(this.element.id + "-chart-title");
      var seriesElement = getElement2(this.element.id + "-svg-0-region-series-0-point-0");
      var legendElement = getElement2(this.element.id + "_chart_legend_translate_g");
      var pagingElement = getElement2(this.element.id + "_chart_legend_pageup");
      this.removeNavigationStyle();
      if (titleElement) {
        titleElement.setAttribute("class", "e-chart-focused");
      }
      if (seriesElement) {
        var className = seriesElement.getAttribute("class");
        if (className && className.indexOf("e-chart-focused") === -1) {
          className = className + " e-chart-focused";
        } else if (!className) {
          className = "e-chart-focused";
        }
        seriesElement.setAttribute("class", className);
      }
      if (legendElement) {
        var firstChild = legendElement.firstElementChild;
        var className = firstChild.getAttribute("class");
        if (className && className.indexOf("e-chart-focused") === -1) {
          className = className + " e-chart-focused";
        } else if (!className) {
          className = "e-chart-focused";
        }
        firstChild.setAttribute("class", className);
      }
      if (pagingElement) {
        pagingElement.setAttribute("class", "e-chart-focused");
      }
      if (e.code === "Tab") {
        if (this.previousTargetId !== "") {
          if (this.previousTargetId.indexOf("-series-") > -1 && targetId.indexOf("-series-") === -1) {
            var previousElement = getElement2(this.element.id + "-svg-0-region-series-" + this.currentSeriesIndex + "-point-" + this.currentPointIndex);
            this.setTabIndex(previousElement, seriesElement);
            this.currentPointIndex = 0;
            this.currentSeriesIndex = 0;
          } else if (this.previousTargetId.indexOf("_chart_legend_page") > -1 && targetId.indexOf("_chart_legend_page") === -1 && targetId.indexOf("_chart_legend_g_") === -1) {
            this.setTabIndex(e.target, getElement2(this.element.id + "_chart_legend_pageup"));
          } else if (this.previousTargetId.indexOf("_chart_legend_g_") > -1 && targetId.indexOf("_chart_legend_g_") === -1) {
            groupElement = getElement2(this.element.id + "_chart_legend_translate_g");
            this.setTabIndex(groupElement.children[this.currentLegendIndex], groupElement.firstElementChild);
          }
        }
        this.previousTargetId = targetId;
        if (targetId.indexOf("-series-") > -1) {
          this.currentSeriesIndex = +targetId.split("-series-")[1].split("-point-")[0];
          targetElement.removeAttribute("tabindex");
          targetElement.blur();
          targetId = this.focusChild(targetElement);
        }
        actionKey = this.highlightMode !== "None" || this.tooltip.enable ? "Tab" : "";
      } else if (e.code.indexOf("Arrow") > -1) {
        e.preventDefault();
        this.previousTargetId = targetId;
        if (targetId.indexOf("_chart_legend_page") > -1) {
          if (e.code === "ArrowLeft") {
            getElement2(this.element.id + "_chart_legend_pagedown").removeAttribute("tabindex");
            this.focusChild(getElement2(this.element.id + "_chart_legend_pageup"));
          } else if (e.code === "ArrowRight") {
            getElement2(this.element.id + "_chart_legend_pageup").removeAttribute("tabindex");
            this.focusChild(getElement2(this.element.id + "_chart_legend_pagedown"));
          }
        } else if (targetId.indexOf("_chart_legend_") > -1) {
          var legendElement_1 = targetElement.parentElement.children;
          legendElement_1[this.currentLegendIndex].removeAttribute("tabindex");
          this.currentLegendIndex += e.code === "ArrowUp" || e.code === "ArrowRight" ? 1 : -1;
          this.currentLegendIndex = this.getActualIndex(this.currentLegendIndex, legendElement_1.length);
          var currentLegend = legendElement_1[this.currentLegendIndex];
          this.focusChild(currentLegend);
          this.removeNavigationStyle();
          this.setNavigationStyle(currentLegend.id);
          targetId = currentLegend.children[1].id;
          actionKey = this.highlightMode !== "None" ? "ArrowMove" : "";
        } else if (targetId.indexOf("-series-") > -1) {
          var currentPoint = e.target;
          targetElement.removeAttribute("tabindex");
          targetElement.blur();
          if (e.code === "ArrowRight" || e.code === "ArrowLeft") {
            this.currentSeriesIndex = this.currentSeriesIndex + (e.code === "ArrowRight" ? 1 : -1);
            this.currentSeriesIndex = this.getActualIndex(this.currentSeriesIndex, this.series.length);
          } else {
            this.currentPointIndex += e.code === "ArrowUp" ? 1 : -1;
          }
          if (targetId.indexOf("-point-") > -1) {
            this.currentPointIndex = this.getActualIndex(this.currentPointIndex, this.visibleSeries[this.currentSeriesIndex].points.length ? this.currentSeries.points.length : 1);
            var pointElements = document.querySelectorAll('[id*="svg-0-region-series-' + this.currentSeriesIndex + "-point-" + this.currentPointIndex + '"]');
            for (var i = 0; i < pointElements.length; i++) {
              if (pointElements[i].id.split("-point-")[1].split("-")[0] === this.currentPointIndex.toString()) {
                currentPoint = pointElements[i];
              }
            }
          }
          targetId = this.focusChild(currentPoint);
          this.removeNavigationStyle();
          this.setNavigationStyle(currentPoint.id);
          actionKey = this.tooltip.enable || this.highlightMode !== "None" ? "ArrowMove" : "";
        }
      } else if ((e.code === "Enter" || e.code === "Space") && (targetId.indexOf("_chart_legend_") > -1 || targetId.indexOf("-point-") > -1)) {
        targetId = targetId.indexOf("_chart_legend_page") > -1 ? targetId : targetId.indexOf("_chart_legend_") > -1 ? targetElement.children[1].id : targetId;
        actionKey = "Enter";
      }
      if (actionKey !== "") {
        this.chartKeyboardNavigations(e, targetId, actionKey);
      }
      if (e.code === "Tab") {
        this.setNavigationStyle(targetId);
      }
      return false;
    };
    Chart3D2.prototype.setTabIndex = function(previousElement, currentElement) {
      if (previousElement) {
        previousElement.removeAttribute("tabindex");
      }
      if (currentElement) {
        currentElement.setAttribute("tabindex", "0");
      }
    };
    Chart3D2.prototype.getActualIndex = function(index, totalLength) {
      return index > totalLength - 1 ? 0 : index < 0 ? totalLength - 1 : index;
    };
    Chart3D2.prototype.axisTooltip = function(event2, x, y, isTouch) {
      var targetId = event2.target.id;
      if (targetId.indexOf("axis-label") > -1 && event2.target.textContent.indexOf("...") > -1) {
        var isTitleOrLegendEnabled = this.legendSettings.visible || this.primaryXAxis.title === "";
        showTooltip(this.findAxisLabel(targetId), x, y, this.element.offsetWidth, this.element.id + "-EJ2-axis-label-tooltip", getElement2(this.element.id + "_Secondary_Element"), isTouch, isTitleOrLegendEnabled);
      } else {
        removeElement(this.element.id + "-EJ2-axis-label-tooltip");
      }
    };
    Chart3D2.prototype.findAxisLabel = function(text) {
      var texts = text.replace(this.element.id + "-", "").replace("-axis-label", "").split("-");
      return this.axisCollections[parseInt(texts[0], 10)].visibleLabels[parseInt(texts[1], 10)].originalText;
    };
    Chart3D2.prototype.focusChild = function(element) {
      element.setAttribute("tabindex", "0");
      var className = element.getAttribute("class");
      element.setAttribute("tabindex", "0");
      if (className && className.indexOf("e-chart-focused") === -1) {
        className = "e-chart-focused " + className;
      } else if (!className) {
        className = "e-chart-focused";
      }
      element.setAttribute("class", className);
      element.focus();
      return element.id;
    };
    Chart3D2.prototype.documentKeyHandler = function(e) {
      if (e.altKey && e.keyCode === 74 && !isNullOrUndefined(this.element)) {
        this.element.focus();
      }
    };
    Chart3D2.prototype.chartKeyboardNavigations = function(e, targetId, actionKey) {
      this.isLegendClicked = false;
      this.removeNavigationStyle();
      this.setNavigationStyle(targetId);
      switch (actionKey) {
        case "Tab":
        case "ArrowMove":
          if (this.highlight3DModule) {
            this.highlight3DModule.removeLegendHighlightStyles();
          }
          if (targetId.indexOf("-point-") > -1) {
            if (document.activeElement) {
              var element = document.activeElement;
              var rect = element.getBoundingClientRect();
              var clientX = rect.left + rect.width / 2;
              var clientY = rect.top;
              var pageX = window.scrollX + clientX;
              var pageY = window.scrollY + clientY;
              this.mouseX = pageX;
              this.mouseY = pageY;
            }
            if (this.highlight3DModule) {
              this.highlight3DModule.highlightChart(document.getElementById(targetId), "mousemove");
              this.highlight3DModule.completeSelection();
            }
            if (this.tooltip3DModule) {
              var data = {
                series: this.visibleSeries[targetId.split("-series-")[1].split("-point-")[0]],
                point: this.visibleSeries[targetId.split("-series-")[1].split("-point-")[0]].points[targetId.split("-point-")[1].split("-")[0]]
              };
              var svgElement = document.getElementById(this.element.id + "_tooltip_svg");
              var isFirst = svgElement && parseInt(svgElement.getAttribute("opacity"), 10) > 0;
              var tooltipDiv = this.tooltip3DModule.getTooltipElement(isFirst);
              if (this.tooltip3DModule.pushData(data, !isFirst, tooltipDiv, true)) {
                this.tooltip3DModule.triggerTooltipRender(data, !isFirst, this.tooltip3DModule.getTooltipText(data), this.tooltip3DModule.findHeader(data));
              }
            }
          }
          if (this.highlight3DModule && this.highlightMode !== "None") {
            targetId = targetId.indexOf("_chart_legend_g_") > -1 ? document.getElementById(targetId).firstChild["id"] : targetId;
            var legendID = this.element.id + "_chart_legend";
            var legendItemsId = [legendID + "_text_", legendID + "_shape_marker_", legendID + "_shape_"];
            for (var i = 0; i < legendItemsId.length; i++) {
              var id = legendItemsId[i];
              if (targetId.indexOf(id) > -1) {
                document.getElementById(targetId).setAttribute("class", "");
                this.highlight3DModule.legendSelection(this, parseInt(targetId.split(id)[1], 10), document.getElementById(targetId), "mousemove");
                break;
              }
            }
          }
          break;
        case "Enter":
        case "Space":
          if (targetId.indexOf("_chart_legend_") > -1) {
            this.isLegendClicked = true;
            this.legend3DModule.click(e);
            this.focusChild(document.getElementById(targetId).parentElement);
            this.setNavigationStyle(document.getElementById(targetId).parentElement.id);
          } else {
            if (this.selection3DModule) {
              this.selection3DModule.calculateSelectedElements(document.getElementById(targetId), "click");
            }
            this.setNavigationStyle(targetId);
          }
          break;
        case "CtrlP":
          this.print();
          break;
        case "ESC":
          this.tooltip3DModule.removeTooltip(1);
          break;
      }
    };
    Chart3D2.prototype.setStyle = function(element) {
      var disableScroll = this.selectionMode !== "None" || this.highlightMode !== "None";
      element.style.touchAction = this.enableRotation || disableScroll ? "none" : "element";
      element.style.msTouchAction = disableScroll ? "none" : "element";
      element.style.msContentZooming = "none";
      element.style.msUserSelect = "none";
      element.style.webkitUserSelect = "none";
      element.style.position = "relative";
      element.style.display = "block";
      element.style.overflow = "hidden";
      element.style.height = element.style.height || this.height && this.height.indexOf("%") === -1 ? element.style.height : "inherit";
    };
    Chart3D2.prototype.isSecondaryAxis = function(axis) {
      return this.axes.indexOf(axis) > -1;
    };
    Chart3D2.prototype.refreshDefinition = function(definitions) {
      for (var _i = 0, definitions_1 = definitions; _i < definitions_1.length; _i++) {
        var item = definitions_1[_i];
        item.axes = [];
      }
    };
    Chart3D2.prototype.addSeries = function(seriesCollection) {
      this.animateSeries = false;
      for (var _i = 0, seriesCollection_1 = seriesCollection; _i < seriesCollection_1.length; _i++) {
        var series = seriesCollection_1[_i];
        series = new Chart3DSeries(this, "series", series);
        this.series.push(series);
      }
      this.refresh();
    };
    Chart3D2.prototype.removeSeries = function(index) {
      this.redraw = false;
      this.animateSeries = false;
      if (this.visibleSeries[index]) {
        this.visibleSeries[index].xAxis.orientation = null;
        this.visibleSeries[index].yAxis.orientation = null;
      }
      for (var i = 0; i < this.axes.length; i++) {
        if (this.axes[i].orientation === null) {
          this.axes.splice(i, 1);
        }
      }
      this.series.splice(index, 1);
      this.refresh();
    };
    Chart3D2.prototype.refreshAxis = function() {
      var axis = this.primaryXAxis;
      axis.rect = new Rect(void 0, void 0, 0, 0);
      axis = this.primaryYAxis;
      axis.isStack100 = false;
      axis.rect = new Rect(void 0, void 0, 0, 0);
      for (var _i = 0, _a = this.axes; _i < _a.length; _i++) {
        var item = _a[_i];
        axis = item;
        axis.rect = new Rect(void 0, void 0, 0, 0);
        axis.isStack100 = false;
      }
    };
    Chart3D2.prototype.axisChange = function(axis) {
      if (!axis.name && !axis.valueType) {
        return false;
      }
      this.refreshDefinition(this.columns);
      this.refreshDefinition(this.rows);
      this.calculateVisibleAxis();
      this.processData();
      return true;
    };
    Chart3D2.prototype.getVisibleSeries = function(visibleSeries, index) {
      for (var _i = 0, visibleSeries_1 = visibleSeries; _i < visibleSeries_1.length; _i++) {
        var series = visibleSeries_1[_i];
        if (index === series.index) {
          return series;
        }
      }
      return null;
    };
    Chart3D2.prototype.removeStyles = function() {
      removeElement(this.element.id + "_ej2_chart_selection");
      removeElement(this.element.id + "_ej2_chart_highlight");
    };
    Chart3D2.prototype.calculateVisibleSeries = function() {
      var series;
      this.visibleSeries = [];
      var colors = this.palettes.length ? this.palettes : get3DSeriesColor(this.theme);
      var count = colors.length;
      var seriesCollection = this.series;
      var vibileSeries = this.series[0];
      if (vibileSeries) {
        this.requireInvertedAxis = vibileSeries.type.indexOf("Bar") !== -1 && !this.isTransposed || vibileSeries.type.indexOf("Bar") === -1 && this.isTransposed;
      }
      for (var i = 0, len = seriesCollection.length; i < len; i++) {
        series = seriesCollection[i];
        series.category = "Series";
        series.index = i;
        series.interior = series.fill || colors[i % count];
        if (this.isSecondaryAxis(series.xAxis)) {
          series.xAxis.internalVisibility = series.xAxis.series.some(function(value) {
            return value.visible;
          });
        }
        if (this.isSecondaryAxis(series.yAxis)) {
          series.yAxis.internalVisibility = series.yAxis.series.some(function(value) {
            return value.visible;
          });
        }
        switch (series.type) {
          case "Bar":
          case "StackingBar":
          case "StackingBar100":
            if (seriesCollection[0].type.indexOf("Bar") === -1) {
              continue;
            }
            break;
          default:
            if (seriesCollection[0].type.indexOf("Bar") > -1) {
              continue;
            }
            break;
        }
        this.visibleSeries.push(series);
        seriesCollection[i] = series;
      }
    };
    Chart3D2.prototype.highlightAnimation = function(element, index, duration, startOpacity) {
      var endOpacity = parseFloat(this.visibleSeries[index].opacity.toString());
      if (endOpacity) {
        new Animation({}).animate(element, {
          duration,
          progress: function(args) {
            element.style.animation = "";
            var progress = args.timeStamp / args.duration;
            var currentOpacity = startOpacity + (endOpacity - startOpacity) * progress;
            element.setAttribute("opacity", currentOpacity.toString());
          },
          end: function() {
            element.setAttribute("opacity", endOpacity.toString());
          }
        });
      }
    };
    Chart3D2.prototype.stopElementAnimation = function(element, index) {
      var endOpacity = parseFloat(this.visibleSeries[index].opacity.toString());
      var animation = element.getAttribute("e-animate");
      if (animation) {
        Animation.stop(element);
      }
      element.setAttribute("opacity", endOpacity.toString());
    };
    Chart3D2.prototype.destroy = function() {
      this.horizontalAxes = [];
      this.verticalAxes = [];
      this.visibleSeries = [];
      this.axisCollections = [];
      this.seriesElements = null;
      this.chartAxisLayoutPanel = null;
      this.dataLabelElements = null;
      this.dataLabelCollections = null;
      removeElement(this.element.id + "Keyboard_chart_focus");
      removeElement(this.element.id + "_ej2_chart_highlight");
      removeElement("chartmeasuretext");
      var highlightElement = document.getElementById(this.element.id + "_ej2_chart_highlight");
      if (highlightElement) {
        highlightElement.remove();
      }
      var selectionElement = document.getElementById(this.element.id + "_ej2_chart_selection");
      if (selectionElement) {
        selectionElement.remove();
      }
      if (this.element) {
        this.unWireEvents();
        if (this.isReact) {
          this.clearTemplate();
        }
        _super.prototype.destroy.call(this);
        this.polygons = [];
        var grpElement = document.getElementById(this.chart3D.id);
        if (grpElement) {
          grpElement.innerHTML = "";
          grpElement.remove();
        }
        this.removeSvg();
        this.svgObject = null;
      }
    };
    Chart3D2.prototype.getModuleName = function() {
      return "chart3d";
    };
    Chart3D2.prototype.getPersistData = function() {
      var keyEntity = ["loaded"];
      return this.addOnPersist(keyEntity);
    };
    Chart3D2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var renderer = false;
      var refreshBounds = false;
      var axis;
      this.animateSeries = false;
      var len;
      var seriesRefresh = false;
      var series;
      if (!this.delayRedraw) {
        for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
          var prop = _a[_i];
          switch (prop) {
            case "primaryXAxis":
              axis = newProp.primaryXAxis;
              refreshBounds = this.axisChange(axis);
              if (newProp.primaryXAxis.edgeLabelPlacement) {
                renderer = true;
              }
              refreshBounds = true;
              if (!isNullOrUndefined(axis.isInversed) || !isNullOrUndefined(axis.opposedPosition)) {
                this.primaryXAxis.setIsInversedAndOpposedPosition();
              }
              break;
            case "primaryYAxis":
              axis = newProp.primaryYAxis;
              refreshBounds = this.axisChange(axis);
              if (newProp.primaryYAxis.edgeLabelPlacement) {
                renderer = true;
              }
              refreshBounds = true;
              if (!isNullOrUndefined(axis.isInversed) || !isNullOrUndefined(axis.opposedPosition)) {
                this.primaryYAxis.setIsInversedAndOpposedPosition();
              }
              break;
            case "axes":
              for (var _b = 0, _c = Object.keys(newProp.axes); _b < _c.length; _b++) {
                var index = _c[_b];
                axis = newProp.axes[index];
                refreshBounds = refreshBounds || this.axisChange(axis);
                refreshBounds = true;
                if (!isNullOrUndefined(axis.isInversed) || !isNullOrUndefined(axis.opposedPosition)) {
                  this.axes[index].setIsInversedAndOpposedPosition();
                }
              }
              break;
            case "height":
            case "width":
              this.createChartSvg();
              refreshBounds = true;
              break;
            case "subTitle":
            case "title":
              refreshBounds = true;
              break;
            case "titleStyle":
              if (newProp.titleStyle && (newProp.titleStyle.size || newProp.titleStyle.textOverflow)) {
                refreshBounds = true;
              } else {
                renderer = true;
              }
              break;
            case "subTitleStyle":
              if (newProp.subTitleStyle && (newProp.subTitleStyle.size || newProp.subTitleStyle.textOverflow)) {
                refreshBounds = true;
              } else {
                renderer = true;
              }
              break;
            case "border":
              renderer = true;
              break;
            case "series":
              len = this.series.length;
              for (var i = 0; i < len; i++) {
                series = newProp.series[i];
                if (series && (series.dataSource || series.query || series.xName || series.yName || series.size || series.fill || series.name || series.type)) {
                  extend(this.getVisibleSeries(this.visibleSeries, i), series, null, true);
                  seriesRefresh = true;
                }
              }
              if (this.availableSize && this.element) {
                this.element.style.height = !this.element.style.height || this.element.style.height === "inherit" ? this.availableSize.height + "px" : this.element.style.height;
              }
              if (seriesRefresh) {
                this.calculateVisibleSeries();
                this.refreshDefinition(this.columns);
                this.refreshDefinition(this.rows);
                this.calculateVisibleAxis();
                this.processData(false);
                refreshBounds = true;
              }
              break;
            case "background":
              renderer = true;
              break;
            case "dataSource":
              this.processData(false);
              refreshBounds = true;
              break;
            case "legendSettings":
              if (!newProp.legendSettings.background || !newProp.legendSettings.opacity) {
                refreshBounds = true;
              }
              renderer = true;
              break;
            case "palettes":
              this.calculateVisibleSeries();
              renderer = true;
              break;
            case "selectedDataIndexes":
              if (this.selection3DModule) {
                this.selection3DModule.currentMode = this.selectionMode;
                this.selection3DModule.selectedDataIndexes = this.selectedDataIndexes;
                this.selection3DModule.styleId = this.element.id + "_ej2_chart_selection";
                this.selection3DModule.redrawSelection(this, oldProp.selectionMode, true);
              }
              break;
            case "selectionMode":
              if (this.selection3DModule && newProp.selectionMode && newProp.selectionMode.indexOf("Drag") === -1) {
                this.selection3DModule.currentMode = this.selectionMode;
                this.selection3DModule.styleId = this.element.id + "_ej2_chart_selection";
                this.selection3DModule.redrawSelection(this, oldProp.selectionMode, true);
              }
              break;
            case "isMultiSelect":
              if (this.selection3DModule && !newProp.isMultiSelect && this.selection3DModule.selectedDataIndexes.length > 1) {
                this.selection3DModule.currentMode = this.selectionMode;
                this.selection3DModule.styleId = this.element.id + "_ej2_chart_selection";
                this.selection3DModule.redrawSelection(this, oldProp.selectionMode);
              }
              break;
            case "highlightMode":
            case "selectionPattern":
            case "highlightPattern":
              this.removeStyles();
              renderer = true;
              break;
            case "theme":
              this.animateSeries = true;
              break;
            case "enableRtl":
            case "locale":
            case "currencyCode":
              this.refresh();
              break;
            case "tooltip":
              if (this.tooltip3DModule) {
                this.tooltip3DModule.previousPoints = [];
                if (this.tooltip.template) {
                  this.tooltip3DModule.template = this.tooltip.template;
                }
              }
              break;
            case "enableRotation":
            case "tilt":
            case "depth":
            case "wallSize":
            case "rotation":
            case "perspectiveAngle":
            case "enableSideBySidePlacement":
              renderer = true;
              break;
          }
        }
        if (!refreshBounds && renderer) {
          this.removeSvg();
          this.polygons = [];
          this.renderElements();
          this.trigger("loaded", {
            chart: this
          });
        }
        if (refreshBounds) {
          this.removeSvg();
          if (this.isReact) {
            this.clearTemplate();
          }
          this.polygons = [];
          this.refreshAxis();
          this.refreshBound();
          this.trigger("loaded", {
            chart: this
          });
          this.redraw = false;
          this.animated = false;
        }
      }
    };
    __decorate30([Property("")], Chart3D2.prototype, "title", void 0);
    __decorate30([Property("")], Chart3D2.prototype, "subTitle", void 0);
    __decorate30([Property("Bootstrap5")], Chart3D2.prototype, "theme", void 0);
    __decorate30([Property(null)], Chart3D2.prototype, "description", void 0);
    __decorate30([Property(null)], Chart3D2.prototype, "width", void 0);
    __decorate30([Property(null)], Chart3D2.prototype, "backgroundImage", void 0);
    __decorate30([Property(null)], Chart3D2.prototype, "background", void 0);
    __decorate30([Property("")], Chart3D2.prototype, "dataSource", void 0);
    __decorate30([Property(null)], Chart3D2.prototype, "height", void 0);
    __decorate30([Property(50)], Chart3D2.prototype, "depth", void 0);
    __decorate30([Property(2)], Chart3D2.prototype, "wallSize", void 0);
    __decorate30([Property(0)], Chart3D2.prototype, "tilt", void 0);
    __decorate30([Property(false)], Chart3D2.prototype, "enableRotation", void 0);
    __decorate30([Property(0)], Chart3D2.prototype, "rotation", void 0);
    __decorate30([Property(true)], Chart3D2.prototype, "enableSideBySidePlacement", void 0);
    __decorate30([Property(90)], Chart3D2.prototype, "perspectiveAngle", void 0);
    __decorate30([Property(null)], Chart3D2.prototype, "wallColor", void 0);
    __decorate30([Property(false)], Chart3D2.prototype, "isTransposed", void 0);
    __decorate30([Property("USD")], Chart3D2.prototype, "currencyCode", void 0);
    __decorate30([Property(false)], Chart3D2.prototype, "enableExport", void 0);
    __decorate30([Event()], Chart3D2.prototype, "load", void 0);
    __decorate30([Event()], Chart3D2.prototype, "loaded", void 0);
    __decorate30([Event()], Chart3D2.prototype, "pointClick", void 0);
    __decorate30([Event()], Chart3D2.prototype, "pointMove", void 0);
    __decorate30([Event()], Chart3D2.prototype, "pointRender", void 0);
    __decorate30([Event()], Chart3D2.prototype, "legendRender", void 0);
    __decorate30([Event()], Chart3D2.prototype, "legendClick", void 0);
    __decorate30([Event()], Chart3D2.prototype, "seriesRender", void 0);
    __decorate30([Event()], Chart3D2.prototype, "textRender", void 0);
    __decorate30([Event()], Chart3D2.prototype, "tooltipRender", void 0);
    __decorate30([Event()], Chart3D2.prototype, "beforeResize", void 0);
    __decorate30([Event()], Chart3D2.prototype, "resized", void 0);
    __decorate30([Event()], Chart3D2.prototype, "chart3DMouseMove", void 0);
    __decorate30([Event()], Chart3D2.prototype, "chart3DMouseClick", void 0);
    __decorate30([Event()], Chart3D2.prototype, "chart3DMouseDown", void 0);
    __decorate30([Event()], Chart3D2.prototype, "chart3DMouseLeave", void 0);
    __decorate30([Event()], Chart3D2.prototype, "chart3DMouseUp", void 0);
    __decorate30([Event()], Chart3D2.prototype, "axisLabelRender", void 0);
    __decorate30([Event()], Chart3D2.prototype, "selectionComplete", void 0);
    __decorate30([Event()], Chart3D2.prototype, "beforeExport", void 0);
    __decorate30([Event()], Chart3D2.prototype, "afterExport", void 0);
    __decorate30([Event()], Chart3D2.prototype, "beforePrint", void 0);
    __decorate30([Complex({}, Margin)], Chart3D2.prototype, "margin", void 0);
    __decorate30([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, TitleSettings)], Chart3D2.prototype, "titleStyle", void 0);
    __decorate30([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, TitleSettings)], Chart3D2.prototype, "subTitleStyle", void 0);
    __decorate30([Complex({}, Chart3DLegendSettings)], Chart3D2.prototype, "legendSettings", void 0);
    __decorate30([Complex({
      color: "#DDDDDD",
      width: 0
    }, Border)], Chart3D2.prototype, "border", void 0);
    __decorate30([Complex({
      name: "primaryXAxis"
    }, Chart3DAxis)], Chart3D2.prototype, "primaryXAxis", void 0);
    __decorate30([Complex({
      name: "primaryYAxis"
    }, Chart3DAxis)], Chart3D2.prototype, "primaryYAxis", void 0);
    __decorate30([Complex({}, Chart3DTooltipSettings)], Chart3D2.prototype, "tooltip", void 0);
    __decorate30([Collection([{}], Chart3DRow)], Chart3D2.prototype, "rows", void 0);
    __decorate30([Collection([{}], Chart3DColumn)], Chart3D2.prototype, "columns", void 0);
    __decorate30([Collection([{}], Chart3DAxis)], Chart3D2.prototype, "axes", void 0);
    __decorate30([Collection([{}], Chart3DSeries)], Chart3D2.prototype, "series", void 0);
    __decorate30([Property("")], Chart3D2.prototype, "highlightColor", void 0);
    __decorate30([Property("None")], Chart3D2.prototype, "selectionMode", void 0);
    __decorate30([Property("None")], Chart3D2.prototype, "highlightMode", void 0);
    __decorate30([Property("None")], Chart3D2.prototype, "selectionPattern", void 0);
    __decorate30([Property("None")], Chart3D2.prototype, "highlightPattern", void 0);
    __decorate30([Property(false)], Chart3D2.prototype, "isMultiSelect", void 0);
    __decorate30([Collection([], Indexes)], Chart3D2.prototype, "selectedDataIndexes", void 0);
    __decorate30([Property(false)], Chart3D2.prototype, "useGroupingSeparator", void 0);
    __decorate30([Property([])], Chart3D2.prototype, "palettes", void 0);
    Chart3D2 = __decorate30([NotifyPropertyChanges], Chart3D2);
    return Chart3D2;
  }(Component)
);

// node_modules/@syncfusion/ej2-charts/src/chart3d/axis/axis-helper.js
var __extends104 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var NiceIntervals = (
  /** @class */
  function(_super) {
    __extends104(NiceIntervals2, _super);
    function NiceIntervals2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    NiceIntervals2.prototype.calculateDateTimeNiceInterval = function(axis, size, start, end) {
      var oneDay = 24 * 60 * 60 * 1e3;
      var startDate = new Date(start);
      var endDate = new Date(end);
      var totalDays = Math.abs((startDate.getTime() - endDate.getTime()) / oneDay);
      var interval;
      axis.actualIntervalType = axis.intervalType;
      var type = axis.intervalType;
      switch (type) {
        case "Years":
          interval = this.calculateNumericNiceInterval(axis, totalDays / 365, size);
          break;
        case "Months":
          interval = this.calculateNumericNiceInterval(axis, totalDays / 30, size);
          break;
        case "Days":
          interval = this.calculateNumericNiceInterval(axis, totalDays, size);
          break;
        case "Hours":
          interval = this.calculateNumericNiceInterval(axis, totalDays * 24, size);
          break;
        case "Minutes":
          interval = this.calculateNumericNiceInterval(axis, totalDays * 24 * 60, size);
          break;
        case "Seconds":
          interval = this.calculateNumericNiceInterval(axis, totalDays * 24 * 60 * 60, size);
          break;
        case "Auto":
          interval = this.calculateNumericNiceInterval(axis, totalDays / 365, size);
          if (interval >= 1) {
            axis.actualIntervalType = "Years";
            return interval;
          }
          interval = this.calculateNumericNiceInterval(axis, totalDays / 30, size);
          if (interval >= 1) {
            axis.actualIntervalType = "Months";
            return interval;
          }
          interval = this.calculateNumericNiceInterval(axis, totalDays, size);
          if (interval >= 1) {
            axis.actualIntervalType = "Days";
            return interval;
          }
          interval = this.calculateNumericNiceInterval(axis, totalDays * 24, size);
          if (interval >= 1) {
            axis.actualIntervalType = "Hours";
            return interval;
          }
          interval = this.calculateNumericNiceInterval(axis, totalDays * 24 * 60, size);
          if (interval >= 1) {
            axis.actualIntervalType = "Minutes";
            return interval;
          }
          interval = this.calculateNumericNiceInterval(axis, totalDays * 24 * 60 * 60, size);
          axis.actualIntervalType = "Seconds";
          return interval;
      }
      return interval;
    };
    NiceIntervals2.prototype.getSkeleton = function(axis) {
      var skeleton;
      var intervalType = axis.actualIntervalType;
      if (axis.skeleton) {
        return axis.skeleton;
      }
      if (intervalType === "Years") {
        skeleton = axis.valueType === "DateTime" && axis.isIntervalInDecimal ? "y" : "yMMM";
      } else if (intervalType === "Months") {
        skeleton = "MMMd";
      } else if (intervalType === "Days") {
        skeleton = axis.valueType === "DateTime" ? "MMMd" : "yMd";
      } else if (intervalType === "Hours") {
        skeleton = axis.valueType === "DateTime" ? "Hm" : "EHm";
      } else if (intervalType === "Minutes") {
        skeleton = "Hms";
      } else {
        skeleton = "Hms";
      }
      return skeleton;
    };
    NiceIntervals2.prototype.findCustomFormats = function(axis) {
      var labelFormat = axis.labelFormat ? axis.labelFormat : "";
      if (!axis.skeleton && axis.actualIntervalType === "Months" && !labelFormat) {
        labelFormat = axis.valueType === "DateTime" ? "MMM yyyy" : "yMMM";
      }
      return labelFormat;
    };
    return NiceIntervals2;
  }(Double3D)
);

// node_modules/@syncfusion/ej2-charts/src/chart3d/axis/category-axis.js
var __extends105 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Category3D = (
  /** @class */
  function(_super) {
    __extends105(Category3D2, _super);
    function Category3D2(chart) {
      return _super.call(this, chart) || this;
    }
    Category3D2.prototype.calculateRangeAndInterval = function(size, axis) {
      this.calculateRange(axis);
      this.getActualRange(axis, size);
      this.applyRangePadding(axis, size);
      this.calculateVisibleLabels(axis);
    };
    Category3D2.prototype.getActualRange = function(axis, size) {
      this.initializeDoubleRange(axis);
      axis.actualRange = {};
      if (!axis.interval) {
        axis.actualRange.interval = Math.max(1, Math.floor(axis.doubleRange.delta / getActualDesiredIntervalsCount(size, axis)));
      } else {
        axis.actualRange.interval = Math.ceil(axis.interval);
      }
      axis.actualRange.min = axis.doubleRange.start;
      axis.actualRange.max = axis.doubleRange.end;
      axis.actualRange.delta = axis.doubleRange.delta;
    };
    Category3D2.prototype.applyRangePadding = function(axis, size) {
      var ticks = 0.5;
      axis.actualRange.min -= ticks;
      axis.actualRange.max += ticks;
      axis.doubleRange = new DoubleRange2(axis.actualRange.min, axis.actualRange.max);
      axis.actualRange.delta = axis.doubleRange.delta;
      this.calculateVisibleRange(size, axis);
    };
    Category3D2.prototype.calculateVisibleLabels = function(axis) {
      axis.visibleLabels = [];
      axis.visibleRange.interval = axis.visibleRange.interval < 1 ? 1 : axis.visibleRange.interval;
      var tempInterval = Math.ceil(axis.visibleRange.min);
      var labelStyle;
      var position;
      axis.startLabel = axis.labels[Math.round(axis.visibleRange.min)];
      axis.endLabel = axis.labels[Math.floor(axis.visibleRange.max)];
      for (; tempInterval <= axis.visibleRange.max; tempInterval += axis.visibleRange.interval) {
        labelStyle = extend({}, getValue("properties", axis.labelStyle), null, true);
        if (withIn(tempInterval, axis.visibleRange) && axis.labels.length > 0) {
          position = Math.round(tempInterval);
          triggerLabelRender(this.chart, position, axis.labels[position] ? axis.labels[position].toString() : position.toString(), labelStyle, axis);
        }
      }
      if (axis.getMaxLabelWidth) {
        axis.getMaxLabelWidth(this.chart);
      }
    };
    Category3D2.prototype.getModuleName = function() {
      return "Category3D";
    };
    Category3D2.prototype.destroy = function() {
    };
    return Category3D2;
  }(NiceIntervals)
);

// node_modules/@syncfusion/ej2-charts/src/chart3d/axis/date-time-axis.js
var __extends106 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DateTime3D = (
  /** @class */
  function(_super) {
    __extends106(DateTime3D2, _super);
    function DateTime3D2(chart) {
      return _super.call(this, chart) || this;
    }
    DateTime3D2.prototype.calculateRangeAndInterval = function(size, axis) {
      this.calculateRange(axis);
      this.getActualRange(axis, size);
      this.applyRangePadding(axis, size);
      this.calculateVisibleLabels(axis, this.chart);
    };
    DateTime3D2.prototype.getActualRange = function(axis, size) {
      var option = {
        skeleton: "full",
        type: "dateTime"
      };
      var dateParser = this.chart.intl.getDateParser(option);
      var dateFormatter = this.chart.intl.getDateFormat(option);
      if (axis.minimum !== null) {
        this.min = Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({
          val: axis.minimum
        }).val))));
      } else if (this.min === null || this.min === Number.POSITIVE_INFINITY) {
        this.min = Date.parse(dateParser(dateFormatter(new Date(1970, 1, 1))));
      }
      if (axis.maximum !== null) {
        this.max = Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({
          val: axis.maximum
        }).val))));
      } else if (this.max === null || this.max === Number.NEGATIVE_INFINITY) {
        this.max = Date.parse(dateParser(dateFormatter(new Date(1970, 5, 1))));
      }
      if (this.min === this.max) {
        this.max = this.max + 2592e6;
        this.min = this.min - 2592e6;
      }
      axis.actualRange = {};
      axis.doubleRange = new DoubleRange2(this.min, this.max);
      var datetimeInterval = this.calculateDateTimeNiceInterval(axis, size, axis.doubleRange.start, axis.doubleRange.end);
      if (!axis.interval) {
        axis.actualRange.interval = datetimeInterval;
      } else {
        axis.actualRange.interval = axis.interval;
      }
      axis.actualRange.min = axis.doubleRange.start;
      axis.actualRange.max = axis.doubleRange.end;
    };
    DateTime3D2.prototype.applyRangePadding = function(axis, size) {
      this.min = axis.actualRange.min;
      this.max = axis.actualRange.max;
      var minimum;
      var maximum;
      var interval = axis.actualRange.interval;
      if (!setRange(axis)) {
        var rangePadding = axis.getRangePadding(this.chart);
        minimum = new Date(this.min);
        maximum = new Date(this.max);
        var intervalType = axis.actualIntervalType;
        if (rangePadding === "None") {
          this.min = minimum.getTime();
          this.max = maximum.getTime();
        } else if (rangePadding === "Additional" || rangePadding === "Round") {
          switch (intervalType) {
            case "Years":
              this.getYear(minimum, maximum, rangePadding, interval);
              break;
            case "Months":
              this.getMonth(minimum, maximum, rangePadding, interval);
              break;
            case "Days":
              this.getDay(minimum, maximum, rangePadding, interval);
              break;
            case "Hours":
              this.getHour(minimum, maximum, rangePadding, interval);
              break;
            case "Minutes": {
              var minute = minimum.getMinutes() / interval * interval;
              var endMinute = maximum.getMinutes() + (minimum.getMinutes() - minute);
              if (rangePadding === "Round") {
                this.min = new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minute, 0).getTime();
                this.max = new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), endMinute, 59).getTime();
              } else {
                this.min = new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minute + -interval, 0).getTime();
                this.max = new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), endMinute + interval, 0).getTime();
              }
              break;
            }
            case "Seconds": {
              var second = minimum.getSeconds() / interval * interval;
              var endSecond = maximum.getSeconds() + (minimum.getSeconds() - second);
              if (rangePadding === "Round") {
                this.min = new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minimum.getMinutes(), second, 0).getTime();
                this.max = new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), maximum.getMinutes(), endSecond, 0).getTime();
              } else {
                this.min = new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minimum.getMinutes(), second + -interval, 0).getTime();
                this.max = new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), maximum.getMinutes(), endSecond + interval, 0).getTime();
              }
              break;
            }
          }
        }
      }
      axis.actualRange.min = axis.minimum != null ? this.min : this.min;
      axis.actualRange.max = axis.maximum != null ? this.max : this.max;
      axis.actualRange.delta = axis.actualRange.max - axis.actualRange.min;
      axis.doubleRange = new DoubleRange2(axis.actualRange.min, axis.actualRange.max);
      this.calculateVisibleRange(size, axis);
    };
    DateTime3D2.prototype.getYear = function(minimum, maximum, rangePadding, interval) {
      var startYear = minimum.getFullYear();
      var endYear = maximum.getFullYear();
      if (rangePadding === "Additional") {
        this.min = new Date(startYear - interval, 1, 1, 0, 0, 0).getTime();
        this.max = new Date(endYear + interval, 1, 1, 0, 0, 0).getTime();
      } else {
        this.min = new Date(startYear, 0, 0, 0, 0, 0).getTime();
        this.max = new Date(endYear, 11, 30, 23, 59, 59).getTime();
      }
    };
    DateTime3D2.prototype.getMonth = function(minimum, maximum, rangePadding, interval) {
      var month = minimum.getMonth();
      var endMonth = maximum.getMonth();
      if (rangePadding === "Round") {
        this.min = new Date(minimum.getFullYear(), month, 0, 0, 0, 0).getTime();
        this.max = new Date(maximum.getFullYear(), endMonth, new Date(maximum.getFullYear(), maximum.getMonth(), 0).getDate(), 23, 59, 59).getTime();
      } else {
        this.min = new Date(minimum.getFullYear(), month + -interval, 1, 0, 0, 0).getTime();
        this.max = new Date(maximum.getFullYear(), endMonth + interval, endMonth === 2 ? 28 : 30, 0, 0, 0).getTime();
      }
    };
    DateTime3D2.prototype.getDay = function(minimum, maximum, rangePadding, interval) {
      var day = minimum.getDate();
      var endDay = maximum.getDate();
      if (rangePadding === "Round") {
        this.min = new Date(minimum.getFullYear(), minimum.getMonth(), day, 0, 0, 0).getTime();
        this.max = new Date(maximum.getFullYear(), maximum.getMonth(), endDay, 23, 59, 59).getTime();
      } else {
        this.min = new Date(minimum.getFullYear(), minimum.getMonth(), day + -interval, 0, 0, 0).getTime();
        this.max = new Date(maximum.getFullYear(), maximum.getMonth(), endDay + interval, 0, 0, 0).getTime();
      }
    };
    DateTime3D2.prototype.getHour = function(minimum, maximum, rangePadding, interval) {
      var hour = minimum.getHours() / interval * interval;
      var endHour = maximum.getHours() + (minimum.getHours() - hour);
      if (rangePadding === "Round") {
        this.min = new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), hour, 0, 0).getTime();
        this.max = new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), endHour, 59, 59).getTime();
      } else {
        this.min = new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), hour + -interval, 0, 0).getTime();
        this.max = new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), endHour + interval, 0, 0).getTime();
      }
    };
    DateTime3D2.prototype.calculateVisibleRange = function(size, axis) {
      axis.visibleRange = {
        min: axis.actualRange.min,
        max: axis.actualRange.max,
        interval: axis.actualRange.interval,
        delta: axis.actualRange.delta
      };
      axis.dateTimeInterval = this.increaseDateTimeInterval(axis, axis.visibleRange.min, axis.visibleRange.interval).getTime() - axis.visibleRange.min;
      axis.triggerRangeRender(this.chart, axis.visibleRange.min, axis.visibleRange.max, axis.visibleRange.interval);
    };
    DateTime3D2.prototype.calculateVisibleLabels = function(axis, chart) {
      axis.visibleLabels = [];
      var tempInterval = axis.visibleRange.min;
      var labelStyle;
      if (!setRange(axis)) {
        tempInterval = this.alignRangeStart(axis, tempInterval, axis.visibleRange.interval).getTime();
      }
      while (tempInterval <= axis.visibleRange.max) {
        labelStyle = extend({}, getValue("properties", axis.labelStyle), null, true);
        axis.format = chart.intl.getDateFormat({
          format: this.findCustomFormats(axis) || "",
          type: firstToLowerCase(axis.skeletonType),
          skeleton: this.getSkeleton(axis)
        });
        axis.startLabel = axis.format(new Date(axis.visibleRange.min));
        axis.endLabel = axis.format(new Date(axis.visibleRange.max));
        if (withIn(tempInterval, axis.visibleRange)) {
          var interval = this.increaseDateTimeInterval(axis, tempInterval, axis.visibleRange.interval).getTime();
          if (interval > axis.visibleRange.max) {
            axis.endLabel = axis.format(new Date(tempInterval));
          }
          triggerLabelRender(chart, tempInterval, axis.format(new Date(tempInterval)), labelStyle, axis);
        }
        var actualInterval = tempInterval;
        tempInterval = this.increaseDateTimeInterval(axis, tempInterval, axis.visibleRange.interval).getTime();
        if (actualInterval === tempInterval) {
          break;
        }
      }
      if (axis.actualIntervalType === "Months" || axis.actualIntervalType === "Days") {
        axis.format = chart.intl.getDateFormat({
          format: axis.labelFormat || (axis.actualIntervalType === "Months" && !axis.skeleton ? "y MMM" : ""),
          type: firstToLowerCase(axis.skeletonType),
          skeleton: axis.skeleton || (axis.actualIntervalType === "Days" ? "MMMd" : "")
        });
      }
      if (axis.getMaxLabelWidth) {
        axis.getMaxLabelWidth(this.chart);
      }
    };
    DateTime3D2.prototype.increaseDateTimeInterval = function(axis, value, interval) {
      var result = new Date(value);
      if (axis.interval) {
        axis.isIntervalInDecimal = interval % 1 === 0;
        axis.visibleRange.interval = interval;
      } else {
        interval = Math.ceil(interval);
        axis.visibleRange.interval = interval;
      }
      var intervalType = axis.actualIntervalType;
      if (axis.isIntervalInDecimal) {
        switch (intervalType) {
          case "Years":
            result.setFullYear(result.getFullYear() + interval);
            return result;
          case "Months":
            result.setMonth(result.getMonth() + interval);
            return result;
          case "Days":
            result.setDate(result.getDate() + interval);
            return result;
          case "Hours":
            result.setHours(result.getHours() + interval);
            return result;
          case "Minutes":
            result.setMinutes(result.getMinutes() + interval);
            return result;
          case "Seconds":
            result.setSeconds(result.getSeconds() + interval);
            return result;
        }
      }
      return result;
    };
    DateTime3D2.prototype.alignRangeStart = function(axis, sDate, intervalSize) {
      var sResult = new Date(sDate);
      switch (axis.actualIntervalType) {
        case "Years": {
          var year = Math.floor(Math.floor(sResult.getFullYear() / intervalSize) * intervalSize);
          sResult = new Date(year, sResult.getMonth(), sResult.getDate(), 0, 0, 0);
          return sResult;
        }
        case "Months": {
          var month = Math.floor(Math.floor(sResult.getMonth() / intervalSize) * intervalSize);
          sResult = new Date(sResult.getFullYear(), month, sResult.getDate(), 0, 0, 0);
          return sResult;
        }
        case "Days": {
          var day = Math.floor(Math.floor(sResult.getDate() / intervalSize) * intervalSize);
          sResult = new Date(sResult.getFullYear(), sResult.getMonth(), day, 0, 0, 0);
          return sResult;
        }
        case "Hours": {
          var hour = Math.floor(Math.floor(sResult.getHours() / intervalSize) * intervalSize);
          sResult = new Date(sResult.getFullYear(), sResult.getMonth(), sResult.getDate(), hour, 0, 0);
          return sResult;
        }
        case "Minutes": {
          var minutes = Math.floor(Math.floor(sResult.getMinutes() / intervalSize) * intervalSize);
          sResult = new Date(sResult.getFullYear(), sResult.getMonth(), sResult.getDate(), sResult.getHours(), minutes, 0, 0);
          return sResult;
        }
        case "Seconds": {
          var seconds = Math.floor(Math.floor(sResult.getSeconds() / intervalSize) * intervalSize);
          sResult = new Date(sResult.getFullYear(), sResult.getMonth(), sResult.getDate(), sResult.getHours(), sResult.getMinutes(), seconds, 0);
          return sResult;
        }
      }
      return sResult;
    };
    DateTime3D2.prototype.getModuleName = function() {
      return "DateTime3D";
    };
    DateTime3D2.prototype.destroy = function() {
    };
    return DateTime3D2;
  }(NiceIntervals)
);

// node_modules/@syncfusion/ej2-charts/src/chart3d/axis/date-time-category-axis.js
var __extends107 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DateTimeCategory3D = (
  /** @class */
  function(_super) {
    __extends107(DateTimeCategory3D2, _super);
    function DateTimeCategory3D2(chart) {
      return _super.call(this, chart) || this;
    }
    DateTimeCategory3D2.prototype.calculateRangeAndInterval = function(size, axis) {
      this.axisSize = size;
      this.calculateRange(axis);
      this.getActualRange(axis, size);
      this.applyRangePadding(axis, size);
      this.calculateVisibleLabels(axis);
    };
    DateTimeCategory3D2.prototype.calculateVisibleLabels = function(axis) {
      axis.visibleLabels = [];
      var labelStyle;
      var padding = 0;
      if (axis.intervalType === "Auto") {
        this.calculateDateTimeNiceInterval(axis, this.axisSize, parseInt(axis.labels[0], 10), parseInt(axis.labels[axis.labels.length - 1], 10));
      } else {
        axis.actualIntervalType = axis.intervalType;
      }
      axis.format = this.chart.intl.getDateFormat({
        format: axis.labelFormat || "",
        type: firstToLowerCase(axis.skeletonType),
        skeleton: this.getSkeleton(axis)
      });
      var i = 0;
      for (; i < axis.labels.length; i++) {
        labelStyle = extend({}, getValue("properties", axis.labelStyle), null, true);
        if (!this.sameInterval(axis.labels.map(Number)[i], axis.labels.map(Number)[i - 1], axis.actualIntervalType, i) || axis.isIndexed) {
          if (withIn(i - padding, axis.visibleRange)) {
            triggerLabelRender(this.chart, i, axis.isIndexed ? this.getIndexedAxisLabel(axis.labels[i], axis.format) : axis.format(new Date(axis.labels.map(Number)[i])), labelStyle, axis);
          }
        }
      }
      if (axis.getMaxLabelWidth) {
        axis.getMaxLabelWidth(this.chart);
      }
    };
    DateTimeCategory3D2.prototype.getIndexedAxisLabel = function(value, format) {
      var texts = value.split(",");
      for (var i = 0; i < texts.length; i++) {
        texts[i] = format(new Date(parseInt(texts[i], 10)));
      }
      return texts.join(", ");
    };
    DateTimeCategory3D2.prototype.sameInterval = function(currentDate, previousDate, type, index) {
      var sameValue;
      if (index === 0) {
        sameValue = false;
      } else {
        switch (type) {
          case "Years":
            sameValue = new Date(currentDate).getFullYear() === new Date(previousDate).getFullYear();
            break;
          case "Months":
            sameValue = new Date(currentDate).getFullYear() === new Date(previousDate).getFullYear() && new Date(currentDate).getMonth() === new Date(previousDate).getMonth();
            break;
          case "Days":
            sameValue = Math.abs(currentDate - previousDate) < 24 * 60 * 60 * 1e3 && new Date(currentDate).getDay() === new Date(previousDate).getDay();
            break;
          case "Hours":
            sameValue = Math.abs(currentDate - previousDate) < 60 * 60 * 1e3 && new Date(currentDate).getDay() === new Date(previousDate).getDay();
            break;
          case "Minutes":
            sameValue = Math.abs(currentDate - previousDate) < 60 * 1e3 && new Date(currentDate).getMinutes() === new Date(previousDate).getMinutes();
            break;
          case "Seconds":
            sameValue = Math.abs(currentDate - previousDate) < 1e3 && new Date(currentDate).getDay() === new Date(previousDate).getDay();
            break;
        }
      }
      return sameValue;
    };
    DateTimeCategory3D2.prototype.getModuleName = function() {
      return "DateTimeCategory3D";
    };
    DateTimeCategory3D2.prototype.destroy = function() {
    };
    return DateTimeCategory3D2;
  }(Category3D)
);

// node_modules/@syncfusion/ej2-charts/src/chart3d/axis/logarithmic-axis.js
var __extends108 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Logarithmic3D = (
  /** @class */
  function(_super) {
    __extends108(Logarithmic3D2, _super);
    function Logarithmic3D2(chart) {
      return _super.call(this, chart) || this;
    }
    Logarithmic3D2.prototype.calculateRangeAndInterval = function(size, axis) {
      this.calculateRange(axis);
      this.getActualRange(axis, size);
      this.calculateVisibleRange(size, axis);
      this.calculateVisibleLabels(axis, this.chart);
    };
    Logarithmic3D2.prototype.getActualRange = function(axis, size) {
      this.initializeDoubleRange(axis);
      this.min = this.min < 0 ? 0 : this.min;
      var logStart = logBase(this.min, axis.logBase);
      logStart = isFinite(logStart) ? logStart : this.min;
      var logEnd = this.max === 1 ? 1 : logBase(this.max, axis.logBase);
      logEnd = isFinite(logStart) ? logEnd : this.max;
      this.min = Math.floor(logStart / 1);
      var isRectSeries = axis.series && axis.series.some(function(item) {
        return item.type.indexOf("Column") !== -1 || item.type.indexOf("Bar") !== -1;
      });
      if (isRectSeries) {
        this.min = this.min <= 0 ? +this.min - 1 : this.min;
      }
      this.max = Math.ceil(logEnd / 1);
      this.max = this.max === this.min ? this.max + 1 : this.max;
      axis.actualRange.interval = axis.interval || this.calculateLogNiceInterval(this.max - this.min, size, axis);
      axis.actualRange.min = this.min;
      axis.actualRange.max = this.max;
      axis.actualRange.delta = this.max - this.min;
    };
    Logarithmic3D2.prototype.calculateVisibleRange = function(size, axis) {
      axis.visibleRange = {
        interval: axis.actualRange.interval,
        max: axis.actualRange.max,
        min: axis.actualRange.min,
        delta: axis.actualRange.delta
      };
    };
    Logarithmic3D2.prototype.calculateLogNiceInterval = function(delta, size, axis) {
      var actualDesiredIntervalsCount = getActualDesiredIntervalsCount(size, axis);
      var niceInterval = delta;
      var minInterval = Math.pow(axis.logBase, Math.floor(logBase(niceInterval, 10)));
      for (var j = 0, len = axis.intervalDivs.length; j < len; j++) {
        var currentInterval = minInterval * axis.intervalDivs[j];
        if (actualDesiredIntervalsCount < delta / currentInterval) {
          break;
        }
        niceInterval = currentInterval;
      }
      return niceInterval;
    };
    Logarithmic3D2.prototype.calculateVisibleLabels = function(axis, chart) {
      var tempInterval = axis.visibleRange.min;
      axis.visibleLabels = [];
      var labelStyle;
      var value;
      var axisFormat = this.getFormat(axis);
      var isCustomFormat = axisFormat.match("{value}") !== null;
      var startValue = Math.pow(axis.logBase, axis.visibleRange.min);
      axis.format = chart.intl.getNumberFormat({
        format: isCustomFormat ? "" : axisFormat,
        useGrouping: chart.useGroupingSeparator,
        maximumFractionDigits: startValue < 1 ? 20 : 3
      });
      axis.startLabel = axis.format(startValue < 1 ? +startValue.toPrecision(1) : startValue);
      axis.endLabel = axis.format(Math.pow(axis.logBase, axis.visibleRange.max));
      for (; tempInterval <= axis.visibleRange.max; tempInterval += axis.visibleRange.interval) {
        labelStyle = extend({}, getValue("properties", axis.labelStyle), null, true);
        if (withIn(tempInterval, axis.visibleRange)) {
          value = Math.pow(axis.logBase, tempInterval);
          triggerLabelRender(this.chart, tempInterval, this.formatValue(axis, isCustomFormat, axisFormat, value < 1 ? +value.toPrecision(1) : value), labelStyle, axis);
        }
      }
      if (axis.getMaxLabelWidth) {
        axis.getMaxLabelWidth(this.chart);
      }
    };
    Logarithmic3D2.prototype.getModuleName = function() {
      return "Logarithmic3D";
    };
    Logarithmic3D2.prototype.destroy = function() {
    };
    return Logarithmic3D2;
  }(Double3D)
);

// node_modules/@syncfusion/ej2-charts/src/chart3d/series/column-series.js
var ColumnSeries3D = (
  /** @class */
  function() {
    function ColumnSeries3D2() {
    }
    ColumnSeries3D2.prototype.draw = function(series, chart) {
      this.createSegments(series);
      for (var i = 0; i < series.visiblePoints.length; i++) {
        var point = series.visiblePoints[i];
        if (point.visible) {
          var argsData = {
            cancel: false,
            series,
            point,
            fill: series.setPointColor(point, series.interior)
          };
          chart.trigger(pointRender, argsData);
          point.color = argsData.fill;
          point.plans = null;
          if (!argsData.cancel) {
            this.update(argsData.series, argsData.point, i, chart);
          } else {
            point.symbolLocations = null;
          }
        }
      }
    };
    ColumnSeries3D2.prototype.update = function(series, point, pointIndex, chart) {
      var seriesIndex = series.index;
      var left = point.left;
      var right = point.right;
      var bottom = series.yAxis.valueType === "Logarithmic" ? Math.pow(series.yAxis.logBase, series.yAxis.visibleRange.min) : series.yAxis.visibleRange.min;
      var top = series.yAxis.valueType === "Logarithmic" ? Math.pow(series.yAxis.logBase, series.yAxis.visibleRange.max) : series.yAxis.visibleRange.max;
      var xStart = series.xAxis.visibleRange.min;
      var xEnd = series.xAxis.visibleRange.max;
      if (!(left >= xStart && left <= xEnd) || !(right >= xStart && right <= xEnd)) {
        return;
      }
      var topValue;
      if (point.top < 0) {
        topValue = point.top > bottom ? point.top : bottom;
      } else {
        topValue = series.yAxis.valueType && series.yAxis.valueType.toLowerCase() === "logarithmic" ? point.top : point.top < top ? point.top : top;
      }
      var tlpoint = chart.svg3DRenderer.transform3DToVisible(series, point.left > xStart ? point.left : xStart, topValue, chart);
      var rbpoint = chart.svg3DRenderer.transform3DToVisible(series, xEnd > point.right ? point.right : xEnd, bottom > point.bottom ? bottom : point.bottom, chart);
      var tlfVector = chart.vector.vector3D(Math.min(tlpoint.x, rbpoint.x), Math.min(tlpoint.y, rbpoint.y), point.startDepth);
      var brbVector = chart.vector.vector3D(Math.max(tlpoint.x, rbpoint.x), Math.max(tlpoint.y, rbpoint.y), point.endDepth);
      var styleOptions = series.setStyle(series);
      var name = "region-series-" + seriesIndex + "-point-" + pointIndex;
      var accessibilityText = point.x + ":" + point.yValue + ", " + series.name;
      if (series.columnFacet === "Cylinder") {
        chart.polygon.createCylinder(tlfVector, brbVector, chart, pointIndex, series.type, "", point.color, null, styleOptions.opacity, name, chart.chart3D);
      } else if (series.columnFacet === "Rectangle") {
        chart.polygon.createBox(tlfVector, brbVector, chart, pointIndex, "", point.color, null, styleOptions.opacity, chart.requireInvertedAxis, name, chart.chart3D, accessibilityText);
      }
    };
    ColumnSeries3D2.prototype.createSegments = function(series) {
      var xValues = series.getXValues(series.visiblePoints);
      var YValues = series.getYValues(series.visiblePoints);
      if (xValues == null || YValues == null) {
        return;
      }
      var sbsInfo = series.getSideBySideInfo(series);
      var depthInfo = series.getSegmentDepth(series);
      var crossValue = 0;
      var median = sbsInfo.delta / 2;
      var visiblePoints = series.visiblePoints;
      var cons = 0.2;
      for (var i = 0; i < visiblePoints.length; i++) {
        var x1 = xValues[i] + sbsInfo.start;
        var x2 = xValues[i] + sbsInfo.end;
        var y1 = YValues[i];
        var y2 = crossValue;
        this.setData(x1, y1, x2, y2, depthInfo.start, depthInfo.end, series, visiblePoints[i]);
        if (!series.dataLabel.visible) {
          continue;
        }
        visiblePoints[i].symbolLocations = {
          x: 0,
          y: 0,
          z: 0
        };
        switch (series.dataLabel.position) {
          case "Top":
            visiblePoints[i].symbolLocations.x = x1 + median;
            visiblePoints[i].symbolLocations.y = y1;
            visiblePoints[i].symbolLocations.z = depthInfo.start;
            break;
          case "Bottom":
            visiblePoints[i].symbolLocations.x = x1 + median;
            visiblePoints[i].symbolLocations.y = y2 - cons + series.yAxis.visibleRange.min;
            visiblePoints[i].symbolLocations.z = depthInfo.start + (depthInfo.end - depthInfo.start) / 2;
            break;
          default:
            visiblePoints[i].symbolLocations.x = x1 + median;
            visiblePoints[i].symbolLocations.y = Math.abs(y2 - y1) / 2 + series.yAxis.visibleRange.min / 2;
            visiblePoints[i].symbolLocations.z = depthInfo.start;
            break;
        }
      }
    };
    ColumnSeries3D2.prototype.setData = function(x1, y1, x2, y2, start, end, series, point) {
      point.left = x1;
      point.bottom = y2;
      point.top = y1;
      point.right = x2;
      point.startDepth = start;
      point.endDepth = end;
      point.xRange = series.getDoubleRange(point.left, point.right);
      if (!isNaN(point.top) && !isNaN(point.bottom)) {
        point.yRange = series.getDoubleRange(point.top, point.bottom);
      }
    };
    ColumnSeries3D2.prototype.destroy = function() {
    };
    ColumnSeries3D2.prototype.getModuleName = function() {
      return "ColumnSeries3D";
    };
    return ColumnSeries3D2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart3d/series/stacking-column-series.js
var StackingColumnSeries3D = (
  /** @class */
  function() {
    function StackingColumnSeries3D2() {
    }
    StackingColumnSeries3D2.prototype.draw = function(series, chart) {
      this.createSegments(series);
      for (var i = 0; i < series.visiblePoints.length; i++) {
        var point = series.visiblePoints[i];
        if (point.visible) {
          var argsData = {
            cancel: false,
            series,
            point,
            fill: series.setPointColor(point, series.interior)
          };
          chart.trigger(pointRender, argsData);
          point.color = argsData.fill;
          point.plans = null;
          if (!argsData.cancel) {
            this.update(argsData.series, argsData.point, i, chart);
          } else {
            point.symbolLocations = null;
          }
        }
      }
    };
    StackingColumnSeries3D2.prototype.update = function(series, point, pointIndex, chart) {
      var seriesIndex = series.index;
      var left = point.left;
      var right = point.right;
      var bottom = series.yAxis.valueType === "Logarithmic" ? Math.pow(series.yAxis.logBase, series.yAxis.visibleRange.min) : series.yAxis.visibleRange.min;
      var top = series.yAxis.valueType === "Logarithmic" ? Math.pow(series.yAxis.logBase, series.yAxis.visibleRange.max) : series.yAxis.visibleRange.max;
      var xStart = series.xAxis.visibleRange.min;
      var xEnd = series.xAxis.visibleRange.max;
      if (!(left >= xStart && left <= xEnd) || !(right >= xStart && right <= xEnd)) {
        return;
      }
      var topValue;
      if (point.top < 0) {
        topValue = point.top > bottom ? point.top : bottom;
      } else {
        topValue = series.yAxis.valueType && series.yAxis.valueType.toLowerCase() === "logarithmic" ? point.top : point.top < top ? point.top : top;
      }
      var tlpoint = chart.svg3DRenderer.transform3DToVisible(series, point.left > xStart ? point.left : xStart, topValue, chart);
      var rbpoint = chart.svg3DRenderer.transform3DToVisible(series, xEnd > point.right ? point.right : xEnd, bottom > point.bottom ? bottom : point.bottom, chart);
      var tlfVector = chart.vector.vector3D(Math.min(tlpoint.x, rbpoint.x), Math.min(tlpoint.y, rbpoint.y), point.startDepth);
      var brbVector = chart.vector.vector3D(Math.max(tlpoint.x, rbpoint.x), Math.max(tlpoint.y, rbpoint.y), point.endDepth);
      var styleOptions = series.setStyle(series);
      var name = "region-series-" + seriesIndex + "-point-" + pointIndex;
      if (series.columnFacet === "Cylinder") {
        chart.polygon.createCylinder(tlfVector, brbVector, chart, pointIndex, series.type, "", point.color, null, styleOptions.opacity, name, chart.chart3D);
      } else if (series.columnFacet === "Rectangle") {
        chart.polygon.createBox(tlfVector, brbVector, chart, pointIndex, "", point.color, null, styleOptions.opacity, chart.requireInvertedAxis, name, chart.chart3D);
      }
    };
    StackingColumnSeries3D2.prototype.createSegments = function(series) {
      var xValues = series.getXValues(series.visiblePoints);
      if (xValues == null) {
        return;
      }
      var sbsInfo = series.getSideBySideInfo(series);
      var depthInfo = series.getSegmentDepth(series);
      var median = sbsInfo.delta / 2;
      var visiblePoints = series.visiblePoints;
      var cons = 0.2;
      for (var i = 0; i < visiblePoints.length; i++) {
        var x1 = xValues[i] + sbsInfo.start;
        var x2 = xValues[i] + sbsInfo.end;
        var y1 = series.stackedValues.startValues[i];
        var y2 = series.stackedValues.endValues[i];
        this.setData(x1, y1, x2, y2, depthInfo.start, depthInfo.end, series, visiblePoints[i]);
        if (!series.dataLabel.visible) {
          continue;
        }
        visiblePoints[i].symbolLocations = {
          x: 0,
          y: 0,
          z: 0
        };
        switch (series.dataLabel.position) {
          case "Top":
            visiblePoints[i].symbolLocations.x = x1 + median;
            visiblePoints[i].symbolLocations.y = y1;
            visiblePoints[i].symbolLocations.z = depthInfo.start + depthInfo.delta / 2;
            break;
          case "Bottom":
            visiblePoints[i].symbolLocations.x = x1 + median;
            visiblePoints[i].symbolLocations.y = y2 - cons;
            visiblePoints[i].symbolLocations.z = depthInfo.start + (depthInfo.end - depthInfo.start) / 2;
            break;
          default:
            visiblePoints[i].symbolLocations.x = x1 + median;
            visiblePoints[i].symbolLocations.y = y1 + (y2 - y1) / 2;
            visiblePoints[i].symbolLocations.z = depthInfo.start;
            break;
        }
      }
    };
    StackingColumnSeries3D2.prototype.setData = function(x1, y1, x2, y2, start, end, series, point) {
      point.left = x1;
      point.bottom = y2;
      point.top = y1;
      point.right = x2;
      point.startDepth = start;
      point.endDepth = end;
      point.xRange = series.getDoubleRange(point.left, point.right);
      if (!isNaN(point.top) && !isNaN(point.bottom)) {
        point.yRange = series.getDoubleRange(point.top, point.bottom);
      }
    };
    StackingColumnSeries3D2.prototype.destroy = function() {
    };
    StackingColumnSeries3D2.prototype.getModuleName = function() {
      return "StackingColumnSeries3D";
    };
    return StackingColumnSeries3D2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart3d/series/stacking-bar-series.js
var StackingBarSeries3D = (
  /** @class */
  function() {
    function StackingBarSeries3D2() {
    }
    StackingBarSeries3D2.prototype.draw = function(series, chart) {
      this.createSegments(series);
      series.isRectSeries = true;
      for (var i = 0; i < series.visiblePoints.length; i++) {
        var point = series.visiblePoints[i];
        if (point.visible) {
          var argsData = {
            cancel: false,
            series,
            point,
            fill: series.setPointColor(point, series.interior)
          };
          chart.trigger(pointRender, argsData);
          point.color = argsData.fill;
          point.plans = null;
          if (!argsData.cancel) {
            this.update(argsData.series, argsData.point, i, chart);
          } else {
            point.symbolLocations = null;
          }
        }
      }
    };
    StackingBarSeries3D2.prototype.update = function(series, point, pointIndex, chart) {
      var seriesIndex = series.index;
      var left = point.left;
      var right = point.right;
      var bottom = series.yAxis.valueType === "Logarithmic" ? Math.pow(series.yAxis.logBase, series.yAxis.visibleRange.min) : series.yAxis.visibleRange.min;
      var top = series.yAxis.valueType === "Logarithmic" ? Math.pow(series.yAxis.logBase, series.yAxis.visibleRange.max) : series.yAxis.visibleRange.max;
      var xStart = series.xAxis.visibleRange.min;
      var xEnd = series.xAxis.visibleRange.max;
      if (!(left >= xStart && left <= xEnd) || !(right >= xStart && right <= xEnd)) {
        return;
      }
      var topValue;
      if (point.top < 0) {
        topValue = point.top > bottom ? point.top : bottom;
      } else {
        topValue = series.yAxis.valueType && series.yAxis.valueType.toLowerCase() === "logarithmic" ? point.top : point.top < top ? point.top : top;
      }
      var tlpoint = chart.svg3DRenderer.transform3DToVisible(series, point.left > xStart ? point.left : xStart, topValue, chart);
      var rbpoint = chart.svg3DRenderer.transform3DToVisible(series, xEnd > point.right ? point.right : xEnd, bottom > point.bottom ? bottom : point.bottom, chart);
      var tlfVector = chart.vector.vector3D(Math.min(tlpoint.x, rbpoint.x), Math.min(tlpoint.y, rbpoint.y), point.startDepth);
      var brbVector = chart.vector.vector3D(Math.max(tlpoint.x, rbpoint.x), Math.max(tlpoint.y, rbpoint.y), point.endDepth);
      var styleOptions = series.setStyle(series);
      var name = "region-series-" + seriesIndex + "-point-" + pointIndex;
      if (series.columnFacet === "Cylinder") {
        chart.polygon.createCylinder(tlfVector, brbVector, chart, pointIndex, series.type, "", point.color, null, styleOptions.opacity, name, chart.chart3D);
      } else if (series.columnFacet === "Rectangle") {
        chart.polygon.createBox(tlfVector, brbVector, chart, pointIndex, "", point.color, null, styleOptions.opacity, chart.requireInvertedAxis, name, chart.chart3D);
      }
    };
    StackingBarSeries3D2.prototype.createSegments = function(series) {
      var xValues = series.getXValues(series.visiblePoints);
      if (xValues == null) {
        return;
      }
      var sbsInfo = series.getSideBySideInfo(series);
      var depthInfo = series.getSegmentDepth(series);
      var median = sbsInfo.delta / 2;
      var visiblePoints = series.visiblePoints;
      var cons = 0.2;
      for (var i = 0; i < visiblePoints.length; i++) {
        var x1 = xValues[i] + sbsInfo.start;
        var x2 = xValues[i] + sbsInfo.end;
        var y2 = series.stackedValues.startValues[i];
        var y1 = series.stackedValues.endValues[i];
        this.setData(x1, y1, x2, y2, depthInfo.start, depthInfo.end, series, visiblePoints[i]);
        if (!series.dataLabel.visible) {
          continue;
        }
        visiblePoints[i].symbolLocations = {
          x: 0,
          y: 0,
          z: 0
        };
        switch (series.dataLabel.position) {
          case "Top":
            visiblePoints[i].symbolLocations.x = x1 + median;
            visiblePoints[i].symbolLocations.y = y1;
            visiblePoints[i].symbolLocations.z = depthInfo.start + depthInfo.delta / 2;
            break;
          case "Bottom":
            visiblePoints[i].symbolLocations.x = x1 + median;
            visiblePoints[i].symbolLocations.y = y2 - cons;
            visiblePoints[i].symbolLocations.z = depthInfo.start + (depthInfo.end - depthInfo.start) / 2;
            break;
          default:
            visiblePoints[i].symbolLocations.x = x1 + median;
            visiblePoints[i].symbolLocations.y = y1 + (y2 - y1) / 2;
            visiblePoints[i].symbolLocations.z = depthInfo.start;
            break;
        }
      }
    };
    StackingBarSeries3D2.prototype.setData = function(x1, y1, x2, y2, start, end, series, point) {
      point.left = x1;
      point.bottom = y2;
      point.top = y1;
      point.right = x2;
      point.startDepth = start;
      point.endDepth = end;
      point.xRange = series.getDoubleRange(point.left, point.right);
      if (!isNaN(point.top) && !isNaN(point.bottom)) {
        point.yRange = series.getDoubleRange(point.top, point.bottom);
      }
    };
    StackingBarSeries3D2.prototype.destroy = function() {
    };
    StackingBarSeries3D2.prototype.getModuleName = function() {
      return "StackingBarSeries3D";
    };
    return StackingBarSeries3D2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart3d/series/bar-series.js
var BarSeries3D = (
  /** @class */
  function() {
    function BarSeries3D2() {
    }
    BarSeries3D2.prototype.draw = function(series, chart) {
      this.createSegments(series);
      for (var i = 0; i < series.visiblePoints.length; i++) {
        var point = series.visiblePoints[i];
        if (point.visible) {
          var argsData = {
            cancel: false,
            series,
            point,
            fill: series.setPointColor(point, series.interior)
          };
          chart.trigger(pointRender, argsData);
          point.color = argsData.fill;
          point.plans = null;
          if (!argsData.cancel) {
            this.update(argsData.series, argsData.point, i, chart);
          } else {
            point.symbolLocations = null;
          }
        }
      }
    };
    BarSeries3D2.prototype.update = function(series, point, pointIndex, chart) {
      var seriesIndex = chart.visibleSeries.indexOf(series);
      var left = point.left;
      var right = point.right;
      var bottom = series.yAxis.valueType === "Logarithmic" ? Math.pow(series.yAxis.logBase, series.yAxis.visibleRange.min) : series.yAxis.visibleRange.min;
      var top = series.yAxis.valueType === "Logarithmic" ? Math.pow(series.yAxis.logBase, series.yAxis.visibleRange.max) : series.yAxis.visibleRange.max;
      var xStart = series.xAxis.visibleRange.min;
      var xEnd = series.xAxis.visibleRange.max;
      if (!(left >= xStart && left <= xEnd || right >= xStart && right <= xEnd)) {
        return;
      }
      var topValue;
      if (point.top < 0) {
        topValue = point.top > bottom ? point.top : bottom;
      } else {
        topValue = series.yAxis.valueType && series.yAxis.valueType.toLowerCase() === "logarithmic" ? point.top : point.top < top ? point.top : top;
      }
      var tlpoint = chart.svg3DRenderer.transform3DToVisible(series, point.left > xStart ? point.left : xStart, topValue, chart);
      var rbpoint = chart.svg3DRenderer.transform3DToVisible(series, xEnd > point.right ? point.right : xEnd, bottom > point.bottom ? bottom : point.bottom, chart);
      var tlfVector = chart.vector.vector3D(Math.min(tlpoint.x, rbpoint.x), Math.min(tlpoint.y, rbpoint.y), point.startDepth);
      var brbVector = chart.vector.vector3D(Math.max(tlpoint.x, rbpoint.x), Math.max(tlpoint.y, rbpoint.y), point.endDepth);
      var styleOptions = series.setStyle(series);
      var name = "region-series-" + seriesIndex + "-point-" + pointIndex;
      if (series.columnFacet === "Cylinder") {
        chart.polygon.createCylinder(tlfVector, brbVector, chart, pointIndex, series.type, "", point.color, null, styleOptions.opacity, name, chart.chart3D);
      } else {
        chart.polygon.createBox(tlfVector, brbVector, chart, pointIndex, "", point.color, null, styleOptions.opacity, chart.requireInvertedAxis, name, chart.chart3D);
      }
    };
    BarSeries3D2.prototype.createSegments = function(series) {
      var xValues = series.getXValues(series.visiblePoints);
      var YValues = series.getYValues(series.visiblePoints);
      if (xValues == null) {
        return;
      }
      series.isRectSeries = true;
      var sbsInfo = series.getSideBySideInfo(series);
      var depthInfo = series.getSegmentDepth(series);
      var crossValue = 0;
      var median = sbsInfo.delta / 2;
      var visiblePoints = series.visiblePoints;
      var cons = 0.2;
      for (var i = 0; i < visiblePoints.length; i++) {
        var x1 = xValues[i] + sbsInfo.start;
        var x2 = xValues[i] + sbsInfo.end;
        var y1 = YValues[i];
        var y2 = crossValue;
        this.setData(x1, y1, x2, y2, depthInfo.start, depthInfo.end, series, visiblePoints[i]);
        if (!series.dataLabel.visible) {
          continue;
        }
        visiblePoints[i].symbolLocations = {
          x: 0,
          y: 0,
          z: 0
        };
        switch (series.dataLabel.position) {
          case "Top":
            visiblePoints[i].symbolLocations.x = x1 + median;
            visiblePoints[i].symbolLocations.y = y1;
            visiblePoints[i].symbolLocations.z = depthInfo.start;
            break;
          case "Bottom":
            visiblePoints[i].symbolLocations.x = x1 + median;
            visiblePoints[i].symbolLocations.y = y2 - cons + series.yAxis.visibleRange.min;
            visiblePoints[i].symbolLocations.z = depthInfo.start + (depthInfo.end - depthInfo.start) / 2;
            break;
          default:
            visiblePoints[i].symbolLocations.x = x1 + median;
            visiblePoints[i].symbolLocations.y = Math.abs(y2 - y1) / 2 + series.yAxis.visibleRange.min / 2;
            visiblePoints[i].symbolLocations.z = depthInfo.start;
            break;
        }
      }
    };
    BarSeries3D2.prototype.setData = function(x1, y1, x2, y2, start, end, series, point) {
      point.left = x1;
      point.bottom = y2;
      point.top = y1;
      point.right = x2;
      point.startDepth = start;
      point.endDepth = end;
      point.xRange = series.getDoubleRange(point.left, point.right);
      if (!isNaN(point.top) && !isNaN(point.bottom)) {
        point.yRange = series.getDoubleRange(point.top, point.bottom);
      }
    };
    BarSeries3D2.prototype.destroy = function() {
    };
    BarSeries3D2.prototype.getModuleName = function() {
      return "BarSeries3D";
    };
    return BarSeries3D2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart3d/series/data-label.js
var DataLabel3D = (
  /** @class */
  function() {
    function DataLabel3D2(chart) {
      this.chart = chart;
    }
    DataLabel3D2.prototype.render = function(series, chart, dataLabel) {
      var point;
      var templateId = chart.element.id + "-series-" + series.index + "-data-label-collections";
      series.dataLabelElement = createElement("div", {
        id: templateId
      });
      for (var i = 0; i < series.visiblePoints.length; i++) {
        point = series.visiblePoints[i];
        if (point.visible) {
          this.draw3DDataLabel(series, point.index, point, chart, dataLabel);
        }
      }
      if (series.dataLabel.template) {
        appendChildElement(false, document.getElementById(this.chart.element.id + "_Secondary_Element"), series.dataLabelElement, chart.redraw, false, "x", "y", null, "", false, false, null);
      }
    };
    DataLabel3D2.prototype.draw3DDataLabel = function(series, pointIndex, point, chart, dataLabel) {
      var pointX;
      var pointY;
      var xOffset = 0;
      var yOffset = 0;
      var commonEventArgs = {
        data: null
      };
      var pointText = this.getLabelText(point, series, this.chart)[0];
      var size = measureText(pointText, dataLabel.font, this.chart.themeStyle.datalabelFont);
      var location = chart.svg3DRenderer.transform3DToVisible(series, point.symbolLocations.x, point.symbolLocations.y, chart);
      pointY = location.y;
      pointX = location.x;
      if (series.dataLabel.position === "Bottom") {
        pointY = location.y + yOffset;
      } else {
        pointY = location.y - yOffset;
      }
      pointX = location.x + xOffset;
      commonEventArgs.data = {
        text: pointText,
        location: {
          x: pointX,
          y: pointY
        },
        series,
        pointIndex
      };
      commonEventArgs.data.Text = commonEventArgs.data.text;
      var argsData = {
        cancel: false,
        series,
        point,
        text: pointText,
        border: dataLabel.border,
        color: dataLabel.fill,
        template: dataLabel.template,
        textStyle: dataLabel.font
      };
      chart.trigger(textRender, argsData);
      this.fontBackground = series.dataLabel.position === "Middle" ? argsData.color === "transparent" ? point.color : argsData.color : argsData.color;
      commonEventArgs.data.text = argsData.text;
      if (!series.dataLabel.template && commonEventArgs.data.Text !== "" && !argsData.cancel) {
        var element_1 = {
          tag: "dataLabel",
          series,
          point,
          pointIndex,
          id: chart.svgObject.id + series.index + "-data-label" + pointIndex,
          child: chart.chart3D
        };
        chart.graphics.addVisual(chart.polygon.createTextElement(chart.vector.vector3D(pointX, pointY, point.symbolLocations.z), element_1, 0, -size.height), chart);
      }
      var tag = !(series.dataLabel && series.dataLabel.template) ? "text" : "template";
      var backgroundColor = this.fontBackground === "transparent" ? this.chart.theme.indexOf("Dark") > -1 || this.chart.theme === "HighContrast" ? "#000000" : "#FFFFFF" : this.fontBackground;
      var rgbValue = convertHexToColor(colorNameToHex(backgroundColor));
      var contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1e3);
      var font = {
        size: argsData.textStyle.size || this.chart.themeStyle.datalabelFont.size,
        fontWeight: argsData.textStyle.fontWeight || this.chart.themeStyle.datalabelFont.fontWeight,
        fontStyle: argsData.textStyle.fontStyle || chart.themeStyle.datalabelFont.fontStyle,
        fontFamily: argsData.textStyle.fontFamily || this.chart.themeStyle.datalabelFont.fontFamily,
        color: argsData.textStyle.color || (this.chart.theme === "Bootstrap5" ? "#212529" : this.chart.theme === "Bootstrap5Dark" ? "#DEE2E6" : argsData.textStyle.color),
        opacity: argsData.textStyle.opacity
      };
      var element = {
        width: size.width,
        height: size.height,
        label: commonEventArgs.data,
        textAnchor: "middle",
        tag,
        font,
        angle: series.dataLabel.angle,
        id: chart.element.id + "-svg-series-" + series.index + "-point-" + pointIndex + "-data-label",
        child: chart.chart3D,
        argsData,
        fill: contrast >= 128 ? this.chart.theme.indexOf("Tailwind3") > -1 ? "#111827" : "#000000" : "#FFFFFF"
      };
      if (!argsData.cancel) {
        chart.graphics.addVisual(chart.polygon.createTextElement(chart.vector.vector3D(pointX, pointY, point.symbolLocations.z), element, 0, -size.height), chart);
      }
    };
    DataLabel3D2.prototype.getLabelText = function(currentPoint, series, chart) {
      var labelFormat = series.dataLabel.format ? series.dataLabel.format : series.yAxis.labelFormat;
      var text = [];
      var customLabelFormat = labelFormat.match("{value}") !== null;
      text.push(currentPoint.text || currentPoint.yValue.toString());
      if ((labelFormat || chart.useGroupingSeparator) && !currentPoint.text) {
        series.yAxis.format = chart.intl.getNumberFormat({
          format: customLabelFormat ? "" : labelFormat,
          useGrouping: chart.useGroupingSeparator
        });
        for (var i = 0; i < text.length; i++) {
          text[i] = customLabelFormat ? labelFormat.replace("{value}", series.yAxis.format(parseFloat(text[i]))) : series.yAxis.format(parseFloat(text[i]));
        }
      }
      return text;
    };
    DataLabel3D2.prototype.createDataLabelTemplate = function(parentElement, series, dataLabel, point, data, labelIndex, redraw, location) {
      this.margin = {
        left: 0,
        right: 0,
        bottom: 0,
        top: 0
      };
      var clip = series.clipRect;
      var childElement = this.createTemplate(createElement("div", {
        id: this.chart.element.id + "-series-" + series.index + "-data-label-" + labelIndex,
        styles: "position: absolute;background-color:" + data.color + ";" + getFontStyle(dataLabel.font, this.chart.themeStyle.datalabelFont) + ";border:" + data.border.width + "px solid " + data.border.color + ";"
      }), data.template, this.chart, point, series, this.chart.element.id + "-data-label-", labelIndex, location);
      this.calculateTemplateLabelSize(parentElement, childElement, point, series, dataLabel, clip, redraw, location);
    };
    DataLabel3D2.prototype.calculateTemplateLabelSize = function(parentElement, childElement, point, series, dataLabel, clip, redraw, location, isReactCallback) {
      var elementRect = measureElementRect(childElement, redraw, isReactCallback);
      var rect = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
      var rectPosition = this.calculateTextPosition(series, point, elementRect, location);
      var clipWidth = 0;
      var clipHeight = 0;
      var isOverlap2 = false;
      if (isReactCallback) {
        isOverlap2 = elementRect.width === 0 || elementRect.height === 0;
      }
      childElement.style.left = rectPosition.left - clipWidth + "px";
      childElement.style.top = rectPosition.top + clipHeight + "px";
      var backgroundColor = this.fontBackground === "transparent" ? this.chart.theme.indexOf("Dark") > -1 ? "black" : "white" : this.fontBackground;
      var rgbValue = convertHexToColor(colorNameToHex(backgroundColor));
      var vAxis = series.chart.requireInvertedAxis ? series.xAxis : series.yAxis;
      var hAxis = series.chart.requireInvertedAxis ? series.yAxis : series.xAxis;
      childElement.style.color = dataLabel.font.color || this.chart.theme === "Bootstrap5" ? "#212529" : this.chart.theme === "Bootstrap5Dark" ? "#DEE2E6" : Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1e3) >= 128 ? this.chart.theme.indexOf("Tailwind3") > -1 ? "#111827" : "black" : this.chart.theme.indexOf("Tailwind3") > -1 ? "#FFFFFF" : "white";
      if (childElement.childElementCount && !isOverlap2 && !isCollide(rect, this.chart.dataLabelCollections, clip) && (point.yValue === void 0 || withIn(point.yValue, series.yAxis.visibleRange) || series.type.indexOf("Stacking") > -1 || series.type.indexOf("100") > -1 && withIn(series.stackedValues.endValues[point.index], series.yAxis.visibleRange)) && withIn(point.xValue, series.xAxis.visibleRange) && parseFloat(childElement.style.top) >= vAxis.rect.y && parseFloat(childElement.style.left) >= hAxis.rect.x && parseFloat(childElement.style.top) <= vAxis.rect.y + vAxis.rect.height && parseFloat(childElement.style.left) <= hAxis.rect.x + hAxis.rect.width) {
        this.chart.dataLabelCollections.push(new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height));
        appendChildElement(false, parentElement, childElement, redraw, true, "left", "top");
      }
    };
    DataLabel3D2.prototype.calculateTextPosition = function(series, point, elementSize, location) {
      var width = elementSize.width / 2;
      var height = elementSize.height;
      var left;
      var top;
      var right;
      if (series.type.indexOf("Bar") !== -1) {
        left = location.x - width;
        top = location.y - height + series.xAxis.plotOffset;
        right = location.x + width;
      } else {
        left = location.x - width;
        top = location.y - height;
        right = location.x + width;
      }
      return {
        left,
        top,
        right
      };
    };
    DataLabel3D2.prototype.chartReactTemplate = function(childElement, chart, point, series, labelIndex, redraw, location) {
      var parentElement = document.getElementById(chart.element.id + "-series-" + series.index + "-data-label-collections");
      if (parentElement) {
        if (point.index === 0) {
          chart.dataLabelCollections = [];
        }
        chart.dataLabel3DModule.calculateTemplateLabelSize(parentElement, childElement, point, series, series.dataLabel, series.clipRect, redraw, location, true);
      }
    };
    DataLabel3D2.prototype.createTemplate = function(childElement, content, chart, point, series, dataLabelId, labelIndex, location, redraw) {
      var templateFn = getTemplateFunction(content);
      var templateElement;
      try {
        var tempObject = {
          chart,
          series,
          point
        };
        var templateId = dataLabelId + "-template";
        var elementData = templateFn ? templateFn(tempObject, chart, templateId, dataLabelId) : [];
        if (elementData.length) {
          templateElement = Array.prototype.slice.call(elementData);
          var len = templateElement.length;
          for (var i = 0; i < len; i++) {
            childElement.appendChild(templateElement[i]);
          }
        }
        var reactCallback = void 0;
        if (chart.getModuleName() === "chart3d") {
          reactCallback = point && series ? this.chartReactTemplate.bind(this, childElement, chart, point, series, labelIndex, redraw, location) : reactCallback;
          if (chart.isReact) {
            chart.renderReactTemplates(reactCallback);
          }
        }
      } catch (e) {
        return childElement;
      }
      return childElement;
    };
    DataLabel3D2.prototype.getModuleName = function() {
      return "DataLabel3D";
    };
    DataLabel3D2.prototype.destroy = function() {
    };
    return DataLabel3D2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/chart3d/user-interaction/selection.js
var __extends109 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Selection3D = (
  /** @class */
  function(_super) {
    __extends109(Selection3D2, _super);
    function Selection3D2(chart) {
      var _this = _super.call(this, chart) || this;
      _this.seriesIndex = 0;
      _this.chart = chart;
      _this.addEventListener();
      return _this;
    }
    Selection3D2.prototype.addEventListener = function() {
      if (this.chart.isDestroyed) {
        return;
      }
      var cancelEvent = Browser.isPointer ? "pointerleave" : "mouseleave";
      this.chart.on(Browser.touchMoveEvent, this.mouseMove, this);
      this.chart.on(cancelEvent, this.mouseLeave, this);
      this.chart.on("click", this.mouseClick, this);
      this.chart.on(Browser.touchStartEvent, this.mousedown, this);
      this.chart.on(Browser.touchEndEvent, this.mouseLeave, this);
    };
    Selection3D2.prototype.mousedown = function() {
      var chart = this.chart;
      if (chart.isPointMouseDown || chart.selectionMode === "Point") {
        return;
      }
    };
    Selection3D2.prototype.removeEventListener = function() {
      if (this.chart.isDestroyed) {
        return;
      }
      this.chart.off(Browser.touchMoveEvent, this.mouseMove);
      this.chart.off("pointerleave", this.mouseLeave);
      this.chart.off("click", this.mouseClick);
      this.chart.off(Browser.touchStartEvent, this.mousedown);
      this.chart.off(Browser.touchEndEvent, this.mouseLeave);
    };
    Selection3D2.prototype.initPrivateVariables = function(chart) {
      this.styleId = chart.element.id + "_ej2_chart_selection";
      this.unselected = chart.element.id + "_ej2_deselected";
      this.selectedDataIndexes = [];
      this.isSeriesMode = chart.selectionMode === "Series";
    };
    Selection3D2.prototype.invokeSelection = function(chart) {
      this.initPrivateVariables(chart);
      this.series = extend({}, chart.visibleSeries, null, true);
      this.seriesStyles();
      this.currentMode = chart.selectionMode;
      this.selectDataIndex(chart, this.concatIndexes(chart.selectedDataIndexes, this.selectedDataIndexes));
    };
    Selection3D2.prototype.generateStyle = function(series) {
      if (series) {
        return this.styleId + "_series_" + series.index;
      }
      return "undefined";
    };
    Selection3D2.prototype.selectDataIndex = function(chart, indexes) {
      for (var _i = 0, indexes_1 = indexes; _i < indexes_1.length; _i++) {
        var index = indexes_1[_i];
        this.performSelection(index, chart, this.getElementByIndex(chart, index)[0]);
      }
    };
    Selection3D2.prototype.getElementByIndex = function(chart, index) {
      var pointElements = [];
      var elements = document.querySelectorAll('[id*="-region-series-' + index.series + "-point-" + index.point + '"]');
      elements.forEach(function(pointElement) {
        pointElements.push(pointElement);
      });
      return pointElements;
    };
    Selection3D2.prototype.getClusterElements = function(chart, index) {
      var clusters = [];
      for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
        var series = _a[_i];
        if (series.visible) {
          index = new Index(series.index, index.point);
          var pointElements = this.getElementByIndex(chart, index);
          for (var i = 0; i < pointElements.length; i++) {
            clusters.push(pointElements[i]);
          }
        }
      }
      return clusters;
    };
    Selection3D2.prototype.findElements = function(chart, series, index) {
      if (this.isSeriesMode) {
        return this.getSeriesElements(series);
      } else if (this.currentMode === "Cluster") {
        return this.getClusterElements(chart, index);
      } else {
        return this.getElementByIndex(chart, index);
      }
    };
    Selection3D2.prototype.isAlreadySelected = function(targetElem, eventType, index) {
      if (eventType === "click") {
        this.currentMode = this.chart.selectionMode;
        this.styleId = this.chart.element.id + "_ej2_chart_selection";
      } else if (eventType === "mousemove" || eventType === "pointermove") {
        this.currentMode = this.chart.highlightMode;
        this.highlightDataIndexes = [];
        this.styleId = this.chart.element.id + "_ej2_chart_highlight";
      }
      if (this.chart.highlightMode !== "None" && this.chart.selectionMode === "None") {
        if (eventType === "click") {
          return false;
        }
      }
      if ((this.chart.highlightMode !== "None" || this.chart.legendSettings.enableHighlight) && this.previousSelectedEle && this.previousSelectedEle[0]) {
        var isElement = void 0;
        var nodeName = targetElem.nodeName;
        if (targetElem.parentNode) {
          isElement = (nodeName === "path" || nodeName === "shape") && targetElem.id.indexOf("region") > 1 ? true : false;
        }
        var _loop_1 = function(i2) {
          if (this_1.previousSelectedEle[i2].hasAttribute("class")) {
            if (this_1.previousSelectedEle[i2].getAttribute("class").indexOf("highlight") > -1 && (isElement || eventType === "click")) {
              var selectionClass_1;
              this_1.previousSelectedEle[i2].classList.forEach(function(className) {
                if (className.indexOf("selection") > -1) {
                  selectionClass_1 = className;
                }
              });
              this_1.previousSelectedEle[i2].removeAttribute("class");
              if (selectionClass_1) {
                this_1.addSvgClass(this_1.previousSelectedEle[i2], selectionClass_1);
              }
              this_1.previousSelectedEle[i2].classList.remove(this_1.styleId + "_series_" + index.series);
              if (this_1.chart.highlightColor !== "" && !isNullOrUndefined(this_1.chart.highlightColor) && this_1.chart.highlightPattern === "None") {
                this_1.previousSelectedEle[i2].setAttribute("fill", this_1.control.visibleSeries[this_1.indexFinder(this_1.previousSelectedEle[i2].id).series].interior);
              }
              this_1.addOrRemoveIndex(this_1.highlightDataIndexes, this_1.indexFinder(this_1.previousSelectedEle[i2].id));
            } else if (!isElement && this_1.previousSelectedEle[i2].getAttribute("class").indexOf("highlight") > -1) {
              this_1.performSelection(this_1.indexFinder(this_1.previousSelectedEle[i2].id), this_1.chart, this_1.previousSelectedEle[i2]);
            }
          }
        };
        var this_1 = this;
        for (var i = 0; i < this.previousSelectedEle.length; i++) {
          _loop_1(i);
        }
      }
      return true;
    };
    Selection3D2.prototype.mouseClick = function(event2) {
      if (!this.chart.rotateActivate) {
        this.calculateSelectedElements(event2.target, event2.type);
      }
    };
    Selection3D2.prototype.calculateSelectedElements = function(targetElement, eventType) {
      if (isNullOrUndefined(targetElement)) {
        return;
      }
      if (this.chart.selectionMode === "None" && this.chart.highlightMode === "None" || targetElement.id && targetElement.id.indexOf(this.chart.element.id + "-") === -1) {
        return;
      }
      if (eventType === "mousemove" || eventType === "pointermove") {
        if (targetElement.hasAttribute("class") && (targetElement.getAttribute("class").indexOf("highlight") > -1 || targetElement.getAttribute("class").indexOf("selection") > -1)) {
          return;
        }
      }
      this.isAlreadySelected(targetElement, eventType, this.indexFinder(targetElement.id));
      if (targetElement.id && targetElement.id.indexOf("-series-") > -1 && targetElement.id.indexOf("_Text_") === -1) {
        var element = void 0;
        this.performSelection(this.indexFinder(targetElement.id), this.chart, element || targetElement);
      }
    };
    Selection3D2.prototype.performSelection = function(index, chart, element) {
      this.isSeriesMode = this.currentMode === "Series";
      switch (this.currentMode) {
        case "Series":
          this.selection(chart, index, this.getSeriesElements(chart.series[index.series]));
          this.selectionComplete(chart, index, this.currentMode);
          this.blurEffect(chart.element.id, chart.visibleSeries);
          break;
        case "Point":
          if (!isNaN(index.point) && element) {
            this.selection(chart, index, this.getElementByIndex(chart, index));
            this.selectionComplete(chart, index, this.currentMode);
            this.blurEffect(chart.element.id, chart.visibleSeries);
          }
          break;
        case "Cluster":
          if (!isNaN(index.point)) {
            this.clusterSelection(chart, index);
            this.selectionComplete(chart, index, this.currentMode);
            this.blurEffect(chart.element.id, chart.visibleSeries);
          }
          break;
      }
    };
    Selection3D2.prototype.selectionComplete = function(chart, index, selectionMode) {
      var points;
      var pointIndex;
      var seriesIndex;
      var selectedPointValues = [];
      var yValue;
      var selectedPointX;
      if (selectionMode === "Cluster") {
        for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
          var series = _a[_i];
          if (series.visible) {
            for (var i = 0; i < this.selectedDataIndexes.length; i++) {
              pointIndex = chart.isMultiSelect ? this.selectedDataIndexes[i].point : index.point;
              seriesIndex = series.index;
              points = series.points;
              if (!isNaN(pointIndex)) {
                yValue = points[pointIndex].yValue;
                selectedPointX = points[pointIndex].xValue;
                if (chart.primaryXAxis.valueType === "Category") {
                  selectedPointX = points[pointIndex].x.toLocaleString();
                } else if (chart.primaryXAxis.valueType === "DateTime") {
                  selectedPointX = new Date(points[pointIndex].xValue);
                }
                selectedPointValues.push({
                  x: selectedPointX,
                  y: yValue,
                  seriesIndex,
                  pointIndex
                });
              }
            }
          }
        }
      } else if (selectionMode === "Series") {
        if (chart.isMultiSelect) {
          for (var i = 0; i < this.selectedDataIndexes.length; i++) {
            seriesIndex = this.selectedDataIndexes[i].series;
            if (this.selectedDataIndexes.length > 0) {
              selectedPointValues.push({
                seriesIndex
              });
            }
          }
        } else {
          seriesIndex = this.selectedDataIndexes.length > 0 ? this.selectedDataIndexes[0].series : this.highlightDataIndexes && this.highlightDataIndexes.length > 0 ? this.highlightDataIndexes[0].series : 0;
          if (this.selectedDataIndexes.length > 0 || this.highlightDataIndexes && this.highlightDataIndexes.length > 0) {
            selectedPointValues.push({
              seriesIndex
            });
          }
        }
      } else if (selectionMode === "Point") {
        var selectedData = [];
        if (this.styleId.indexOf("highlight") > -1) {
          selectedData = this.highlightDataIndexes;
        } else {
          selectedData = this.selectedDataIndexes;
        }
        for (var i = 0; i < selectedData.length; i++) {
          pointIndex = selectedData[i].point;
          seriesIndex = selectedData[i].series;
          var series = chart.series[seriesIndex];
          points = series.points;
          if (!isNaN(pointIndex)) {
            selectedPointX = points[pointIndex].xValue;
            yValue = points[pointIndex].yValue;
            if (chart.primaryXAxis.valueType === "Category") {
              selectedPointX = points[pointIndex].x.toLocaleString();
            } else if (chart.primaryXAxis.valueType === "DateTime") {
              selectedPointX = new Date(points[pointIndex].xValue);
            }
            selectedPointValues.push({
              x: selectedPointX,
              y: yValue,
              seriesIndex,
              pointIndex
            });
          }
        }
      }
      var args = {
        selectedDataValues: selectedPointValues,
        cancel: false,
        chart
      };
      chart.trigger(selectionComplete, args);
    };
    Selection3D2.prototype.selection = function(chart, index, selectedElements) {
      if (!chart.isMultiSelect && this.styleId.indexOf("highlight") === -1 && chart.selectionMode !== "None") {
        this.removeMultiSelectElements(chart, this.selectedDataIndexes, index, chart.series);
      }
      var indexValue = index.series;
      if (!isNullOrUndefined(selectedElements[0])) {
        if (chart.visibleSeries[indexValue].isRectSeries) {
          if (selectedElements[0].id) {
            if (document.getElementById(selectedElements[0].id + "_Symbol")) {
              selectedElements.push(getElement2(selectedElements[0].id + "_Symbol"));
            }
          }
        }
        var isAdd = void 0;
        var className = selectedElements[0] && (selectedElements[0].getAttribute("class") || "");
        if (selectedElements[0] && className.indexOf(this.getSelectionClass(selectedElements[0].id)) > -1) {
          this.removeStyles(selectedElements);
        } else {
          this.previousSelectedEle = chart.highlightMode !== "None" || chart.legendSettings.enableHighlight ? selectedElements : [];
          if (this.chart.selection3DModule) {
            this.chart.selection3DModule.previousSelectedEle = selectedElements;
          }
          this.applyStyles(selectedElements);
          isAdd = true;
        }
        if (this.styleId.indexOf("highlight") > 0 && (chart.highlightMode !== "None" || chart.legendSettings.enableHighlight)) {
          this.addOrRemoveIndex(this.highlightDataIndexes, index, isAdd);
        } else {
          this.addOrRemoveIndex(this.selectedDataIndexes, index, isAdd);
        }
      }
    };
    Selection3D2.prototype.clusterSelection = function(chart, index) {
      this.selection(chart, index, this.getClusterElements(chart, new Index(index.series, index.point)));
    };
    Selection3D2.prototype.removeMultiSelectElements = function(chart, index, currentIndex, seriesCollection) {
      var series;
      for (var i = 0; i < index.length; i++) {
        series = seriesCollection[index[i].series];
        if (this.isSeriesMode && !this.toEquals(index[i], currentIndex, this.isSeriesMode) || this.currentMode === "Cluster" && !this.toEquals(index[i], currentIndex, false) || !this.isSeriesMode && this.toEquals(index[i], currentIndex, true) && !this.toEquals(index[i], currentIndex, false)) {
          this.removeStyles(this.findElements(chart, series, index[i]));
          index.splice(i, 1);
          i--;
        }
      }
    };
    Selection3D2.prototype.blurEffect = function(chartId, visibleSeries) {
      var visibility = this.checkVisibility(this.highlightDataIndexes, this.chart) || this.checkVisibility(this.selectedDataIndexes, this.chart);
      var _loop_2 = function(series2) {
        var legendIndex = series2.index;
        var legendStrokeColor = this_2.chart.visibleSeries[series2.index].interior;
        var pointElements = [];
        if (series2.visible) {
          var elements = document.querySelectorAll('[id*="region-series-' + series2.index + '"]');
          elements.forEach(function(el) {
            pointElements.push(el);
          });
          this_2.checkSelectionElements(pointElements, this_2.generateStyle(series2), visibility, legendIndex, legendStrokeColor);
          if (!isNullOrUndefined(getElement2(chartId + "SymbolGroup" + series2.index))) {
            this_2.checkSelectionElements(pointElements, this_2.generateStyle(series2), visibility, legendIndex, legendStrokeColor);
          }
        }
      };
      var this_2 = this;
      for (var _i = 0, visibleSeries_1 = visibleSeries; _i < visibleSeries_1.length; _i++) {
        var series = visibleSeries_1[_i];
        _loop_2(series);
      }
    };
    Selection3D2.prototype.checkSelectionElements = function(element, className, visibility, series, legendStrokeColor) {
      if (series === void 0) {
        series = 0;
      }
      if (legendStrokeColor === void 0) {
        legendStrokeColor = "#D3D3D3";
      }
      var children = this.isSeriesMode ? element || [element] : element;
      if (this.chart.selectionMode !== "None" && (this.chart.highlightMode !== "None" || this.chart.legendSettings.enableHighlight)) {
        children = element;
      }
      var elementClassName;
      var parentClassName;
      var legendShape;
      var selectElement = element;
      for (var i = 0; i < children.length; i++) {
        elementClassName = children[i].getAttribute("class") || "";
        parentClassName = children[i].parentNode.getAttribute("class") || "";
        if (this.chart.selectionMode !== "None" && (this.chart.highlightMode !== "None" || this.chart.legendSettings.enableHighlight)) {
          className = elementClassName.indexOf("selection") > 0 || elementClassName.indexOf("highlight") > 0 ? elementClassName : className;
        }
        if (elementClassName.indexOf(className) === -1 && parentClassName.indexOf(className) === -1 && visibility) {
          this.addSvgClass(children[i], this.unselected);
        } else {
          selectElement = children[i];
          if (elementClassName.indexOf(this.unselected) !== -1 && this.chart.tooltip3DModule && className.indexOf("highlight") > 0) {
            this.chart.highlightAnimation(children[i], series, 700, 0.3);
          }
          this.removeSvgClass(children[i], this.unselected);
          this.removeSvgClass(children[i].parentNode, this.unselected);
        }
      }
      if (this.control.legend3DModule && this.control.legendSettings.visible) {
        legendShape = getElement2(this.control.element.id + "_chart_legend_shape_" + series);
        if (legendShape) {
          if (legendShape.hasAttribute("class")) {
            this.removeSvgClass(legendShape, legendShape.getAttribute("class"));
            if (!isNullOrUndefined(this.chart.highlightColor && this.chart.highlightColor !== "") && !this.chart.legendSettings.enableHighlight) {
              legendShape.setAttribute("stroke", legendStrokeColor);
              if (this.chart.highlightPattern === "None") {
                legendShape.setAttribute("fill", legendStrokeColor);
              }
            }
          }
          if (selectElement.length > 0) {
            elementClassName = selectElement[0].getAttribute("class");
            parentClassName = selectElement[0].parentNode.getAttribute("class") || "";
          } else if (selectElement) {
            elementClassName = selectElement.getAttribute("class") || "";
            parentClassName = selectElement.parentNode.getAttribute("class") || "";
          }
          if (elementClassName.indexOf(className) === -1 && parentClassName.indexOf(className) === -1 && visibility) {
            this.addSvgClass(legendShape, this.chart.highlightMode === "None" && this.chart.legendSettings.enableHighlight ? className : this.unselected);
            this.removeSvgClass(legendShape, className);
            if (this.chart.highlightColor !== "" && !isNullOrUndefined(this.chart.highlightColor)) {
              legendShape.setAttribute("stroke", this.control.visibleSeries[series].interior);
              if (this.chart.highlightPattern === "None") {
                legendShape.setAttribute("fill", this.control.visibleSeries[series].interior);
              }
            }
          } else {
            this.removeSvgClass(legendShape, this.unselected);
            if (!isNullOrUndefined(this.chart.highlightColor) && this.chart.highlightColor !== "") {
              legendShape.setAttribute("stroke", this.control.visibleSeries[series].interior);
              if (this.chart.highlightPattern === "None") {
                legendShape.setAttribute("fill", this.control.visibleSeries[series].interior);
              }
            }
            if (elementClassName === "" && parentClassName === "" || elementClassName.trim() === "EJ2-Trackball") {
              this.removeSvgClass(legendShape, className);
            } else {
              this.addSvgClass(legendShape, className);
              if (className.indexOf("highlight") > 0 && this.chart.highlightColor !== "" && this.chart.highlightColor !== "transparent" && !isNullOrUndefined(this.chart.highlightColor)) {
                legendShape.setAttribute("stroke", this.chart.highlightColor);
                if (this.styleId.indexOf("highlight") > 0 && this.chart.highlightPattern === "None") {
                  legendShape.setAttribute("fill", this.chart.highlightColor);
                }
              }
            }
          }
        }
      }
    };
    Selection3D2.prototype.applyStyles = function(elements) {
      for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
        var element = elements_1[_i];
        if (element) {
          this.removeSvgClass(element.parentNode, this.unselected);
          this.removeSvgClass(element, this.unselected);
          if (this.chart.series[0].pointColorMapping === "fill") {
            var className = this.getSelectionClass(element.id);
            var index = className.indexOf("highlight") > -1 ? parseInt(className.split(this.chart.element.id + "_ej2_chart_highlight_series_")[1], 10) : parseInt(className.split(this.chart.element.id + "_ej2_chart_selection_series_")[1], 10);
            var patternName = this.styleId.indexOf("highlight") > 0 ? this.chart.highlightPattern : this.chart.selectionPattern;
            var pattern = void 0;
            if (className.indexOf("highlight") > -1 || className.indexOf("selection") > -1) {
              pattern = document.getElementById(this.chart.element.id + "_" + patternName + "_Selection_" + index);
            }
            if (element.id.indexOf("legend") === -1 && element.id.indexOf("Group") === -1 && pattern != null) {
              for (var i = 1; i < pattern.children.length; i++) {
                pattern.children[i].setAttribute("fill", element.getAttribute("fill"));
                pattern.children[i].setAttribute("stroke", element.getAttribute("fill"));
              }
            }
          }
          this.addSvgClass(element, this.getSelectionClass(element.id));
          if (this.chart.tooltip3DModule && this.getSelectionClass(element.id).indexOf("highlight") > 0) {
            var index = parseFloat(element.id.split("-series-")[1].split("-point-")[0]);
            this.chart.stopElementAnimation(element, index);
          }
          if (this.styleId.indexOf("highlight") > 0 && this.chart.highlightColor !== "" && !isNullOrUndefined(this.chart.highlightColor) && this.chart.highlightPattern === "None" && this.chart.highlightColor !== "transparent") {
            element.setAttribute("fill", this.chart.highlightColor);
          }
        }
      }
    };
    Selection3D2.prototype.getSelectionClass = function(id) {
      return this.generateStyle(this.control.visibleSeries[this.indexFinder(id).series]);
    };
    Selection3D2.prototype.removeStyles = function(elements) {
      for (var _i = 0, elements_2 = elements; _i < elements_2.length; _i++) {
        var element = elements_2[_i];
        if (element) {
          this.removeSvgClass(element, this.getSelectionClass(element.id));
          if (this.chart.highlightPattern === "None" && this.chart.highlightColor !== "" && !isNullOrUndefined(this.chart.highlightColor) && this.chart.highlightColor !== "transparent") {
            var color = this.control.visibleSeries[this.indexFinder(element.id).series].interior;
            if (element.getAttribute("name") === "ZLight") {
              color = this.chart.polygon.applyZLight(color, this.control);
            }
            if (element.getAttribute("name") === "XLight") {
              color = this.chart.polygon.applyXLight(color, this.control);
            }
            element.setAttribute("fill", color);
          }
        }
      }
    };
    Selection3D2.prototype.addOrRemoveIndex = function(indexes, index, isAdd) {
      for (var i = 0; i < indexes.length; i++) {
        if (this.toEquals(indexes[i], index, this.isSeriesMode)) {
          indexes.splice(i, 1);
          i--;
        }
      }
      if (isAdd) {
        indexes.push(index);
      }
    };
    Selection3D2.prototype.toEquals = function(first, second, checkSeriesOnly) {
      return (first.series === second.series || this.currentMode === "Cluster" && !checkSeriesOnly) && (checkSeriesOnly || first.point === second.point);
    };
    Selection3D2.prototype.redrawSelection = function(chart, oldMode, chartRedraw) {
      this.isSeriesMode = oldMode === "Series";
      if (!isNullOrUndefined(oldMode)) {
        if (chartRedraw) {
          chart.isRedrawSelection = false;
        } else {
          chart.isRedrawSelection = true;
        }
      }
      var selectedDataIndexes = extend([], this.selectedDataIndexes, null, true);
      var highlightDataIndexes = extend([], this.highlightDataIndexes, null, true);
      if (this.styleId.indexOf("highlight") > 0 && highlightDataIndexes.length > 0) {
        this.removeSelectedElements(chart, this.highlightDataIndexes, chart.series);
        selectedDataIndexes = highlightDataIndexes;
      } else {
        this.removeSelectedElements(chart, this.selectedDataIndexes, chart.series);
      }
      this.blurEffect(chart.element.id, chart.visibleSeries);
      this.selectDataIndex(chart, selectedDataIndexes);
    };
    Selection3D2.prototype.legendSelection = function(chart, series, targetElement, eventType) {
      if (eventType === "mousemove") {
        if (targetElement.id.indexOf("text") > 1) {
          targetElement = getElement2(targetElement.id.replace("text", "shape"));
        }
        if (targetElement.id.indexOf("marker") > 1) {
          targetElement = getElement2(targetElement.id.replace("_marker", ""));
        }
        if (targetElement.id.indexOf("g") > 1) {
          targetElement = getElement2(targetElement.id.replace("_g_", "_shape_"));
        }
        if (targetElement.hasAttribute("class") && (targetElement.getAttribute("class").indexOf("highlight") > -1 || targetElement.getAttribute("class").indexOf("selection") > -1)) {
          return;
        }
        this.currentMode = this.chart.highlightMode;
      } else if (eventType === "click") {
        if (targetElement.id.indexOf("text") > 1) {
          targetElement = getElement2(targetElement.id.replace("text", "shape"));
        }
        if (targetElement.id.indexOf("g") > 1) {
          targetElement = getElement2(targetElement.id.replace("_g_", "_shape_"));
        }
      }
      var index = this.indexFinder(targetElement.id);
      var isPreSelected = this.isAlreadySelected(targetElement, eventType, index);
      if (isPreSelected) {
        var seriesStyle = this.generateStyle(chart.visibleSeries[series]);
        var selectedElements = document.querySelectorAll("." + seriesStyle);
        this.isSeriesMode = this.currentMode === "Series";
        var isBlurEffectNeeded = true;
        if (selectedElements.length > 0) {
          this.removeSelection(chart, series, selectedElements, seriesStyle, isBlurEffectNeeded);
        } else {
          for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
            var element = _a[_i];
            if (element.index !== series && !chart.isMultiSelect) {
              seriesStyle = this.generateStyle(chart.visibleSeries[element.index]);
              selectedElements = document.querySelectorAll("." + seriesStyle);
              this.removeSelection(chart, series, selectedElements, seriesStyle, isBlurEffectNeeded);
            }
          }
          var seriesElements = [];
          if (this.chart.legendSettings.mode === "Point") {
            seriesElements = this.getElementByIndex(chart, index);
          } else {
            seriesElements = this.getSeriesElements(chart.visibleSeries[series]);
          }
          if (seriesElements.length > 0) {
            this.checkSelectionElements(seriesElements, seriesStyle, false, series, "");
            this.isSeriesMode = true;
            this.selection(chart, new Index(index.series, NaN), seriesElements);
            this.isSeriesMode = chart.selectionMode === "Series";
            this.blurEffect(chart.element.id, chart.visibleSeries);
          }
        }
      }
    };
    Selection3D2.prototype.removeSelection = function(chart, series, selectedElements, seriesStyle, isBlurEffectNeeded) {
      if (selectedElements.length > 0) {
        var elements = [];
        for (var i = 0; i < selectedElements.length; i++) {
          elements.push(selectedElements[i]);
        }
        this.removeStyles(elements);
        this.isSeriesMode = true;
        this.addOrRemoveIndex(this.selectedDataIndexes, new Index(series, NaN));
        for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
          var value = _a[_i];
          seriesStyle = this.generateStyle(value);
          if (document.querySelectorAll("." + seriesStyle).length > 0) {
            for (var _b = 0, elements_3 = elements; _b < elements_3.length; _b++) {
              var element = elements_3[_b];
              this.checkSelectionElements(element, seriesStyle, true, series, "");
            }
            isBlurEffectNeeded = false;
            break;
          }
        }
        if (isBlurEffectNeeded) {
          this.isSeriesMode = chart.selectionMode === "Series";
          this.blurEffect(chart.element.id, chart.visibleSeries);
        }
      }
    };
    Selection3D2.prototype.getSeriesElements = function(series) {
      var seriesElements = [];
      if (series.visible) {
        var elements = document.querySelectorAll('[id*="region-series-' + series.index + '"]');
        elements.forEach(function(seriesElement) {
          seriesElements.push(seriesElement);
        });
      }
      return seriesElements;
    };
    Selection3D2.prototype.indexFinder = function(id) {
      var ids = ["NaN", "NaN"];
      if (id.indexOf("-point-") > -1) {
        ids = id.split("-series-")[1].split("-point-");
      } else if (id.indexOf("-border-") > -1) {
        ids[0] = id.split("-border-")[1];
      } else if (id.indexOf("-series-") > -1) {
        ids[0] = id.split("-series-")[1];
      } else if (id.indexOf("_chart_legend_shape_") > -1) {
        ids = id.split("_chart_legend_shape_");
        ids[0] = ids[1];
      }
      return new Index(parseInt(ids[0], 10), parseInt(ids[1], 10));
    };
    Selection3D2.prototype.removeSelectedElements = function(chart, index, seriesCollection) {
      index = chart.isRedrawSelection ? index : index.splice(0, index.length);
      var seriesElements;
      for (var _i = 0, seriesCollection_1 = seriesCollection; _i < seriesCollection_1.length; _i++) {
        var series = seriesCollection_1[_i];
        if (series.visible) {
          seriesElements = this.getSeriesElements(series);
          this.removeStyles(seriesElements);
          for (var _a = 0, seriesElements_1 = seriesElements; _a < seriesElements_1.length; _a++) {
            var seriesElement = seriesElements_1[_a];
            this.removeStyles(this.getChildren(seriesElement));
          }
        }
      }
    };
    Selection3D2.prototype.mouseLeave = function() {
      this.completeSelection();
    };
    Selection3D2.prototype.completeSelection = function() {
      var chart = this.chart;
      if (chart.selectionMode === "None") {
        return;
      }
      this.currentMode = chart.selectionMode;
    };
    Selection3D2.prototype.mouseMove = function(event2) {
      var chart = this.chart;
      var target = event2.target;
      var eventType = event2.type;
      this.highlightChart(target, eventType);
      if (chart.selectionMode === "None") {
        return;
      }
      if (eventType === "touchmove" && (Browser.isIos || Browser.isIos7) && event2.preventDefault) {
        event2.preventDefault();
      }
    };
    Selection3D2.prototype.highlightChart = function(target, eventType) {
      if (!this.chart.rotateActivate && (this.chart.highlightMode !== "None" || this.chart.legendSettings.enableHighlight)) {
        if (!isNullOrUndefined(target)) {
          if (target.id.indexOf("_legend_text") > 1) {
            target = getElement2(target.id.replace("text", "shape"));
          }
          if (target.hasAttribute("class") && (target.getAttribute("class").indexOf("highlight") > -1 || target.getAttribute("class").indexOf("selection") > -1)) {
            return;
          }
          this.calculateSelectedElements(target, eventType);
          if (this.chart.highlight3DModule.highlightDataIndexes && this.chart.highlight3DModule.highlightDataIndexes.length > 0 && target.id.indexOf("_chart_legend_") === -1 && target.id.indexOf("-series-") === -1) {
            this.removeLegendHighlightStyles();
          }
        }
        return;
      }
    };
    Selection3D2.prototype.removeLegendHighlightStyles = function() {
      this.chart.highlight3DModule.highlightDataIndexes = [];
      var elementCollection;
      for (var i = 0; i < this.chart.visibleSeries.length; i++) {
        elementCollection = document.getElementsByClassName(this.generateStyle(this.chart.visibleSeries[i]));
        if (this.selectedDataIndexes.length === 0) {
          elementCollection = document.getElementsByClassName(this.generateStyle(this.chart.visibleSeries[i]));
          while (elementCollection.length > 0) {
            var element = elementCollection[0];
            if (element) {
              this.removeSvgClass(element, element.getAttribute("class"));
              if (this.chart.highlightPattern === "None" && this.chart.highlightColor !== "" && !isNullOrUndefined(this.chart.highlightColor) && this.chart.highlightColor !== "transparent") {
                var color = this.control.visibleSeries[i].interior;
                if (element.getAttribute("name") === "ZLight") {
                  color = this.chart.polygon.applyZLight(color, this.control);
                }
                if (element.getAttribute("name") === "XLight") {
                  color = this.chart.polygon.applyXLight(color, this.control);
                }
                if (element.id.indexOf("_chart_legend_shape") !== -1 && element.getAttribute("stroke")) {
                  element.setAttribute("stroke", color);
                }
                element.setAttribute("fill", color);
              }
            }
          }
          elementCollection = document.getElementsByClassName(this.unselected);
          while (elementCollection.length > 0) {
            var element = elementCollection[0];
            if (element) {
              this.removeSvgClass(element, element.getAttribute("class"));
              if (this.chart.tooltip3DModule && this.generateStyle(this.chart.visibleSeries[i]).indexOf("highlight") > -1) {
                this.chart.highlightAnimation(element, i, 700, 0.3);
              }
            }
          }
        } else {
          elementCollection = document.getElementsByClassName(this.generateStyle(this.chart.visibleSeries[i]));
          while (elementCollection.length > 0) {
            var element = elementCollection[0];
            if (element) {
              this.removeSvgClass(element, element.getAttribute("class"));
              this.addSvgClass(element, this.unselected);
            }
          }
        }
      }
    };
    Selection3D2.prototype.getModuleName = function() {
      return "Selection3D";
    };
    Selection3D2.prototype.destroy = function() {
      this.removeEventListener();
    };
    return Selection3D2;
  }(BaseSelection)
);

// node_modules/@syncfusion/ej2-charts/src/chart3d/user-interaction/high-light.js
var __extends110 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Highlight3D = (
  /** @class */
  function(_super) {
    __extends110(Highlight3D2, _super);
    function Highlight3D2(chart) {
      var _this = _super.call(this, chart) || this;
      _this.chart = chart;
      _this.wireEvents();
      return _this;
    }
    Highlight3D2.prototype.wireEvents = function() {
      if (this.chart.isDestroyed) {
        return;
      }
      this.chart.on(Browser.touchMoveEvent, this.mouseMove, this);
    };
    Highlight3D2.prototype.unWireEvents = function() {
      if (this.chart.isDestroyed) {
        return;
      }
      this.chart.off(Browser.touchMoveEvent, this.mouseMove);
    };
    Highlight3D2.prototype.declarePrivateVariables = function(chart) {
      this.styleId = chart.element.id + "_ej2_chart_highlight";
      this.unselected = chart.element.id + "_ej2_deselected";
      this.selectedDataIndexes = [];
      this.highlightDataIndexes = [];
      this.isSeriesMode = chart.highlightMode === "Series";
    };
    Highlight3D2.prototype.invokeHighlight = function(chart) {
      this.declarePrivateVariables(chart);
      this.series = extend({}, chart.visibleSeries, null, true);
      this.seriesStyles();
      this.currentMode = chart.highlightMode;
    };
    Highlight3D2.prototype.getModuleName = function() {
      return "Highlight3D";
    };
    Highlight3D2.prototype.destroy = function() {
      this.unWireEvents();
    };
    return Highlight3D2;
  }(Selection3D)
);

// node_modules/@syncfusion/ej2-charts/src/chart3d/print-export/export.js
var Export3D = (
  /** @class */
  function() {
    function Export3D2(chart) {
      this.chart = chart;
    }
    Export3D2.prototype.export = function(type, fileName) {
      var exportChart = new ExportUtils(this.chart);
      var argsData = {
        cancel: false,
        width: null,
        height: null
      };
      this.chart.trigger(beforeExport, argsData);
      if (!argsData.cancel) {
        exportChart.export(type, fileName, void 0, [this.chart]);
      }
    };
    Export3D2.prototype.pdfExport = function(fileName, orientation, controls, width, height, isVertical, header, footer, exportToMultiplePage) {
      var exportChart = new ExportUtils(this.chart);
      controls = controls ? controls : [this.chart];
      var argsData = {
        cancel: false,
        width,
        height
      };
      this.chart.trigger(beforeExport, argsData);
      if (!argsData.cancel) {
        exportChart.export("PDF", fileName, orientation, controls, width = argsData.width, height = argsData.height, isVertical, header, footer, exportToMultiplePage);
      }
    };
    Export3D2.prototype.getDataUrl = function(chart) {
      var exportUtil = new ExportUtils(chart);
      return exportUtil.getDataUrl(chart);
    };
    Export3D2.prototype.getModuleName = function() {
      return "Export3D";
    };
    Export3D2.prototype.destroy = function() {
    };
    return Export3D2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/circularchart3d/renderer/dataLabel.js
var __extends111 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate31 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CircularChart3DDataLabelFont = (
  /** @class */
  function(_super) {
    __extends111(CircularChart3DDataLabelFont2, _super);
    function CircularChart3DDataLabelFont2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate31([Property("Normal")], CircularChart3DDataLabelFont2.prototype, "fontStyle", void 0);
    __decorate31([Property("16px")], CircularChart3DDataLabelFont2.prototype, "size", void 0);
    __decorate31([Property("Normal")], CircularChart3DDataLabelFont2.prototype, "fontWeight", void 0);
    __decorate31([Property("")], CircularChart3DDataLabelFont2.prototype, "color", void 0);
    __decorate31([Property("Segoe UI")], CircularChart3DDataLabelFont2.prototype, "fontFamily", void 0);
    __decorate31([Property(1)], CircularChart3DDataLabelFont2.prototype, "opacity", void 0);
    return CircularChart3DDataLabelFont2;
  }(ChildProperty)
);
var CircularChart3DConnector = (
  /** @class */
  function(_super) {
    __extends111(CircularChart3DConnector2, _super);
    function CircularChart3DConnector2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate31([Property(null)], CircularChart3DConnector2.prototype, "color", void 0);
    __decorate31([Property(1)], CircularChart3DConnector2.prototype, "width", void 0);
    __decorate31([Property(null)], CircularChart3DConnector2.prototype, "length", void 0);
    __decorate31([Property("")], CircularChart3DConnector2.prototype, "dashArray", void 0);
    return CircularChart3DConnector2;
  }(ChildProperty)
);
var CircularChart3DDataLabelSettings = (
  /** @class */
  function(_super) {
    __extends111(CircularChart3DDataLabelSettings2, _super);
    function CircularChart3DDataLabelSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate31([Property(false)], CircularChart3DDataLabelSettings2.prototype, "visible", void 0);
    __decorate31([Property(null)], CircularChart3DDataLabelSettings2.prototype, "name", void 0);
    __decorate31([Property("transparent")], CircularChart3DDataLabelSettings2.prototype, "fill", void 0);
    __decorate31([Property("Inside")], CircularChart3DDataLabelSettings2.prototype, "position", void 0);
    __decorate31([Property(0)], CircularChart3DDataLabelSettings2.prototype, "angle", void 0);
    __decorate31([Property(false)], CircularChart3DDataLabelSettings2.prototype, "enableRotation", void 0);
    __decorate31([Complex({
      width: null,
      color: null
    }, Border)], CircularChart3DDataLabelSettings2.prototype, "border", void 0);
    __decorate31([Complex({
      fontFamily: null,
      size: "12px",
      fontStyle: "Normal",
      fontWeight: "400",
      color: null
    }, CircularChart3DDataLabelFont)], CircularChart3DDataLabelSettings2.prototype, "font", void 0);
    __decorate31([Complex({}, CircularChart3DConnector)], CircularChart3DDataLabelSettings2.prototype, "connectorStyle", void 0);
    __decorate31([Property(null)], CircularChart3DDataLabelSettings2.prototype, "template", void 0);
    __decorate31([Property("")], CircularChart3DDataLabelSettings2.prototype, "format", void 0);
    return CircularChart3DDataLabelSettings2;
  }(ChildProperty)
);
var CircularChartDataLabel3D = (
  /** @class */
  function(_super) {
    __extends111(CircularChartDataLabel3D2, _super);
    function CircularChartDataLabel3D2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CircularChartDataLabel3D2.prototype.renderDataLabel = function(series, chart) {
      var templateId = chart.element.id + "-series-" + series.index + "-data-label-collections";
      series.labelBound = isNullOrUndefined(series.labelBound) ? new Rect(Infinity, Infinity, -Infinity, -Infinity) : series.labelBound;
      series.dataLabelElement = createElement("div", {
        id: templateId
      });
      for (var i = 0; i < series.points.length; i++) {
        var point = series.points[i];
        var pointText = this.getDatalabelText(series.dataLabel.format, chart, point.text ? point.text : isNullOrUndefined(point.y) ? "" : point.y.toString());
        var border = {
          width: series.dataLabel.border.width,
          color: series.dataLabel.border.color,
          dashArray: series.dataLabel.border.dashArray
        };
        var argsFont = extend({}, getValue("properties", series.dataLabel.font), null, true);
        var argsData = {
          cancel: false,
          name: textRender,
          series,
          point,
          text: pointText,
          border,
          color: series.dataLabel.fill,
          template: series.dataLabel.template,
          font: argsFont
        };
        chart.trigger(textRender, argsData);
        point.argsData = argsData;
        if (point.visible && !argsData.cancel && !isNullOrUndefined(point.y)) {
          this.draw3DDataLabel(series, point.index, point, chart);
        }
      }
      if (series.dataLabel.template) {
        appendChildElement(false, document.getElementById(chart.element.id + "_Secondary_Element"), series.dataLabelElement, chart.redraw, false, "x", "y", null, "", false, false, null);
      }
    };
    CircularChartDataLabel3D2.prototype.createDataLabelTemplate = function(parentElement, series, dataLabel, point, data, labelIndex, redraw, location, chart) {
      var childElement = this.createTemplate(createElement("div", {
        id: chart.element.id + "-series-" + series.index + "-data-label-" + labelIndex,
        styles: "position: absolute;background-color:" + data.color + ";" + getFontStyle(dataLabel.font, chart.themeStyle.datalabelFont) + ";border:" + data.border.width + "px solid " + data.border.color + ";"
      }), data.template, chart, point, series, chart.element.id + "-data-label-");
      this.calculateTemplateLabelSize(parentElement, childElement, point, series, dataLabel, redraw, location);
    };
    CircularChartDataLabel3D2.prototype.calculateTemplateLabelSize = function(parentElement, childElement, point, series, dataLabel, redraw, location, isReactCallback) {
      var elementRect = measureElementRect(childElement, redraw, isReactCallback);
      childElement.style.left = location.x - elementRect.width / 2 + "px";
      childElement.style.top = location.y - elementRect.height + "px";
      appendChildElement(false, parentElement, childElement, redraw, true, "left", "top");
    };
    CircularChartDataLabel3D2.prototype.createTemplate = function(childElement, content, chart, point, series, dataLabelId) {
      var templateFn = getTemplateFunction(content);
      var templateElement;
      try {
        var tempObject = {
          chart,
          series,
          point
        };
        var templateId = dataLabelId + "-template";
        var elementData = templateFn ? templateFn(tempObject, chart, templateId, dataLabelId) : [];
        if (elementData.length) {
          templateElement = Array.prototype.slice.call(elementData);
          var len = templateElement.length;
          for (var i = 0; i < len; i++) {
            childElement.appendChild(templateElement[i]);
          }
        }
        var reactCallback = void 0;
        if (chart.isReact) {
          chart.renderReactTemplates(reactCallback);
        }
      } catch (e) {
        return childElement;
      }
      return childElement;
    };
    CircularChartDataLabel3D2.prototype.draw3DDataLabel = function(series, pointIndex, point, chart) {
      var connectorHeight = series.dataLabel.connectorStyle.length ? parseFloat(series.dataLabel.connectorStyle.length) : series.dataLabel.connectorStyle.length;
      var radius;
      var pointX;
      var pointY;
      var degree;
      var commonEventArgs = {
        data: null
      };
      var location = {
        x: 0,
        y: 0
      };
      var seriesIndex = series.index;
      var center = point.symbolLocation.center;
      var dradius = point.symbolLocation.radius * series.coefficient;
      if (isNullOrUndefined(connectorHeight)) {
        connectorHeight = measureText(point.argsData.text, series.dataLabel.font, chart.themeStyle.datalabelFont).height;
      }
      if (series != null && series.dataLabel.position !== "Inside") {
        radius = point.symbolLocation.radius + connectorHeight;
      } else if (series != null) {
        radius = dradius + (point.symbolLocation.radius - dradius) / 2;
      }
      pointX = location.x = center.x + parseFloat(point.argsData.font.size) / 3 + radius * Math.cos(point.symbolLocation.angle);
      pointY = location.y = center.y + parseFloat(point.argsData.font.size) / 3 + radius * Math.sin(point.symbolLocation.angle);
      commonEventArgs.data = {
        text: point.argsData.text,
        location: {
          x: pointX,
          y: pointY
        },
        series,
        pointIndex,
        seriesIndex
      };
      commonEventArgs.data.Text = commonEventArgs.data.text;
      var size = measureText(point.argsData.text, series.dataLabel.font, chart.themeStyle.datalabelFont);
      pointX = location.x = commonEventArgs.data.location.x;
      pointY = location.y = commonEventArgs.data.location.y;
      var tag = !series.dataLabel.template ? "text" : "template";
      var saturationColor = this.getSaturatedColor(point, point.argsData.color, chart);
      var element = {
        width: size.width,
        height: size.height,
        fill: saturationColor,
        label: commonEventArgs.data,
        textAnchor: "middle",
        tag,
        font: point.argsData.font,
        angle: 0,
        id: chart.element.id + "-svg-data-label-text-" + pointIndex,
        child: chart.groupElement
      };
      if (chart.circularChartLegend3DModule && chart.legendSettings.visible && point.visible && series.dataLabel.position === "Outside") {
        var rect = chart.circularChartLegend3DModule.legendBounds;
        var legendpadding = chart.legendSettings.border.width / 2;
        rect = new Rect(rect.x - legendpadding, rect.y - legendpadding, rect.width + 2 * legendpadding, rect.height + 2 * legendpadding);
        var labelRegion = new Rect(element.label.location.x + size.width / 2 + 20, element.label.location.y + 2.5, element.width, element.height);
        if (isOverlap(labelRegion, rect)) {
          if (chart.circularChartLegend3DModule.position === "Right") {
            element.width = rect.x - labelRegion.x;
          } else if (chart.circularChartLegend3DModule.position === "Left") {
            element.width = labelRegion.x - (rect.x + rect.width);
            if (element.width < 0) {
              element.width += labelRegion.width;
              element.label.location.x = rect.x + rect.width - size.width / 2 + 20;
            }
          }
          if (labelRegion && element.width < labelRegion.width) {
            element.label.text = textTrim(element.width, element.label.text, series.dataLabel.font, chart.enableRtl, chart.themeStyle.datalabelFont);
          }
          if (element.label.text.length === 3 && element.label.text.indexOf("...") > -1) {
            return;
          }
        }
      }
      var connectorPoints;
      if (series.dataLabel.position !== "Inside") {
        connectorPoints = this.updateConnectorLine(point, pointIndex, series, connectorHeight, chart);
      }
      if (series.dataLabel.template && series.dataLabel.position !== "Inside") {
        var childElement = this.createTemplate(createElement("div", {
          id: chart.element.id + "-series-data-label-0",
          styles: "position: absolute;background-color:" + point.argsData.color + ";" + getFontStyle(point.argsData.font, chart.themeStyle.datalabelFont) + ";border:" + point.argsData.border.width + "px solid " + point.argsData.border.color + ";"
        }), point.argsData.template, chart, point, series, chart.element.id + "-data-label-");
        size = measureText(childElement.textContent, series.dataLabel.font, chart.themeStyle.datalabelFont);
      }
      if (chart.circularChartLegend3DModule && chart.legendSettings.visible && series.dataLabel.position === "Outside") {
        chart.visibleSeries[0].findMaxBounds(chart.visibleSeries[0].labelBound, {
          x: pointX,
          y: pointY,
          width: size.width,
          height: size.height
        });
      }
      var padding = 0;
      var heightPadding = 0;
      var textAngle = point.symbolLocation.angle;
      if (series.dataLabel.position !== "Inside") {
        if (textAngle > 1.5 && textAngle < 1.8 || textAngle > 1.3 && textAngle < 1.5 || textAngle > 4.5 && textAngle < 4.8 || textAngle > 4.3 && textAngle < 4.5) {
          location.x = connectorPoints.x;
          location.y = connectorPoints.y;
          textAngle = connectorPoints.angle;
        }
        if (textAngle < Math.PI / 2 || textAngle >= Math.PI / 2 + Math.PI) {
          padding = size.width / 2 + 20;
          heightPadding = 5 / 2;
        } else {
          padding = -(size.width / 2 + (point.argsData.color !== "transparent" || point.argsData.border.color ? 25 : 20));
          heightPadding = 5 / 2;
        }
      }
      if (!point.argsData.template && commonEventArgs.data.text !== "") {
        var element_1 = {
          tag: "dataLabel",
          series,
          point,
          pointIndex,
          id: chart.element.id + "-svg-" + seriesIndex + "-data-label-" + pointIndex,
          child: chart.groupElement
        };
        var angle = void 0;
        var transform = "";
        if (series.dataLabel.enableRotation) {
          angle = degree = series.dataLabel.angle;
          if (angle === 0) {
            var toDegrees = function(angle2) {
              return angle2 * (180 / Math.PI);
            };
            var midAngle = toDegrees(point.symbolLocation.angle);
            if (series.dataLabel.position === "Outside") {
              degree = 0;
            } else if (midAngle >= 90 && midAngle <= 260) {
              degree = midAngle + 180;
              location.x = location.x - parseFloat(point.argsData.font.size) / 2;
            } else {
              degree = midAngle;
            }
          } else {
            degree = angle > 360 ? angle - 360 : angle < -360 ? angle + 360 : angle;
          }
          transform = "rotate(" + degree + "," + location.x + "," + location.y + ")";
        }
        element_1.transform = transform;
        var borderElement = chart.polygon.createTextElement(chart.vector.vector3D(pointX + padding, pointY + heightPadding, point.symbolLocation.z ? point.symbolLocation.z : 0), element_1, 0, -size.height);
        chart.circular3DPolygon.push(borderElement);
      }
      element.angle = series.dataLabel.enableRotation ? series.dataLabel.angle !== 0 ? series.dataLabel.angle : degree : 0;
      var polygon = chart.polygon.createTextElement(chart.vector.vector3D(location.x + padding, location.y + heightPadding, -1), element, 0, -size.height);
      chart.circular3DPolygon.push(polygon);
    };
    CircularChartDataLabel3D2.prototype.getSaturatedColor = function(point, color, chart) {
      var saturatedColor;
      saturatedColor = color === "transparent" ? this.getLabelBackground(point, chart) : color;
      saturatedColor = saturatedColor === "transparent" ? chart.theme.indexOf("Dark") > -1 || chart.theme.indexOf("HighContrast") > -1 ? "black" : "white" : saturatedColor;
      var rgbValue = convertHexToColor(colorNameToHex(saturatedColor));
      var contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1e3);
      return chart.theme === "Bootstrap5" ? "#212529" : chart.theme === "Bootstrap5Dark" ? "#DEE2E6" : contrast >= 128 ? chart.theme.indexOf("Tailwind3") > -1 ? "#4B5563" : "black" : chart.theme.indexOf("Tailwind3") > -1 ? "#D1D5DB" : "white";
    };
    CircularChartDataLabel3D2.prototype.getLabelBackground = function(point, chart) {
      return point.argsData.series.dataLabel.position === "Outside" ? chart.background || chart.themeStyle.background : !point.y ? chart.theme.indexOf("dark") ? "white" : "black" : point.color;
    };
    CircularChartDataLabel3D2.prototype.getDatalabelText = function(labelFormat, chart, labelText) {
      if (Number(labelText)) {
        var customLabelFormat = labelFormat.match("{value}") !== null;
        var format = chart.intl.getNumberFormat({
          format: customLabelFormat ? "" : labelFormat,
          useGrouping: chart.useGroupingSeparator
        });
        labelText = customLabelFormat ? labelFormat.replace("{value}", format(parseFloat(labelText))) : format(parseFloat(labelText));
      }
      return labelText;
    };
    CircularChartDataLabel3D2.prototype.updateConnectorLine = function(point, pointIndex, series, connectorHeight, chart) {
      var drawPoints = [];
      var symbolLocation = point.symbolLocation;
      var x = symbolLocation.center.x + Math.cos(symbolLocation.angle) * symbolLocation.radius;
      var y = symbolLocation.center.y + Math.sin(symbolLocation.angle) * symbolLocation.radius;
      drawPoints.push({
        x,
        y
      });
      var labelRadiusFromOrigin = symbolLocation.radius + connectorHeight;
      var angle = symbolLocation.angle;
      x = symbolLocation.center.x + Math.cos(angle) * labelRadiusFromOrigin;
      y = symbolLocation.center.y + Math.sin(angle) * labelRadiusFromOrigin;
      drawPoints.push({
        x,
        y
      });
      var padding;
      if (angle < Math.PI / 2 || angle >= Math.PI / 2 + Math.PI) {
        padding = 10;
      } else {
        padding = -10;
      }
      drawPoints.push({
        x: x + padding,
        y
      });
      this.drawLineSegment(drawPoints, pointIndex, series, chart);
      return {
        x,
        y,
        angle
      };
    };
    CircularChartDataLabel3D2.prototype.drawLineSegment = function(drawpoints, pointIndex, series, chart) {
      var vectorPoints = [];
      for (var i = 0; i < drawpoints.length; i++) {
        vectorPoints.push(chart.vector.vector3D(drawpoints[i].x, drawpoints[i].y, 0));
      }
      var seriesIndex = series.index;
      var color = series.points[pointIndex].color;
      var stroke = series.dataLabel.connectorStyle.color ? series.dataLabel.connectorStyle.color : color;
      var line = {
        width: series.dataLabel.connectorStyle.width,
        stroke,
        child: chart.groupElement,
        tag: "polyline",
        dashArray: series.dataLabel.connectorStyle.dashArray,
        id: chart.element.id + "-datalabel-series-" + seriesIndex + "-connector-" + pointIndex
      };
      var ploygon = chart.polygon.createPolyline(vectorPoints, line);
      chart.circular3DPolygon.push(ploygon);
    };
    CircularChartDataLabel3D2.prototype.getModuleName = function() {
      return "CircularChartDataLabel3D";
    };
    CircularChartDataLabel3D2.prototype.destroy = function() {
    };
    return CircularChartDataLabel3D2;
  }(ChildProperty)
);

// node_modules/@syncfusion/ej2-charts/src/circularchart3d/model/theme.js
function getCircular3DSeriesColor(theme) {
  var palette;
  switch (theme) {
    case "Fabric":
      palette = ["#4472c4", "#ed7d31", "#ffc000", "#70ad47", "#5b9bd5", "#c1c1c1", "#6f6fe2", "#e269ae", "#9e480e", "#997300"];
      break;
    case "Bootstrap4":
      palette = ["#a16ee5", "#f7ce69", "#55a5c2", "#7ddf1e", "#ff6ea6", "#7953ac", "#b99b4f", "#407c92", "#5ea716", "#b91c52"];
      break;
    case "Bootstrap":
      palette = ["#a16ee5", "#f7ce69", "#55a5c2", "#7ddf1e", "#ff6ea6", "#7953ac", "#b99b4f", "#407c92", "#5ea716", "#b91c52"];
      break;
    case "HighContrastLight":
    case "HighContrast":
      palette = ["#79ECE4", "#E98272", "#DFE6B6", "#C6E773", "#BA98FF", "#FA83C3", "#00C27A", "#43ACEF", "#D681EF", "#D8BC6E"];
      break;
    case "MaterialDark":
      palette = ["#9ECB08", "#56AEFF", "#C57AFF", "#61EAA9", "#EBBB3E", "#F45C5C", "#8A77FF", "#63C7FF", "#FF84B0", "#F7C928"];
      break;
    case "FabricDark":
      palette = ["#4472c4", "#ed7d31", "#ffc000", "#70ad47", "#5b9bd5", "#c1c1c1", "#6f6fe2", "#e269ae", "#9e480e", "#997300"];
      break;
    case "BootstrapDark":
      palette = ["#a16ee5", "#f7ce69", "#55a5c2", "#7ddf1e", "#ff6ea6", "#7953ac", "#b99b4f", "#407c92", "#5ea716", "#b91c52"];
      break;
    case "Tailwind3":
      palette = ["#2F4074", "#03B4B4", "#0D72DE", "#FF5733", "#D63384", "#F39C12", "#EF291F", "#91C822"];
      break;
    case "Tailwind3Dark":
      palette = ["#8029F1", "#1ABC9C", "#0D72DE", "#FF5733", "#D63384", "#F39C12", "#EF291F", "#91C822"];
      break;
    case "Tailwind":
      palette = ["#5A61F6", "#65A30D", "#334155", "#14B8A6", "#8B5CF6", "#0369A1", "#F97316", "#9333EA", "#F59E0B", "#15803D"];
      break;
    case "TailwindDark":
      palette = ["#8B5CF6", "#22D3EE", "#F87171", "#4ADE80", "#E879F9", "#FCD34D", "#F97316", "#2DD4BF", "#F472B6", "#10B981"];
      break;
    case "Bootstrap5Dark":
    case "Bootstrap5":
      palette = ["#FD7E14", "#6610F2", "#6F42C1", "#D63384", "#DC3545", "#FFC107", "#198754", "#0DCAF0"];
      break;
    case "FluentDark":
      palette = ["#1AC9E6", "#DA4CB2", "#EDBB40", "#AF4BCF", "#FF7266", "#1BD565", "#EE993D", "#5887FF", "#EC548D", "#7D39C0"];
      break;
    case "Fluent":
      palette = ["#1AC9E6", "#DA4CB2", "#EDBB40", "#AF4BCF", "#FF7266", "#1BD565", "#EE993D", "#5887FF", "#EC548D", "#7D39C0"];
      break;
    case "Fluent2":
      palette = ["#6200EE", "#09AF74", "#0076E5", "#CB3587", "#E7910F", "#0364DE", "#66CD15", "#F3A93C", "#107C10", "#C19C00"];
      break;
    case "Fluent2Dark":
      palette = ["#9BB449", "#2A72D5", "#43B786", "#3F579A", "#584EC6", "#E85F9C", "#6E7A89", "#EA6266", "#0B6A0B", "#C19C00"];
      break;
    case "Fluent2HighContrast":
      palette = ["#9BB449", "#2A72D5", "#43B786", "#3F579A", "#584EC6", "#E85F9C", "#6E7A89", "#EA6266", "#0B6A0B", "#C19C00"];
      break;
    case "Material3":
      palette = ["#6355C7", "#00AEE0", "#FFB400", "#F7523F", "#963C70", "#FD7400", "#4BE0BC", "#2196F5", "#DE3D8A", "#162F88"];
      break;
    case "Material3Dark":
      palette = ["#4EAAFF", "#FA4EAB", "#FFF500", "#17EA58", "#38FFE7", "#FF9E45", "#B3F32F", "#B93CE4", "#FC5664", "#9B55FF"];
      break;
    default:
      palette = ["#00bdae", "#404041", "#357cd2", "#e56590", "#f8b883", "#70ad47", "#dd8abd", "#7f84e8", "#7bb4eb", "#ea7a57"];
      break;
  }
  return palette;
}
function getCircular3DThemeColor(theme) {
  var style;
  switch (theme) {
    case "HighContrastLight":
    case "HighContrast":
      style = {
        chartTitle: "#ffffff",
        legendLabel: "#ffffff",
        background: "transparent",
        tooltipFill: "#ffffff",
        tooltipBoldLabel: "#000000",
        tooltipLightLabel: "#000000",
        tooltipHeaderLine: "#969696",
        tabColor: "#FFD939",
        chartTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#969696",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#000000",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal"
        },
        datalabelFont: {
          color: "#969696",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "MaterialDark":
    case "FabricDark":
    case "BootstrapDark":
      style = {
        chartTitle: "#ffffff",
        legendLabel: "#DADADA",
        background: "transparent",
        tooltipFill: "#F4F4F4",
        tooltipBoldLabel: "#282727",
        tooltipLightLabel: "#333232",
        tooltipHeaderLine: "#9A9A9A",
        tabColor: theme === "MaterialDark" ? "#00B0FF" : theme === "FabricDark" ? "#0074CC" : "#0070F0",
        chartTitleFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.87)" : theme === "FabricDark" ? "#DADADA" : "#FFFFFF",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendTitleFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.87)" : theme === "FabricDark" ? "#DADADA" : "#FFFFFF",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.6)" : theme === "FabricDark" ? "#A19F9D" : "#676767",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: theme === "MaterialDark" ? "rgba(18, 18, 18, 1)" : theme === "FabricDark" ? "#DADADA" : "#1A1A1A",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "12px",
          fontStyle: "Normal"
        },
        datalabelFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.6)" : theme === "FabricDark" ? "#A19F9D" : "#676767",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: theme === "MaterialDark" ? "rgba(255, 255, 255, 0.87)" : theme === "FabricDark" ? "#DADADA" : "#FFFFFF",
          fontFamily: theme === "MaterialDark" ? "Roboto" : theme === "FabricDark" ? "Segoe UI" : "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Bootstrap4":
      style = {
        chartTitle: "#212529",
        legendLabel: "#212529",
        background: "transparent",
        tooltipFill: "#020202",
        tooltipBoldLabel: "rgba(255,255,255)",
        tooltipLightLabel: "rgba(255,255,255, 0.9)",
        tooltipHeaderLine: "rgba(255,255,255, 0.2)",
        tabColor: "#007BFF",
        chartTitleFont: {
          color: "#212529",
          fontFamily: "Helvetica",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendTitleFont: {
          color: "#212529",
          fontFamily: "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#666666",
          fontFamily: "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#F9FAFB",
          fontFamily: "Helvetica",
          size: "12px",
          fontStyle: "Normal"
        },
        datalabelFont: {
          color: "#495057",
          fontFamily: "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#212529",
          fontFamily: "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Tailwind3":
      style = {
        chartTitle: "#111827",
        legendLabel: "#6B7280",
        background: "transparent",
        tooltipFill: "#111827",
        tooltipBoldLabel: "#F9FAFB",
        tooltipLightLabel: "#F9FAFB",
        tooltipHeaderLine: "#D1D5DB",
        tabColor: "#4F46E5",
        chartTitleFont: {
          color: "#111827",
          fontFamily: "Inter",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendTitleFont: {
          color: "#374151",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        legendLabelFont: {
          color: "#6B7280",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        tooltipLabelFont: {
          color: "#F9FAFB",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal"
        },
        datalabelFont: {
          color: "#4B5563",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#6B7280",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "500"
        }
      };
      break;
    case "Tailwind3Dark":
      style = {
        chartTitle: "#FFFFFF",
        legendLabel: "#9CA3AF",
        background: "transparent",
        tooltipFill: "#F9FAFB",
        tooltipBoldLabel: "#1F2937",
        tooltipLightLabel: "#1F2937",
        tooltipHeaderLine: "#374151",
        tabColor: "#22D3EE",
        chartTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Inter",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendTitleFont: {
          color: "#E5E7EB",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        legendLabelFont: {
          color: "#9CA3AF",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "500"
        },
        tooltipLabelFont: {
          color: "#1F2937",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal"
        },
        datalabelFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#9CA3AF",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "500"
        }
      };
      break;
    case "Tailwind":
      style = {
        chartTitle: "#374151",
        legendLabel: "#374151",
        background: "transparent",
        tooltipFill: "#111827",
        tooltipBoldLabel: "#D1D5DB",
        tooltipLightLabel: "#F9FAFB",
        tooltipHeaderLine: "#6B7280",
        tabColor: "#4F46E5",
        chartTitleFont: {
          color: "#374151",
          fontFamily: "Inter",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendTitleFont: {
          color: "#374151",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#374151",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#F9FAFB",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal"
        },
        datalabelFont: {
          color: "#6B7280",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#374151",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "TailwindDark":
      style = {
        chartTitle: "#D1D5DB",
        legendLabel: "#D1D5DB",
        background: "transparent",
        tooltipFill: "#F9FAFB",
        tooltipBoldLabel: "#6B7280",
        tooltipLightLabel: "#1F2937",
        tooltipHeaderLine: "#9CA3AF",
        tabColor: "#22D3EE",
        chartTitleFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendTitleFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#1F2937",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal"
        },
        datalabelFont: {
          color: "#9CA3AF",
          fontFamily: "Inter",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#D1D5DB",
          fontFamily: "Inter",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Bootstrap5":
      style = {
        chartTitle: "#212529",
        legendLabel: "#212529",
        background: "transparent",
        tooltipFill: "#000000E5",
        tooltipBoldLabel: "#F9FAFB",
        tooltipLightLabel: "#FFFFFF",
        tooltipHeaderLine: "#FFFFFF",
        tabColor: "#0D6EFD",
        chartTitleFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendTitleFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal"
        },
        datalabelFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#21252980",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        }
      };
      break;
    case "Bootstrap5Dark":
      style = {
        chartTitle: "#DEE2E6",
        legendLabel: "#DEE2E6",
        background: "transparent",
        tooltipFill: "#E9ECEF",
        tooltipBoldLabel: "#212529",
        tooltipLightLabel: "#212529",
        tooltipHeaderLine: "#212529",
        tabColor: "#0D6EFD",
        chartTitleFont: {
          color: "#DEE2E6",
          fontFamily: "Segoe UI",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendTitleFont: {
          color: "#DEE2E6",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#DEE2E6",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#212529",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal"
        },
        datalabelFont: {
          color: "#DEE2E6",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#DEE2E680",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        }
      };
      break;
    case "Fluent":
      style = {
        chartTitle: "#201F1E",
        legendLabel: "#323130",
        background: "transparent",
        tooltipFill: "#FFFFFF",
        tooltipBoldLabel: "#323130",
        tooltipLightLabel: "#323130",
        tooltipHeaderLine: "#D2D0CE",
        tabColor: "#0078D4",
        chartTitleFont: {
          color: "#201F1E",
          fontFamily: "Segoe UI",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendTitleFont: {
          color: "#201F1E",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#49454E",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#323130",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal"
        },
        datalabelFont: {
          color: "#3B3A39",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#323129",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "FluentDark":
      style = {
        chartTitle: "#F3F2F1",
        legendLabel: "#D2D0CE",
        background: "transparent",
        tooltipFill: "#252423",
        tooltipBoldLabel: "#F3F2F1",
        tooltipLightLabel: "#F3F2F1",
        tooltipHeaderLine: "#3B3A39",
        tabColor: "#0078D4",
        chartTitleFont: {
          color: "#C8C6C4",
          fontFamily: "Segoe UI",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendTitleFont: {
          color: "#F3F2F1",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#D2D0CE",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#F3F2F1",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal"
        },
        datalabelFont: {
          color: "#D2D0CE",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#F3F2F1",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Fluent2":
      style = {
        chartTitle: "#242424",
        legendLabel: "#242424",
        background: "transparent",
        tooltipFill: "#FFFFFF",
        tooltipBoldLabel: "#242424",
        tooltipLightLabel: "#242424",
        tooltipHeaderLine: "#D2D0CE",
        tabColor: "#0078D4",
        chartTitleFont: {
          color: "#242424",
          fontFamily: "Segoe UI",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendTitleFont: {
          color: "#242424",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#242424",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#242424",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal"
        },
        datalabelFont: {
          color: "#242424",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#616161",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        }
      };
      break;
    case "Fluent2Dark":
      style = {
        chartTitle: "#FFFFFF",
        legendLabel: "#FFFFFF",
        background: "transparent",
        tooltipFill: "#292929",
        tooltipBoldLabel: "#FFFFFF",
        tooltipLightLabel: "#FFFFFF",
        tooltipHeaderLine: "#3B3A39",
        tabColor: "#0078D4",
        chartTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal"
        },
        datalabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#ADADAD",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        }
      };
      break;
    case "Fluent2HighContrast":
      style = {
        chartTitle: "#FFFFFF",
        legendLabel: "#FFFFFF",
        background: "transparent",
        tooltipFill: "#000000",
        tooltipBoldLabel: "#FFFFFF",
        tooltipLightLabel: "#FFFFFF",
        tooltipHeaderLine: "#3B3A39",
        tabColor: "#0078D4",
        chartTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal"
        },
        datalabelFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#FFFFFF",
          fontFamily: "Segoe UI",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        }
      };
      break;
    case "Material3":
      style = {
        chartTitle: "#1C1B1F",
        legendLabel: "#49454E",
        background: "transparent",
        tooltipFill: "#313033",
        tooltipBoldLabel: "#F4EFF4",
        tooltipLightLabel: "#F4EFF4",
        tooltipHeaderLine: "#F4EFF4",
        tabColor: "#49454E",
        chartTitleFont: {
          color: "#1C1B1F",
          fontFamily: "Roboto",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendTitleFont: {
          color: "#1C1B1F",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#49454E",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#F4EFF4",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal"
        },
        datalabelFont: {
          color: "#49454E",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#49454E",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    case "Material3Dark":
      style = {
        chartTitle: "#E6E1E5",
        legendLabel: "#CAC4D0",
        background: "transparent",
        tooltipFill: "#E6E1E5",
        tooltipBoldLabel: "#313033",
        tooltipLightLabel: "#313033",
        tooltipHeaderLine: "#313033",
        tabColor: "#CAC4D0",
        chartTitleFont: {
          color: "#E6E1E5",
          fontFamily: "Roboto",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendTitleFont: {
          color: "#E6E1E5",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: "#CAC4D0",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: "#313033",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal"
        },
        datalabelFont: {
          color: "#CAC4D0",
          fontFamily: "Roboto",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: "#CAC4D0",
          fontFamily: "Roboto",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
    default:
      style = {
        chartTitle: "#424242",
        legendLabel: "#353535",
        background: "transparent",
        tooltipFill: "#000816",
        tooltipBoldLabel: "#ffffff",
        tooltipLightLabel: "#dbdbdb",
        tooltipHeaderLine: "#ffffff",
        tabColor: theme === "Material" ? "#ff4081" : theme === "Fabric" ? "#0078D6" : "#317AB9",
        chartTitleFont: {
          color: theme === "Material" ? "rgba(0, 0, 0, 1)" : theme === "Fabric" ? "#333333" : "#212529",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Fabric" ? "Segoe UI" : "Helvetica",
          size: "16px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendTitleFont: {
          color: theme === "Material" ? "rgba(0, 0, 0, 1)" : theme === "Fabric" ? "#333333" : "#212529",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Fabric" ? "Segoe UI" : "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "600"
        },
        legendLabelFont: {
          color: theme === "Material" ? "rgba(97, 97, 97, 1)" : theme === "Fabric" ? "#666666" : "#666666",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Fabric" ? "Segoe UI" : "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        tooltipLabelFont: {
          color: theme === "Material" ? "rgba(249, 250, 251, 1)" : theme === "Fabric" ? "#333333" : "#F9FAFB",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Fabric" ? "Segoe UI" : "Helvetica",
          size: "12px",
          fontStyle: "Normal"
        },
        datalabelFont: {
          color: theme === "Material" ? "rgba(97, 97, 97, 1)" : theme === "Fabric" ? "#666666" : "#676767",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Fabric" ? "Segoe UI" : "Helvetica",
          size: "12px",
          fontStyle: "Normal",
          fontWeight: "400"
        },
        chartSubTitleFont: {
          color: theme === "Material" ? "rgba(0, 0, 0, 1)" : theme === "Fabric" ? "#333333" : "#212529",
          fontFamily: theme === "Material" ? "Roboto" : theme === "Fabric" ? "Segoe UI" : "Helvetica",
          size: "14px",
          fontStyle: "Normal",
          fontWeight: "400"
        }
      };
      break;
  }
  return style;
}

// node_modules/@syncfusion/ej2-charts/src/circularchart3d/renderer/series.js
var __extends112 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate32 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CircularChart3DPoints = (
  /** @class */
  /* @__PURE__ */ function() {
    function CircularChart3DPoints2() {
      this.visible = true;
      this.isExplode = false;
      this.argsData = null;
    }
    return CircularChart3DPoints2;
  }()
);
var CircularChart3DEmptyPointSettings = (
  /** @class */
  function(_super) {
    __extends112(CircularChart3DEmptyPointSettings2, _super);
    function CircularChart3DEmptyPointSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate32([Property(null)], CircularChart3DEmptyPointSettings2.prototype, "fill", void 0);
    __decorate32([Property("Gap")], CircularChart3DEmptyPointSettings2.prototype, "mode", void 0);
    return CircularChart3DEmptyPointSettings2;
  }(ChildProperty)
);
var CircularChart3DSeries = (
  /** @class */
  function(_super) {
    __extends112(CircularChart3DSeries2, _super);
    function CircularChart3DSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.points = [];
      _this.sumOfPoints = 0;
      _this.isRectSeries = true;
      _this.clipRect = new Rect(0, 0, 0, 0);
      _this.category = "Series";
      _this.rightSidePoints = [];
      _this.leftSidePoints = [];
      _this.segments = [];
      _this.isExploded = false;
      return _this;
    }
    CircularChart3DSeries2.prototype.refreshDataManager = function(chart, render) {
      var _this = this;
      var dateSource = this.dataSource || chart.dataSource;
      if (!(dateSource instanceof DataManager) && isNullOrUndefined(this.query)) {
        this.dataManagerSuccess({
          result: dateSource,
          count: dateSource.length
        }, chart, render);
        return;
      }
      var dataManager = this.dataModule.getData(this.dataModule.generateQuery().requiresCount());
      dataManager.then(function(e) {
        return _this.dataManagerSuccess(e, chart);
      });
    };
    CircularChart3DSeries2.prototype.dataManagerSuccess = function(dataObject, chart, render) {
      if (render === void 0) {
        render = true;
      }
      var argsData = {
        name: seriesRender,
        series: this,
        data: dataObject.result
      };
      chart.allowServerDataBinding = false;
      chart.trigger(seriesRender, argsData);
      this.resultData = dataObject.result !== "" ? dataObject.result : [];
      if (!render) {
        this.getPoints(this.resultData, chart);
      }
      if (++chart.seriesCounts === chart.visibleSeries.length && render) {
        this.getPoints(this.resultData, chart);
        chart.refreshChart();
      }
    };
    CircularChart3DSeries2.prototype.getPoints = function(result, chart) {
      var length = Object.keys(result).length;
      this.sumOfPoints = 0;
      if (length === 0) {
        this.points = [];
        return null;
      }
      this.findSumOfPoints(result);
      this.points = [];
      var point;
      var colors = this.palettes.length ? this.palettes : getCircular3DSeriesColor(chart.theme);
      for (var i = 0; i < length; i++) {
        point = this.setPoints(result, i, chart);
        if (isNullOrUndefined(point.y)) {
          point.visible = false;
        }
        this.pushPoints(point, colors, chart);
      }
    };
    CircularChart3DSeries2.prototype.pushPoints = function(point, colors, chart) {
      point.index = this.points.length;
      point.isExplode = this.explodeAll || point.index === this.explodeIndex;
      point.color = point.color || colors[point.index % colors.length];
      var argsData = {
        cancel: false,
        name: pointRender,
        series: this,
        point,
        fill: point.color
      };
      chart.trigger(pointRender, argsData);
      point.color = argsData.fill;
      point.visible = !argsData.cancel;
      this.points.push(point);
    };
    CircularChart3DSeries2.prototype.findSumOfPoints = function(result) {
      var length = Object.keys(result).length;
      for (var i = 0; i < length; i++) {
        if (!isNullOrUndefined(result[i]) && !isNullOrUndefined(result[i][this.yName]) && !isNaN(result[i][this.yName])) {
          this.sumOfPoints += Math.abs(result[i][this.yName]);
        }
      }
    };
    CircularChart3DSeries2.prototype.setPoints = function(data, index, chart) {
      var point = new CircularChart3DPoints();
      point.x = getValue(this.xName, data[index]);
      point.y = getValue(this.yName, data[index]);
      point.percentage = +(point.y / this.sumOfPoints * 100).toFixed(2);
      point.legendImageUrl = getValue(this.legendImageUrl, data[index]);
      point.color = getValue(this.pointColorMapping, data[index]);
      point.text = point.originalText = getValue(this.dataLabel.name || "", data[index]);
      point.tooltip = getValue(this.tooltipMappingName || "", data[index]);
      point.sliceRadius = getValue(this.radius ? this.radius : "80%", data[index]);
      point.sliceRadius = isNullOrUndefined(point.sliceRadius) ? "80%" : point.sliceRadius;
      point.separatorY = chart.intl.formatNumber(point.y, {
        useGrouping: chart.useGroupingSeparator
      });
      this.setEmptyPoint(point, index, data, chart);
      return point;
    };
    CircularChart3DSeries2.prototype.draw = function(series, chart) {
      var marginRatio = 0.03;
      var seriesIndex = chart.visibleSeries.indexOf(series);
      this.calculateSize(chart, series);
      var seriesRadius = series.radius ? series.radius : Browser.isDevice && series.dataLabel.position === "Outside" ? "40%" : "80%";
      var radius = parseInt(seriesRadius, 10);
      if (!((seriesRadius.indexOf("%") !== -1 || typeof radius === "number") && !isNaN(radius))) {
        this.isRadiusMapped = true;
      }
      series.size = this.isRadiusMapped ? 0.8 : parseInt(seriesRadius, 10) / 100;
      series.coefficient = parseInt(series.innerRadius, 10) / 100;
      chart.circularRadius[seriesIndex] = (1 - marginRatio) * Math.min(series.actualWidth / 2 - (chart.legendSettings.visible && chart.circularChartLegend3DModule && (chart.legendSettings.position === "Right" || chart.legendSettings.position === "Left") ? chart.circularChartLegend3DModule.legendBounds.width : 0), series.actualHeight / 2) * series.size;
      chart.innerRadius[seriesIndex] = series.coefficient * chart.circularRadius[seriesIndex];
      this.createPolygons(series, chart);
      if (this.dataLabel.visible) {
        chart.circularChartDataLabel3DModule.renderDataLabel(series, chart);
      }
      appendChildElement(false, chart.svgObject, chart.groupElement, chart.redraw);
      var size = new Size(chart.availableSize.width, chart.availableSize.height);
      chart.graphics.prepareView(0, chart.depth, chart.rotation, chart.tilt, size, chart);
      chart.graphics.view(chart.svgObject, chart);
    };
    CircularChart3DSeries2.prototype.calculateSize = function(chart, series) {
      var legend = chart.legendSettings;
      var legXSpace = 0;
      var legYSpace = 0;
      var legendPosition = chart.circularChartLegend3DModule ? chart.circularChartLegend3DModule.position : "Auto";
      var title = chart.title;
      var subTitle = chart.subTitle;
      var titleLocation = chart.titleLocation;
      var subTitleLocation = chart.subTitleLocation;
      var titleTextOverflow = chart.titleStyle.textOverflow;
      var subTitleTextOverflow = chart.subTitleStyle.textOverflow;
      var titleEnable = title && titleTextOverflow === "Wrap" ? true : false;
      var subTitleEnable = subTitle && subTitleTextOverflow === "Wrap" ? true : false;
      if (legend.visible && chart.circularChartLegend3DModule && legendPosition !== "Custom") {
        if (legendPosition === "Right" || legendPosition === "Left") {
          legXSpace = legendPosition.toLowerCase() === "right" ? chart.margin.right : chart.margin.left + chart.circularChartLegend3DModule.legendBounds.width;
        } else {
          legYSpace = legendPosition === "Top" ? chart.margin.top : legendPosition === "Bottom" ? chart.margin.bottom + chart.circularChartLegend3DModule.legendBounds.height : 0;
        }
      }
      series.actualWidth = chart.availableSize.width - legXSpace;
      var centerx = series.actualWidth * 0.5 + (legendPosition === "Left" ? legXSpace : 0);
      if (titleEnable || subTitleEnable) {
        var yOffset = titleLocation.size.height + (subTitleEnable ? subTitleLocation.size.height : 0) + legYSpace;
        series.actualHeight = chart.svgObject.height.baseVal.value - yOffset;
        var centery = series.actualHeight * 0.5 + (titleLocation.size.height + (subTitleEnable ? subTitleLocation.size.height : 0));
        return {
          centerX: centerx,
          centerY: centery
        };
      } else {
        var yOffset = (title ? titleLocation.y : 0) + legYSpace;
        series.actualHeight = chart.svgObject.height.baseVal.value - yOffset;
        var centery = series.actualHeight * 0.5 + (legendPosition === "Top" ? yOffset : title ? titleLocation.y : 0);
        return {
          centerX: centerx,
          centerY: centery
        };
      }
    };
    CircularChart3DSeries2.prototype.createPolygons = function(series, chart) {
      var segments = [];
      var polygons = [];
      var seg;
      var style;
      var pointIndex;
      var polygonCollection = [];
      if (series.segments.length === 0) {
        segments = this.createPoints(series, chart);
      } else {
        segments = series.segments;
      }
      var segmentsLength = segments.length;
      for (var i = 0; i < segmentsLength; i++) {
        seg = segments[i];
        if (seg.visible) {
          pointIndex = segments[i].pointIndex;
          style = {
            opacity: series.opacity,
            interior: series.points[pointIndex].color
          };
          polygonCollection = this.createSector(seg, chart, style, series.index);
          if (polygonCollection !== null) {
            for (var k = 0; k < polygonCollection.length; k++) {
              if (!polygons[k]) {
                polygons[k] = [];
              }
              if (polygonCollection[k] !== null) {
                for (var j = 0; j < polygonCollection[k].length; j++) {
                  polygons[k].push(polygonCollection[k][j]);
                }
              }
            }
          }
        }
      }
      for (var i = 0; i < polygons.length; i++) {
        for (var k = 0; k < polygons[i].length; k++) {
          var polygone = polygons[i][k];
          chart.circular3DPolygon.push(polygone);
        }
      }
      return null;
    };
    CircularChart3DSeries2.prototype.createSector = function(segment, chart, style, seriesIndex) {
      var count = Math.ceil(segment.actualEndValue / 6);
      var degreesToRadians = Math.PI / 180;
      var index = 0;
      var depth = chart.depth;
      if (count < 1) {
        return null;
      }
      var polygonCollection = [];
      var endValue = segment.actualEndValue / count;
      var outputPoints = [];
      var inputPoints = [];
      for (var i = 0; i < count + 1; i++) {
        var ox = segment.center.x + segment.radius * Math.cos((segment.actualStartValue + i * endValue) * degreesToRadians);
        var oy = segment.center.y + segment.radius * Math.sin((segment.actualStartValue + i * endValue) * degreesToRadians);
        outputPoints[i] = {
          x: ox,
          y: oy
        };
        var ix = segment.center.x + segment.inSideRadius * Math.cos((segment.actualStartValue + i * endValue) * degreesToRadians);
        var iy = segment.center.y + segment.inSideRadius * Math.sin((segment.actualStartValue + i * endValue) * degreesToRadians);
        inputPoints[i] = {
          x: ix,
          y: iy
        };
      }
      var originPolygon = [];
      var vts = [];
      for (var i = 0; i < count; i++) {
        vts = [this.vector(outputPoints[i].x, outputPoints[i].y, 0), this.vector(outputPoints[i].x, outputPoints[i].y, depth), this.vector(outputPoints[i + 1].x, outputPoints[i + 1].y, depth), this.vector(outputPoints[i + 1].x, outputPoints[i + 1].y, 0)];
        originPolygon[i] = chart.polygon.polygon3D(vts, null, segment.index, null, null, style.opacity, style.interior, index.toString() + "-region-series-" + seriesIndex + "-point-" + segment.index, chart.groupElement, segment.accessibilityText);
        index++;
      }
      polygonCollection[1] = originPolygon;
      if (segment.inSideRadius > 0) {
        var iPlgs = [];
        for (var i = 0; i < count; i++) {
          vts = [this.vector(inputPoints[i].x, inputPoints[i].y, 0), this.vector(inputPoints[i].x, inputPoints[i].y, depth), this.vector(inputPoints[i + 1].x, inputPoints[i + 1].y, depth), this.vector(inputPoints[i + 1].x, inputPoints[i + 1].y, 0)];
          iPlgs[i] = chart.polygon.polygon3D(vts, null, segment.index, null, null, style.opacity, style.interior, index.toString() + "-region-series-" + seriesIndex + "-point-" + segment.index, chart.groupElement, segment.accessibilityText);
          index++;
        }
        polygonCollection[3] = iPlgs;
      }
      var tVtxs = [];
      var bVtxs = [];
      for (var i = 0; i < count + 1; i++) {
        tVtxs.push(this.vector(outputPoints[i].x, outputPoints[i].y, 0));
        bVtxs.push(this.vector(outputPoints[i].x, outputPoints[i].y, depth));
      }
      if (segment.inSideRadius > 0) {
        for (var i = count; i > -1; i--) {
          tVtxs.push(this.vector(inputPoints[i].x, inputPoints[i].y, 0));
          bVtxs.push(this.vector(inputPoints[i].x, inputPoints[i].y, depth));
        }
      } else {
        tVtxs.push(segment.center);
        bVtxs.push(this.vector(segment.center.x, segment.center.y, depth));
      }
      polygonCollection[0] = [];
      polygonCollection[0].push(chart.polygon.polygon3D(tVtxs, null, segment.index, null, null, style.opacity, style.interior, index.toString() + "-region-series-" + seriesIndex + "-point-" + segment.index, chart.groupElement, segment.accessibilityText));
      index++;
      polygonCollection[0].push(chart.polygon.polygon3D(bVtxs, null, segment.index, null, null, style.opacity, style.interior, index.toString() + "-region-series-" + seriesIndex + "-point-" + segment.index, chart.groupElement, segment.accessibilityText));
      index++;
      if (segment.inSideRadius > 0) {
        var rvts = [this.vector(outputPoints[0].x, outputPoints[0].y, 0), this.vector(outputPoints[0].x, outputPoints[0].y, depth), this.vector(inputPoints[0].x, inputPoints[0].y, depth), this.vector(inputPoints[0].x, inputPoints[0].y, 0)];
        var lvts = [this.vector(outputPoints[count].x, outputPoints[count].y, 0), this.vector(outputPoints[count].x, outputPoints[count].y, depth), this.vector(inputPoints[count].x, inputPoints[count].y, depth), this.vector(inputPoints[count].x, inputPoints[count].y, 0)];
        polygonCollection[2] = [];
        polygonCollection[2].push(chart.polygon.polygon3D(rvts, null, segment.index, null, null, style.opacity, style.interior, index.toString() + "-region-series-" + seriesIndex + "-point-" + segment.index, chart.groupElement, segment.accessibilityText));
        index++;
        polygonCollection[2].push(chart.polygon.polygon3D(lvts, null, segment.index, null, null, style.opacity, style.interior, index.toString() + "-region-series-" + seriesIndex + "-point-" + segment.index, chart.groupElement, segment.accessibilityText));
        index++;
      } else {
        var rvts = [this.vector(outputPoints[0].x, outputPoints[0].y, 0), this.vector(outputPoints[0].x, outputPoints[0].y, depth), this.vector(segment.center.x, segment.center.y, depth), this.vector(segment.center.x, segment.center.y, 0)];
        var lvts = [this.vector(outputPoints[count].x, outputPoints[count].y, 0), this.vector(outputPoints[count].x, outputPoints[count].y, depth), this.vector(segment.center.x, segment.center.y, depth), this.vector(segment.center.x, segment.center.y, 0)];
        polygonCollection[2] = [];
        polygonCollection[2].push(chart.polygon.polygon3D(rvts, null, segment.index, null, null, style.opacity, style.interior, index.toString() + "-region-series-" + seriesIndex + "-point-" + segment.index, chart.groupElement, segment.accessibilityText));
        index++;
        polygonCollection[2].push(chart.polygon.polygon3D(lvts, null, segment.index, null, null, style.opacity, style.interior, index.toString() + "-region-series-" + seriesIndex + "-point-" + segment.index, chart.groupElement, segment.accessibilityText));
        index++;
      }
      return polygonCollection;
    };
    CircularChart3DSeries2.prototype.createPoints = function(series, chart) {
      series.segments = [];
      var size = this.calculateSize(chart, series);
      var all = 0;
      var visiblePoints = series.points;
      var count = visiblePoints.length;
      for (var j = 0; j < count; j++) {
        if (visiblePoints[j].visible && !isNullOrUndefined(visiblePoints[j].y)) {
          all += visiblePoints[j].y;
        }
      }
      all = all !== 0 ? all : 1;
      var coefficient = 360 / all;
      var seriesIndex = series.index;
      var insideRadius = chart.innerRadius[seriesIndex];
      var yValues = this.getYValues(series.points);
      var pieHeight = chart.depth;
      var center;
      var arcStartAngle = 0;
      var arcEndAngle = 0;
      var current = 0;
      var pointIndex;
      var value;
      var rect = new Rect(0, 0, 0, 0);
      var offset = {
        X: 0,
        Y: 0
      };
      var segment;
      var segIndex = 0;
      var radius = chart.circularRadius[seriesIndex];
      for (var i = 0; i < count; i++) {
        if (series.points[i].visible && !isNullOrUndefined(yValues[i])) {
          pointIndex = series.points[i].index;
          value = Math.abs(yValues[i]);
          arcEndAngle = Math.abs(value) * (Math.PI * 2 / all);
          rect.x = 0;
          rect.y = 0;
          var point = series.points[i];
          if (series.isRadiusMapped) {
            if (series.points[i].sliceRadius.indexOf("%") !== -1) {
              point.radius = stringToNumber(series.points[i].sliceRadius, this.size / 2);
            } else {
              point.radius = parseInt(series.points[i].sliceRadius, 10);
            }
          } else {
            point.radius = radius;
          }
          var accessibilityText = point.x + ":" + point.y + ", " + series.name;
          if (!isNullOrUndefined(value)) {
            if (series.explode && (series.explodeIndex === point.index || !series.isExploded && series.explodeAll)) {
              offset.X = Math.cos(2 * Math.PI * (current + value / 2) / all);
              offset.Y = Math.sin(2 * Math.PI * (current + value / 2) / all);
              rect.x = 0.01 * point.radius * offset.X * stringToNumber(series.explodeOffset, 100);
              rect.y = 0.01 * point.radius * offset.Y * stringToNumber(series.explodeOffset, 100);
            }
            center = this.vector(rect.x + size.centerX, rect.y + size.centerY, 0);
            segment = this.createSegment(center, coefficient * current, coefficient * value, pieHeight, point.radius, i, value, insideRadius, pointIndex, series, accessibilityText);
            series.segments.push(segment);
          }
          this.addPieDataLabel(segIndex, yValues[i], arcStartAngle, arcStartAngle + arcEndAngle, point.radius, this.isChartRotated(chart) ? chart.depth + 5 : 0, center, series.points[i]);
          segIndex++;
          arcStartAngle += arcEndAngle;
          current += value;
        }
      }
      return series.segments;
    };
    CircularChart3DSeries2.prototype.addPieDataLabel = function(x, y, startAngle, endAngle, radius, startDepth, center, point) {
      var angle = (startAngle + endAngle) / 2;
      point.symbolLocation = {
        x: 0,
        y: 0,
        radius: 0,
        angle: 0
      };
      point.symbolLocation.x = x;
      point.symbolLocation.y = y;
      point.symbolLocation.radius = radius;
      point.symbolLocation.angle = angle;
      point.symbolLocation.center = center;
      point.startDepth = startDepth;
    };
    CircularChart3DSeries2.prototype.isChartRotated = function(chart) {
      var actualTiltView = Math.abs(chart.tilt % 360);
      var actualRotateView = Math.abs(chart.rotation % 360);
      if ((actualTiltView > 90 && actualTiltView < 270) !== (actualRotateView > 90 && actualRotateView < 270)) {
        return true;
      }
      return false;
    };
    CircularChart3DSeries2.prototype.createSegment = function(center, start, end, height, radius, index, yValue, insideRadius, pointIndex, series, accessibilityText) {
      return {
        startValue: start,
        endValue: end,
        depth: height,
        radius,
        index,
        yData: yValue,
        center,
        inSideRadius: insideRadius,
        actualEndValue: end,
        actualStartValue: start,
        pointIndex,
        series,
        visible: true,
        accessibilityText
      };
    };
    CircularChart3DSeries2.prototype.vector = function(vx, vy, vz) {
      return {
        x: vx,
        y: vy,
        z: vz
      };
    };
    CircularChart3DSeries2.prototype.getYValues = function(points) {
      var values = [];
      var length = points.length;
      for (var i = 0; i < length; i++) {
        values.push(points[i].y);
      }
      return values;
    };
    CircularChart3DSeries2.prototype.findMaxBounds = function(totalBound, bound) {
      totalBound.x = bound.x < totalBound.x ? bound.x : totalBound.x;
      totalBound.y = bound.y < totalBound.y ? bound.y : totalBound.y;
      totalBound.height = bound.y + bound.height > totalBound.height ? bound.y + bound.height : totalBound.height;
      totalBound.width = bound.x + bound.width > totalBound.width ? bound.x + bound.width : totalBound.width;
    };
    CircularChart3DSeries2.prototype.setEmptyPoint = function(point, index, data, chart) {
      if (!(isNullOrUndefined(point.y) || isNaN(point.y))) {
        return null;
      }
      point.color = this.emptyPointSettings.fill || point.color;
      var previous;
      var next;
      switch (this.emptyPointSettings.mode) {
        case "Zero":
          point.y = 0;
          point.visible = true;
          break;
        case "Average":
          previous = data[index - 1] ? data[index - 1][this.yName] || 0 : 0;
          next = data[index + 1] ? data[index + 1][this.yName] || 0 : 0;
          point.y = (Math.abs(previous) + Math.abs(next)) / 2;
          point.separatorY = chart.intl.formatNumber(point.y, {
            useGrouping: chart.useGroupingSeparator
          });
          this.sumOfPoints += point.y;
          point.visible = true;
          break;
        default:
          point.visible = false;
          break;
      }
    };
    __decorate32([Property("")], CircularChart3DSeries2.prototype, "dataSource", void 0);
    __decorate32([Property()], CircularChart3DSeries2.prototype, "query", void 0);
    __decorate32([Property("")], CircularChart3DSeries2.prototype, "xName", void 0);
    __decorate32([Property("")], CircularChart3DSeries2.prototype, "name", void 0);
    __decorate32([Property("")], CircularChart3DSeries2.prototype, "tooltipMappingName", void 0);
    __decorate32([Property("")], CircularChart3DSeries2.prototype, "yName", void 0);
    __decorate32([Property(true)], CircularChart3DSeries2.prototype, "visible", void 0);
    __decorate32([Complex(null, Animation2)], CircularChart3DSeries2.prototype, "animation", void 0);
    __decorate32([Property("SeriesType")], CircularChart3DSeries2.prototype, "legendShape", void 0);
    __decorate32([Property("")], CircularChart3DSeries2.prototype, "legendImageUrl", void 0);
    __decorate32([Property("")], CircularChart3DSeries2.prototype, "pointColorMapping", void 0);
    __decorate32([Complex({}, CircularChart3DDataLabelSettings)], CircularChart3DSeries2.prototype, "dataLabel", void 0);
    __decorate32([Property([])], CircularChart3DSeries2.prototype, "palettes", void 0);
    __decorate32([Property(null)], CircularChart3DSeries2.prototype, "radius", void 0);
    __decorate32([Property("0")], CircularChart3DSeries2.prototype, "innerRadius", void 0);
    __decorate32([Property(true)], CircularChart3DSeries2.prototype, "enableTooltip", void 0);
    __decorate32([Property(false)], CircularChart3DSeries2.prototype, "explode", void 0);
    __decorate32([Property("30%")], CircularChart3DSeries2.prototype, "explodeOffset", void 0);
    __decorate32([Property(false)], CircularChart3DSeries2.prototype, "explodeAll", void 0);
    __decorate32([Property(null)], CircularChart3DSeries2.prototype, "explodeIndex", void 0);
    __decorate32([Complex({
      mode: "Drop"
    }, CircularChart3DEmptyPointSettings)], CircularChart3DSeries2.prototype, "emptyPointSettings", void 0);
    __decorate32([Property(1)], CircularChart3DSeries2.prototype, "opacity", void 0);
    return CircularChart3DSeries2;
  }(ChildProperty)
);
var PieSeries3D = (
  /** @class */
  function(_super) {
    __extends112(PieSeries3D2, _super);
    function PieSeries3D2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PieSeries3D2.prototype.getModuleName = function() {
      return "PieSeries3D";
    };
    PieSeries3D2.prototype.destroy = function() {
    };
    return PieSeries3D2;
  }(CircularChart3DSeries)
);

// node_modules/@syncfusion/ej2-charts/src/circularchart3d/legend/legend.js
var __extends113 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate33 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CircularChart3DLegendSettings = (
  /** @class */
  function(_super) {
    __extends113(CircularChart3DLegendSettings2, _super);
    function CircularChart3DLegendSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate33([Property(true)], CircularChart3DLegendSettings2.prototype, "visible", void 0);
    __decorate33([Property(null)], CircularChart3DLegendSettings2.prototype, "height", void 0);
    __decorate33([Property(null)], CircularChart3DLegendSettings2.prototype, "width", void 0);
    __decorate33([Complex({
      x: 0,
      y: 0
    }, Location)], CircularChart3DLegendSettings2.prototype, "location", void 0);
    __decorate33([Property("Auto")], CircularChart3DLegendSettings2.prototype, "position", void 0);
    __decorate33([Property(8)], CircularChart3DLegendSettings2.prototype, "padding", void 0);
    __decorate33([Property(null)], CircularChart3DLegendSettings2.prototype, "itemPadding", void 0);
    __decorate33([Property("Center")], CircularChart3DLegendSettings2.prototype, "alignment", void 0);
    __decorate33([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, Font)], CircularChart3DLegendSettings2.prototype, "textStyle", void 0);
    __decorate33([Property(10)], CircularChart3DLegendSettings2.prototype, "shapeHeight", void 0);
    __decorate33([Property(10)], CircularChart3DLegendSettings2.prototype, "shapeWidth", void 0);
    __decorate33([Complex({}, Border)], CircularChart3DLegendSettings2.prototype, "border", void 0);
    __decorate33([Complex({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, Margin)], CircularChart3DLegendSettings2.prototype, "margin", void 0);
    __decorate33([Complex({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, ContainerPadding)], CircularChart3DLegendSettings2.prototype, "containerPadding", void 0);
    __decorate33([Property(8)], CircularChart3DLegendSettings2.prototype, "shapePadding", void 0);
    __decorate33([Property("transparent")], CircularChart3DLegendSettings2.prototype, "background", void 0);
    __decorate33([Property(1)], CircularChart3DLegendSettings2.prototype, "opacity", void 0);
    __decorate33([Property(true)], CircularChart3DLegendSettings2.prototype, "toggleVisibility", void 0);
    __decorate33([Property(false)], CircularChart3DLegendSettings2.prototype, "enableHighlight", void 0);
    __decorate33([Property(null)], CircularChart3DLegendSettings2.prototype, "description", void 0);
    __decorate33([Property(3)], CircularChart3DLegendSettings2.prototype, "tabIndex", void 0);
    __decorate33([Property(null)], CircularChart3DLegendSettings2.prototype, "title", void 0);
    __decorate33([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, Font)], CircularChart3DLegendSettings2.prototype, "titleStyle", void 0);
    __decorate33([Property("Top")], CircularChart3DLegendSettings2.prototype, "titlePosition", void 0);
    __decorate33([Property("Normal")], CircularChart3DLegendSettings2.prototype, "textWrap", void 0);
    __decorate33([Property("Ellipsis")], CircularChart3DLegendSettings2.prototype, "textOverflow", void 0);
    __decorate33([Property(100)], CircularChart3DLegendSettings2.prototype, "maximumTitleWidth", void 0);
    __decorate33([Property(null)], CircularChart3DLegendSettings2.prototype, "maximumLabelWidth", void 0);
    __decorate33([Property(true)], CircularChart3DLegendSettings2.prototype, "enablePages", void 0);
    __decorate33([Property(false)], CircularChart3DLegendSettings2.prototype, "isInversed", void 0);
    __decorate33([Property(false)], CircularChart3DLegendSettings2.prototype, "reverse", void 0);
    return CircularChart3DLegendSettings2;
  }(ChildProperty)
);
var CircularChartLegend3D = (
  /** @class */
  function(_super) {
    __extends113(CircularChartLegend3D2, _super);
    function CircularChartLegend3D2(chart) {
      var _this = _super.call(this, chart) || this;
      _this.library = _this;
      _this.titleRect = new Rect(0, chart.margin.top, 0, 0);
      _this.addEventListener();
      return _this;
    }
    CircularChartLegend3D2.prototype.addEventListener = function() {
      if (this.chart.isDestroyed) {
        return;
      }
      this.chart.on(Browser.touchMoveEvent, this.mouseMove, this);
      this.chart.on(Browser.touchEndEvent, this.mouseEnd, this);
      this.chart.on("click", this.click, this);
    };
    CircularChartLegend3D2.prototype.removeEventListener = function() {
      if (this.chart.isDestroyed) {
        return;
      }
      this.chart.off(Browser.touchMoveEvent, this.mouseMove);
      this.chart.off("click", this.click);
      this.chart.off(Browser.touchEndEvent, this.mouseEnd);
    };
    CircularChartLegend3D2.prototype.mouseMove = function(e) {
      if (this.chart.legendSettings.visible && !this.chart.isTouch) {
        this.move(e);
        if (this.chart.circularChartHighlight3DModule && (this.chart.highlightMode !== "None" || this.chart.legendSettings.enableHighlight)) {
          var legendItemsId = [this.legendID + "_text_", this.legendID + "_shape_marker_", this.legendID + "_shape_", this.legendID + "_g_"];
          var targetId = e.target.id;
          for (var _i = 0, legendItemsId_1 = legendItemsId; _i < legendItemsId_1.length; _i++) {
            var id = legendItemsId_1[_i];
            if (targetId.indexOf(id) > -1) {
              if (this.chart.circularChartSelection3DModule) {
                this.chart.circularChartSelection3DModule.legendSelection(this.chart, e.target, e.type);
              } else if (this.chart.circularChartHighlight3DModule) {
                this.chart.circularChartHighlight3DModule.legendSelection(this.chart, e.target, e.type);
              }
              break;
            }
          }
        }
      }
    };
    CircularChartLegend3D2.prototype.mouseEnd = function(e) {
      if (this.chart.legendSettings.visible && this.chart.isTouch) {
        this.move(e);
      }
    };
    CircularChartLegend3D2.prototype.getLegendOptions = function(chart, series) {
      this.legendCollections = [];
      this.isRtlEnable = chart.enableRtl;
      this.isReverse = !this.isRtlEnable && chart.legendSettings.reverse;
      for (var i = 0; i < 1; i++) {
        for (var _i = 0, _a = series[i].points; _i < _a.length; _i++) {
          var point = _a[_i];
          if (!isNullOrUndefined(point.x) && !isNullOrUndefined(point.y)) {
            this.legendCollections.push(new LegendOptions(point.x.toString(), point.color, series[i].legendShape, point.visible, "Pie", series[0].legendImageUrl, null, null, point.index, series[i].index));
          }
        }
        if (this.isReverse) {
          this.legendCollections.reverse();
        }
      }
    };
    CircularChartLegend3D2.prototype.getLegendBounds = function(availableSize, legendBounds, legend) {
      this.calculateLegendTitle(legend, legendBounds);
      this.isTitle = legend.title ? true : false;
      var extraWidth = 0;
      var extraHeight = 0;
      var legendOption;
      this.chartRowCount = 1;
      this.rowHeights = [];
      this.columnHeights = [];
      this.pageHeights = [];
      var padding = legend.padding;
      var titlePosition = legend.titlePosition;
      var titlePlusArrowSpace = 0;
      var arrowWidth = this.arrowWidth;
      var arrowHeight = legend.enablePages ? 0 : this.arrowHeight;
      if (!this.isVertical) {
        extraHeight = !legend.height ? availableSize.height / 100 * 5 : 0;
      } else {
        extraWidth = !legend.width ? availableSize.width / 100 * 5 : 0;
      }
      legendBounds.width += extraWidth;
      legendBounds.height += extraHeight;
      var shapePadding = legend.shapePadding;
      var maximumWidth = legend.maximumLabelWidth ? legend.maximumLabelWidth : 0;
      var shapeWidth = legend.shapeWidth;
      var rowWidth = 0;
      var columnCount = 0;
      var rowCount = 0;
      var columnWidth = [];
      var pageWidth = [];
      var pageRowWidth = 0;
      var previousRowCount = 0;
      var columnHeight = 0;
      var legendWidth = 0;
      var titleHeight = 0;
      this.maxItemHeight = Math.max(measureText("MeasureText", legend.textStyle, this.chart.themeStyle.legendLabelFont).height, legend.shapeHeight);
      var legendEventArgs;
      var render = false;
      for (var i = 0; i < this.legendCollections.length; i++) {
        legendOption = this.legendCollections[i];
        legendEventArgs = {
          fill: legendOption.fill,
          text: legendOption.text,
          shape: legendOption.shape,
          name: "legendRender",
          cancel: false
        };
        this.chart.trigger("legendRender", legendEventArgs);
        legendOption.render = !legendEventArgs.cancel;
        legendOption.text = legendEventArgs.text.indexOf("&") > -1 ? this.convertHtmlEntities(legendEventArgs.text) : legendEventArgs.text;
        legendOption.fill = legendEventArgs.fill;
        legendOption.shape = legendEventArgs.shape;
        legendOption.textSize = measureText(legendOption.text, legend.textStyle, this.chart.themeStyle.legendLabelFont);
        if (legendOption.render && legendOption.text !== "") {
          render = true;
          legendWidth = shapeWidth + shapePadding + (legend.maximumLabelWidth ? legend.maximumLabelWidth : legendOption.textSize.width) + (!this.isVertical ? i === 0 ? padding : this.itemPadding : padding);
          this.getLegendHeight(legendOption, legend, legendBounds, rowWidth, this.maxItemHeight, padding);
          if (this.isVertical) {
            columnHeight += legendOption.textSize.height + (i === 0 ? padding : this.itemPadding);
            if (columnHeight + this.itemPadding + arrowHeight / this.pageButtonSize > legendBounds.height) {
              rowWidth = rowWidth + maximumWidth;
              pageRowWidth = this.getPageWidth(pageWidth);
              this.totalPages = Math.max(rowCount, this.totalPages || 1);
              if (rowWidth - pageRowWidth + legendWidth > legendBounds.width) {
                pageWidth.push(rowWidth - pageRowWidth);
                rowCount = this.rowHeights.length;
                previousRowCount = rowCount;
              } else {
                rowCount = previousRowCount;
              }
              columnWidth.push(maximumWidth);
              maximumWidth = 0;
              columnHeight = legendOption.textSize.height + padding;
              columnCount++;
            }
            this.columnHeights[columnCount] = (this.columnHeights[columnCount] ? this.columnHeights[columnCount] : 0) + legendOption.textSize.height + (i === 0 ? padding : this.itemPadding);
            maximumWidth = Math.max(legendWidth, maximumWidth);
            this.rowHeights[rowCount] = Math.max(this.rowHeights[rowCount] ? this.rowHeights[rowCount] : 0, legendOption.textSize.height);
            rowCount++;
          } else {
            if (!legend.enablePages) {
              titlePlusArrowSpace = this.isTitle && titlePosition !== "Top" ? this.legendTitleSize.width + this.fivePixel : 0;
              titlePlusArrowSpace += arrowWidth;
            }
            rowWidth = rowWidth + legendWidth;
            if (legendBounds.width < padding + rowWidth + titlePlusArrowSpace) {
              maximumWidth = Math.max(maximumWidth, rowWidth + padding + titlePlusArrowSpace - legendWidth);
              if (rowCount === 0 && legendWidth !== rowWidth) {
                rowCount = 1;
              }
              rowWidth = legendWidth;
              rowCount++;
              columnCount = 0;
            }
            var len = rowCount ? rowCount - 1 : rowCount;
            this.rowHeights[len] = Math.max(this.rowHeights[len] ? this.rowHeights[len] : 0, legendOption.textSize.height);
            this.columnHeights[columnCount] = (this.columnHeights[columnCount] ? this.columnHeights[columnCount] : 0) + legendOption.textSize.height + padding;
            columnCount++;
          }
        }
      }
      titleHeight = titlePosition === "Top" ? this.legendTitleSize.height : 0;
      if (this.isVertical) {
        rowWidth = rowWidth + maximumWidth;
        this.isPaging = legendBounds.width < rowWidth + padding;
        columnHeight = Math.max.apply(null, this.columnHeights) + padding + arrowHeight + titleHeight;
        columnHeight = Math.max(columnHeight, (this.totalPages || 1) * (this.maxItemHeight + padding) + padding + arrowHeight);
        this.isPaging = this.isPaging && this.totalPages > 1;
        columnWidth.push(maximumWidth);
      } else {
        this.totalPages = rowCount;
        columnHeight = Math.max.apply(null, this.columnHeights) + padding + arrowHeight + titleHeight;
        this.isPaging = legendBounds.height < columnHeight;
        columnHeight = !legend.enablePages && this.isPaging ? this.maxItemHeight + padding + padding + titleHeight : columnHeight;
        columnHeight = Math.max(columnHeight, this.maxItemHeight + padding + padding + titleHeight);
        if (!this.isPaging) {
          rowWidth += this.isTitle && titlePosition !== "Top" ? this.fivePixel + this.legendTitleSize.width + this.fivePixel : 0;
        }
      }
      this.maxColumns = 0;
      var width = this.isVertical ? this.getMaxColumn(columnWidth, legendBounds.width, padding, rowWidth + padding) : Math.max(rowWidth + padding, maximumWidth);
      if (render) {
        this.setBounds(width, columnHeight, legend, legendBounds);
      } else {
        this.setBounds(0, 0, legend, legendBounds);
      }
    };
    CircularChartLegend3D2.prototype.getPageWidth = function(pageWidth) {
      var sum2 = 0;
      for (var i = 0; i < pageWidth.length; i++) {
        sum2 += pageWidth[i];
      }
      return sum2;
    };
    CircularChartLegend3D2.prototype.getLegendHeight = function(option, legend, bounds, rowWidth, legendHeight, padding) {
      var legendWidth = option.textSize.width;
      var textPadding = legend.shapePadding + padding * 2 + legend.shapeWidth;
      switch (legend.textWrap) {
        case "Wrap":
        case "AnyWhere":
          if (legendWidth > legend.maximumLabelWidth || legendWidth + rowWidth > bounds.width) {
            option.textCollection = textWrap(option.text, legend.maximumLabelWidth ? Math.min(legend.maximumLabelWidth, bounds.width - textPadding) : bounds.width - textPadding, legend.textStyle, this.chart.enableRtl, null, null, this.chart.themeStyle.legendLabelFont);
          } else {
            option.textCollection.push(option.text);
          }
          option.textSize.height = legendHeight * option.textCollection.length;
          break;
      }
    };
    CircularChartLegend3D2.prototype.convertHtmlEntities = function(legendText) {
      var text = legendText.replace("&amp;", "&").replace("&lt;", "<").replace("&gt;", ">").replace("&quot;", '"').replace("&nbsp;", " ").replace("&cent;", "").replace("&pound;", "").replace("&yen;", "").replace("&euro;", "").replace("&copy;", "").replace("&reg;", "");
      text = text.replace("&#38;", "&").replace("&#60;", "<").replace("&#62;", ">").replace("&#34;", '"').replace("&#160;", " ").replace("&#162;", "").replace("&#163;", "").replace("&#165;", "").replace("&#8364;", "").replace("&#169;", "").replace("&#174;", "");
      return text;
    };
    CircularChartLegend3D2.prototype.getMaxColumn = function(columns, width, padding, rowWidth) {
      var maxPageColumn = padding;
      this.maxColumnWidth = Math.max.apply(null, columns);
      for (var i = 0; i < columns.length; i++) {
        maxPageColumn += this.maxColumnWidth;
        this.maxColumns++;
        if (maxPageColumn + padding > width) {
          maxPageColumn -= this.maxColumnWidth;
          this.maxColumns--;
          break;
        }
      }
      this.isPaging = maxPageColumn < rowWidth && this.totalPages > 1;
      if (maxPageColumn === padding) {
        maxPageColumn = width;
      }
      this.maxColumns = Math.max(1, this.maxColumns);
      this.maxWidth = maxPageColumn;
      var columnWidth = this.maxColumnWidth + padding;
      var prevPage = 0;
      var columnCount = this.columnHeights.length;
      if (this.isPaging && this.isVertical) {
        for (var i = 1; i < columnCount; i++) {
          columnWidth += this.maxColumnWidth + padding;
          if (columnWidth > width) {
            this.pageHeights.push(prevPage !== i - 1 ? Math.max.apply(null, this.columnHeights.slice(prevPage, i - 1)) : this.columnHeights[prevPage]);
            columnWidth = this.maxColumnWidth + padding;
            prevPage = i;
          }
        }
        this.pageHeights.push(prevPage !== columnCount - 1 ? Math.max.apply(null, this.columnHeights.slice(prevPage, columnCount - 1)) : this.columnHeights[prevPage]);
        this.totalPages = this.pageHeights.length;
      }
      return maxPageColumn;
    };
    CircularChartLegend3D2.prototype.getAvailWidth = function(tx, width) {
      if (this.isVertical) {
        width = this.maxWidth;
      } else if (!this.isVertical && this.isPaging && !this.legend.enablePages) {
        return width - tx - this.fivePixel;
      }
      return width - (this.legend.padding * 2 + this.legend.shapeWidth + this.legend.shapePadding);
    };
    CircularChartLegend3D2.prototype.getRenderPoint = function(legendOption, start, textPadding, prevLegend, rect, count, firstLegend) {
      var padding = this.legend.padding;
      var previousLocation = prevLegend.location.y + this.maxItemHeight / 4 + (prevLegend.textCollection.length > 0 ? (prevLegend.textCollection.length - 1) * this.maxItemHeight : 0);
      if (this.isVertical) {
        if (count === firstLegend || previousLocation + legendOption.textSize.height + padding > rect.y + rect.height) {
          legendOption.location.x = prevLegend.location.x + (count === firstLegend ? 0 : !this.isRtlEnable ? this.maxColumnWidth : -this.maxColumnWidth);
          legendOption.location.y = start.y;
          var textStartLoc = this.legend.shapeWidth / 2 + padding;
          this.pageXCollections.push(legendOption.location.x + (!this.isRtlEnable ? -textStartLoc : textStartLoc));
        } else {
          legendOption.location.x = prevLegend.location.x;
          legendOption.location.y = prevLegend.location.y + prevLegend.textSize.height + this.itemPadding;
        }
      } else {
        var textWidth = textPadding + (this.legend.maximumLabelWidth ? this.legend.maximumLabelWidth : prevLegend.textSize.width);
        var previousBound = prevLegend.location.x + (!this.isRtlEnable ? textWidth : -textWidth);
        if (this.isWithinBounds(previousBound, (this.legend.maximumLabelWidth ? this.legend.maximumLabelWidth : legendOption.textSize.width) + textPadding - this.itemPadding, rect, this.legend.shapeWidth / 2)) {
          if (count !== firstLegend) {
            this.chartRowCount++;
          }
          legendOption.location.y = count === firstLegend ? prevLegend.location.y : prevLegend.location.y + this.rowHeights[this.chartRowCount - 2] + padding;
          legendOption.location.x = start.x;
        } else {
          legendOption.location.y = prevLegend.location.y;
          legendOption.location.x = count === firstLegend ? prevLegend.location.x : previousBound;
        }
      }
      var availablewidth = this.getAvailWidth(legendOption.location.x, this.legendBounds.width);
      availablewidth = this.legend.maximumLabelWidth ? Math.min(this.legend.maximumLabelWidth, availablewidth) : availablewidth;
      if (this.legend.textOverflow === "Ellipsis" && this.legend.textWrap === "Normal") {
        legendOption.text = textTrim(+availablewidth.toFixed(4), legendOption.text, this.legend.textStyle, this.chart.enableRtl, this.chart.themeStyle.legendLabelFont);
      }
    };
    CircularChartLegend3D2.prototype.isWithinBounds = function(previousBound, textWidth, legendBounds, shapeWidth) {
      if (!this.isRtlEnable) {
        return previousBound + textWidth > legendBounds.x + legendBounds.width + shapeWidth;
      } else {
        return previousBound - textWidth < legendBounds.x - shapeWidth;
      }
    };
    CircularChartLegend3D2.prototype.getSmartLegendLocation = function(labelBound, legendBound, margin) {
      var space;
      switch (this.position) {
        case "Left":
          space = (labelBound.x - legendBound.width - margin.left) / 2;
          legendBound.x = labelBound.x - legendBound.width < margin.left ? legendBound.x : labelBound.x - legendBound.width - space;
          break;
        case "Right":
          space = (this.chart.availableSize.width - margin.right - (labelBound.x + labelBound.width + legendBound.width)) / 2;
          legendBound.x = labelBound.x + labelBound.width + legendBound.width > this.chart.availableSize.width - margin.right ? legendBound.x : labelBound.x + labelBound.width + space;
          break;
        case "Top":
          this.getTitleRect(this.chart);
          space = (labelBound.y - legendBound.height - (this.titleRect.y + this.titleRect.height)) / 2;
          legendBound.y = labelBound.y - legendBound.height < margin.top ? legendBound.y : labelBound.y - legendBound.height - space;
          break;
        case "Bottom":
          space = (this.chart.availableSize.height - margin.bottom - (labelBound.y + labelBound.height + legendBound.height)) / 2;
          legendBound.y = labelBound.y + labelBound.height + legendBound.height > this.chart.availableSize.height - margin.bottom ? legendBound.y : labelBound.y + labelBound.height + space;
          break;
      }
    };
    CircularChartLegend3D2.prototype.getTitleRect = function(circular) {
      if (!circular.title) {
        return null;
      }
      var titleSize = measureText(circular.title, circular.titleStyle, this.chart.themeStyle.legendTitleFont);
      this.titleRect = new Rect(circular.availableSize.width / 2 - titleSize.width / 2, circular.margin.top, titleSize.width, titleSize.height);
    };
    CircularChartLegend3D2.prototype.legendByIndex = function(index, legendCollections) {
      for (var _i = 0, legendCollections_1 = legendCollections; _i < legendCollections_1.length; _i++) {
        var legend = legendCollections_1[_i];
        if (legend.pointIndex === index) {
          return legend;
        }
      }
      return null;
    };
    CircularChartLegend3D2.prototype.click = function(event2) {
      var targetId = event2.target.id.indexOf("_chart_legend_g_") > -1 ? event2.target.firstChild["id"] : event2.target.id;
      var chart = this.chart;
      var legendItemsId = [this.legendID + "_text_", this.legendID + "_shape_", this.legendID + "_shape_marker_"];
      this.chart.animateSeries = false;
      for (var _i = 0, legendItemsId_2 = legendItemsId; _i < legendItemsId_2.length; _i++) {
        var id = legendItemsId_2[_i];
        if (targetId.indexOf(id) > -1) {
          var pointIndex = parseInt(targetId.split(id)[1], 10);
          if (this.chart.legendSettings.toggleVisibility && !isNaN(pointIndex)) {
            var currentSeries = this.chart.visibleSeries[0];
            var point = currentSeries.points[pointIndex];
            var legendOption = this.legendByIndex(pointIndex, this.legendCollections);
            var legendClickArgs = {
              legendText: legendOption.text,
              legendShape: legendOption.shape,
              chart,
              series: currentSeries,
              point,
              name: legendClick,
              cancel: false
            };
            this.chart.trigger(legendClick, legendClickArgs);
            if (!legendClickArgs.cancel) {
              point.visible = !point.visible;
              legendOption.visible = point.visible;
              currentSeries.sumOfPoints += point.visible ? point.y : -point.y;
              chart.redraw = chart.enableAnimation;
              this.sliceVisibility(pointIndex, point.visible);
              chart.removeSeriesElements(chart);
              chart.removeSvg();
              var svgObject = document.getElementById(this.chart.element.id + "-svg-chart-3d");
              if (svgObject) {
                while (svgObject.childNodes.length > 0) {
                  svgObject.removeChild(svgObject.firstChild);
                }
              }
              this.chart.circular3DPolygon = [];
              this.chart.visibleSeries[0].segments = [];
              this.chart.animateSeries = false;
              this.chart.calculateBounds();
              this.chart.renderElements();
              if (chart.circularChartHighlight3DModule && (chart.highlightMode !== "None" || chart.legendSettings.enableHighlight)) {
                chart.circularChartHighlight3DModule.redrawSelection(chart);
              }
            }
          } else {
            if (this.chart.circularChartSelection3DModule && !isNaN(pointIndex)) {
              this.chart.circularChartSelection3DModule.legendSelection(this.chart, event2.target, event2.type);
            } else if (this.chart.circularChartHighlight3DModule && !isNaN(pointIndex)) {
              this.chart.circularChartHighlight3DModule.legendSelection(this.chart, event2.target, event2.type);
            }
          }
        }
      }
      if (targetId.indexOf(this.legendID + "_pageup") > -1) {
        this.changePage(event2, true);
      } else if (targetId.indexOf(this.legendID + "_pagedown") > -1) {
        this.changePage(event2, false);
      }
      chart.redraw = false;
    };
    CircularChartLegend3D2.prototype.sliceVisibility = function(index, isVisible) {
      var sliceId = this.chart.element.id + "_Series_0_Point_";
      if (this.chart.visibleSeries[0].dataLabel.visible) {
        sliceId = this.chart.element.id + "_datalabel_Series_0_";
        this.sliceAnimate(getElement2(sliceId + "g_" + index), isVisible);
      }
    };
    CircularChartLegend3D2.prototype.sliceAnimate = function(element, isVisible) {
      if (!element) {
        return null;
      }
      new Animation({}).animate(element, {
        duration: 300,
        delay: 0,
        name: isVisible ? "FadeIn" : "FadeOut",
        end: function(args) {
          args.element.style.visibility = isVisible ? "visible" : "hidden";
        }
      });
    };
    CircularChartLegend3D2.prototype.getModuleName = function() {
      return "CircularChartLegend3D";
    };
    CircularChartLegend3D2.prototype.destroy = function() {
      this.removeEventListener();
    };
    return CircularChartLegend3D2;
  }(BaseLegend)
);

// node_modules/@syncfusion/ej2-charts/src/circularchart3d/user-interaction/tooltip.js
var __extends114 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate34 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CircularChart3DPointData = (
  /** @class */
  /* @__PURE__ */ function() {
    function CircularChart3DPointData2(point, series, index) {
      if (index === void 0) {
        index = 0;
      }
      this.point = point;
      this.series = series;
      this.index = index;
    }
    return CircularChart3DPointData2;
  }()
);
var CircularChart3DTooltipSettings = (
  /** @class */
  function(_super) {
    __extends114(CircularChart3DTooltipSettings2, _super);
    function CircularChart3DTooltipSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate34([Property(false)], CircularChart3DTooltipSettings2.prototype, "enable", void 0);
    __decorate34([Property(true)], CircularChart3DTooltipSettings2.prototype, "enableMarker", void 0);
    __decorate34([Property(null)], CircularChart3DTooltipSettings2.prototype, "fill", void 0);
    __decorate34([Property(null)], CircularChart3DTooltipSettings2.prototype, "header", void 0);
    __decorate34([Property(null)], CircularChart3DTooltipSettings2.prototype, "opacity", void 0);
    __decorate34([Complex({
      fontFamily: null,
      size: "12px",
      fontStyle: "Normal",
      fontWeight: null,
      color: null
    }, Font)], CircularChart3DTooltipSettings2.prototype, "textStyle", void 0);
    __decorate34([Property(null)], CircularChart3DTooltipSettings2.prototype, "format", void 0);
    __decorate34([Property(null)], CircularChart3DTooltipSettings2.prototype, "template", void 0);
    __decorate34([Property(false)], CircularChart3DTooltipSettings2.prototype, "enableAnimation", void 0);
    __decorate34([Property(300)], CircularChart3DTooltipSettings2.prototype, "duration", void 0);
    __decorate34([Property(700)], CircularChart3DTooltipSettings2.prototype, "fadeOutDuration", void 0);
    __decorate34([Property(false)], CircularChart3DTooltipSettings2.prototype, "enableTextWrap", void 0);
    __decorate34([Complex({
      color: null,
      width: null
    }, Border)], CircularChart3DTooltipSettings2.prototype, "border", void 0);
    __decorate34([Complex({
      x: null,
      y: null
    }, Location)], CircularChart3DTooltipSettings2.prototype, "location", void 0);
    return CircularChart3DTooltipSettings2;
  }(ChildProperty)
);
var CircularChartTooltip3D = (
  /** @class */
  function(_super) {
    __extends114(CircularChartTooltip3D2, _super);
    function CircularChartTooltip3D2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.currentPoints = [];
      _this.previousPoints = [];
      _this.tooltipRendered = false;
      return _this;
    }
    CircularChartTooltip3D2.prototype.mouseLeaveHandler = function() {
      this.removeTooltip(this.control.tooltip.fadeOutDuration);
    };
    CircularChartTooltip3D2.prototype.mouseUpHandler = function(event2, chart) {
      this.control = chart;
      this.element = chart.element;
      var swipeThreshold = 10;
      var isWithinSwipeThreshold = Math.abs(chart.mouseX - chart.cachedX) < swipeThreshold && Math.abs(chart.mouseY - chart.cachedY) < swipeThreshold;
      if (this.control.tooltip.enable && !chart.rotateActivate && isWithinSwipeThreshold && withInBounds(this.control.mouseX, this.control.mouseY, this.control.initialClipRect) && this.control.isTouch) {
        this.tooltip(event2);
        this.removeTooltip(2e3);
        this.tooltipRendered = true;
      } else if (this.control.isTouch) {
        this.removeTooltip(0);
      }
    };
    CircularChartTooltip3D2.prototype.mouseMoveHandler = function(event2, chart) {
      this.control = chart;
      this.element = chart.element;
      if (!this.tooltipRendered) {
        if (this.control.tooltip.enable && !chart.rotateActivate && withInBounds(this.control.mouseX, this.control.mouseY, this.control.initialClipRect)) {
          this.tooltip(event2);
        } else {
          this.removeTooltip(0);
        }
      }
      this.tooltipRendered = false;
    };
    CircularChartTooltip3D2.prototype.tooltip = function(event2) {
      this.renderSeriesTooltip(this.control, this.getPieData(event2, this.control));
    };
    CircularChartTooltip3D2.prototype.getElement = function(id) {
      return document.getElementById(id);
    };
    CircularChartTooltip3D2.prototype.getTooltipElement = function(isTooltip) {
      this.header = this.control.tooltip.header === null ? "${series.name}" : this.control.tooltip.header;
      this.formattedText = [];
      var tooltipDiv = document.getElementById(this.control.element.id + "_tooltip");
      if (!isTooltip && !tooltipDiv) {
        return this.createElement();
      }
      return null;
    };
    CircularChartTooltip3D2.prototype.createElement = function() {
      var tooltipDiv = document.createElement("div");
      tooltipDiv.id = this.element.id + "_tooltip";
      tooltipDiv.className = "ejSVGTooltip";
      tooltipDiv.style.pointerEvents = "none";
      tooltipDiv.style.position = "absolute";
      tooltipDiv.style.zIndex = "1";
      return tooltipDiv;
    };
    CircularChartTooltip3D2.prototype.renderSeriesTooltip = function(chart, data) {
      var svgElement = this.getElement(this.element.id + "_tooltip_svg");
      var isTooltip = svgElement && parseInt(svgElement.getAttribute("opacity"), 10) > 0;
      var tooltipDiv = this.getTooltipElement(isTooltip);
      var isFirst = !isTooltip;
      this.template = chart.tooltip.template;
      this.currentPoints = [];
      if (data.point) {
        if (this.pushData(data, tooltipDiv)) {
          this.triggerTooltipRender(data, isFirst, this.getTooltipText(data, chart.tooltip), this.findHeader(data));
        }
      } else {
        if (!data.point && this.isRemove) {
          this.removeTooltip(this.control.tooltip.fadeOutDuration);
          this.isRemove = false;
        }
      }
    };
    CircularChartTooltip3D2.prototype.removeTooltip = function(duration) {
      var _this = this;
      var tooltipElement = this.getElement(this.element.id + "_tooltip");
      this.stopAnimation();
      if (tooltipElement && this.previousPoints.length > 0) {
        this.tooltipInterval = +setTimeout(function() {
          if (_this.svgTooltip) {
            _this.svgTooltip.fadeOut();
          }
        }, duration);
      }
    };
    CircularChartTooltip3D2.prototype.stopAnimation = function() {
      stopTimer(this.tooltipInterval);
    };
    CircularChartTooltip3D2.prototype.pushData = function(data, tooltipDiv) {
      if (data.series.enableTooltip) {
        this.currentPoints.push(data);
        this.stopAnimation();
        if (tooltipDiv && !document.getElementById(tooltipDiv.id)) {
          document.getElementById(this.element.id + "_Secondary_Element").appendChild(tooltipDiv);
        }
        return true;
      }
      return false;
    };
    CircularChartTooltip3D2.prototype.triggerTooltipRender = function(point, isFirst, textCollection, headerText) {
      var _this = this;
      var tooltip = this.control.tooltip;
      var argsData = {
        cancel: false,
        text: textCollection,
        point: point.point,
        textStyle: tooltip.textStyle,
        series: point.series,
        headerText,
        template: this.template,
        data: {
          pointX: point.point.x,
          pointY: point.point.y,
          seriesIndex: point.series.index,
          pointIndex: point.point.index,
          pointText: point.point.text,
          seriesName: point.series.name
        }
      };
      var padding = 10;
      var tooltipSuccess = function(argsData2) {
        if (!argsData2.cancel) {
          _this.formattedText = _this.formattedText.concat(argsData2.text);
          _this.text = _this.formattedText;
          _this.headerText = argsData2.headerText;
          var location_1 = {
            x: tooltip.location.x !== null ? tooltip.location.x : _this.control.mouseX,
            y: tooltip.location.y !== null ? tooltip.location.y : _this.control.mouseY - padding
          };
          _this.createTooltip(_this.control, isFirst, location_1, point.series.clipRect, point.point, 0, _this.control.initialClipRect, null, point.point, _this.template ? argsData2.template : "");
        } else {
          _this.removeHighlight();
          remove(_this.getElement(_this.element.id + "_tooltip"));
        }
        _this.isRemove = true;
      };
      tooltipSuccess.bind(this, point);
      this.control.trigger(tooltipRender, argsData, tooltipSuccess);
    };
    CircularChartTooltip3D2.prototype.getPieData = function(event2, chart) {
      var point;
      var series = chart.visibleSeries[0];
      var element = event2.target;
      if (element.id.indexOf("point") > -1 && element.id.indexOf("series") > -1) {
        var pointIndex = parseInt(element.id.split("point-")[1], 10);
        point = series.points[pointIndex];
      } else if (element.id.indexOf("-data-label-text") > -1 && series.dataLabel.position === "Inside") {
        var index = parseInt(element.id.split("data-label-text-")[1], 10);
        point = series.points[index];
      } else if (element.id.indexOf("data-label-series") > -1 && series.dataLabel.position === "Inside") {
        var index = parseInt(element.id.split("data-label-series-0-shape-")[1], 10);
        point = series.points[index];
      }
      if (point) {
        var pointData = {
          point,
          series,
          index: point.index
        };
        return pointData;
      }
      return new CircularChart3DPointData(null, null);
    };
    CircularChartTooltip3D2.prototype.getTooltipText = function(data, tooltip) {
      var series = data.series;
      var format = tooltip.format ? tooltip.format : this.control.theme.indexOf("Tailwind3") > -1 ? "${point.x} : ${point.y}" : "${point.x} : <b>${point.y}</b>";
      format = this.control.useGroupingSeparator ? format.replace("${point.y}", "${point.separatorY}") : format;
      return this.parseTemplate(data.point, series, format);
    };
    CircularChartTooltip3D2.prototype.findHeader = function(data) {
      if (this.header === "") {
        return "";
      }
      this.header = this.parseTemplate(data.point, data.series, this.header);
      if (this.header.replace(/<b>/g, "").replace(/<\/b>/g, "").trim() !== "") {
        return this.header;
      }
      return "";
    };
    CircularChartTooltip3D2.prototype.parseTemplate = function(point, series, format) {
      var value;
      var textValue;
      var regExp = RegExp;
      for (var _i = 0, _a = Object.keys(point); _i < _a.length; _i++) {
        var dataValue = _a[_i];
        value = new regExp("${point." + dataValue + "}", "gm");
        format = format.replace(value.source, point[dataValue]);
      }
      for (var _b = 0, _c = Object.keys(Object.getPrototypeOf(series)); _b < _c.length; _b++) {
        var dataValue = _c[_b];
        value = new regExp("${series." + dataValue + "}", "gm");
        textValue = series[dataValue];
        format = format.replace(value.source, textValue);
      }
      return format;
    };
    CircularChartTooltip3D2.prototype.createTooltip = function(chart, isFirst, location, clipLocation, point, offset, bounds, extraPoints, templatePoint, customTemplate) {
      if (extraPoints === void 0) {
        extraPoints = null;
      }
      if (templatePoint === void 0) {
        templatePoint = null;
      }
      var tooltipModule = chart.circularChartTooltip3DModule;
      if (!tooltipModule || location === null) {
        removeElement2(this.control.element.id + "_tooltip");
        return;
      }
      if (isFirst) {
        this.svgTooltip = new Tooltip({
          opacity: chart.tooltip.opacity ? chart.tooltip.opacity : this.control.theme === "Material3" || this.control.theme === "Material3Dark" || this.control.theme.indexOf("Bootstrap5") > -1 ? 1 : 0.75,
          header: this.headerText,
          content: this.text,
          fill: chart.tooltip.fill,
          border: chart.tooltip.border,
          enableAnimation: chart.tooltip.enableAnimation,
          location,
          shared: false,
          crosshair: false,
          shapes: !chart.tooltip.enableMarker ? [] : ["Circle"],
          clipBounds: clipLocation,
          areaBounds: bounds,
          palette: this.findPalette(),
          template: customTemplate || this.template,
          data: templatePoint,
          theme: chart.theme,
          offset,
          textStyle: chart.tooltip.textStyle,
          isNegative: false,
          inverted: false,
          arrowPadding: 0,
          availableSize: chart.availableSize,
          duration: this.control.tooltip.duration,
          isCanvas: false,
          isFixed: this.control.tooltip.location.x !== null || this.control.tooltip.location.y !== null,
          isTextWrap: chart.tooltip.enableTextWrap,
          blazorTemplate: {
            name: "Template",
            parent: this.control.tooltip
          },
          controlInstance: this.control,
          enableRTL: chart.enableRtl,
          controlName: "Chart",
          allowHighlight: false,
          tooltipRender: function() {
            tooltipModule.removeHighlight();
            tooltipModule.highlightPoints();
            tooltipModule.updatePreviousPoint(extraPoints);
          },
          animationComplete: function(args) {
            if (args.tooltip.fadeOuted) {
              tooltipModule.fadeOut();
            }
          }
        });
        this.svgTooltip.appendTo(this.getElement(this.element.id + "_tooltip"));
      } else {
        if (this.svgTooltip) {
          this.svgTooltip.location = location;
          this.svgTooltip.content = this.text;
          this.svgTooltip.header = this.headerText;
          this.svgTooltip.offset = offset;
          this.svgTooltip.palette = this.findPalette();
          this.svgTooltip.shapes = !chart.tooltip.enableMarker ? [] : ["Circle"];
          this.svgTooltip.data = templatePoint;
          this.svgTooltip.template = this.template;
          this.svgTooltip.controlName = "Chart";
          this.svgTooltip.crosshair = false;
          this.svgTooltip.textStyle = chart.tooltip.textStyle;
          this.svgTooltip.isNegative = false;
          this.svgTooltip.clipBounds = clipLocation;
          this.svgTooltip.arrowPadding = 0;
          this.svgTooltip.allowHighlight = false;
          this.svgTooltip.dataBind();
        }
      }
      if (this.control.isReact) {
        this.control.renderReactTemplates();
      }
    };
    CircularChartTooltip3D2.prototype.highlightPoints = function() {
      for (var _i = 0, _a = this.currentPoints; _i < _a.length; _i++) {
        var item = _a[_i];
        if (item.series.isRectSeries && item.series.category === "Series") {
          this.highlightPoint(item.series, item.point.index, true);
        }
      }
    };
    CircularChartTooltip3D2.prototype.removeHighlight = function() {
      var item;
      for (var i = 0, len = this.previousPoints.length; i < len; i++) {
        item = this.previousPoints[i];
        if (item.series.isRectSeries) {
          if (item.series.visible) {
            this.highlightPoint(item.series, item.point.index, false);
          }
          continue;
        }
      }
    };
    CircularChartTooltip3D2.prototype.highlightPoint = function(series, pointIndex, highlight) {
      var _this = this;
      if (this.control.circularChartHighlight3DModule && this.control.highlightMode === "None" || !this.control.circularChartHighlight3DModule) {
        var elements = document.querySelectorAll('[id*="region-series-0-point-' + pointIndex + '"]');
        var pointElements_1 = [];
        elements.forEach(function(pointElement) {
          var elementIndex = parseInt(pointElement.id.split("point-")[1], 10);
          if (elementIndex === pointIndex) {
            pointElements_1.push(pointElement);
          }
        });
        var datalabelElement = document.getElementById(this.control.element.id + "-svg-data-label-text-" + pointIndex);
        var connectorElement = document.getElementById(this.control.element.id + "-datalabel-series-0-connector-" + pointIndex);
        var shapeElement = document.getElementById(this.control.element.id + "-svg-data-label-series-0-shape-" + pointIndex);
        if (datalabelElement) {
          pointElements_1.push(datalabelElement);
        }
        if (connectorElement) {
          pointElements_1.push(connectorElement);
        }
        if (shapeElement) {
          pointElements_1.push(shapeElement);
        }
        var seriesElements = document.getElementById(this.element.id + "-svg-chart-3d").children;
        if (seriesElements) {
          for (var _i = 0, seriesElements_1 = seriesElements; _i < seriesElements_1.length; _i++) {
            var seriesElement = seriesElements_1[_i];
            if (seriesElement.parentElement.id === this.control.groupElement.id) {
              var selection = seriesElement.hasAttribute("class") ? seriesElement.getAttribute("class").indexOf("_selection_") === -1 : true;
              seriesElement.setAttribute("opacity", (highlight && this.control.highlightColor !== "transparent" && selection ? 0.2 : series.opacity).toString());
            }
          }
        }
        if (pointElements_1) {
          pointElements_1.forEach(function(element) {
            if (element.parentElement.id === _this.control.groupElement.id) {
              element.setAttribute("opacity", series.opacity.toString());
            }
          });
        }
      }
    };
    CircularChartTooltip3D2.prototype.fadeOut = function() {
      var svgElement = this.getElement(this.element.id + "_tooltip_svg");
      var isTooltip = svgElement && parseInt(svgElement.getAttribute("opacity"), 10) > 0;
      if (!isTooltip) {
        this.currentPoints = [];
        this.removeHighlight();
        this.previousPoints = [];
        this.svgTooltip = null;
        this.control.trigger("animationComplete", {});
      }
    };
    CircularChartTooltip3D2.prototype.updatePreviousPoint = function(extraPoints) {
      if (extraPoints) {
        this.currentPoints = this.currentPoints.concat(extraPoints);
      }
      this.previousPoints = extend([], this.currentPoints, null, true);
    };
    CircularChartTooltip3D2.prototype.findPalette = function() {
      var colors = [];
      for (var _i = 0, _a = this.currentPoints; _i < _a.length; _i++) {
        var data = _a[_i];
        colors.push(data.point.color);
      }
      return colors;
    };
    CircularChartTooltip3D2.prototype.getModuleName = function() {
      return "CircularChartTooltip3D";
    };
    CircularChartTooltip3D2.prototype.destroy = function() {
    };
    return CircularChartTooltip3D2;
  }(ChildProperty)
);

// node_modules/@syncfusion/ej2-charts/src/circularchart3d/renderer/3d-renderer.js
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
var CircularChart3DRender = (
  /** @class */
  /* @__PURE__ */ function() {
    function CircularChart3DRender2() {
      this.transform = null;
    }
    return CircularChart3DRender2;
  }()
);
var circular3DRender = new CircularChart3DRender();
var CircularChart3DVectorModule = (
  /** @class */
  function() {
    function CircularChart3DVectorModule2(pointX, vy, vz) {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.epsilon = 1e-5;
      this.x = pointX;
      this.y = vy || 0;
      this.z = vz || 0;
    }
    CircularChart3DVectorModule2.prototype.isValid = function(point) {
      return !isNaN(point.x) && !isNaN(point.y) && !isNaN(point.z);
    };
    CircularChart3DVectorModule2.prototype.vector3D = function(vx, vy, vz) {
      this.x = vx;
      this.y = vy;
      this.z = vz;
      return {
        x: this.x,
        y: this.y,
        z: this.z
      };
    };
    CircularChart3DVectorModule2.prototype.vector3DMinus = function(v1, v2) {
      return this.vector3D(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);
    };
    CircularChart3DVectorModule2.prototype.vector3DPlus = function(v1, v2) {
      return this.vector3D(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);
    };
    CircularChart3DVectorModule2.prototype.vector3DMultiply = function(v1, v2) {
      var x = v1.y * v2.z - v2.y * v1.z;
      var y = v1.z * v2.x - v2.z * v1.x;
      var z = v1.x * v2.y - v2.x * v1.y;
      return this.vector3D(x, y, z);
    };
    CircularChart3DVectorModule2.prototype.vector3DAdd = function(v1, v2) {
      return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
    };
    CircularChart3DVectorModule2.prototype.vector3DStarMultiply = function(v1, value) {
      var x = v1.x * value;
      var y = v1.y * value;
      var z = v1.z * value;
      return this.vector3D(x, y, z);
    };
    CircularChart3DVectorModule2.prototype.getLength = function(vector3) {
      var sqt = this.vector3DAdd(vector3, vector3);
      return Math.sqrt(sqt);
    };
    CircularChart3DVectorModule2.prototype.getNormal = function(v1, v2, v3) {
      var vector4 = this.vector3DMinus(v1, v2);
      var vector5 = this.vector3DMinus(v3, v2);
      var n = this.vector3DMultiply(vector4, vector5);
      var length = this.getLength(n);
      if (length < this.epsilon) {
        return this.vector3D(0, 0, 0);
      }
      return this.vector3D(n.x / length, n.y / length, n.z / length);
    };
    return CircularChart3DVectorModule2;
  }()
);
var CircularChart3DMatrix = (
  /** @class */
  function() {
    function CircularChart3DMatrix2() {
      this.matrixSize = 4;
    }
    CircularChart3DMatrix2.prototype.matrix3D = function(size) {
      var matrixData = [];
      for (var i = 0; i < size; i++) {
        matrixData[i] = this.createArray(size);
      }
      return matrixData;
    };
    CircularChart3DMatrix2.prototype.isAffine = function(matrixData) {
      return matrixData[0][3] === 0 && matrixData[1][3] === 0 && matrixData[2][3] === 0 && matrixData[3][3] === 1;
    };
    CircularChart3DMatrix2.prototype.createArray = function(initialSize) {
      var matrixData = [];
      for (var index = 0; index < initialSize; ++index) {
        matrixData[index] = 0;
      }
      return matrixData;
    };
    CircularChart3DMatrix2.prototype.getIdentity = function() {
      var matrixData = this.matrix3D(this.matrixSize);
      for (var i = 0; i < this.matrixSize; i++) {
        matrixData[i][i] = 1;
      }
      return matrixData;
    };
    CircularChart3DMatrix2.prototype.getInterval = function(matrix) {
      var matrixData = this.getIdentity();
      for (var i = 0; i < this.matrixSize; i++) {
        for (var j = 0; j < this.matrixSize; j++) {
          matrixData[i][j] = this.getMinor(matrix, i, j);
        }
      }
      matrixData = this.transposed(matrixData);
      matrixData = this.getMatrixMultiple(1 / this.getDeterminant(matrix), matrixData);
      return matrixData;
    };
    CircularChart3DMatrix2.prototype.getMatrixMultiple = function(factor, matrix) {
      for (var i = 0; i < matrix.length; i++) {
        for (var j = 0; j < matrix[i].length; j++) {
          matrix[i][j] = matrix[i][j] * factor;
        }
      }
      return matrix;
    };
    CircularChart3DMatrix2.prototype.getMatrixVectorMultiple = function(matrix, point) {
      var x = matrix[0][0] * point.x + matrix[1][0] * point.y + matrix[2][0] * point.z + matrix[3][0];
      var y = matrix[0][1] * point.x + matrix[1][1] * point.y + matrix[2][1] * point.z + matrix[3][1];
      var z = matrix[0][2] * point.x + matrix[1][2] * point.y + matrix[2][2] * point.z + matrix[3][2];
      if (!this.isAffine(matrix)) {
        var c = 1 / (matrix[0][3] * point.x + matrix[1][3] * point.y + matrix[2][3] * point.z + matrix[3][3]);
        x *= c;
        y *= c;
        z *= c;
      }
      return {
        x,
        y,
        z
      };
    };
    CircularChart3DMatrix2.prototype.getMatrixMultiplication = function(matrix1, matrix2) {
      var result = this.getIdentity();
      for (var i = 0; i < this.matrixSize; i++) {
        for (var j = 0; j < this.matrixSize; j++) {
          var value = 0;
          for (var k = 0; k < this.matrixSize; k++) {
            value += matrix1[k][j] * matrix2[i][k];
          }
          result[i][j] = value;
        }
      }
      return result;
    };
    CircularChart3DMatrix2.prototype.getMinor = function(matrix, columnIndex, rowIndex) {
      return ((columnIndex + rowIndex) % 2 === 0 ? 1 : -1) * this.getDeterminant(this.getMatrix(matrix, columnIndex, rowIndex));
    };
    CircularChart3DMatrix2.prototype.getMatrix = function(matrix, columnIndex, rowIndex) {
      var count = matrix.length - 1;
      var subMatrix = this.createArray(count);
      for (var i = 0; i < count; i++) {
        var matrixColumn = i >= columnIndex ? i + 1 : i;
        subMatrix[i] = this.createArray(count);
        for (var j = 0; j < count; j++) {
          var matrixRow = j >= rowIndex ? j + 1 : j;
          subMatrix[i][j] = matrix[matrixColumn][matrixRow];
        }
      }
      return subMatrix;
    };
    CircularChart3DMatrix2.prototype.getDeterminant = function(matrix) {
      var count = matrix.length;
      var determinant = 0;
      if (count < 2) {
        determinant = matrix[0][0];
      } else {
        var k = 1;
        for (var i = 0; i < count; i++) {
          var submatrix = this.getMatrix(matrix, i, 0);
          determinant += k * matrix[i][0] * this.getDeterminant(submatrix);
          k = k > 0 ? -1 : 1;
        }
      }
      return determinant;
    };
    CircularChart3DMatrix2.prototype.transform = function(x, y, z) {
      var transformedMatrix = this.getIdentity();
      transformedMatrix[3][0] = x;
      transformedMatrix[3][1] = y;
      transformedMatrix[3][2] = z;
      return transformedMatrix;
    };
    CircularChart3DMatrix2.prototype.turn = function(angle) {
      var rotatedMatrix = this.getIdentity();
      rotatedMatrix[0][0] = Math.cos(angle);
      rotatedMatrix[2][0] = -Math.sin(angle);
      rotatedMatrix[0][2] = Math.sin(angle);
      rotatedMatrix[2][2] = Math.cos(angle);
      return rotatedMatrix;
    };
    CircularChart3DMatrix2.prototype.tilt = function(angle) {
      var rotatedMatrix = this.getIdentity();
      rotatedMatrix[1][1] = Math.cos(angle);
      rotatedMatrix[2][1] = Math.sin(angle);
      rotatedMatrix[1][2] = -Math.sin(angle);
      rotatedMatrix[2][2] = Math.cos(angle);
      return rotatedMatrix;
    };
    CircularChart3DMatrix2.prototype.transposed = function(matrix3D) {
      var transposedMatrix = this.getIdentity();
      for (var i = 0; i < this.matrixSize; i++) {
        for (var j = 0; j < this.matrixSize; j++) {
          transposedMatrix[i][j] = matrix3D[j][i];
        }
      }
      return transposedMatrix;
    };
    return CircularChart3DMatrix2;
  }()
);
var CircularChart3DTransform = (
  /** @class */
  function() {
    function CircularChart3DTransform2() {
      this.toRadial = Math.PI / 180;
      this.vector = new CircularChart3DVectorModule(0, 0, 0);
      this.matrixObj = new CircularChart3DMatrix();
    }
    CircularChart3DTransform2.prototype.transform3D = function(size) {
      return {
        viewingArea: size,
        rotation: 0,
        tilt: 0,
        depth: 0,
        perspectiveAngle: 0,
        needUpdate: true,
        centeredMatrix: this.matrixObj.getIdentity(),
        perspective: this.matrixObj.getIdentity(),
        resultMatrix: this.matrixObj.getIdentity(),
        viewMatrix: this.matrixObj.getIdentity()
      };
    };
    CircularChart3DTransform2.prototype.transform = function(transform) {
      this.setCenter(this.vector.vector3D(transform.viewingArea.width / 2, transform.viewingArea.height / 2, transform.depth / 2), transform);
      this.setViewMatrix(this.matrixObj.transform(0, 0, transform.depth), transform);
      this.setViewMatrix(this.matrixObj.getMatrixMultiplication(transform.viewMatrix, this.matrixObj.turn(-this.toRadial * transform.rotation)), transform);
      this.setViewMatrix(this.matrixObj.getMatrixMultiplication(transform.viewMatrix, this.matrixObj.tilt(-this.toRadial * transform.tilt)), transform);
      this.updatePerspective(transform.perspectiveAngle, transform);
      transform.needUpdate = true;
    };
    CircularChart3DTransform2.prototype.updatePerspective = function(angle, transform) {
      var width = (transform.viewingArea.width + transform.viewingArea.height) * Math.tan(this.degreeToRadianConverter((180 - Math.abs(angle % 181)) / 2)) + transform.depth * 2 / 2;
      transform.perspective[0][0] = width;
      transform.perspective[1][1] = width;
      transform.perspective[2][3] = 1;
      transform.perspective[3][3] = width;
    };
    CircularChart3DTransform2.prototype.degreeToRadianConverter = function(angle) {
      return angle * Math.PI / 180;
    };
    CircularChart3DTransform2.prototype.toScreen = function(vector3D, transform, chartObj) {
      if (!chartObj) {
        transform.chartObj = this.matrixObj;
        vector3D = this.matrixObj.getMatrixVectorMultiple(this.result(transform), vector3D);
      } else {
        this.matrixObj = chartObj;
        vector3D = chartObj.getMatrixVectorMultiple(this.result(transform, chartObj), vector3D);
      }
      return {
        x: vector3D.x,
        y: vector3D.y
      };
    };
    CircularChart3DTransform2.prototype.setViewMatrix = function(matrix, transform) {
      if (transform.viewMatrix === matrix) {
        return;
      }
      transform.viewMatrix = matrix;
      transform.needUpdate = true;
    };
    CircularChart3DTransform2.prototype.result = function(transform, matrixobj) {
      var chartObj = transform.chartObj ? transform.chartObj : this.matrixObj;
      if (!chartObj) {
        chartObj = matrixobj;
      }
      if (!transform.needUpdate) {
        return transform.resultMatrix;
      }
      var matrixObj3 = this.matrixObj;
      transform.resultMatrix = chartObj.getMatrixMultiplication(matrixObj3.getInterval(transform.centeredMatrix), transform.perspective);
      transform.resultMatrix = chartObj.getMatrixMultiplication(transform.resultMatrix, transform.viewMatrix);
      transform.resultMatrix = chartObj.getMatrixMultiplication(transform.resultMatrix, transform.centeredMatrix);
      transform.needUpdate = false;
      return transform.resultMatrix;
    };
    CircularChart3DTransform2.prototype.setCenter = function(center, transform) {
      transform.centeredMatrix = this.matrixObj.transform(-center.x, -center.y, -center.z);
      transform.needUpdate = true;
    };
    return CircularChart3DTransform2;
  }()
);
var CircularChart3DGraphics = (
  /** @class */
  function() {
    function CircularChart3DGraphics2() {
      this.vector = new CircularChart3DVectorModule(0, 0, 0);
    }
    CircularChart3DGraphics2.prototype.prepareView = function(perspectiveAngle, depth, rotation, tilt, size, chart) {
      if (arguments.length === 0) {
        bspTreeObj2.build(null, chart);
      } else {
        if (circular3DRender.transform == null) {
          circular3DRender.transform = chart.transform3D.transform3D(size);
        } else {
          circular3DRender.transform.viewingArea = size;
        }
        if (!circular3DRender.tree) {
          circular3DRender.tree = [];
        }
        circular3DRender.transform.rotation = rotation;
        circular3DRender.transform.tilt = tilt;
        circular3DRender.transform.depth = depth;
        circular3DRender.transform.perspectiveAngle = perspectiveAngle;
        chart.transform3D.transform(circular3DRender.transform);
        circular3DRender.tree[chart.groupElement.id] = bspTreeObj2.build(null, chart);
      }
    };
    CircularChart3DGraphics2.prototype.view = function(panel, chart, rotation, tilt, size, perspectiveAngle, depth) {
      var MaxValue = 32767;
      if (arguments.length === 2) {
        if (panel == null) {
          return;
        }
        var eyeVector = this.vector.vector3D(0, 0, MaxValue);
        this.drawNode3D(circular3DRender.tree[chart.groupElement.id], eyeVector, panel, chart);
      } else {
        if (panel == null) {
          return;
        }
        if (circular3DRender.transform == null) {
          circular3DRender.transform = chart.transform3D.transform3D(size);
        } else {
          circular3DRender.transform.viewingArea = size;
        }
        circular3DRender.transform.rotation = rotation;
        circular3DRender.transform.tilt = tilt;
        circular3DRender.transform.depth = depth;
        circular3DRender.transform.perspectiveAngle = perspectiveAngle;
        chart.transform3D.transform(circular3DRender.transform);
        var eye = this.vector.vector3D(0, 0, MaxValue);
        this.drawNode3D(circular3DRender.tree[chart.groupElement.id], eye, panel, chart);
      }
    };
    CircularChart3DGraphics2.prototype.draw3DElement = function(bspElement, chart) {
      if (bspElement.plane.element) {
        if (bspElement.plane.element.tag === "text" || bspElement.plane.element.tag === "dataLabel") {
          polygonObj2.drawText(bspElement.plane, chart);
        } else if (bspElement.plane.element.tag === "polyline") {
          polygonObj2.drawPolyLine(bspElement.plane, chart);
        } else if (bspElement.plane.element.tag === "template") {
          polygonObj2.drawTemplate(bspElement.plane, chart);
        }
      } else {
        polygonObj2.draw(bspElement.plane, chart);
      }
    };
    CircularChart3DGraphics2.prototype.drawNode3D = function(bspElement, eyeVector, panel, chart) {
      if (bspElement === null || circular3DRender.transform == null) {
        return;
      }
      var isVector = true;
      while (isVector) {
        var r = vector2.vector3DAdd(polygonObj2.getNormal(chart.transform3D.result(circular3DRender.transform), bspElement.plane.vectorPoints), eyeVector);
        if (r > bspElement.plane.d) {
          if (bspElement.front != null) {
            this.drawNode3D(bspElement.front, eyeVector, panel, chart);
          }
          this.draw3DElement(bspElement, chart);
          if (bspElement.back != null) {
            bspElement = bspElement.back;
            continue;
          }
        } else {
          if (bspElement.back != null) {
            this.drawNode3D(bspElement.back, eyeVector, panel, chart);
          }
          this.draw3DElement(bspElement, chart);
          if (bspElement.front != null) {
            bspElement = bspElement.front;
            continue;
          }
        }
        break;
      }
      return null;
    };
    return CircularChart3DGraphics2;
  }()
);
var CircularChart3DBinaryTreeBuilder = (
  /** @class */
  function() {
    function CircularChart3DBinaryTreeBuilder2(chart) {
      this.epsilon = 5e-4;
      this.chart = chart;
    }
    CircularChart3DBinaryTreeBuilder2.prototype.getNext = function(index, count) {
      if (index >= count) {
        return index - count;
      }
      if (index < 0) {
        return index + count;
      }
      return index;
    };
    CircularChart3DBinaryTreeBuilder2.prototype.vector3DIndexClassification = function(point, index, result) {
      return {
        index,
        result,
        vector: point,
        isCuttingBackPoint: false,
        cuttingBackPairIndex: null,
        alreadyCutBack: false,
        isCuttingFrontPoint: false,
        cuttingFrontPairIndex: null,
        alreadyCutFront: false
      };
    };
    CircularChart3DBinaryTreeBuilder2.prototype.classifyPoint = function(point, polygon) {
      var result = "OnPlane";
      var signedDistance = -polygon.d - vector2.vector3DAdd(point, polygon.normal);
      if (signedDistance > this.epsilon) {
        result = "OnBack";
      } else if (signedDistance < -this.epsilon) {
        result = "OnFront";
      }
      return result;
    };
    CircularChart3DBinaryTreeBuilder2.prototype.classifyPolygon = function(refPolygon, classPolygon) {
      var result = "Unknown";
      var points = classPolygon.points;
      if (points == null) {
        return result;
      }
      var onBack = 0;
      var onFront = 0;
      var onPlane = 0;
      var normal = refPolygon.normal;
      var polygonValue = refPolygon.d;
      for (var i = 0, len = points.length; i < len; i++) {
        var value = -polygonValue - vector2.vector3DAdd(points[i], normal);
        if (value > this.epsilon) {
          onBack++;
        } else if (value < -this.epsilon) {
          onFront++;
        } else {
          onPlane++;
        }
        if (onBack > 0 && onFront > 0) {
          break;
        }
      }
      if (onPlane === points.length) {
        result = "OnPlane";
      } else if (onFront + onPlane === points.length) {
        result = "ToRight";
      } else if (onBack + onPlane === points.length) {
        result = "ToLeft";
      } else {
        result = "Unknown";
      }
      return result;
    };
    CircularChart3DBinaryTreeBuilder2.prototype.splitPolygon = function(splitPolygon, refPolygon) {
      var backPoint = [];
      var frontPoint = [];
      if (splitPolygon.points != null) {
        var polyPoints = [];
        var backPartPoints = [];
        var frontPartPoints = [];
        var outputs = void 0;
        var inputs = void 0;
        var count = splitPolygon.points.length;
        for (var i = 0; i < count; i++) {
          var pointB = splitPolygon.points[i];
          var pointC = splitPolygon.points[this.getNext(i + 1, count)];
          var sideB = this.classifyPoint(pointB, refPolygon);
          var sideC = this.classifyPoint(pointC, refPolygon);
          var attributeB = this.vector3DIndexClassification(pointB, polyPoints.length, sideB);
          polyPoints.push(attributeB);
          if (sideB !== sideC && sideB !== "OnPlane" && sideC !== "OnPlane") {
            var vectorValue = vector2.vector3DMinus(pointB, pointC);
            var direction = vector2.vector3DMinus(vector2.vector3DStarMultiply(refPolygon.normal, -refPolygon.d), pointC);
            var signedDistance = vector2.vector3DAdd(direction, refPolygon.normal);
            var intersectionParameter = signedDistance / vector2.vector3DAdd(refPolygon.normal, vectorValue);
            var intersectionPoint = vector2.vector3DPlus(pointC, vector2.vector3DStarMultiply(vectorValue, intersectionParameter));
            var attributeIntersection = this.vector3DIndexClassification(intersectionPoint, polyPoints.length, "OnPlane");
            polyPoints.push(attributeIntersection);
            backPartPoints.push(attributeIntersection);
            frontPartPoints.push(attributeIntersection);
          }
        }
        if (frontPartPoints.length !== 0 || backPartPoints.length !== 0) {
          for (var i = 0; i < backPartPoints.length - 1; i += 2) {
            var backAttribute1 = backPartPoints[i];
            var backAttribute2 = backPartPoints[i + 1];
            backAttribute1.cuttingBackPoint = true;
            backAttribute2.cuttingBackPoint = true;
            backAttribute1.alterCuttingBackPairIndex = backAttribute2.index;
            backAttribute2.alterCuttingBackPairIndex = backAttribute1.index;
          }
          for (var i = 0; i < frontPartPoints.length - 1; i += 2) {
            var frontAttribute1 = frontPartPoints[i];
            var frontAttribute2 = frontPartPoints[i + 1];
            frontAttribute1.cuttingFrontPoint = true;
            frontAttribute2.cuttingFrontPoint = true;
            frontAttribute1.alterCuttingFrontPairIndex = frontAttribute2.index;
            frontAttribute2.alterCuttingFrontPairIndex = frontAttribute1.index;
          }
          for (var i = 0; i < backPartPoints.length - 1; i++) {
            var backAttribute1 = backPartPoints[i];
            if (backAttribute1.alreadyCutBack) {
              continue;
            }
            outputs = this.cutOutBackPolygon(polyPoints, backAttribute1);
            if (outputs.length > 2) {
              var polygon1 = polygonObj2.polygon3D(outputs, splitPolygon);
              backPoint.push(__assign2({}, polygon1));
            }
          }
          for (var i = 0; i < frontPartPoints.length - 1; i++) {
            var backAttribute2 = frontPartPoints[i];
            if (backAttribute2.alreadyCutFront) {
              continue;
            }
            inputs = this.cutOutFrontPolygon(polyPoints, backAttribute2);
            if (inputs.length > 2) {
              var polygon2 = polygonObj2.polygon3D(inputs, splitPolygon);
              frontPoint.push(__assign2({}, polygon2));
            }
          }
        }
      } else {
        backPoint.push(splitPolygon);
        frontPoint.push(splitPolygon);
      }
      return {
        backPolygon: backPoint,
        frontPolygon: frontPoint
      };
    };
    CircularChart3DBinaryTreeBuilder2.prototype.cutOutFrontPolygon = function(polyPoints, initialVertex) {
      var points = [];
      var currentVertex = initialVertex;
      var isVector = true;
      while (isVector) {
        currentVertex.alreadyCutFront = true;
        points.push(currentVertex.vector);
        var currentVertexPair = polyPoints[currentVertex.alterCuttingFrontPairIndex];
        if (currentVertex.cuttingFrontPoint) {
          if (!currentVertexPair.alreadyCutFront) {
            currentVertex = currentVertexPair;
          } else {
            var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];
            var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];
            if (previousVertexOnBack.result === "OnFront" && !previousVertexOnBack.alreadyCutFront) {
              currentVertex = previousVertexOnBack;
            } else if (nextVertexOnBack.result === "OnFront" && !nextVertexOnBack.alreadyCutFront) {
              currentVertex = nextVertexOnBack;
            } else {
              return points;
            }
          }
        } else {
          var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];
          var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];
          if (previousVertexOnBack.result !== "OnBack" && !previousVertexOnBack.alreadyCutFront) {
            currentVertex = previousVertexOnBack;
          } else if (nextVertexOnBack.result !== "OnBack" && !nextVertexOnBack.alreadyCutFront) {
            currentVertex = nextVertexOnBack;
          } else {
            return points;
          }
        }
      }
      return null;
    };
    CircularChart3DBinaryTreeBuilder2.prototype.cutOutBackPolygon = function(polyPoints, initialVertex) {
      var points = [];
      var currentVertex = initialVertex;
      var isVector = true;
      while (isVector) {
        currentVertex.alreadyCutBack = true;
        points.push(currentVertex.vector);
        var currentVertexPair = polyPoints[currentVertex.alterCuttingBackPairIndex];
        if (currentVertex.cuttingBackPoint) {
          if (!currentVertexPair.alreadyCutBack) {
            currentVertex = currentVertexPair;
          } else {
            var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];
            var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];
            if (previousVertexOnBack.result === "OnBack" && !previousVertexOnBack.alreadyCutBack) {
              currentVertex = previousVertexOnBack;
            } else if (nextVertexOnBack.result === "OnBack" && !nextVertexOnBack.alreadyCutBack) {
              currentVertex = nextVertexOnBack;
            } else {
              return points;
            }
          }
        } else {
          var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];
          var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];
          if (previousVertexOnBack.result !== "OnFront" && !previousVertexOnBack.alreadyCutBack) {
            currentVertex = previousVertexOnBack;
          } else if (nextVertexOnBack.result !== "OnFront" && !nextVertexOnBack.alreadyCutBack) {
            currentVertex = nextVertexOnBack;
          } else {
            return points;
          }
        }
      }
      return null;
    };
    CircularChart3DBinaryTreeBuilder2.prototype.build = function(points, chart) {
      if (!points) {
        return this.build(chart.circular3DPolygon);
      } else {
        var inputPolygons = points;
        if (inputPolygons.length < 1) {
          return null;
        }
        var bspNode = {
          back: null,
          front: null,
          plane: null
        };
        var plane = inputPolygons[0];
        bspNode.plane = plane;
        var polygonsToLeft = [];
        var polygonsToRight = [];
        for (var i = 1, len = inputPolygons.length; i < len; i++) {
          var currentPolygon = inputPolygons[i];
          if (currentPolygon === plane) {
            continue;
          }
          var classificationResult = this.classifyPolygon(plane, currentPolygon);
          switch (classificationResult) {
            case "OnPlane":
            case "ToRight":
              polygonsToRight.push(currentPolygon);
              break;
            case "ToLeft":
              polygonsToLeft.push(currentPolygon);
              break;
            case "Unknown":
              if (currentPolygon.element) {
                polygonsToLeft.push(currentPolygon);
              } else {
                var result = this.splitPolygon(currentPolygon, plane);
                for (var k = 0; k < result.backPolygon.length; k++) {
                  result.backPolygon[k].name = result.backPolygon[k].name + "-back";
                  polygonsToLeft.push(result.backPolygon[k]);
                }
                for (var j = 0; j < result.frontPolygon.length; j++) {
                  result.frontPolygon[j].name = result.frontPolygon[j].name + "-front";
                  polygonsToRight.push(result.frontPolygon[j]);
                }
              }
              break;
          }
        }
        if (polygonsToLeft.length > 0) {
          bspNode.back = this.build(polygonsToLeft);
        }
        if (polygonsToRight.length > 0) {
          bspNode.front = this.build(polygonsToRight);
        }
        return bspNode;
      }
    };
    return CircularChart3DBinaryTreeBuilder2;
  }()
);
var CircularChart3DSvgRenderer = (
  /** @class */
  function() {
    function CircularChart3DSvgRenderer2() {
    }
    CircularChart3DSvgRenderer2.prototype.getStringBuilder = function() {
      var data = [];
      var counter = 0;
      return {
        append: function(text) {
          data[counter++] = text;
          return this;
        },
        toString: function(text) {
          return data.join(text || "");
        }
      };
    };
    CircularChart3DSvgRenderer2.prototype.hexToValue = function(hexColorCode) {
      var result;
      var values;
      if (hexColorCode.indexOf("rgba(") === 0) {
        values = hexColorCode.slice(5, -1).split(",");
        return values ? {
          red: parseInt(values[0], 10),
          green: parseInt(values[1], 10),
          blue: parseInt(values[2], 10),
          alpha: parseFloat(values[3])
        } : null;
      } else if (hexColorCode.indexOf("rgb(") === 0) {
        values = hexColorCode.slice(4, -1).split(",");
        return values ? {
          red: parseInt(values[0], 10),
          green: parseInt(values[1], 10),
          blue: parseInt(values[2], 10)
        } : null;
      } else {
        result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hexColorCode);
        return result ? {
          red: parseInt(result[1], 16),
          green: parseInt(result[2], 16),
          blue: parseInt(result[3], 16)
        } : null;
      }
    };
    CircularChart3DSvgRenderer2.prototype.drawText = function(options, label, font, chart) {
      var text = document.getElementById(options.id) || chart.groupElement.querySelector("#" + options.id);
      if (text === null) {
        text = document.createElementNS("http://www.w3.org/2000/svg", "text");
      }
      text.textContent = label;
      text = chart.renderer.setElementAttributes(options, text);
      return text;
    };
    CircularChart3DSvgRenderer2.prototype.hexColor = function(color) {
      var redValue = color.red;
      var greenValue = color.green;
      var blueValue = color.blue;
      if (color.alpha) {
        var returnColor = "rgba(" + redValue.toString() + "," + greenValue.toString() + "," + blueValue.toString() + "," + color.alpha + ")";
        return returnColor;
      } else {
        var hex_1 = [redValue.toString(16), greenValue.toString(16), blueValue.toString(16)];
        hex_1.forEach(function(val, nr) {
          if (val.length === 1) {
            hex_1[nr] = "0" + val;
          }
        });
        return "#" + hex_1.join("").toUpperCase();
      }
    };
    CircularChart3DSvgRenderer2.prototype.checkColorFormat = function(color) {
      if (color.indexOf("rgba(") === 0 || color.indexOf("rgb(") === 0) {
        var rgbaValues = color.substring(color.indexOf("(") + 1, color.lastIndexOf(")")).split(",");
        if (rgbaValues.length === 3 || rgbaValues.length === 4) {
          return rgbaValues.every(function(val) {
            var num = parseFloat(val);
            return !isNaN(num) && num >= 0 && num <= 255;
          });
        }
      } else if (color.indexOf("#") === 0) {
        var hex = color.substring(1);
        return (hex.length === 3 || hex.length === 6) && /^[0-9A-Fa-f]{3,6}$/.test(hex);
      }
      return false;
    };
    return CircularChart3DSvgRenderer2;
  }()
);
var CircularChart3DPolygonModule = (
  /** @class */
  function() {
    function CircularChart3DPolygonModule2() {
      this.epsilon = 1e-5;
      this.normal = {
        x: 0,
        y: 0,
        z: 0
      };
      this.vector = new CircularChart3DVectorModule(0, 0, 0);
      this.vectorPoints = [];
      this.matrixObj = new CircularChart3DMatrix();
    }
    CircularChart3DPolygonModule2.prototype.polygon3D = function(points, tag, index, stroke, strokeThickness, opacity, fill, name, parent, text) {
      if (arguments.length === 2) {
        this.calculateNormal(points[0], points[1], points[2]);
        this.vectorPoints = points;
        this.calculateNormal(this.vectorPoints);
        var polygon = tag;
        polygon.normal = this.normal;
        polygon.points = points;
        polygon.vectorPoints = this.vectorPoints;
        polygon.isSplit = true;
        polygon.d = this.d;
        return polygon;
      } else {
        this.calculateNormal(points[0], points[1], points[2]);
        this.vectorPoints = points;
        this.calculateNormal(this.vectorPoints);
        var element = {
          tag: "path",
          parent
        };
        var polygon = {
          normal: this.normal,
          points,
          vectorPoints: this.vectorPoints,
          index,
          tag,
          name: name ? name : null,
          strokeThickness,
          opacity,
          fill,
          d: this.d,
          text: text ? text : "",
          polygonElement: element
        };
        if (arguments.length !== 1) {
          polygon.polygonElement = element;
        }
        return polygon;
      }
    };
    CircularChart3DPolygonModule2.prototype.calculateNormal = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (args.length >= 3) {
        var vector1 = args[0];
        var vector22 = args[1];
        var vector3 = args[2];
        var vector4 = this.vector.vector3DMinus(vector1, vector22);
        var vector5 = this.vector.vector3DMinus(vector3, vector22);
        var normal = this.vector.vector3DMultiply(vector4, vector5);
        var length_1 = this.vector.getLength(normal);
        if (length_1 < this.epsilon) {
          length_1 = 1;
        }
        this.normal = this.vector.vector3D(normal.x / length_1, normal.y / length_1, normal.z / length_1);
        this.d = -(this.normal.x * vector1.x + this.normal.y * vector1.y + this.normal.z * vector1.z);
        if (args[3]) {
          args[3].normal = this.normal;
          args[3].d = this.d;
        }
      } else {
        var points = args[0];
        this.calculateNormal(points[0], points[1], points[2], args[1]);
        for (var i = 3; i < points.length && this.test(); i++) {
          this.calculateNormal(points[i], points[0], points[i / 2]);
        }
      }
    };
    CircularChart3DPolygonModule2.prototype.test = function() {
      return !this.vector.isValid(this.normal);
    };
    CircularChart3DPolygonModule2.prototype.getNormal = function(transform, vectorPoints) {
      var normal;
      if (vectorPoints != null) {
        normal = this.vector.getNormal(this.matrixObj.getMatrixVectorMultiple(transform, vectorPoints[0]), matrixObj2.getMatrixVectorMultiple(transform, vectorPoints[1]), this.matrixObj.getMatrixVectorMultiple(transform, vectorPoints[2]));
        for (var i = 3; i < vectorPoints.length && !this.vector.isValid(normal) && vectorPoints[i / 2]; i++) {
          var v1 = matrixObj2.getMatrixVectorMultiple(transform, vectorPoints[i]);
          var v2 = matrixObj2.getMatrixVectorMultiple(transform, vectorPoints[0]);
          var v3 = matrixObj2.getMatrixVectorMultiple(transform, vectorPoints[i / 2]);
          normal = this.vector.getNormal(v1, v2, v3);
        }
      }
      return normal;
    };
    CircularChart3DPolygonModule2.prototype.createTextElement = function(position, element, xLength, yLength) {
      var vectorCollection = [];
      var x = position.x;
      var y = position.y;
      var desiredWidth = element.width;
      var desiredHeight = element.height;
      vectorCollection[0] = this.vector.vector3D(x, y, position.z);
      vectorCollection[1] = this.vector.vector3D(x + desiredWidth, y + desiredHeight + yLength, position.z);
      vectorCollection[2] = this.vector.vector3D(x + desiredWidth + xLength, y + desiredHeight + yLength, position.z);
      return this.text3D(element, vectorCollection);
    };
    CircularChart3DPolygonModule2.prototype.createPolyline = function(points, element) {
      if (points.length === 2) {
        var prePoint = points[1];
        points.push({
          x: prePoint.x,
          y: prePoint.y,
          z: prePoint.z
        });
      }
      return this.polyLine3D(element, points);
    };
    CircularChart3DPolygonModule2.prototype.polyLine3D = function(element, points) {
      var plane = this.polygon3D(points);
      plane.element = element;
      return plane;
    };
    CircularChart3DPolygonModule2.prototype.text3D = function(element, points) {
      var plane = this.polygon3D(points);
      plane.element = element;
      return plane;
    };
    CircularChart3DPolygonModule2.prototype.drawPolyLine = function(panel, chart) {
      var transform = circular3DRender.transform;
      var pathDirection = chart.svg3DRenderer.getStringBuilder();
      var startPoint = chart.transform3D.toScreen(panel.vectorPoints[0], transform);
      pathDirection.append("M " + startPoint.x + " " + startPoint.y + " ");
      var lineSegment1 = chart.transform3D.toScreen(panel.vectorPoints[1], transform);
      pathDirection.append("L " + lineSegment1.x + " " + lineSegment1.y + " ");
      pathDirection.append("M " + lineSegment1.x + " " + lineSegment1.y + " ");
      var lineSegment2 = chart.transform3D.toScreen(panel.vectorPoints[2], transform);
      pathDirection.append("L " + lineSegment2.x + " " + lineSegment2.y + " ");
      var direction = pathDirection.toString();
      var optionsLine = {
        id: panel.element.id,
        "stroke-dasharray": panel.element.dashArray,
        "stroke-width": panel.element.width,
        stroke: panel.element.stroke,
        d: direction
      };
      var element = chart.renderer.drawPath(optionsLine);
      appendChildElement(false, chart.groupElement, element, chart.redraw, true, "x", "y", null, direction);
    };
    CircularChart3DPolygonModule2.prototype.drawText = function(panel, chart) {
      var element = panel.element;
      var transform = circular3DRender.transform;
      if (transform == null) {
        return;
      }
      var actual3DPosition = chart.transform3D.toScreen(panel.vectorPoints[0], transform);
      var x = actual3DPosition.x;
      var y = actual3DPosition.y;
      if (element.tag === "text") {
        var options = {
          "id": element.id,
          "x": x,
          "y": y,
          "fill": element.font.color || element.fill,
          "font-size": element.font.size,
          "font-family": element.font.fontFamily || chart.themeStyle.datalabelFont.fontFamily,
          "font-style": element.font.fontStyle,
          "font-weight": element.font.fontWeight,
          "opacity": element.font.opacity,
          "text-anchor": element.textAnchor,
          "cursor": "default",
          "transform": element.angle ? "rotate(" + element.angle + "," + x + "," + y + ")" : ""
        };
        var textElement3 = chart.svg3DRenderer.drawText(options, element.label.text, panel.element.font, chart);
        if (element.id.indexOf("text") > -1) {
          textElement3.setAttribute("aria-hidden", "true");
        }
        chart.groupElement.append(textElement3);
        if (chart.previousID && chart.isTouch) {
          var previousElement = document.getElementById(chart.previousID);
          var currentElement = document.getElementById(options.id);
          if (previousElement && currentElement) {
            currentElement.parentNode.insertBefore(currentElement, previousElement.nextSibling);
          }
        }
        chart.previousID = options.id;
      } else {
        var series = element.series;
        var pointText = element.point.argsData.text;
        var textOffset = measureText(pointText, element.point.argsData.font, chart.themeStyle.datalabelFont);
        var padding = 10;
        var width = textOffset.width + padding + padding;
        var height = textOffset.height + padding + padding;
        var location_1 = {
          x: actual3DPosition.x,
          y: actual3DPosition.y
        };
        var xXalue = location_1.x - padding / 2 + padding / 2;
        var yValue = location_1.y - padding / 2 - height / padding + padding / 2;
        var seriesIndex = series.index;
        this.dataLabelSymbol(seriesIndex, series, element, xXalue, yValue, width, height, chart);
      }
    };
    CircularChart3DPolygonModule2.prototype.dataLabelSymbol = function(seriesIndex, series, dataElement, x, y, width, height, chart) {
      var path = "M " + (x + -width / 2) + " " + (y + -height / 2) + " L " + (x + width / 2) + " " + (y + -height / 2) + " L " + (x + width / 2) + " " + (y + height / 2) + " L " + (x + -width / 2) + " " + (y + height / 2) + " L " + (x + -width / 2) + " " + (y + -height / 2) + " z";
      var transform = "";
      if (series.dataLabel.enableRotation) {
        var degree = void 0;
        var angle = degree = series.dataLabel.angle;
        if (angle === 0) {
          var toDegrees = function(angle2) {
            return angle2 * (180 / Math.PI);
          };
          var midAngle = toDegrees(dataElement.point.symbolLocation.angle);
          if (series.dataLabel.position === "Outside") {
            degree = 0;
          } else if (midAngle >= 90 && midAngle <= 260) {
            degree = midAngle + 180;
          } else {
            degree = midAngle;
          }
        } else {
          degree = angle > 360 ? angle - 360 : angle < -360 ? angle + 360 : angle;
        }
        transform = "rotate(" + degree + "," + x + "," + y + ")";
      }
      var rectOptions = {
        id: chart.element.id + "-svg-data-label-series-" + seriesIndex + "-shape-" + dataElement.pointIndex,
        fill: dataElement.point.argsData.color,
        "stroke-width": dataElement.point.argsData.border.width,
        stroke: dataElement.point.argsData.border.color,
        "stroke-dasharray": dataElement.point.argsData.border.dashArray,
        opacity: 1,
        visibility: "",
        transform,
        d: path
      };
      var element = chart.renderer.drawPath(rectOptions);
      chart.groupElement.append(element);
      if (chart.previousID && chart.isTouch) {
        var previousElement = document.getElementById(chart.previousID);
        var currentElement = document.getElementById(rectOptions.id);
        if (previousElement && currentElement) {
          currentElement.parentNode.insertBefore(currentElement, previousElement.nextSibling);
        }
      }
      chart.previousID = rectOptions.id;
    };
    CircularChart3DPolygonModule2.prototype.draw = function(panel, chart) {
      if (panel.vectorPoints == null || panel.vectorPoints.length <= 0) {
        return;
      }
      var transform = circular3DRender.transform;
      var pathDirection = chart.svg3DRenderer.getStringBuilder();
      var color = panel.fill;
      var format = chart.svg3DRenderer.checkColorFormat(color);
      if (!format) {
        color = colorNameToHex(color);
      }
      var figure = {
        StartPoint: null
      };
      if (transform != null) {
        figure.StartPoint = chart.transform3D.toScreen(panel.vectorPoints[0], transform);
        pathDirection.append("M " + figure.StartPoint.x + " " + figure.StartPoint.y + " ");
        for (var i = 0; i < panel.vectorPoints.length; i++) {
          var lineSegment = chart.transform3D.toScreen(panel.vectorPoints[i], transform);
          pathDirection.append("L " + lineSegment.x + " " + lineSegment.y + " ");
        }
      }
      var direction = pathDirection.toString();
      var name = "Light";
      var lightCoefficientZ = 2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(0, 0, 1))) - 1);
      var lightCoefficientY = 2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(0, 1, 0))) - 1);
      var lightCoefficientX = 2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(1, 0, 0))) - 1);
      if (panel.name && !(panel.name.indexOf("-wall-brush") > -1)) {
        if (lightCoefficientZ === lightCoefficientX) {
          name = "ZLight";
          color = this.applyZLight(color, chart);
        } else if (lightCoefficientY === lightCoefficientZ || lightCoefficientZ !== 0 && lightCoefficientY < lightCoefficientZ) {
          name = "XLight";
          color = this.applyXLight(color, chart);
        } else if (lightCoefficientZ < 0) {
          name = "ZLight";
          color = this.applyZLight(color, chart);
        } else {
          name = "Light";
        }
      }
      var options = {
        "id": chart.element.id + "-svg-" + panel.name,
        "name": name,
        "fill": color,
        "stroke": "",
        "stroke-width": panel.strokeThickness,
        "opacity": panel.opacity,
        "d": direction
      };
      var element = chart.renderer.drawPath(options);
      if (panel.text) {
        element.setAttribute("aria-label", panel.text);
        element.setAttribute("role", "img");
      }
      appendChildElement(false, panel.polygonElement.parent, element, chart.redraw, true, "x", "y", null, direction);
      if (chart.previousID && chart.isTouch) {
        var previousElement = document.getElementById(chart.previousID);
        var currentElement = document.getElementById(options.id);
        if (previousElement && currentElement) {
          currentElement.parentNode.insertBefore(currentElement, previousElement.nextSibling);
        }
      }
      chart.previousID = options.id;
    };
    CircularChart3DPolygonModule2.prototype.drawTemplate = function(panel, chart) {
      var element = panel.element;
      var transform = circular3DRender.transform;
      if (transform == null) {
        return;
      }
      var label = element.label;
      var actual3DPosition = chart.transform3D.toScreen(panel.vectorPoints[0], transform);
      chart.circularChartDataLabel3DModule.createDataLabelTemplate(label.series.dataLabelElement, label.series, label.series.dataLabel, label.series.points[label.pointIndex], label.series.points[label.pointIndex].argsData, label.pointIndex, false, actual3DPosition, chart);
    };
    CircularChart3DPolygonModule2.prototype.applyXLight = function(color, chart) {
      var RGB = chart.svg3DRenderer.hexToValue(color);
      RGB.red = parseInt((RGB.red * 0.7).toString(), 10);
      RGB.green = parseInt((RGB.green * 0.7).toString(), 10);
      RGB.blue = parseInt((RGB.blue * 0.7).toString(), 10);
      return chart.svg3DRenderer.hexColor(RGB);
    };
    CircularChart3DPolygonModule2.prototype.applyZLight = function(color, chart) {
      var RGB = chart.svg3DRenderer.hexToValue(color);
      RGB.red = parseInt((RGB.red * 0.9).toString(), 10);
      RGB.green = parseInt((RGB.green * 0.9).toString(), 10);
      RGB.blue = parseInt((RGB.blue * 0.9).toString(), 10);
      return chart.svg3DRenderer.hexColor(RGB);
    };
    return CircularChart3DPolygonModule2;
  }()
);
var vector2 = new CircularChart3DVectorModule(0, 0, 0);
var matrixObj2 = new CircularChart3DMatrix();
var bspTreeObj2 = new CircularChart3DBinaryTreeBuilder();
var polygonObj2 = new CircularChart3DPolygonModule();

// node_modules/@syncfusion/ej2-charts/src/circularchart3d/circularchart3d.js
var __extends115 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate35 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CircularChart3D = (
  /** @class */
  function(_super) {
    __extends115(CircularChart3D2, _super);
    function CircularChart3D2(options, element) {
      var _this = _super.call(this, options, element) || this;
      _this.chartId = 57724;
      _this.explodeDistance = 0;
      _this.rotateActivate = false;
      _this.previousTargetId = "";
      _this.currentPointIndex = 0;
      _this.currentLegendIndex = 0;
      _this.isLegendClicked = false;
      _this.delayRedraw = false;
      return _this;
    }
    Object.defineProperty(CircularChart3D2.prototype, "type", {
      get: function() {
        return "Pie";
      },
      enumerable: true,
      configurable: true
    });
    CircularChart3D2.prototype.preRender = function() {
      this.allowServerDataBinding = false;
      this.unWireEvents();
      this.titleLocation = {
        x: 0,
        y: 0,
        size: new Size(0, 0)
      };
      this.subTitleLocation = {
        x: 0,
        y: 0,
        size: new Size(0, 0)
      };
      this.circularRadius = [];
      this.innerRadius = [];
      this.matrixObj = new CircularChart3DMatrix();
      this.bspTreeObj = new CircularChart3DBinaryTreeBuilder();
      this.polygon = new CircularChart3DPolygonModule();
      this.vector = new CircularChart3DVectorModule(null, null, null);
      this.graphics = new CircularChart3DGraphics();
      this.transform3D = new CircularChart3DTransform();
      this.svg3DRenderer = new CircularChart3DSvgRenderer();
      this.circular3DPolygon = [];
      this.explodeDistance = 0;
      this.setCulture();
      this.animateSeries = true;
      if (this.element.id === "") {
        var collection = document.getElementsByClassName("e-circular3dchart").length;
        this.element.id = "acc_chart_" + this.chartId + "_" + collection;
      }
      this.wireEvents();
      this.element.setAttribute("dir", this.enableRtl ? "rtl" : "");
      this.element.style.outline = "none";
    };
    CircularChart3D2.prototype.unWireEvents = function() {
      var isIE11Pointer = Browser.isPointer;
      var start = Browser.touchStartEvent;
      var move = Browser.touchMoveEvent;
      var stop = Browser.touchEndEvent;
      var cancel = isIE11Pointer ? "pointerleave" : "mouseleave";
      EventHandler.remove(this.element, move, this.chartOnMouseMove);
      EventHandler.remove(this.element, stop, this.chartMouseUp);
      EventHandler.remove(this.element, start, this.chartMouseDown);
      EventHandler.remove(this.element, "click", this.chartOnMouseClick);
      EventHandler.remove(this.element, cancel, this.chartMouseLeave);
      EventHandler.remove(this.element, "keydown", this.circular3DChartKeyDown);
      EventHandler.remove(this.element, "keyup", this.circular3DChartKeyUp);
      window.removeEventListener(Browser.isTouch && "orientation" in window && "onorientationchange" in window ? "orientationchange" : "resize", this.chartResizeBound);
    };
    CircularChart3D2.prototype.chartOnMouseClick = function(e) {
      this.setMouseXY(e);
      if (this.circularChartLegend3DModule && this.legendSettings.visible) {
        this.circularChartLegend3DModule.click(e);
      }
      if (this.selectionMode !== "None" && this.circularChartSelection3DModule) {
        this.circularChartSelection3DModule.calculateSelectedElements(this, e.target, e.type);
      }
      if (this.visibleSeries[0].explode) {
        var id = e.target.id;
        var indexes = void 0;
        var pointIndex = void 0;
        if (id.indexOf("-point-") > -1) {
          indexes = id.split("-series-")[1].split("-point-");
          pointIndex = parseInt(indexes[1], 10);
          var currentPointIndex = this.visibleSeries[0].explodeIndex;
          if (currentPointIndex === pointIndex || this.visibleSeries[0].points[pointIndex].isExplode) {
            this.visibleSeries[0].explodeIndex = null;
            this.visibleSeries[0].isExploded = true;
            this.visibleSeries[0].points.forEach(function(point) {
              point.isExplode = false;
            });
          } else {
            this.visibleSeries[0].explodeIndex = pointIndex;
          }
          this.removeSeriesElements(this);
          this.visibleSeries[0].segments = [];
          this.circular3DPolygon = [];
          this.renderSeries();
          this.processSelection();
          this.delayRedraw = true;
        }
      }
      this.trigger("circularChart3DMouseClick", {
        target: e.target.id,
        x: this.mouseX,
        y: this.mouseY
      });
      if (this.pointClick) {
        this.triggerPointEvent(pointClick, e.target, e);
      }
      this.removeNavigationStyle();
      return false;
    };
    CircularChart3D2.prototype.triggerPointEvent = function(event2, element, e) {
      var evt = e;
      var point;
      var series = this.visibleSeries[0];
      if (element.id.indexOf("point") > -1 && element.id.indexOf("series") > -1) {
        var pointIndex = parseInt(element.id.split("point-")[1], 10);
        point = series.points[pointIndex];
      }
      if (point) {
        this.trigger(event2, {
          series,
          point,
          seriesIndex: series.index,
          pointIndex: point.index,
          x: this.mouseX,
          y: this.mouseY,
          pageX: evt.pageX,
          pageY: evt.pageY
        });
      }
    };
    CircularChart3D2.prototype.chartOnMouseMove = function(e) {
      if (!getElement2(this.element.id + "_svg")) {
        return false;
      }
      this.setMouseXY(e);
      this.trigger("circularChart3DMouseMove", {
        target: e.target.id,
        x: this.mouseX,
        y: this.mouseY
      });
      if (this.rotateActivate) {
        var deltaX = this.previousCoords.x - this.mouseX;
        var deltaY = this.previousCoords.y - this.mouseY;
        if (deltaX || deltaY) {
          this.tilt -= deltaY;
          this.rotation += deltaX;
          if (!this.isTouch) {
            var grpElement = document.getElementById(this.groupElement.id);
            grpElement.innerHTML = "";
            grpElement.remove();
          }
          var size = {
            width: this.availableSize.width,
            height: this.availableSize.height
          };
          this.graphics.view(this.svgObject, this, this.rotation, this.tilt, size, 0, this.depth);
          appendChildElement(false, this.svgObject, this.groupElement, this.redraw);
          this.setSeriesTabIndex();
          this.previousCoords.y = this.mouseY;
          this.previousCoords.x = this.mouseX;
          if (this.circularChartHighlight3DModule && this.highlightMode !== "None") {
            this.circularChartHighlight3DModule.calculateSelectedElements(this, document.getElementById(this.element.id + "-border"), "mousemove");
            this.circularChartHighlight3DModule.previousSelectedElement = [];
          }
          this.processSelection();
        }
      }
      if (this.pointMove) {
        this.triggerPointEvent(pointMove, e.target, e);
      }
      if (this.tooltip.enable && this.circularChartTooltip3DModule) {
        this.circularChartTooltip3DModule.mouseMoveHandler(e, this);
      }
      if (!this.isTouch) {
        this.titleTooltip(e, this.mouseX, this.mouseY);
      }
      this.notify(Browser.touchMoveEvent, e);
      return false;
    };
    CircularChart3D2.prototype.titleTooltip = function(event2, x, y, isTouch) {
      var targetId = event2.target.id;
      var id = targetId === this.element.id + "-title" || targetId === this.element.id + "-sub-title" || targetId === this.element.id + "_chart_legend_title";
      if (event2.target.textContent.indexOf("...") > -1 && id) {
        var title = targetId === this.element.id + "-title" ? this.title : targetId === this.element.id + "-sub-title" ? this.subTitle : this.legendSettings.title;
        showTooltip(title, x, y, this.element.offsetWidth, this.element.id + "_EJ2_Title_Tooltip", getElement2(this.element.id + "_Secondary_Element"), isTouch);
      } else {
        removeElement2(this.element.id + "_EJ2_Title_Tooltip");
      }
    };
    CircularChart3D2.prototype.setMouseXY = function(e) {
      var pageX;
      var pageY;
      var svgRectElement = getElement2(this.element.id + "_svg");
      if (svgRectElement && this.element) {
        var svgRect = svgRectElement.getBoundingClientRect();
        var rect = this.element.getBoundingClientRect();
        if (e.type.indexOf("touch") > -1) {
          this.isTouch = true;
          var touchArg = e;
          pageY = touchArg.changedTouches[0].clientY;
          pageX = touchArg.changedTouches[0].clientX;
        } else {
          this.isTouch = e.pointerType === "touch" || e.pointerType === "2";
          pageX = e.clientX;
          pageY = e.clientY;
        }
        this.mouseY = pageY - rect.top - Math.max(svgRect.top - rect.top, 0);
        this.mouseX = pageX - rect.left - Math.max(svgRect.left - rect.left, 0);
      }
    };
    CircularChart3D2.prototype.wireEvents = function() {
      if (!this.element) {
        return;
      }
      var isIE11Pointer = Browser.isPointer;
      var start = Browser.touchStartEvent;
      var stop = Browser.touchEndEvent;
      var move = Browser.touchMoveEvent;
      var cancel = isIE11Pointer ? "pointerleave" : "mouseleave";
      EventHandler.add(this.element, move, this.chartOnMouseMove, this);
      EventHandler.add(this.element, stop, this.chartMouseUp, this);
      EventHandler.add(this.element, start, this.chartMouseDown, this);
      EventHandler.add(this.element, "click", this.chartOnMouseClick, this);
      EventHandler.add(this.element, cancel, this.chartMouseLeave, this);
      EventHandler.add(this.element, "keydown", this.circular3DChartKeyDown, this);
      EventHandler.add(this.element, "keyup", this.circular3DChartKeyUp, this);
      this.chartResizeBound = this.chartResize.bind(this);
      window.addEventListener(Browser.isTouch && "orientation" in window && "onorientationchange" in window ? "orientationchange" : "resize", this.chartResizeBound);
      this.setStyle(this.element);
    };
    CircularChart3D2.prototype.chartMouseLeave = function(e) {
      this.setMouseXY(e);
      this.trigger("circularChart3DMouseLeave", {
        target: e.target.id,
        x: this.mouseX,
        y: this.mouseY
      });
      if (this.tooltip.enable && this.circularChartTooltip3DModule) {
        this.circularChartTooltip3DModule.mouseLeaveHandler();
      }
      this.notify(Browser.isPointer ? "pointerleave" : "mouseleave", e);
      this.rotateActivate = false;
      return false;
    };
    CircularChart3D2.prototype.chartMouseUp = function(e) {
      this.setMouseXY(e);
      this.trigger("circularChart3DMouseUp", {
        target: e.target.id,
        x: this.mouseX,
        y: this.mouseY
      });
      if (this.isTouch) {
        this.titleTooltip(e, this.mouseX, this.mouseY, this.isTouch);
      }
      this.rotateActivate = false;
      if (this.tooltip.enable && this.circularChartTooltip3DModule) {
        this.circularChartTooltip3DModule.mouseUpHandler(e, this);
      }
      this.notify(Browser.touchEndEvent, e);
      return false;
    };
    CircularChart3D2.prototype.chartMouseDown = function(e) {
      this.setMouseXY(e);
      this.trigger("circularChart3DMouseDown", {
        target: e.target.id,
        x: this.mouseX,
        y: this.mouseY
      });
      this.cachedX = this.mouseX;
      this.cachedY = this.mouseY;
      var svgRect = getElement2(this.element.id + "_svg").getBoundingClientRect();
      var bounds = document.getElementById(this.element.id + "-svg-chart-3d").getBoundingClientRect();
      var rect = {
        x: bounds.left - svgRect.left,
        y: bounds.top - svgRect.top,
        width: bounds.width,
        height: bounds.height
      };
      if (this.enableRotation && withInBounds(this.mouseX, this.mouseY, rect)) {
        this.rotateActivate = true;
        this.previousCoords = {
          x: this.mouseX,
          y: this.mouseY
        };
      }
      return false;
    };
    CircularChart3D2.prototype.setStyle = function(element) {
      element.style.touchAction = this.enableRotation ? "none" : "element";
      element.style.msTouchAction = "element";
      element.style.msContentZooming = "none";
      element.style.msUserSelect = "none";
      element.style.webkitUserSelect = "none";
      element.style.position = "relative";
      element.style.display = "block";
      element.style.height = element.style.height || this.height && this.height.indexOf("%") === -1 ? element.style.height : "inherit";
    };
    CircularChart3D2.prototype.setCulture = function() {
      this.intl = new Internationalization();
    };
    CircularChart3D2.prototype.render = function() {
      var _this = this;
      if (this.element.className.indexOf("e-circular3dchart") === -1) {
        this.element.classList.add("e-circular3dchart");
      }
      this.element.setAttribute("role", "region");
      this.element.setAttribute("tabindex", "0");
      this.element.setAttribute("aria-label", this.title + ". Syncfusion interactive chart.");
      this.element.setAttribute("class", this.element.getAttribute("class") + " e-circular3dchart-focused");
      var loadEventData = {
        chart: this,
        theme: this.theme,
        name: load,
        cancel: false
      };
      this.trigger(load, loadEventData, function() {
        if (!loadEventData.cancel) {
          _this.setTheme();
          _this.calculateVisibleSeries();
          _this.processData();
          _this.renderComplete();
          _this.allowServerDataBinding = true;
        }
      });
    };
    CircularChart3D2.prototype.setTheme = function() {
      this.themeStyle = getCircular3DThemeColor(this.theme);
    };
    CircularChart3D2.prototype.processData = function(render) {
      if (render === void 0) {
        render = true;
      }
      this.seriesCounts = 0;
      for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
        var series = _a[_i];
        series.dataModule = new Data(series.dataSource || this.dataSource, series.query);
        series.refreshDataManager(this, render);
      }
    };
    CircularChart3D2.prototype.refreshChart = function() {
      this.createPieSvg();
      this.calculateBounds();
      this.circular3DPolygon = [];
      this.visibleSeries[0].segments = [];
      this.groupElement = this.renderer.createGroup({
        "id": this.element.id + "-svg-chart-3d"
      });
      this.groupElement.setAttribute("role", "region");
      this.groupElement.setAttribute("aria-hidden", "false");
      this.renderElements();
      removeElement2("chartmeasuretext");
    };
    CircularChart3D2.prototype.renderElements = function() {
      this.renderBorder();
      this.createSecondaryElement();
      this.renderTitle();
      this.renderSeries();
      this.renderLegend();
      appendChildElement(false, this.element, this.svgObject, this.redraw);
      this.processSelection();
      this.setSecondaryElementPosition();
      this.trigger("loaded", {
        chart: this
      });
      this.setSeriesTabIndex();
      this.doAnimation();
      this.animateSeries = false;
    };
    CircularChart3D2.prototype.setSeriesTabIndex = function() {
      var elements;
      for (var i = 0; i < this.visibleSeries[0].points.length; i++) {
        if (this.visibleSeries[0].points[i].visible) {
          elements = document.querySelectorAll('[id*="region-series-0-point-' + this.visibleSeries[0].points[i].index + '"]');
          break;
        }
      }
      if (elements && elements.length > 0) {
        var element = elements[elements.length - 1];
        element.setAttribute("tabindex", "0");
      }
    };
    CircularChart3D2.prototype.processSelection = function() {
      var selectedDataIndexes = [];
      if (this.circularChartSelection3DModule && this.selectionMode !== "None") {
        selectedDataIndexes = extend([], this.circularChartSelection3DModule.selectedDataIndexes, null, true);
        this.circularChartSelection3DModule.invokeSelection(this);
      }
      if (this.circularChartHighlight3DModule) {
        this.circularChartHighlight3DModule.invokeHighlight(this);
      }
      if (selectedDataIndexes.length > 0) {
        this.circularChartSelection3DModule.selectedDataIndexes = selectedDataIndexes;
        this.circularChartSelection3DModule.redrawSelection(this);
      }
    };
    CircularChart3D2.prototype.highlightAnimation = function(element, duration, startOpacity) {
      var endOpacity = parseFloat(this.visibleSeries[0].opacity.toString());
      if (endOpacity) {
        new Animation({}).animate(element, {
          duration,
          progress: function(args) {
            element.style.animation = "";
            var progress = args.timeStamp / args.duration;
            var currentOpacity = startOpacity + (endOpacity - startOpacity) * progress;
            element.setAttribute("opacity", currentOpacity.toString());
          },
          end: function() {
            element.setAttribute("opacity", endOpacity.toString());
          }
        });
      }
    };
    CircularChart3D2.prototype.stopElementAnimation = function(element) {
      var endOpacity = parseFloat(this.visibleSeries[0].opacity.toString());
      var animation = element.getAttribute("e-animate");
      if (animation) {
        Animation.stop(element);
      }
      element.setAttribute("opacity", endOpacity.toString());
    };
    CircularChart3D2.prototype.doAnimation = function() {
      var series = this.visibleSeries[0];
      if (series.animation.enable && this.animateSeries) {
        var clippath_1 = this.renderer.createClipPath({
          id: this.element.id + "SeriesGroup0_clipPath"
        });
        var path = new PathOption(this.element.id + "SeriesGroup0_slice", "transparent", 1, "transparent", 1, "", "");
        var clipslice = this.renderer.drawPath(path);
        clippath_1.appendChild(clipslice);
        this.svgObject.appendChild(clippath_1);
        var id_1 = this.element.id;
        var groupElementID_1 = this.groupElement.id;
        document.querySelectorAll('[id*="region-series-"]').forEach(function(slice) {
          if (slice.parentElement.id === groupElementID_1) {
            slice.style.cssText = "clip-path:url(#" + clippath_1.id + "); -webkit-clip-path:url(#" + clippath_1.id + ");";
            slice.setAttribute("clip-path", "url(#" + id_1 + "SeriesGroup0_clipPath)");
          }
        });
        if (series.segments[0]) {
          this.animationRect(clipslice, series);
        }
      }
    };
    CircularChart3D2.prototype.renderLegend = function() {
      if (!this.circularChartLegend3DModule || !this.legendSettings.visible) {
        return null;
      }
      if (this.circularChartLegend3DModule.legendCollections.length && this.visibleSeries[0].labelBound) {
        this.circularChartLegend3DModule.getSmartLegendLocation(this.visibleSeries[0].labelBound, this.circularChartLegend3DModule.legendBounds, this.margin);
      }
      this.circularChartLegend3DModule.renderLegend(this, this.legendSettings, this.circularChartLegend3DModule.legendBounds, this.redraw);
    };
    CircularChart3D2.prototype.animationRect = function(slice, series) {
      var _this = this;
      var startAngle = -90;
      var duration = series.animation.duration;
      var value;
      var radius = Math.max(this.availableSize.height, this.availableSize.width) * 0.75;
      radius += radius * 0.414;
      var effect = getAnimationFunction("Linear");
      var center = {
        x: series.segments[0].center.x - this.rotation / 2,
        y: series.segments[0].center.y + this.tilt / 2
      };
      for (var i = 0; i < series.points.length; i++) {
        var dataLabelElement = getElement2(this.element.id + "-svg-data-label-text-" + i);
        if (dataLabelElement) {
          dataLabelElement.style.visibility = "hidden";
        }
        var shapeElement = getElement2(this.element.id + "-svg-data-label-series-0-shape-" + i);
        if (shapeElement) {
          shapeElement.style.visibility = "hidden";
        }
        var templateElement = getElement2(this.element.id + "-series-" + series.index + "-data-label-" + i);
        if (templateElement) {
          templateElement.style.visibility = "hidden";
        }
        var connectorElement = getElement2(this.element.id + "-datalabel-series-0-connector-" + i);
        if (connectorElement) {
          connectorElement.style.visibility = "hidden";
        }
      }
      if (!isNullOrUndefined(slice)) {
        new Animation({}).animate(slice, {
          duration: duration === 0 && animationMode === "Enable" ? 1e3 : duration,
          delay: series.animation.delay,
          progress: function(args) {
            value = effect(args.timeStamp, startAngle, 359.99999, args.duration);
            slice.setAttribute("d", _this.getPathArc(center, startAngle, value, radius));
          },
          end: function() {
            slice.setAttribute("d", _this.getPathArc(center, 0, 359.99999, radius));
            _this.trigger(animationComplete, {
              series,
              chart: _this
            });
            for (var i2 = 0; i2 < series.points.length; i2++) {
              var dataLabelElement2 = getElement2(_this.element.id + "-svg-data-label-text-" + i2);
              if (dataLabelElement2) {
                dataLabelElement2.style.visibility = "visible";
              }
              var shapeElement2 = getElement2(_this.element.id + "-svg-data-label-series-0-shape-" + i2);
              if (shapeElement2) {
                shapeElement2.style.visibility = "visible";
              }
              var templateElement2 = getElement2(_this.element.id + "-series-" + series.index + "-data-label-" + i2);
              if (templateElement2) {
                templateElement2.style.visibility = "visible";
              }
              var connectorElement2 = getElement2(_this.element.id + "-datalabel-series-0-connector-" + i2);
              if (connectorElement2) {
                connectorElement2.style.visibility = "visible";
              }
            }
          }
        });
      }
    };
    CircularChart3D2.prototype.getPathArc = function(center, start, end, radius) {
      var degree = end - start;
      degree = degree < 0 ? degree + 360 : degree;
      var flag = degree < 180 ? 0 : 1;
      return this.getPiePath(center, degreeToLocation(start, radius, center), degreeToLocation(end, radius, center), radius, flag);
    };
    CircularChart3D2.prototype.getPiePath = function(center, start, end, radius, clockWise) {
      return "M " + center.x + " " + center.y + " L " + start.x + " " + start.y + " A " + radius + " " + radius + " 0 " + clockWise + " 1 " + end.x + " " + end.y + " Z";
    };
    CircularChart3D2.prototype.renderBorder = function() {
      var padding = this.border.width;
      var rect = new RectOption(this.element.id + "-border", this.background || this.themeStyle.background, this.border, 1, new Rect(padding / 2, padding / 2, this.availableSize.width - padding, this.availableSize.height - padding));
      var htmlObject = this.renderer.drawRectangle(rect);
      htmlObject.setAttribute("aria-hidden", "true");
      appendChildElement(false, this.svgObject, htmlObject, this.redraw);
      var backGroundImage = this.backgroundImage;
      if (backGroundImage) {
        var image = new ImageOption(this.availableSize.height - padding, this.availableSize.width - padding, backGroundImage, 0, 0, this.element.id + "-background", "visible", "none");
        appendChildElement(false, this.svgObject, this.renderer.drawImage(image), this.redraw);
      }
    };
    CircularChart3D2.prototype.createSecondaryElement = function() {
      var element = redrawElement(this.redraw, this.element.id + "_Secondary_Element") || this.createElement("div", {
        id: this.element.id + "_Secondary_Element",
        styles: "position: relative"
      });
      appendChildElement(false, this.element, element, this.redraw);
    };
    CircularChart3D2.prototype.renderSeries = function() {
      if (!this.redraw) {
        this.svgObject.appendChild(this.renderer.createGroup({
          id: this.element.id + "_SeriesCollection"
        }));
      }
      for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
        var series = _a[_i];
        if (series.visible && this["pieSeries3DModule"]) {
          series.draw(series, this);
          this.defaultLabelBound(series);
        }
      }
    };
    CircularChart3D2.prototype.defaultLabelBound = function(series) {
      if (series.segments.length > 0 && series.dataLabel.visible) {
        var circularBound = this.getSeriesBound(series);
        if (series.dataLabel.visible && series.dataLabel.position === "Inside") {
          series.labelBound = new Rect(circularBound.x, circularBound.y, circularBound.width + circularBound.x, circularBound.height + circularBound.y);
        }
        series.findMaxBounds(series.labelBound, circularBound);
        if (this.circularChartLegend3DModule) {
          series.labelBound.x -= this.explodeDistance;
          series.labelBound.y -= this.explodeDistance;
          series.labelBound.height += this.explodeDistance - series.labelBound.y;
          series.labelBound.width += this.explodeDistance - series.labelBound.x;
        }
      }
    };
    CircularChart3D2.prototype.getSeriesBound = function(series) {
      var rect = new Rect(Infinity, Infinity, -Infinity, -Infinity);
      var start = 0;
      var total = 360;
      var end = (0 + total) % 360;
      end = end === 0 ? 360 : end;
      series.findMaxBounds(rect, this.getRectFromAngle(start));
      series.findMaxBounds(rect, this.getRectFromAngle(end));
      series.findMaxBounds(rect, new Rect(series.segments[0].center.x, series.segments[0].center.y, 0, 0));
      var nextQuandrant = (Math.floor(start / 90) * 90 + 90) % 360;
      var lastQuadrant = Math.floor(end / 90) * 90 % 360;
      lastQuadrant = lastQuadrant === 0 ? 360 : lastQuadrant;
      if (total >= 90 || lastQuadrant === nextQuandrant) {
        series.findMaxBounds(rect, this.getRectFromAngle(nextQuandrant));
        series.findMaxBounds(rect, this.getRectFromAngle(lastQuadrant));
      }
      if (start === 0 || start + total >= 360) {
        series.findMaxBounds(rect, this.getRectFromAngle(0));
      }
      var length = nextQuandrant === lastQuadrant ? 0 : Math.floor(total / 90);
      for (var i = 1; i < length; i++) {
        nextQuandrant = nextQuandrant + 90;
        if (nextQuandrant < lastQuadrant || end < start || total === 360) {
          series.findMaxBounds(rect, this.getRectFromAngle(nextQuandrant));
        }
      }
      rect.width -= rect.x;
      rect.height -= rect.y;
      return rect;
    };
    CircularChart3D2.prototype.getRectFromAngle = function(angle) {
      var location = degreeToLocation(angle, this.circularRadius[0], this.visibleSeries[0].segments[0].center);
      return new Rect(location.x, location.y, 0, 0);
    };
    CircularChart3D2.prototype.renderTitle = function() {
      var margin = this.margin;
      if (!this.title) {
        return null;
      }
      var getAnchor = this.getTextAnchor(this.titleStyle.textAlignment, this.enableRtl);
      var titleSize = measureText(this.title, this.titleStyle, this.themeStyle.chartTitleFont);
      var titleHeight = this.margin.top + titleSize.height * 3 / 4;
      var rect = new Rect(margin.left, 0, this.availableSize.width - margin.left - margin.right, 0);
      var options = new TextOption(this.element.id + "-title", titlePositionX(rect, this.titleStyle), titleHeight, getAnchor, this.titleCollection, "", "auto");
      this.titleLocation = {
        x: options.x,
        y: options.y,
        size: titleSize
      };
      var element = textElement2(this.renderer, options, this.titleStyle, this.titleStyle.color || this.themeStyle.chartTitleFont.color, this.svgObject, false, this.redraw, null, null, null, null, null, null, null, null, this.themeStyle.chartTitleFont);
      if (element) {
        element.setAttribute("tabindex", "0");
        element.style.outline = "none";
        element.parentNode.insertBefore(element, this.svgObject.children && this.svgObject.children[1]);
      }
      if (this.subTitle) {
        this.renderSubTitle(options);
      }
    };
    CircularChart3D2.prototype.getTextAnchor = function(alignment, enableRTL) {
      switch (alignment) {
        case "Near":
          return enableRTL ? "end" : "start";
        case "Far":
          return enableRTL ? "start" : "end";
        default:
          return "middle";
      }
    };
    CircularChart3D2.prototype.renderSubTitle = function(options) {
      var maxWidth = 0;
      var titleWidth = 0;
      var padding = 10;
      var alignment = this.titleStyle.textAlignment;
      var subTitleElementSize = measureText(this.subTitle, this.subTitleStyle, this.themeStyle.chartSubTitleFont);
      for (var _i = 0, _a = this.titleCollection; _i < _a.length; _i++) {
        var titleText = _a[_i];
        titleWidth = measureText(titleText, this.titleStyle, this.themeStyle.chartTitleFont).width;
        maxWidth = titleWidth > maxWidth ? titleWidth : maxWidth;
      }
      var rect = new Rect(alignment === "Center" ? options.x - maxWidth / 2 : alignment === "Far" ? options.x - maxWidth : options.x, 0, maxWidth, 0);
      var subTitleOption = new TextOption(this.element.id + "-sub-title", titlePositionX(rect, this.subTitleStyle), options.y * options.text.length + subTitleElementSize.height * 3 / 4 + padding, this.getTextAnchor(this.subTitleStyle.textAlignment, this.enableRtl), this.subTitleCollection, "", "auto");
      this.subTitleLocation = {
        x: subTitleOption.x,
        y: subTitleOption.y,
        size: subTitleElementSize
      };
      textElement2(this.renderer, subTitleOption, this.subTitleStyle, this.subTitleStyle.color || this.themeStyle.chartSubTitleFont.color, this.svgObject, false, this.redraw, null, null, null, null, null, null, null, null, this.themeStyle.chartSubTitleFont);
    };
    CircularChart3D2.prototype.setSecondaryElementPosition = function() {
      var tooltipParent = getElement2(this.element.id + "_Secondary_Element");
      if (!tooltipParent) {
        return;
      }
      var rect = this.element.getBoundingClientRect();
      var svgRect = getElement2(this.element.id + "_svg").getBoundingClientRect();
      tooltipParent.style.left = Math.max(svgRect.left - rect.left, 0) + "px";
      tooltipParent.style.top = Math.max(svgRect.top - rect.top, 0) + "px";
    };
    CircularChart3D2.prototype.createPieSvg = function() {
      this.removeSvg();
      createSvg(this);
    };
    CircularChart3D2.prototype.removeSvg = function() {
      if (this.redraw) {
        return null;
      }
      removeElement2(this.element.id + "_Secondary_Element");
      if (this.svgObject) {
        while (this.svgObject.childNodes.length > 0) {
          this.svgObject.removeChild(this.svgObject.firstChild);
        }
        if (!this.svgObject.hasChildNodes() && this.svgObject.parentNode) {
          remove(this.svgObject);
        }
      }
      removeElement2("EJ2_legend_tooltip");
      removeElement2("EJ2_datalabel_tooltip");
      removeElement2(this.element.id + "PointHover_Border");
    };
    CircularChart3D2.prototype.calculateVisibleSeries = function() {
      this.visibleSeries = [];
      this.series[0].index = 0;
      this.visibleSeries.push(this.series[0]);
    };
    CircularChart3D2.prototype.calculateBounds = function() {
      this.initialClipRect = new Rect(this.margin.left, this.margin.top, this.availableSize.width, this.availableSize.height);
      this.titleCollection = [];
      this.subTitleCollection = [];
      var titleHeight = 0;
      var subTitleHeight = 0;
      var maxWidth = 0;
      var titleWidth = 0;
      if (this.title) {
        this.titleCollection = getTitle(this.title, this.titleStyle, this.initialClipRect.width, this.enableRtl, this.themeStyle.chartTitleFont);
      }
      titleHeight = this.title ? measureText(this.title, this.titleStyle, this.themeStyle.chartTitleFont).height * this.titleCollection.length : titleHeight;
      if (this.subTitle) {
        for (var _i = 0, _a = this.titleCollection; _i < _a.length; _i++) {
          var titleText = _a[_i];
          titleWidth = measureText(titleText, this.titleStyle, this.themeStyle.chartTitleFont).width;
          maxWidth = titleWidth > maxWidth ? titleWidth : maxWidth;
        }
        this.subTitleCollection = getTitle(this.subTitle, this.subTitleStyle, maxWidth, this.enableRtl, this.themeStyle.chartSubTitleFont);
        subTitleHeight = measureText(this.subTitle, this.subTitleStyle, this.themeStyle.chartSubTitleFont).height * this.subTitleCollection.length;
      }
      subtractRect(this.initialClipRect, new Rect(0, subTitleHeight + titleHeight, this.margin.right + this.margin.left, this.margin.bottom + this.margin.top));
      this.calculateLegendBounds();
    };
    CircularChart3D2.prototype.calculateLegendBounds = function() {
      if (!this.circularChartLegend3DModule || !this.legendSettings.visible) {
        return null;
      }
      this.circularChartLegend3DModule.getLegendOptions(this, this.visibleSeries);
      this.circularChartLegend3DModule.calculateLegendBounds(this.initialClipRect, this.availableSize, null);
    };
    CircularChart3D2.prototype.print = function(id) {
      var exportChart = new PrintUtils(this);
      exportChart.print(id);
    };
    CircularChart3D2.prototype.export = function(type, fileName) {
      if (this.circularChartExport3DModule) {
        this.circularChartExport3DModule.export(type, fileName);
        if (this.afterExport) {
          this.circularChartExport3DModule.getDataUrl(this);
        }
      }
    };
    CircularChart3D2.prototype.pdfExport = function(fileName, orientation, controls, width, height, isVertical, header, footer, exportToMultiplePage) {
      if (this.circularChartExport3DModule) {
        this.circularChartExport3DModule.pdfExport(fileName, orientation, controls, width, height, isVertical, header, footer, exportToMultiplePage);
      }
    };
    CircularChart3D2.prototype.requiredModules = function() {
      var modules = [];
      modules.push({
        member: this.type + "Series3D",
        args: [this]
      });
      if (this.legendSettings.visible) {
        modules.push({
          member: "CircularChartLegend3D",
          args: [this]
        });
      }
      if (this.series[0].dataLabel.visible) {
        modules.push({
          member: "CircularChartDataLabel3D",
          args: [this]
        });
      }
      if (this.tooltip.enable) {
        modules.push({
          member: "CircularChartTooltip3D",
          args: [this]
        });
      }
      if (this.selectionMode !== "None") {
        modules.push({
          member: "CircularChartSelection3D",
          args: [this]
        });
      }
      if (this.highlightMode !== "None" || this.legendSettings.enableHighlight) {
        modules.push({
          member: "CircularChartHighlight3D",
          args: [this]
        });
      }
      if (this.enableExport) {
        modules.push({
          member: "CircularChartExport3D",
          args: [this]
        });
      }
      return modules;
    };
    CircularChart3D2.prototype.setNavigationStyle = function(target) {
      var tabColor = "";
      switch (this.theme) {
        case "HighContrastLight":
        case "HighContrast":
          tabColor = "#969696";
          break;
        case "MaterialDark":
        case "FabricDark":
        case "Bootstrap":
        case "Bootstrap4":
          tabColor = "#66afe9";
          break;
        case "Tailwind":
        case "TailwindDark":
          tabColor = "#4f46e5";
          break;
        case "Bootstrap5":
        case "Bootstrap5Dark":
          tabColor = "#0d6efd";
          break;
        case "Fluent":
        case "FluentDark":
          tabColor = "#9e9e9e";
          break;
        case "Fluent2":
        case "Fluent2Dark":
        case "Fluent2HighContrast":
          tabColor = "#0078D4";
          break;
        default:
          tabColor = "#9e9e9e";
          break;
      }
      var currentElement = document.getElementById(target);
      if (currentElement) {
        currentElement.style.setProperty("outline", "1.5px solid " + tabColor);
      }
    };
    CircularChart3D2.prototype.removeNavigationStyle = function() {
      var currentElement = document.querySelectorAll("path[id*=_Series_0_Point_], [id*=" + this.element.id + "], [id*=_ChartBorder], text[id*=_title],g[id*=_chart_legend]");
      if (currentElement) {
        currentElement.forEach(function(element) {
          if (element instanceof HTMLElement || element instanceof SVGElement) {
            element.style.setProperty("outline", "none");
          }
        });
      }
    };
    CircularChart3D2.prototype.circular3DChartKeyDown = function(e) {
      var actionKey = "";
      if (this.tooltip.enable && (e.code === "Tab" && this.previousTargetId.indexOf("series") > -1 || this.previousTargetId.indexOf("legend") > -1 || e.code === "Escape")) {
        actionKey = "ESC";
      }
      if (e.code.indexOf("Arrow") > -1) {
        e.preventDefault();
      }
      if (e.ctrlKey && e.key === "p") {
        e.preventDefault();
        actionKey = "CtrlP";
      }
      if (actionKey !== "") {
        this.chartKeyboardNavigations(e, e.target.id, actionKey);
      }
      if (e.code === "Tab") {
        this.removeNavigationStyle();
      }
      return false;
    };
    CircularChart3D2.prototype.chartKeyboardNavigations = function(e, targetId, actionKey) {
      this.isLegendClicked = false;
      switch (actionKey) {
        case "Tab":
        case "ArrowMove":
          if (targetId.indexOf("-point-") > -1) {
            var seriesIndex = 0;
            var pointIndex = parseInt(targetId.split("point-")[1], 10);
            var point = this.visibleSeries[0].points[pointIndex];
            var center = point.symbolLocation.center;
            var dradius = point.symbolLocation.radius * this.visibleSeries[0].coefficient;
            var radius = dradius + (point.symbolLocation.radius - dradius) / 2;
            this.mouseX = center.x + radius * Math.cos(point.symbolLocation.angle);
            this.mouseY = center.y + radius * Math.sin(point.symbolLocation.angle);
            if (this.circularChartHighlight3DModule) {
              var targetElement = getElement2(targetId);
              if (!isNullOrUndefined(targetElement)) {
                if (targetElement.id.indexOf("text") > 1) {
                  targetElement = getElement2(targetElement.id.replace("text", "shape"));
                }
                if (this.circularChartSelection3DModule) {
                  this.circularChartSelection3DModule.calculateSelectedElements(this, targetElement, "mousemove");
                } else {
                  this.circularChartHighlight3DModule.calculateSelectedElements(this, targetElement, "mousemove");
                }
              }
            }
            if (this.circularChartTooltip3DModule) {
              var series = this.visibleSeries[seriesIndex];
              var data = void 0;
              if (series.enableTooltip) {
                data = new CircularChart3DPointData(series.points[pointIndex], series);
              }
              this.circularChartTooltip3DModule.element = this.element;
              this.circularChartTooltip3DModule.control = this;
              this.circularChartTooltip3DModule.renderSeriesTooltip(this, data);
            }
          }
          if (this.circularChartHighlight3DModule && this.highlightMode !== "None") {
            targetId = targetId.indexOf("_chart_legend_g_") > -1 ? document.getElementById(targetId).firstChild["id"] : targetId;
            var legendID = this.element.id + "_chart_legend";
            var legendItemsId = [legendID + "_text_", legendID + "_shape_marker_", legendID + "_shape_"];
            for (var i = 0; i < legendItemsId.length; i++) {
              var id = legendItemsId[i];
              if (targetId.indexOf(id) > -1) {
                document.getElementById(targetId).setAttribute("class", "");
                if (this.circularChartSelection3DModule) {
                  this.circularChartSelection3DModule.legendSelection(this, getElement2(targetId), "mousemove");
                } else {
                  this.circularChartHighlight3DModule.legendSelection(this, getElement2(targetId), "mousemove");
                }
                break;
              }
            }
          }
          break;
        case "Enter":
        case "Space":
          if (targetId.indexOf("_chart_legend_") > -1 && this.circularChartLegend3DModule) {
            this.isLegendClicked = true;
            this.circularChartLegend3DModule.click(e);
            this.focusChild(document.getElementById(targetId).parentElement);
            this.setNavigationStyle(document.getElementById(targetId).parentElement.id);
          } else {
            if (this.circularChartSelection3DModule) {
              this.circularChartSelection3DModule.calculateSelectedElements(this, document.getElementById(targetId), "click");
            }
            this.setNavigationStyle(targetId);
          }
          break;
        case "CtrlP":
          this.print();
          break;
        case "ESC":
          if (this.circularChartTooltip3DModule) {
            this.circularChartTooltip3DModule.removeTooltip(1);
          }
          if (this.circularChartSelection3DModule) {
            this.circularChartSelection3DModule.calculateSelectedElements(this, document.getElementById(this.element.id + "-border"), "mousemove");
          } else if (this.circularChartHighlight3DModule && this.highlightMode !== "None") {
            this.circularChartHighlight3DModule.calculateSelectedElements(this, document.getElementById(this.element.id + "-border"), "mousemove");
          }
          break;
      }
    };
    CircularChart3D2.prototype.focusChild = function(element) {
      element.setAttribute("tabindex", "0");
      var className = element.getAttribute("class");
      element.setAttribute("tabindex", "0");
      if (className && className.indexOf("e-circular3dchart-focused") === -1) {
        className = "e-circular3dchart-focused " + className;
      } else if (!className) {
        className = "e-circular3dchart-focused";
      }
      element.setAttribute("class", className);
      element.focus();
      return element.id;
    };
    CircularChart3D2.prototype.circular3DChartKeyUp = function(e) {
      var actionKey = "";
      var targetId = e.target["id"];
      var legendElement = getElement2(this.element.id + "_chart_legend_translate_g");
      var pagingElement = getElement2(this.element.id + "_chart_legend_pageup");
      if (legendElement) {
        var firstChild = legendElement.firstElementChild;
        var className = firstChild.getAttribute("class");
        if (className && className.indexOf("e-circular3dchart-focused") === -1) {
          className = className + " e-circular3dchart-focused";
        } else if (!className) {
          className = "e-circular3dchart-focused";
        }
        firstChild.setAttribute("class", className);
      }
      if (pagingElement) {
        pagingElement.setAttribute("class", "e-circular3dchart-focused");
      }
      this.removeNavigationStyle();
      if (e.code === "Tab") {
        if (this.previousTargetId !== "") {
          if (this.previousTargetId.indexOf("-point-") > -1 && targetId.indexOf("-point-") === -1) {
            this.currentPointIndex = 0;
          } else if (this.previousTargetId.indexOf("_chart_legend_page") > -1 && targetId.indexOf("_chart_legend_page") === -1 && targetId.indexOf("_chart_legend_g_") === -1) {
            this.setTabIndex(e.target, pagingElement);
          } else if (this.previousTargetId.indexOf("_chart_legend_g_") > -1 && targetId.indexOf("chart_legend_g_") === -1) {
            this.setTabIndex(legendElement.children[this.currentLegendIndex], legendElement.firstElementChild);
          } else if (this.previousTargetId.indexOf("-title") > -1 && targetId.indexOf("-point-") > -1) {
            this.currentPointIndex = parseInt(targetId.split("point-")[1], 10);
          }
        }
        this.previousTargetId = targetId;
        if (targetId.indexOf("_chart_legend_g_") > -1 && this.highlightMode !== "None") {
          targetId = e.target["lastElementChild"].id;
          actionKey = "Tab";
        } else if (targetId.indexOf("-point-") > -1 && (this.highlightMode !== "None" || this.tooltip.enable)) {
          actionKey = "Tab";
        }
      } else if (e.code.indexOf("Arrow") > -1) {
        e.preventDefault();
        if (targetId.indexOf("_chart_legend_page") > -1) {
          e.target.removeAttribute("tabindex");
          this.previousTargetId = targetId = this.element.id + "_chart_legend_page" + (e.code === "ArrowRight" ? "up" : "down");
          this.focusTarget(getElement2(targetId));
        } else if (targetId.indexOf("_chart_legend_") > -1) {
          e.target.removeAttribute("tabindex");
          this.currentLegendIndex += e.code === "ArrowUp" || e.code === "ArrowRight" ? 1 : -1;
          this.currentLegendIndex = this.getActualIndex(this.currentLegendIndex, legendElement.children.length);
          var currentLegend = legendElement.children[this.currentLegendIndex];
          this.focusTarget(currentLegend);
          this.removeNavigationStyle();
          this.setNavigationStyle(currentLegend.id);
          this.previousTargetId = targetId = currentLegend.lastElementChild.id;
          actionKey = this.highlightMode !== "None" ? "ArrowMove" : "";
        } else if (targetId.indexOf("-point-") > -1) {
          e.target.setAttribute("tabindex", "-1");
          var totalLength = 0;
          var seriesIndexes = [];
          for (var i = 0; i < this.visibleSeries[0].points.length; i++) {
            var point = this.visibleSeries[0].points[i];
            totalLength = point.visible ? totalLength + 1 : totalLength;
            if (this.visibleSeries[0].points[i].visible) {
              seriesIndexes.push(this.visibleSeries[0].points[i].index);
            }
          }
          this.currentPointIndex = seriesIndexes.indexOf(this.currentPointIndex) + (e.code === "ArrowUp" || e.code === "ArrowRight" ? 1 : -1);
          this.currentPointIndex = seriesIndexes[this.getActualIndex(this.currentPointIndex, seriesIndexes.length)];
          var elements = document.querySelectorAll('[id*="region-series-0-point-' + this.currentPointIndex + '"]');
          var element = void 0;
          if (elements.length > 0) {
            element = elements[elements.length - 1];
          }
          targetId = element ? element.id : "";
          this.focusTarget(getElement2(targetId));
          this.removeNavigationStyle();
          this.setNavigationStyle(targetId);
          actionKey = this.tooltip.enable || this.circularChartHighlight3DModule ? "ArrowMove" : "";
        }
      } else if ((e.code === "Enter" || e.code === "Space") && (targetId.indexOf("_chart_legend_") > -1 || targetId.indexOf("-point-") > -1)) {
        targetId = targetId.indexOf("_chart_legend_g") > -1 ? e.target["lastElementChild"].id : targetId;
        actionKey = "Enter";
      }
      if (actionKey !== "") {
        this.chartKeyboardNavigations(e, targetId, actionKey);
      }
      if (e.code === "Tab") {
        this.setNavigationStyle(targetId);
      }
      return false;
    };
    CircularChart3D2.prototype.getActualIndex = function(index, totalLength) {
      return index > totalLength - 1 ? 0 : index < 0 ? totalLength - 1 : index;
    };
    CircularChart3D2.prototype.focusTarget = function(element) {
      var className = element.getAttribute("class");
      element.setAttribute("tabindex", "0");
      if (className && className.indexOf("e-circular3dchart-focused") === -1) {
        className = className + " e-circular3dchart-focused";
      } else if (!className) {
        className = "e-circular3dchart-focused";
      }
      element.setAttribute("tabindex", "0");
      element.setAttribute("class", className);
      element.focus();
      return element.id;
    };
    CircularChart3D2.prototype.setTabIndex = function(previousElement, currentElement) {
      if (previousElement) {
        previousElement.removeAttribute("tabindex");
      }
      if (currentElement) {
        currentElement.setAttribute("tabindex", "0");
      }
    };
    CircularChart3D2.prototype.getPersistData = function() {
      return "";
    };
    CircularChart3D2.prototype.getModuleName = function() {
      return "circularchart3d";
    };
    CircularChart3D2.prototype.destroy = function() {
      if (this.element) {
        this.unWireEvents();
        this.circular3DPolygon = [];
        this.visibleSeries[0].segments = [];
        _super.prototype.destroy.call(this);
        this.element.classList.remove("e-circular3dchart");
        this.element.classList.remove("e-circular3dchart-focused");
        var element = document.getElementById(this.element.id + "Keyboard_circular3dchart_focus");
        if (element) {
          element.remove();
        }
        var highlightElement = document.getElementById(this.element.id + "_ej2_chart_highlight");
        if (highlightElement) {
          highlightElement.remove();
        }
        var selectionElement = document.getElementById(this.element.id + "_ej2_chart_selection");
        if (selectionElement) {
          selectionElement.remove();
        }
        removeElement2("chartmeasuretext");
        this.removeSvg();
        this.svgObject = null;
      }
    };
    CircularChart3D2.prototype.chartResize = function() {
      var _this = this;
      this.animateSeries = false;
      var args = {
        previousSize: new Size(this.availableSize.width, this.availableSize.height),
        currentSize: new Size(0, 0),
        chart: this
      };
      var beforeResizeArgs = {
        cancel: false
      };
      if (this.resizeTo) {
        clearTimeout(this.resizeTo);
      }
      this.trigger(beforeResize, beforeResizeArgs);
      if (!beforeResizeArgs.cancel) {
        this.resizeTo = +setTimeout(function() {
          if (_this.isDestroyed) {
            clearTimeout(_this.resizeTo);
            return;
          }
          calculateSize(_this);
          args.currentSize = _this.availableSize;
          _this.trigger(resized, args);
          _this.refreshChart();
        }, 500);
      }
      return false;
    };
    CircularChart3D2.prototype.changeVisibleSeries = function(visibleSeries, index) {
      for (var _i = 0, visibleSeries_1 = visibleSeries; _i < visibleSeries_1.length; _i++) {
        var series = visibleSeries_1[_i];
        if (index === series.index) {
          return series;
        }
      }
      return null;
    };
    CircularChart3D2.prototype.removeSeriesElements = function(chart) {
      document.querySelectorAll('[id*="region-series-"]').forEach(function(element) {
        if (element.parentElement.id === chart.groupElement.id) {
          return element.remove();
        }
      });
      document.querySelectorAll('[id*="data-label-text-"]').forEach(function(element) {
        if (element.parentElement.id === chart.groupElement.id) {
          return element.remove();
        }
      });
      document.querySelectorAll('[id*="data-label-series-0-shape-"]').forEach(function(element) {
        if (element.parentElement.id === chart.groupElement.id) {
          return element.remove();
        }
      });
      document.querySelectorAll('[id*="datalabel-series-0-connector-"]').forEach(function(element) {
        if (element.parentElement.id === chart.groupElement.id) {
          return element.remove();
        }
      });
    };
    CircularChart3D2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var update = {
        refreshElements: false,
        refreshBounds: false
      };
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "theme":
            this.animateSeries = true;
            break;
          case "title":
          case "subTitle":
          case "height":
          case "width":
          case "margin":
          case "enableRotation":
          case "depth":
            update.refreshBounds = true;
            break;
          case "tilt":
          case "rotation":
            if (!this.rotateActivate) {
              update.refreshBounds = true;
              this.animateSeries = false;
            }
            break;
          case "titleStyle":
            if (newProp.titleStyle && (newProp.titleStyle.size || newProp.titleStyle.textOverflow)) {
              update.refreshBounds = true;
            } else {
              update.refreshElements = true;
            }
            break;
          case "subTitleStyle":
            if (newProp.subTitleStyle && (newProp.subTitleStyle.size || newProp.subTitleStyle.textOverflow)) {
              update.refreshBounds = true;
            } else {
              update.refreshElements = true;
            }
            break;
          case "legendSettings":
            update.refreshBounds = true;
            update.refreshElements = true;
            break;
          case "dataSource":
            this.processData(false);
            update.refreshBounds = true;
            break;
          case "series":
            if (!this.delayRedraw) {
              var seriesRefresh = false;
              var series = void 0;
              var seriesRender3 = void 0;
              for (var i = 0; i < this.series.length; i++) {
                series = newProp.series[i];
                if (series.explodeOffset || series.radius || series.innerRadius || series.emptyPointSettings) {
                  seriesRender3 = true;
                }
                if (newProp.series[i] && (newProp.series[i].dataSource || newProp.series[i].yName || newProp.series[i].xName || newProp.series[i].dataLabel || seriesRender3)) {
                  extend(this.changeVisibleSeries(this.visibleSeries, i), series, null, true);
                  seriesRefresh = true;
                }
                if (newProp.series[i] && !isNullOrUndefined(newProp.series[i].explodeIndex) && newProp.series[i].explodeIndex >= 0 && newProp.series[i].explodeIndex !== oldProp.series[i].explodeIndex) {
                  seriesRefresh = true;
                  this.removeSeriesElements(this);
                }
              }
              if (seriesRefresh) {
                this.processData(false);
                update.refreshBounds = true;
              }
            }
            this.delayRedraw = false;
            this.redraw = false;
            break;
          case "enableRtl":
          case "locale":
            if (this.circularChartHighlight3DModule) {
              removeElement2(this.circularChartHighlight3DModule.styleId);
            }
            if (this.circularChartSelection3DModule) {
              removeElement2(this.circularChartSelection3DModule.styleId);
            }
            _super.prototype.refresh.call(this);
            break;
          case "background":
          case "border":
            update.refreshElements = true;
            break;
          case "isMultiSelect":
          case "selectedDataIndexes":
          case "selectionMode":
            if (this.circularChartSelection3DModule) {
              if (isNullOrUndefined(this.circularChartSelection3DModule.selectedDataIndexes)) {
                this.circularChartSelection3DModule.invokeSelection(this);
              } else {
                this.circularChartSelection3DModule.selectedDataIndexes = this.selectedDataIndexes;
                this.circularChartSelection3DModule.redrawSelection(this);
              }
            }
            break;
          case "tooltip":
            if (this.circularChartTooltip3DModule) {
              this.circularChartTooltip3DModule.previousPoints = [];
              if (this.tooltip.template) {
                this.circularChartTooltip3DModule.template = this.tooltip.template;
              }
            }
            break;
        }
        if (!update.refreshBounds && update.refreshElements) {
          this.removeSeriesElements(this);
          this.createPieSvg();
          this.circular3DPolygon = [];
          this.visibleSeries[0].segments = [];
          this.renderElements();
        } else if (update.refreshBounds) {
          this.removeSeriesElements(this);
          this.createPieSvg();
          this.circular3DPolygon = [];
          this.visibleSeries[0].segments = [];
          this.calculateBounds();
          this.renderElements();
        }
      }
    };
    __decorate35([Property(null)], CircularChart3D2.prototype, "width", void 0);
    __decorate35([Property(null)], CircularChart3D2.prototype, "height", void 0);
    __decorate35([Property(null)], CircularChart3D2.prototype, "title", void 0);
    __decorate35([Property(null)], CircularChart3D2.prototype, "backgroundImage", void 0);
    __decorate35([Property("")], CircularChart3D2.prototype, "dataSource", void 0);
    __decorate35([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, Font)], CircularChart3D2.prototype, "titleStyle", void 0);
    __decorate35([Property(null)], CircularChart3D2.prototype, "subTitle", void 0);
    __decorate35([Complex({
      fontFamily: null,
      size: null,
      fontStyle: null,
      fontWeight: null,
      color: null
    }, Font)], CircularChart3D2.prototype, "subTitleStyle", void 0);
    __decorate35([Property("None")], CircularChart3D2.prototype, "selectionMode", void 0);
    __decorate35([Property("None")], CircularChart3D2.prototype, "highlightMode", void 0);
    __decorate35([Collection([{}], CircularChart3DSeries)], CircularChart3D2.prototype, "series", void 0);
    __decorate35([Complex({}, CircularChart3DLegendSettings)], CircularChart3D2.prototype, "legendSettings", void 0);
    __decorate35([Property("")], CircularChart3D2.prototype, "highlightColor", void 0);
    __decorate35([Property("None")], CircularChart3D2.prototype, "selectionPattern", void 0);
    __decorate35([Property("None")], CircularChart3D2.prototype, "highlightPattern", void 0);
    __decorate35([Property(false)], CircularChart3D2.prototype, "isMultiSelect", void 0);
    __decorate35([Property(true)], CircularChart3D2.prototype, "enableAnimation", void 0);
    __decorate35([Property("Material")], CircularChart3D2.prototype, "theme", void 0);
    __decorate35([Collection([], Indexes)], CircularChart3D2.prototype, "selectedDataIndexes", void 0);
    __decorate35([Complex({}, Margin)], CircularChart3D2.prototype, "margin", void 0);
    __decorate35([Complex({
      color: "#DDDDDD",
      width: 0
    }, Border)], CircularChart3D2.prototype, "border", void 0);
    __decorate35([Complex({}, CircularChart3DTooltipSettings)], CircularChart3D2.prototype, "tooltip", void 0);
    __decorate35([Property(null)], CircularChart3D2.prototype, "background", void 0);
    __decorate35([Property(false)], CircularChart3D2.prototype, "useGroupingSeparator", void 0);
    __decorate35([Property(50)], CircularChart3D2.prototype, "depth", void 0);
    __decorate35([Property(0)], CircularChart3D2.prototype, "tilt", void 0);
    __decorate35([Property(false)], CircularChart3D2.prototype, "enableRotation", void 0);
    __decorate35([Property(0)], CircularChart3D2.prototype, "rotation", void 0);
    __decorate35([Property(false)], CircularChart3D2.prototype, "enableExport", void 0);
    __decorate35([Event()], CircularChart3D2.prototype, "load", void 0);
    __decorate35([Event()], CircularChart3D2.prototype, "loaded", void 0);
    __decorate35([Event()], CircularChart3D2.prototype, "legendRender", void 0);
    __decorate35([Event()], CircularChart3D2.prototype, "legendClick", void 0);
    __decorate35([Event()], CircularChart3D2.prototype, "selectionComplete", void 0);
    __decorate35([Event()], CircularChart3D2.prototype, "pointRender", void 0);
    __decorate35([Event()], CircularChart3D2.prototype, "seriesRender", void 0);
    __decorate35([Event()], CircularChart3D2.prototype, "textRender", void 0);
    __decorate35([Event()], CircularChart3D2.prototype, "beforeExport", void 0);
    __decorate35([Event()], CircularChart3D2.prototype, "afterExport", void 0);
    __decorate35([Event()], CircularChart3D2.prototype, "beforePrint", void 0);
    __decorate35([Event()], CircularChart3D2.prototype, "beforeResize", void 0);
    __decorate35([Event()], CircularChart3D2.prototype, "resized", void 0);
    __decorate35([Event()], CircularChart3D2.prototype, "circularChart3DMouseMove", void 0);
    __decorate35([Event()], CircularChart3D2.prototype, "circularChart3DMouseClick", void 0);
    __decorate35([Event()], CircularChart3D2.prototype, "circularChart3DMouseDown", void 0);
    __decorate35([Event()], CircularChart3D2.prototype, "circularChart3DMouseLeave", void 0);
    __decorate35([Event()], CircularChart3D2.prototype, "circularChart3DMouseUp", void 0);
    __decorate35([Event()], CircularChart3D2.prototype, "pointClick", void 0);
    __decorate35([Event()], CircularChart3D2.prototype, "pointMove", void 0);
    __decorate35([Event()], CircularChart3D2.prototype, "tooltipRender", void 0);
    CircularChart3D2 = __decorate35([NotifyPropertyChanges], CircularChart3D2);
    return CircularChart3D2;
  }(Component)
);

// node_modules/@syncfusion/ej2-charts/src/circularchart3d/print-export/export.js
var CircularChartExport3D = (
  /** @class */
  function() {
    function CircularChartExport3D2(chart) {
      this.chart = chart;
    }
    CircularChartExport3D2.prototype.export = function(type, fileName) {
      var exportChart = new ExportUtils(this.chart);
      var argsData = {
        cancel: false,
        width: null,
        height: null
      };
      this.chart.trigger(beforeExport, argsData);
      if (!argsData.cancel) {
        exportChart.export(type, fileName, void 0, [this.chart]);
      }
    };
    CircularChartExport3D2.prototype.pdfExport = function(fileName, orientation, controls, width, height, isVertical, header, footer, exportToMultiplePage) {
      var exportChart = new ExportUtils(this.chart);
      controls = controls ? controls : [this.chart];
      var argsData = {
        cancel: false,
        width,
        height
      };
      this.chart.trigger(beforeExport, argsData);
      if (!argsData.cancel) {
        exportChart.export("PDF", fileName, orientation, controls, width = argsData.width, height = argsData.height, isVertical, header, footer, exportToMultiplePage);
      }
    };
    CircularChartExport3D2.prototype.getDataUrl = function(chart) {
      var exportUtil = new ExportUtils(chart);
      return exportUtil.getDataUrl(chart);
    };
    CircularChartExport3D2.prototype.getModuleName = function() {
      return "CircularChartExport3D";
    };
    CircularChartExport3D2.prototype.destroy = function() {
    };
    return CircularChartExport3D2;
  }()
);

// node_modules/@syncfusion/ej2-charts/src/circularchart3d/user-interaction/selection.js
var __extends116 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var CircularChartSelection3D = (
  /** @class */
  function(_super) {
    __extends116(CircularChartSelection3D2, _super);
    function CircularChartSelection3D2(circular3D) {
      var _this = _super.call(this, circular3D) || this;
      _this.circular3D = circular3D;
      _this.renderer = circular3D.renderer;
      _this.addEventListener();
      return _this;
    }
    CircularChartSelection3D2.prototype.addEventListener = function() {
      if (this.circular3D.isDestroyed) {
        return;
      }
      this.circular3D.on(Browser.touchMoveEvent, this.mouseMove, this);
      this.circular3D.on("click", this.mouseClick, this);
    };
    CircularChartSelection3D2.prototype.removeEventListener = function() {
      if (this.circular3D.isDestroyed) {
        return;
      }
      this.circular3D.off(Browser.touchMoveEvent, this.mouseMove);
      this.circular3D.off("click", this.mouseClick);
    };
    CircularChartSelection3D2.prototype.initPrivateVariables = function(circular3D) {
      this.styleId = circular3D.element.id + "_ej2_chart_selection";
      this.unselected = circular3D.element.id + "_ej2_deselected";
      this.selectedDataIndexes = [];
      this.rectPoints = null;
    };
    CircularChartSelection3D2.prototype.invokeSelection = function(circular3D) {
      this.initPrivateVariables(circular3D);
      this.series = extend({}, circular3D.visibleSeries, null, true);
      this.seriesStyles();
      this.currentMode = circular3D.selectionMode;
      this.selectDataIndex(this.concatIndexes(circular3D.selectedDataIndexes, this.selectedDataIndexes), circular3D);
    };
    CircularChartSelection3D2.prototype.generateStyle = function(series, point) {
      return this.styleId + "_series_" + series.index + "_point_" + point;
    };
    CircularChartSelection3D2.prototype.getElementByIndex = function(index) {
      var _this = this;
      var pointElements = [];
      var elements = document.querySelectorAll('[id*="-region-series-' + index.series + "-point-" + index.point + '"]');
      elements.forEach(function(pointElement) {
        if (pointElement.id.indexOf(_this.circular3D.element.id + "-") > -1 && _this.indexFinder(pointElement.id).point === index.point) {
          pointElements.push(pointElement);
        }
      });
      var element = document.getElementById(this.control.element.id + "-svg-data-label-text-" + index.point);
      var connectorElement = document.getElementById(this.control.element.id + "-datalabel-series-0-connector-" + index.point);
      var shapeElement = document.getElementById(this.control.element.id + "-svg-data-label-series-0-shape-" + index.point);
      if (element) {
        pointElements.push(element);
      }
      if (connectorElement) {
        pointElements.push(connectorElement);
      }
      if (shapeElement) {
        pointElements.push(shapeElement);
      }
      return pointElements;
    };
    CircularChartSelection3D2.prototype.isAlreadySelected = function(targetElement, eventType, index) {
      if (eventType === "mousemove") {
        this.currentMode = this.circular3D.highlightMode;
        this.highlightDataIndexes = [];
        this.styleId = this.circular3D.element.id + "_ej2_chart_highlight";
      } else if (eventType === "click" || eventType === "keyup") {
        this.currentMode = this.circular3D.selectionMode;
        this.styleId = this.circular3D.element.id + "_ej2_chart_selection";
      }
      if (this.circular3D.highlightMode !== "None" && this.circular3D.selectionMode === "None") {
        if (eventType === "click") {
          return false;
        }
      }
      if ((this.circular3D.highlightMode !== "None" || this.circular3D.legendSettings.enableHighlight) && this.previousSelectedElement && this.previousSelectedElement[0]) {
        var isElement = void 0;
        var nodeName = targetElement.nodeName;
        if (targetElement.parentNode) {
          isElement = (nodeName === "path" || nodeName === "shape") && targetElement.id.indexOf("region") > 1 ? true : false;
        }
        var _loop_1 = function(i2) {
          if (this_1.previousSelectedElement[i2].hasAttribute("class")) {
            if (this_1.previousSelectedElement[i2].getAttribute("class").indexOf("highlight") > -1 && (isElement || eventType === "click" || eventType === "keyup")) {
              var selectionClass_1;
              this_1.previousSelectedElement[i2].classList.forEach(function(className) {
                if (className.indexOf("selection") > -1) {
                  selectionClass_1 = className;
                }
              });
              this_1.previousSelectedElement[i2].removeAttribute("class");
              if (selectionClass_1) {
                this_1.addSvgClass(this_1.previousSelectedElement[i2], selectionClass_1);
              }
              this_1.previousSelectedElement[i2].classList.remove(this_1.styleId + "_series_" + index.series);
              this_1.addOrRemoveIndex(this_1.highlightDataIndexes, this_1.indexFinder(this_1.previousSelectedElement[i2].id));
            } else if (!isElement && this_1.previousSelectedElement[i2].getAttribute("class").indexOf("highlight") > -1) {
              this_1.performSelection(this_1.indexFinder(this_1.previousSelectedElement[i2].id), this_1.circular3D, this_1.previousSelectedElement[i2]);
            }
          }
        };
        var this_1 = this;
        for (var i = 0; i < this.previousSelectedElement.length; i++) {
          _loop_1(i);
        }
      }
      return true;
    };
    CircularChartSelection3D2.prototype.mouseClick = function(circular3D, event2) {
      this.calculateSelectedElements(circular3D, event2.target, event2.type);
    };
    CircularChartSelection3D2.prototype.calculateSelectedElements = function(circular3D, targetElement, eventType) {
      if (isNullOrUndefined(targetElement)) {
        return;
      }
      if (circular3D.selectionMode === "None" && circular3D.highlightMode === "None" || targetElement.id && targetElement.id.indexOf(circular3D.element.id + "-") === -1) {
        return;
      }
      if (targetElement.getAttribute("id").indexOf("_connector_") > -1) {
        return;
      } else {
        this.isAlreadySelected(targetElement, eventType, this.indexFinder(targetElement.id));
        if (targetElement.id.indexOf("-series-") > -1 || targetElement.id.indexOf("-data-label-") > -1) {
          this.performSelection(this.indexFinder(targetElement.id), circular3D, targetElement);
        }
      }
    };
    CircularChartSelection3D2.prototype.indexFinder = function(id) {
      var ids = ["NaN", "NaN"];
      if (id.indexOf("-point-") > -1) {
        ids = id.split("-series-")[1].split("-point-");
      } else if (id.indexOf("-border-") > -1) {
        ids[0] = id.split("-border-")[1];
      } else if (id.indexOf("data-label-series-0-shape-") > -1 && this.control.series[0].dataLabel.position === "Inside") {
        ids[0] = "0";
        ids[1] = id.split("-shape-")[1];
      } else if (id.indexOf("-series-") > -1) {
        ids[0] = id.split("-series-")[1];
      } else if (id.indexOf("_chart_legend_shape_") > -1) {
        ids = id.split("_chart_legend_shape_");
        ids[0] = "0";
      } else if (id.indexOf("_chart_legend_g_") > -1) {
        ids = id.split("_chart_legend_g_");
        ids[0] = "0";
      } else if (id.indexOf("-data-label-") > -1) {
        ids[0] = "0";
        ids[1] = id.split("-data-label-text-")[1];
      } else if (id.indexOf("-connector-") > -1) {
        ids[0] = "0";
        ids[1] = id.split("-connector-")[1];
      }
      return new Index(parseInt(ids[0], 10), parseInt(ids[1], 10));
    };
    CircularChartSelection3D2.prototype.performSelection = function(index, circular3D, element) {
      if (!isNaN(index.point) && this.currentMode === "Point" && element && this.getElementByIndex(index).length > 0) {
        this.selection(circular3D, index, this.getElementByIndex(index));
        this.selectionComplete(circular3D, circular3D.series[0]);
        this.blurEffect(circular3D.element.id, circular3D.visibleSeries);
      }
    };
    CircularChartSelection3D2.prototype.selectionComplete = function(circular3D, series) {
      var pointIndex;
      var selectedPointValues = [];
      for (var i = 0; i < this.selectedDataIndexes.length; i++) {
        pointIndex = this.selectedDataIndexes[i].point;
        if (!isNaN(pointIndex)) {
          selectedPointValues.push({
            x: series.dataSource[pointIndex][series.xName],
            y: series.points[pointIndex].y,
            seriesIndex: this.selectedDataIndexes[i].series,
            pointIndex
          });
        }
      }
      var args = {
        name: selectionComplete,
        selectedDataValues: selectedPointValues,
        cancel: false
      };
      circular3D.trigger(selectionComplete, args);
    };
    CircularChartSelection3D2.prototype.selection = function(circular3D, index, selectedElements) {
      if (!circular3D.isMultiSelect && this.styleId.indexOf("highlight") === -1 && circular3D.selectionMode !== "None") {
        this.removeMultiSelectElements(circular3D, this.selectedDataIndexes, index);
      }
      var className = selectedElements[0] && (selectedElements[0].getAttribute("class") || "");
      if (selectedElements[0] && className.indexOf(this.getSelectionClass(selectedElements[0].id)) > -1) {
        this.removeStyles(selectedElements);
        if (this.styleId.indexOf("highlight") > 0 && (circular3D.highlightMode !== "None" || circular3D.legendSettings.enableHighlight)) {
          this.addOrRemoveIndex(this.highlightDataIndexes, index);
        } else {
          this.addOrRemoveIndex(this.selectedDataIndexes, index);
        }
      } else {
        this.previousSelectedElement = circular3D.highlightMode !== "None" ? selectedElements : [];
        if (className.indexOf("selection") < 0) {
          this.applyStyles(selectedElements, index);
        }
        if (this.styleId.indexOf("highlight") > 0 && (circular3D.highlightMode !== "None" || circular3D.legendSettings.enableHighlight)) {
          this.addOrRemoveIndex(this.highlightDataIndexes, index, true);
        } else {
          this.addOrRemoveIndex(this.selectedDataIndexes, index, true);
        }
      }
    };
    CircularChartSelection3D2.prototype.redrawSelection = function(circular3D) {
      var selectedDataIndexes = extend([], this.selectedDataIndexes, null, true);
      var highlightDataIndexes = extend([], this.highlightDataIndexes, null, true);
      if (this.styleId.indexOf("highlight") > 0 && highlightDataIndexes.length > 0) {
        this.removeSelectedElements(circular3D, this.highlightDataIndexes);
        selectedDataIndexes = highlightDataIndexes;
      } else {
        this.removeSelectedElements(circular3D, this.selectedDataIndexes);
      }
      this.blurEffect(circular3D.element.id, circular3D.visibleSeries);
      this.selectDataIndex(selectedDataIndexes, circular3D);
    };
    CircularChartSelection3D2.prototype.removeSelectedElements = function(circular3D, indexes) {
      for (var _i = 0, indexes_1 = indexes; _i < indexes_1.length; _i++) {
        var index = indexes_1[_i];
        this.removeStyles(this.getElementByIndex(index));
      }
      var points = circular3D.visibleSeries[0].points;
      for (var i = 0; i < points.length; i++) {
        var index = new Index(0, points[i].index);
        this.removeStyles(this.getElementByIndex(index).length === 0 ? [document.getElementById(this.control.element.id + "_chart_legend_shape_" + index.point)] : this.getElementByIndex(index));
      }
    };
    CircularChartSelection3D2.prototype.legendSelection = function(chart, targetElement, eventType) {
      if (eventType === "mousemove") {
        if (targetElement.id.indexOf("text") > 1) {
          targetElement = getElement2(targetElement.id.replace("text", "shape"));
        }
        if (targetElement.id.indexOf("marker") > 1) {
          targetElement = getElement2(targetElement.id.replace("_marker", ""));
        }
        if (targetElement.id.indexOf("g") > 1) {
          targetElement = getElement2(targetElement.id.replace("_g_", "_shape_"));
        }
        if (targetElement.hasAttribute("class") && (targetElement.getAttribute("class").indexOf("highlight") > -1 || targetElement.getAttribute("class").indexOf("selection") > -1)) {
          return;
        }
        this.currentMode = this.circular3D.highlightMode;
      } else if (eventType === "click") {
        if (targetElement.id.indexOf("text") > 1) {
          targetElement = getElement2(targetElement.id.replace("text", "shape"));
        }
        if (targetElement.id.indexOf("g") > 1) {
          targetElement = getElement2(targetElement.id.replace("_g_", "_shape_"));
        }
      }
      var index = this.indexFinder(targetElement.id);
      var isPreSelected = this.isAlreadySelected(targetElement, eventType, index);
      if (isPreSelected) {
        var seriesStyle = this.generateStyle(chart.visibleSeries[index.series], index.point);
        var selectedElements = document.querySelectorAll("." + seriesStyle);
        var isBlurEffectNeeded = true;
        if (selectedElements.length > 0) {
          this.removeSelection(chart, index.series, selectedElements, seriesStyle, isBlurEffectNeeded, index);
        } else {
          for (var _i = 0, _a = chart.visibleSeries[0].points; _i < _a.length; _i++) {
            var element = _a[_i];
            if (element.index !== index.point && (!chart.isMultiSelect || seriesStyle.indexOf("highlight") > 0)) {
              seriesStyle = this.generateStyle(chart.visibleSeries[index.series], element.index);
              selectedElements = document.querySelectorAll("." + seriesStyle);
              this.removeSelection(chart, index.series, selectedElements, seriesStyle, isBlurEffectNeeded, index);
            }
          }
          var seriesElements = [];
          seriesElements = this.getElementByIndex(index);
          if (seriesElements.length > 0) {
            this.checkSelectionElements(seriesElements, seriesStyle, false, index.point);
            this.selection(chart, index, seriesElements);
            this.blurEffect(chart.element.id, chart.visibleSeries);
          }
        }
      }
    };
    CircularChartSelection3D2.prototype.selectDataIndex = function(indexes, circular3D) {
      var element;
      for (var _i = 0, indexes_2 = indexes; _i < indexes_2.length; _i++) {
        var index = indexes_2[_i];
        element = this.getElementByIndex(index)[0];
        if (element) {
          this.performSelection(index, circular3D, element);
        }
      }
    };
    CircularChartSelection3D2.prototype.removeMultiSelectElements = function(circular3D, index, currentIndex) {
      for (var i = 0; i < index.length; i++) {
        if (!this.checkEquals(index[i], currentIndex)) {
          this.removeStyles(this.getElementByIndex(index[i]));
          index.splice(i, 1);
          i--;
        }
      }
    };
    CircularChartSelection3D2.prototype.blurEffect = function(pieId, visibleSeries) {
      var visibility = this.checkVisibility(this.highlightDataIndexes) || this.checkVisibility(this.selectedDataIndexes);
      for (var _i = 0, _a = visibleSeries[0].points; _i < _a.length; _i++) {
        var point = _a[_i];
        var pointElements = [];
        if (point.visible) {
          pointElements = this.getElementByIndex({
            series: 0,
            point: point.index
          });
          this.checkSelectionElements(pointElements, this.generateStyle(visibleSeries[0], point.index), visibility, point.index);
        }
      }
    };
    CircularChartSelection3D2.prototype.checkSelectionElements = function(element, className, visibility, point) {
      if (point === void 0) {
        point = 0;
      }
      var children = element;
      if (this.circular3D.selectionMode !== "None" && (this.circular3D.highlightMode !== "None" || this.circular3D.legendSettings.enableHighlight)) {
        children = element;
      }
      var elementClassName;
      var legendShape;
      var selectElement = element;
      for (var i = 0; i < children.length; i++) {
        elementClassName = children[i].getAttribute("class") || "";
        if (this.circular3D.selectionMode !== "None" && (this.circular3D.highlightMode !== "None" || this.circular3D.legendSettings.enableHighlight)) {
          className = elementClassName.indexOf("selection") > 0 || elementClassName.indexOf("highlight") > 0 ? elementClassName : className;
        }
        if (elementClassName.indexOf(className) === -1 && visibility) {
          this.addSvgClass(children[i], this.unselected);
        } else {
          selectElement = children[i];
          if (elementClassName.indexOf(this.unselected) !== -1 && className.indexOf("highlight") > 0) {
            this.circular3D.highlightAnimation(children[i], 700, 0.3);
          }
          this.removeSvgClass(children[i], this.unselected);
          this.removeSvgClass(children[i].parentNode, this.unselected);
        }
        if (children[i].id.indexOf("-data-label-text-") !== -1 || children[i].id.indexOf("-connector-") !== -1 || children[i].id.indexOf("-data-label-series-0-shape-") !== -1) {
          if (this.highlightDataIndexes && this.highlightDataIndexes[0] && point === this.highlightDataIndexes[0].point) {
            this.removeSvgClass(children[i], this.unselected);
          }
          if (this.selectedDataIndexes) {
            for (var j = 0; j < this.selectedDataIndexes.length; j++) {
              if (point === this.selectedDataIndexes[j].point) {
                this.removeSvgClass(children[i], this.unselected);
              }
            }
          }
        }
      }
      if (this.control.circularChartLegend3DModule && this.control.legendSettings.visible) {
        legendShape = getElement2(this.control.element.id + "_chart_legend_shape_" + point);
        if (legendShape) {
          if (legendShape.hasAttribute("class")) {
            this.removeSvgClass(legendShape, legendShape.getAttribute("class"));
          }
          if (selectElement.length > 0) {
            elementClassName = selectElement[0].getAttribute("class");
          } else if (selectElement) {
            elementClassName = selectElement.getAttribute("class") || "";
          }
          if (elementClassName.indexOf(className) === -1 && visibility) {
            this.addSvgClass(legendShape, this.unselected);
          } else {
            this.removeSvgClass(legendShape, this.unselected);
            if (elementClassName === "") {
              this.removeSvgClass(legendShape, className);
            } else {
              this.addSvgClass(legendShape, className);
            }
          }
        }
      }
    };
    CircularChartSelection3D2.prototype.applyStyles = function(elements, index) {
      var circular3DTooltip = this.control.circularChartTooltip3DModule;
      for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
        var element = elements_1[_i];
        if (element) {
          this.removeSvgClass(element.parentNode, this.unselected);
          this.removeSvgClass(element, this.unselected);
          var opacity = circular3DTooltip && circular3DTooltip.previousPoints.length > 0 && circular3DTooltip.previousPoints[0].point.index !== index.point ? circular3DTooltip.svgTooltip.opacity : this.series[index.series].opacity;
          element.setAttribute("opacity", opacity.toString());
          if (element.id.indexOf("-data-label-text-") === -1 && element.id.indexOf("-connector-") === -1 && element.id.indexOf("-data-label-series-0-shape-") === -1) {
            this.addSvgClass(element, this.getSelectionClass(element.id));
          }
          if (this.getSelectionClass(element.id).indexOf("highlight") > 0) {
            this.circular3D.stopElementAnimation(element);
          }
        }
      }
      if (this.control.circularChartLegend3DModule && this.control.legendSettings.visible) {
        var legendShape = document.getElementById(this.control.element.id + "_chart_legend_shape_" + index.point);
        this.removeSvgClass(legendShape, legendShape.getAttribute("class"));
        this.addSvgClass(legendShape, this.getSelectionClass(legendShape.id));
      }
    };
    CircularChartSelection3D2.prototype.getSelectionClass = function(id) {
      return this.generateStyle(this.control.series[this.indexFinder(id).series], this.indexFinder(id).point);
    };
    CircularChartSelection3D2.prototype.removeSelection = function(chart, series, selectedElements, seriesStyle, isBlurEffectNeeded, index) {
      if (selectedElements.length > 0) {
        var elements = [];
        for (var i = 0; i < selectedElements.length; i++) {
          elements.push(selectedElements[i]);
        }
        this.removeStyles(elements);
        this.addOrRemoveIndex(this.selectedDataIndexes, new Index(series, index.point));
        for (var _i = 0, _a = chart.visibleSeries[0].points; _i < _a.length; _i++) {
          var value = _a[_i];
          seriesStyle = this.generateStyle(chart.visibleSeries[0], value.index);
          if (document.querySelectorAll("." + seriesStyle).length > 0) {
            for (var _b = 0, elements_2 = elements; _b < elements_2.length; _b++) {
              var element = elements_2[_b];
              this.checkSelectionElements(element, seriesStyle, true, index.point);
            }
            isBlurEffectNeeded = false;
            break;
          }
        }
        if (isBlurEffectNeeded) {
          this.blurEffect(chart.element.id, chart.visibleSeries);
        }
      }
    };
    CircularChartSelection3D2.prototype.removeStyles = function(elements) {
      for (var _i = 0, elements_3 = elements; _i < elements_3.length; _i++) {
        var element = elements_3[_i];
        if (element) {
          this.removeSvgClass(element, this.getSelectionClass(element.id));
        }
      }
    };
    CircularChartSelection3D2.prototype.addOrRemoveIndex = function(indexes, index, add) {
      for (var i = 0; i < indexes.length; i++) {
        if (this.checkEquals(indexes[i], index)) {
          indexes.splice(i, 1);
          i--;
        }
      }
      if (add) {
        indexes.push(index);
      }
    };
    CircularChartSelection3D2.prototype.checkEquals = function(first, second) {
      return first.point === second.point && first.series === second.series;
    };
    CircularChartSelection3D2.prototype.mouseMove = function(event2) {
      var circular3D = this.circular3D;
      var targetElement = event2.target;
      if (!circular3D.rotateActivate && circular3D.circularChartHighlight3DModule && (circular3D.highlightMode !== "None" || circular3D.legendSettings.enableHighlight)) {
        if (!isNullOrUndefined(targetElement)) {
          if (event2.target.id.indexOf("text") > 1 && event2.target.id.indexOf("legend") > -1) {
            targetElement = getElement2(event2.target.id.replace("text", "shape"));
          }
          if (targetElement.hasAttribute("class") && (targetElement.getAttribute("class").indexOf("highlight") > -1 || targetElement.getAttribute("class").indexOf("selection") > -1)) {
            return;
          }
          this.calculateSelectedElements(circular3D, event2.target, event2.type);
          if (this.highlightDataIndexes && (targetElement.id.indexOf("_chart_legend_") === -1 || targetElement.id.indexOf("_legend_element") !== -1) && this.highlightDataIndexes.length > 0 && targetElement.id.indexOf("-series-") === -1 && targetElement.id.indexOf("-data-label-") === -1) {
            this.removeLegendHighlightStyles();
          }
          return;
        }
      }
      if (circular3D.selectionMode === "None") {
        return;
      }
    };
    CircularChartSelection3D2.prototype.removeLegendHighlightStyles = function() {
      this.circular3D.circularChartHighlight3DModule.highlightDataIndexes = [];
      var elementCollection;
      for (var i = 0; i < this.circular3D.visibleSeries[0].points.length; i++) {
        elementCollection = document.getElementsByClassName(this.generateStyle(this.circular3D.visibleSeries[0], i));
        if (this.selectedDataIndexes.length === 0) {
          elementCollection = document.getElementsByClassName(this.generateStyle(this.circular3D.visibleSeries[0], i));
          while (elementCollection.length > 0) {
            var element = elementCollection[0];
            if (element) {
              this.removeSvgClass(element, element.getAttribute("class"));
            }
          }
          elementCollection = document.getElementsByClassName(this.unselected);
          while (elementCollection.length > 0) {
            var element = elementCollection[0];
            if (element) {
              this.removeSvgClass(element, element.getAttribute("class"));
              if (this.generateStyle(this.circular3D.visibleSeries[0], i).indexOf("highlight") > -1) {
                this.circular3D.highlightAnimation(element, 700, 0.3);
              }
            }
          }
        } else {
          elementCollection = document.getElementsByClassName(this.generateStyle(this.circular3D.visibleSeries[0], i));
          while (elementCollection.length > 0) {
            var element = elementCollection[0];
            if (element) {
              this.removeSvgClass(element, element.getAttribute("class"));
              this.addSvgClass(element, this.unselected);
            }
          }
        }
      }
    };
    CircularChartSelection3D2.prototype.getModuleName = function() {
      return "CircularChartSelection3D";
    };
    CircularChartSelection3D2.prototype.destroy = function() {
      this.removeEventListener();
    };
    return CircularChartSelection3D2;
  }(BaseSelection)
);

// node_modules/@syncfusion/ej2-charts/src/circularchart3d/user-interaction/high-light.js
var __extends117 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var CircularChartHighlight3D = (
  /** @class */
  function(_super) {
    __extends117(CircularChartHighlight3D2, _super);
    function CircularChartHighlight3D2(circular3D) {
      var _this = _super.call(this, circular3D) || this;
      _this.circular3D = circular3D;
      _this.renderer = circular3D.renderer;
      _this.wireEvents();
      return _this;
    }
    CircularChartHighlight3D2.prototype.wireEvents = function() {
      if (this.circular3D.isDestroyed) {
        return;
      }
      this.circular3D.on(Browser.touchMoveEvent, this.mouseMove, this);
    };
    CircularChartHighlight3D2.prototype.unWireEvents = function() {
      if (this.circular3D.isDestroyed) {
        return;
      }
      this.circular3D.off(Browser.touchMoveEvent, this.mouseMove);
    };
    CircularChartHighlight3D2.prototype.declarePrivateVariables = function(circular3D) {
      this.styleId = circular3D.element.id + "_ej2_chart_highlight";
      this.unselected = circular3D.element.id + "_ej2_deselected";
      this.selectedDataIndexes = [];
      this.highlightDataIndexes = [];
    };
    CircularChartHighlight3D2.prototype.invokeHighlight = function(circular3D) {
      this.declarePrivateVariables(circular3D);
      this.series = extend({}, circular3D.visibleSeries, null, true);
      this.seriesStyles();
      this.currentMode = circular3D.highlightMode;
    };
    CircularChartHighlight3D2.prototype.getModuleName = function() {
      return "CircularChartHighlight3D";
    };
    CircularChartHighlight3D2.prototype.destroy = function() {
      this.unWireEvents();
    };
    return CircularChartHighlight3D2;
  }(CircularChartSelection3D)
);

export {
  Connector,
  Location,
  Accessibility,
  SeriesAccessibility,
  Font,
  StackLabelsFont,
  CenterLabel,
  Border,
  Offset,
  Margin,
  Animation2 as Animation,
  TooltipSettings,
  EmptyPointSettings,
  Indexes,
  CornerRadius,
  ContainerPadding,
  titleBorder,
  titleSettings,
  TitleStyleSettings,
  ChartArea,
  DragSettings,
  Periods,
  PeriodSelectorSettings,
  StockTooltipSettings,
  Index,
  Double,
  loaded,
  legendClick,
  load,
  animationComplete,
  legendRender,
  textRender,
  pointRender,
  sharedTooltipRender,
  seriesRender,
  axisLabelRender,
  axisLabelClick,
  axisRangeCalculated,
  axisMultiLabelRender,
  tooltipRender,
  chartMouseMove,
  chartMouseClick,
  chartDoubleClick,
  pointClick,
  pointDoubleClick,
  pointMove,
  chartMouseLeave,
  chartMouseDown,
  chartMouseUp,
  zoomComplete,
  dragComplete,
  selectionComplete,
  resized,
  beforeResize,
  beforePrint,
  annotationRender,
  scrollStart,
  scrollEnd,
  scrollChanged,
  stockEventRender,
  multiLevelLabelClick,
  dragStart,
  drag,
  dragEnd,
  regSub,
  regSup,
  beforeExport,
  afterExport,
  bulletChartMouseClick,
  onZooming,
  ChartAnnotationSettings,
  LabelBorder,
  MultiLevelCategories,
  StripLineSettings,
  MultiLevelLabels,
  ScrollbarSettingsRange,
  ScrollbarSettings,
  ToolbarPosition,
  StackLabelSettings,
  Row,
  Column,
  MajorGridLines,
  MinorGridLines,
  AxisLine,
  MajorTickLines,
  MinorTickLines,
  CrosshairTooltip,
  Axis,
  VisibleLabels,
  sort,
  isBreakLabel,
  getVisiblePoints,
  calculateScrollbarOffset,
  rotateTextSize,
  removeElement2 as removeElement,
  logBase,
  showTooltip,
  inside,
  withIn,
  logWithIn,
  withInRange,
  sum,
  subArraySum,
  subtractThickness,
  subtractRect,
  degreeToLocation,
  degreeToRadian,
  getRotatedRectangleCoordinates,
  isRotatedRectIntersect,
  getAngle,
  subArray,
  valueToCoefficient,
  TransformToVisible,
  indexFinder,
  CoefficientToVector,
  valueToPolarCoefficient,
  Mean,
  PolarArc,
  createTooltip,
  createZoomingLabels,
  findCrosshairDirection,
  withInBounds,
  getValueXByPoint,
  getValueYByPoint,
  findClipRect,
  firstToLowerCase,
  getTransform,
  getMinPointsDelta,
  getAnimationFunction,
  linear,
  markerAnimate,
  animateRectElement,
  pathAnimation,
  animateAddPoints,
  appendClipElement,
  triggerLabelRender,
  setRange,
  isZoomSet,
  getActualDesiredIntervalsCount,
  templateAnimate,
  drawSymbol,
  calculateShapes,
  getRectLocation,
  minMax,
  getElement2 as getElement,
  getTemplateFunction,
  accReactTemplate,
  chartReactTemplate,
  createTemplate,
  getFontStyle,
  measureElementRect,
  findlElement,
  getPoint,
  appendElement,
  appendChildElement,
  getDraggedRectLocation,
  checkBounds,
  getLabelText,
  stopTimer,
  isCollide,
  isOverlap,
  containsRect,
  calculateRect,
  convertToHexCode,
  componentToHex,
  convertHexToColor,
  colorNameToHex,
  checkColorFormat,
  getSaturationColor,
  applyZLight,
  getMedian,
  calculateLegendShapes,
  textTrim,
  lineBreakLabelTrim,
  stringToNumber,
  redrawElement,
  animateRedrawElement,
  animateTextElement,
  textElement2 as textElement,
  calculateSize,
  createSvg,
  getTitle,
  titlePositionX,
  textWrap,
  textWrapAnyWhere,
  getUnicodeText,
  blazorTemplatesReset,
  CustomizeOption,
  StackValues,
  RectOption,
  ImageOption,
  CircleOption,
  PolygonOption,
  ChartLocation,
  LabelLocation,
  Thickness,
  ColorValue,
  PointData,
  AccPointData,
  Point3D,
  ControlPoints,
  getColorByValue,
  getGradientColor,
  getPercentageColor,
  getPercentage,
  getTextAnchor,
  stockEventFont,
  getSeriesColor,
  getThemeColor,
  getScrollbarThemeColor,
  DataLabelSettings,
  MarkerSettings,
  ParetoOptions,
  Points,
  Trendline,
  ErrorBarCapSettings,
  ChartSegment,
  ErrorBarSettings,
  SeriesBase,
  Series,
  TechnicalIndicator,
  RangeColorSetting,
  CrosshairSettings,
  ZoomSettings,
  Chart,
  NiceInterval,
  DateTime,
  Category,
  Logarithmic,
  DateTimeCategory,
  StripLine,
  LineSeries,
  ColumnSeries,
  MultiColoredSeries,
  AreaSeries,
  BarSeries,
  PolarSeries,
  RadarSeries,
  StackingBarSeries,
  CandleSeries,
  StackingColumnSeries,
  StepLineSeries,
  StepAreaSeries,
  StackingAreaSeries,
  StackingStepAreaSeries,
  StackingLineSeries,
  ScatterSeries,
  RangeColumnSeries,
  RangeStepAreaSeries,
  WaterfallSeries,
  HiloSeries,
  HiloOpenCloseSeries,
  RangeAreaSeries,
  SplineRangeAreaSeries,
  BubbleSeries,
  SplineSeries,
  HistogramSeries,
  SplineAreaSeries,
  SmaIndicator,
  EmaIndicator,
  TmaIndicator,
  AccumulationDistributionIndicator,
  AtrIndicator,
  MomentumIndicator,
  RsiIndicator,
  StochasticIndicator,
  BollingerBands,
  MacdIndicator,
  Trendlines,
  Crosshair,
  Selection,
  Tooltip2 as Tooltip,
  Zoom,
  DataEditing,
  Highlight,
  DataLabel,
  ErrorBar,
  Legend,
  ChartAnnotation,
  BoxAndWhiskerSeries,
  MultiColoredAreaSeries,
  MultiColoredLineSeries,
  MultiLevelLabel,
  ScrollBar,
  ParetoSeries,
  Export,
  AccumulationAnnotationSettings,
  AccumulationDataLabelSettings,
  PieCenter,
  AccPoints,
  AccumulationSeries,
  getSeriesFromIndex,
  pointByIndex,
  PieSeries,
  AccumulationChart,
  FunnelSeries,
  PyramidSeries,
  AccumulationLegend,
  AccumulationDataLabel,
  AccumulationTooltip,
  AccumulationSelection,
  AccumulationHighlight,
  AccumulationAnnotation,
  rangeValueToCoefficient,
  getXLocation,
  getRangeValueXByPoint,
  getExactData,
  getNearestValue,
  DataPoint,
  RangeSeries,
  RangeNavigatorAxis,
  RangeNavigatorSeries,
  ThumbSettings,
  StyleSettings,
  RangeTooltipSettings,
  RangeSlider,
  getRangeThemeColor,
  PeriodSelector,
  RangeNavigator,
  StockChartFont,
  StockChartBorder,
  StockChartArea,
  StockMargin,
  StockChartStripLineSettings,
  StockEmptyPointSettings,
  StockChartConnector,
  StockSeries,
  StockChartIndicator,
  StockChartAxis,
  StockChartRow,
  StockChartTrendline,
  StockChartAnnotationSettings,
  StockChartIndexes,
  StockEventsSettings,
  StockChartLegendSettings,
  StockLegend,
  StockChart,
  RangeTooltip,
  Range,
  MajorTickLinesSettings,
  MinorTickLinesSettings,
  BulletLabelStyle,
  BulletTooltipSettings,
  BulletDataLabel,
  BulletChartLegendSettings,
  getBulletThemeColor,
  BulletChart,
  BulletTooltip,
  BulletChartLegend,
  SmithchartFont,
  SmithchartMargin,
  SmithchartBorder,
  SmithchartRect,
  LabelCollection,
  LegendSeries,
  LabelRegion,
  HorizontalLabelCollection,
  RadialLabelCollections,
  LineSegment,
  PointRegion,
  Point,
  ClosestPoint,
  MarkerOptions,
  SmithchartLabelPosition,
  Direction,
  DataLabelTextOptions,
  LabelOption,
  SmithchartSize,
  GridArcPoints,
  LegendTitle,
  LegendLocation,
  LegendItemStyleBorder,
  LegendItemStyle,
  LegendBorder,
  SmithchartLegendSettings,
  SmithchartMajorGridLines,
  SmithchartMinorGridLines,
  SmithchartAxisLine,
  SmithchartAxis,
  Subtitle,
  Title,
  SeriesTooltipBorder,
  SeriesTooltip,
  SeriesMarkerBorder,
  SeriesMarkerDataLabelBorder,
  SeriesMarkerDataLabelConnectorLine,
  SeriesMarkerDataLabel,
  SeriesMarker,
  SmithchartSeries,
  smithchartBeforePrint,
  Smithchart,
  TooltipRender,
  SmithchartLegend,
  SparklineBorder,
  SparklineFont,
  TrackLineSettings,
  SparklineTooltipSettings,
  ContainerArea,
  LineSettings,
  RangeBandSettings,
  AxisSettings,
  Padding,
  SparklineMarkerSettings,
  LabelOffset,
  SparklineDataLabelSettings,
  Sparkline,
  SparklineTooltip,
  Chart3DTextFont,
  TitleBorder,
  TitleSettings,
  CartesianAxisLayoutPanel2 as CartesianAxisLayoutPanel,
  get3DThemeColor,
  get3DSeriesColor,
  Chart3DRender,
  Vector3D,
  Matrix3D,
  ChartTransform3D,
  Graphics3D,
  BinaryTreeBuilder,
  Svg3DRenderer,
  Polygon3D,
  getMinPointsDeltaValue,
  valueToCoefficients,
  WallRenderer,
  AxisRenderer,
  Double3D,
  Chart3DRow,
  Chart3DColumn,
  Chart3DMajorGridLines,
  Chart3DMinorGridLines,
  Chart3DMajorTickLines,
  Chart3DMinorTickLines,
  Chart3DAxis,
  Visible3DLabels,
  Chart3DDataLabelSettings,
  Chart3DEmptyPointSettings,
  Chart3DPoint,
  Chart3DSeries,
  Chart3DTooltipSettings,
  Tooltip3D,
  Chart3DLegendSettings,
  Legend3D,
  Chart3D,
  NiceIntervals,
  Category3D,
  DateTime3D,
  DateTimeCategory3D,
  Logarithmic3D,
  ColumnSeries3D,
  StackingColumnSeries3D,
  StackingBarSeries3D,
  BarSeries3D,
  DataLabel3D,
  Selection3D,
  Highlight3D,
  Export3D,
  CircularChart3DDataLabelFont,
  CircularChart3DConnector,
  CircularChart3DDataLabelSettings,
  CircularChartDataLabel3D,
  CircularChart3DPoints,
  CircularChart3DEmptyPointSettings,
  CircularChart3DSeries,
  PieSeries3D,
  CircularChart3DLegendSettings,
  CircularChartLegend3D,
  CircularChart3DPointData,
  CircularChart3DTooltipSettings,
  CircularChartTooltip3D,
  CircularChart3D,
  CircularChartExport3D,
  CircularChartSelection3D,
  CircularChartHighlight3D
};
//# sourceMappingURL=chunk-DIHZL7EQ.js.map
